/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.7.0 (NJsonSchema v9.10.70.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MedApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "172.16.6.166:8080/tcmk";
    }

    /**
     * Получение полной информации об авторизованном сотруднике и его бригаде
     * @return OK
     */
    getPerformerByMeWithBrigadeUsingGET(): Observable<PerformerContainer> {
        let url_ = this.baseUrl + "/api/andy/admin/performer/additional";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerByMeWithBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerByMeWithBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerByMeWithBrigadeUsingGET(response: HttpResponseBase): Observable<PerformerContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerContainer.fromJS(resultData200) : new PerformerContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerContainer>(<any>null);
    }

    /**
     * Получение краткой информации об авторизованном сотруднике
     * @return OK
     */
    getPerformerByMeUsingGET(): Observable<PerformerContainer> {
        let url_ = this.baseUrl + "/api/andy/admin/performer/main";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerByMeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerByMeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerByMeUsingGET(response: HttpResponseBase): Observable<PerformerContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerContainer.fromJS(resultData200) : new PerformerContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerContainer>(<any>null);
    }

    /**
     * Обновление ролей сотрудника
     * @param roles roles
     * @param performerId (optional) performerId
     * @return OK
     */
    addRolesToPerformerUsingPOST(roles: RoleBean[], performerId?: number | null | undefined): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/admin/performer/role/update?";
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roles);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToPerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToPerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToPerformerUsingPOST(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Получение списка ролей
     * @return OK
     */
    getRoleListUsingGET(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/andy/admin/role/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleListUsingGET(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * Удаление элемента атх по ID
     * @param id id
     * @return OK
     */
    deleteAthUsingDELETE(id: number): Observable<AthBean> {
        let url_ = this.baseUrl + "/api/andy/ath2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAthUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAthUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<AthBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AthBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAthUsingDELETE(response: HttpResponseBase): Observable<AthBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AthBean.fromJS(resultData200) : new AthBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AthBean>(<any>null);
    }

    /**
     * Получение элемента атх по ID
     * @param id id
     * @return OK
     */
    getAthUsingGET(id: number): Observable<AthBean> {
        let url_ = this.baseUrl + "/api/andy/ath2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AthBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AthBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetAthUsingGET(response: HttpResponseBase): Observable<AthBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AthBean.fromJS(resultData200) : new AthBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AthBean>(<any>null);
    }

    /**
     * Получение списка элементов атх
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listAthUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/ath2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAthUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAthUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListAthUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востановление элемента атх по ID
     * @param id id
     * @return OK
     */
    restoreAthUsingGET(id: number): Observable<AthBean> {
        let url_ = this.baseUrl + "/api/andy/ath2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreAthUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreAthUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AthBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AthBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreAthUsingGET(response: HttpResponseBase): Observable<AthBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AthBean.fromJS(resultData200) : new AthBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AthBean>(<any>null);
    }

    /**
     * Обновление элемента атх
     * @param bean bean
     * @return OK
     */
    updateAthUsingPOST(bean: AthBean): Observable<AthBean> {
        let url_ = this.baseUrl + "/api/andy/ath2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAthUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAthUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<AthBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AthBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAthUsingPOST(response: HttpResponseBase): Observable<AthBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AthBean.fromJS(resultData200) : new AthBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AthBean>(<any>null);
    }

    /**
     * Получение расписания авиабригад
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param isBrigadeDeleted (optional) isBrigadeDeleted
     * @param isAvailable (optional) isAvailable
     * @param isTrimming (optional) isTrimming
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getAviaBrigadeScheduleMapUsingGET(dateFrom: string, dateTo: string, isBrigadeDeleted?: boolean | null | undefined, isAvailable?: boolean | null | undefined, isTrimming?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/avia/brigade/schedule/all?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isBrigadeDeleted !== undefined)
            url_ += "isBrigadeDeleted=" + encodeURIComponent("" + isBrigadeDeleted) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (isTrimming !== undefined)
            url_ += "isTrimming=" + encodeURIComponent("" + isTrimming) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAviaBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAviaBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAviaBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Получение списка доступного для назначения в бригаду транспорта
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getAvailableHelicoptersUsingGET(dateFrom: string, dateTo: string, subdivisionId?: number | null | undefined): Observable<BrigadeTransportScheduleBean[]> {
        let url_ = this.baseUrl + "/api/andy/avia/brigade/schedule/available/transport?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableHelicoptersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableHelicoptersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTransportScheduleBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTransportScheduleBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableHelicoptersUsingGET(response: HttpResponseBase): Observable<BrigadeTransportScheduleBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeTransportScheduleBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTransportScheduleBean[]>(<any>null);
    }

    /**
     * Получение списка актуальных составов авиабригад
     * @param actualDate (optional) actualDate
     * @param isAvailable (optional) isAvailable
     * @param subdivisionId (optional) subdivisionId
     * @param isAvailableTransport (optional) isAvailableTransport
     * @return OK
     */
    getActualAviaBrigadeCrewListUsingGET(actualDate?: string | null | undefined, isAvailable?: boolean | null | undefined, subdivisionId?: number | null | undefined, isAvailableTransport?: boolean | null | undefined): Observable<BrigadeContainer[]> {
        let url_ = this.baseUrl + "/api/andy/avia/brigade/schedule/crew/list/actual?";
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent("" + actualDate) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (isAvailableTransport !== undefined)
            url_ += "isAvailableTransport=" + encodeURIComponent("" + isAvailableTransport) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualAviaBrigadeCrewListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualAviaBrigadeCrewListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualAviaBrigadeCrewListUsingGET(response: HttpResponseBase): Observable<BrigadeContainer[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeContainer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer[]>(<any>null);
    }

    /**
     * Получение расписания авиабригады по Id
     * @param id id
     * @return OK
     */
    getAviaBrigadeScheduleUsingGET(id: number): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/avia/brigade/schedule/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAviaBrigadeScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAviaBrigadeScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetAviaBrigadeScheduleUsingGET(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Создание/обновление расписания авиабригады
     * @param bean bean
     * @return OK
     */
    updateAviaBrigadeScheduleUsingPOST(bean: BrigadeScheduleBean): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/avia/brigade/schedule/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAviaBrigadeScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAviaBrigadeScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAviaBrigadeScheduleUsingPOST(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Получение заявки по Id
     * @param id id
     * @return OK
     */
    getAviaRequestUsingGET(id: number): Observable<AviaRequestBean> {
        let url_ = this.baseUrl + "/api/andy/avia/request/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAviaRequestUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAviaRequestUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AviaRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AviaRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetAviaRequestUsingGET(response: HttpResponseBase): Observable<AviaRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AviaRequestBean.fromJS(resultData200) : new AviaRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AviaRequestBean>(<any>null);
    }

    /**
     * Получение заявки по Id вызова
     * @param id id
     * @return OK
     */
    getAviaRequestByCallIdUsingGET(id: number): Observable<AviaRequestBean> {
        let url_ = this.baseUrl + "/api/andy/avia/request/getByCallId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAviaRequestByCallIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAviaRequestByCallIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AviaRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AviaRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetAviaRequestByCallIdUsingGET(response: HttpResponseBase): Observable<AviaRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AviaRequestBean.fromJS(resultData200) : new AviaRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AviaRequestBean>(<any>null);
    }

    /**
     * Получение списка типов документов пациентов
     * @param from (optional) from
     * @param count (optional) count
     * @param isAccepted (optional) isAccepted
     * @param isNewRequest (optional) isNewRequest
     * @return OK
     */
    getAviaRequestListUsingGET(from?: number | null | undefined, count?: number | null | undefined, isAccepted?: boolean | null | undefined, isNewRequest?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/avia/request/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (isAccepted !== undefined)
            url_ += "isAccepted=" + encodeURIComponent("" + isAccepted) + "&"; 
        if (isNewRequest !== undefined)
            url_ += "isNewRequest=" + encodeURIComponent("" + isNewRequest) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAviaRequestListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAviaRequestListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetAviaRequestListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Обновление/создание заявки
     * @param bean bean
     * @return OK
     */
    updateAviaRequestUsingPOST(bean: AviaRequestBean): Observable<AviaRequestBean> {
        let url_ = this.baseUrl + "/api/andy/avia/request/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAviaRequestUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAviaRequestUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<AviaRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AviaRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAviaRequestUsingPOST(response: HttpResponseBase): Observable<AviaRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AviaRequestBean.fromJS(resultData200) : new AviaRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AviaRequestBean>(<any>null);
    }

    /**
     * Получение списка укладкок
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listBagsUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/bag/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListBagsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListBagsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListBagsUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка укладкок бригады
     * @param brigadeId brigadeId
     * @param from (optional) from
     * @param count (optional) count
     * @return OK
     */
    listBagsOfBrigadeUsingGET(brigadeId: number, from?: number | null | undefined, count?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/bag/listOfBrigade/{brigadeId}?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListBagsOfBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListBagsOfBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListBagsOfBrigadeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Обновление укладки
     * @param bean bean
     * @return OK
     */
    updateBagNewUsingPOST(bean: BagNewBean): Observable<BagNewBean> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/bag/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBagNewUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBagNewUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBagNewUsingPOST(response: HttpResponseBase): Observable<BagNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagNewBean.fromJS(resultData200) : new BagNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagNewBean>(<any>null);
    }

    /**
     * Удаление шаблона или укладки по ID
     * @param id id
     * @return OK
     */
    deleteTmpBagUsingDELETE(id: number): Observable<BagNewBean> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTmpBagUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTmpBagUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BagNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTmpBagUsingDELETE(response: HttpResponseBase): Observable<BagNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagNewBean.fromJS(resultData200) : new BagNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagNewBean>(<any>null);
    }

    /**
     * Получение шаблона или укладки по ID
     * @param id id
     * @return OK
     */
    getTmpBagUsingGET(id: number): Observable<BagNewBean> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTmpBagUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTmpBagUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BagNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTmpBagUsingGET(response: HttpResponseBase): Observable<BagNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagNewBean.fromJS(resultData200) : new BagNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagNewBean>(<any>null);
    }

    /**
     * Востановление шаблона или укладки по ID
     * @param id id
     * @return OK
     */
    restoreTmpBagUsingGET(id: number): Observable<BagNewBean> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTmpBagUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTmpBagUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BagNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTmpBagUsingGET(response: HttpResponseBase): Observable<BagNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagNewBean.fromJS(resultData200) : new BagNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagNewBean>(<any>null);
    }

    /**
     * Получение списка шаблонов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listTmpUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/template/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListTmpUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListTmpUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListTmpUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Обновление шаблона укладки
     * @param bean bean
     * @return OK
     */
    updateTmpUsingPOST(bean: BagNewBean): Observable<BagNewBean> {
        let url_ = this.baseUrl + "/api/andy/bagTmp2.0/template/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTmpUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTmpUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTmpUsingPOST(response: HttpResponseBase): Observable<BagNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagNewBean.fromJS(resultData200) : new BagNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagNewBean>(<any>null);
    }

    /**
     * Добавление лекарств в укладку
     * @param bagId bagId
     * @param drugs drugs
     * @return OK
     */
    updateDrugInBagUsingPOST(bagId: number, drugs: DrugBean[]): Observable<ListContainerOfDrugBean> {
        let url_ = this.baseUrl + "/api/andy/bags/addDrug?";
        if (bagId === undefined || bagId === null)
            throw new Error("The parameter 'bagId' must be defined and cannot be null.");
        else
            url_ += "bagId=" + encodeURIComponent("" + bagId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(drugs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugInBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugInBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugInBagUsingPOST(response: HttpResponseBase): Observable<ListContainerOfDrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugBean.fromJS(resultData200) : new ListContainerOfDrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugBean>(<any>null);
    }

    /**
     * Обновление/добавление укладки лекарств
     * @param bean bean
     * @return OK
     */
    updateBagUsingPOST(bean: BagBean): Observable<BagBean> {
        let url_ = this.baseUrl + "/api/andy/bags/bag/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBagUsingPOST(response: HttpResponseBase): Observable<BagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagBean.fromJS(resultData200) : new BagBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagBean>(<any>null);
    }

    /**
     * Назначение бригаде укладки лекарств
     * @param bagId bagId
     * @param brigadeId brigadeId
     * @return OK
     */
    appointmentBrigadeToBagUsingPOST(bagId: number, brigadeId: number): Observable<BagBean> {
        let url_ = this.baseUrl + "/api/andy/bags/brigade/appointmentBrigadeToBag?";
        if (bagId === undefined || bagId === null)
            throw new Error("The parameter 'bagId' must be defined and cannot be null.");
        else
            url_ += "bagId=" + encodeURIComponent("" + bagId) + "&"; 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined and cannot be null.");
        else
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppointmentBrigadeToBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppointmentBrigadeToBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagBean>><any>_observableThrow(response_);
        }));
    }

    protected processAppointmentBrigadeToBagUsingPOST(response: HttpResponseBase): Observable<BagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagBean.fromJS(resultData200) : new BagBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagBean>(<any>null);
    }

    /**
     * Список уникальных лекарств по ID бригады
     * @param id id
     * @return OK
     */
    getUniqueDrugsForBrigadeUsingGET(id: number): Observable<PairOfDrugBeanAndint[]> {
        let url_ = this.baseUrl + "/api/andy/bags/brigade/getUniqueDrugs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniqueDrugsForBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniqueDrugsForBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PairOfDrugBeanAndint[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfDrugBeanAndint[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUniqueDrugsForBrigadeUsingGET(response: HttpResponseBase): Observable<PairOfDrugBeanAndint[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfDrugBeanAndint.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfDrugBeanAndint[]>(<any>null);
    }

    /**
     * Удаление укладки лекарств
     * @param id id
     * @return OK
     */
    deleteBagUsingDELETE(id: number): Observable<BagBean> {
        let url_ = this.baseUrl + "/api/andy/bags/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBagUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBagUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBagUsingDELETE(response: HttpResponseBase): Observable<BagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagBean.fromJS(resultData200) : new BagBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagBean>(<any>null);
    }

    /**
     * Формирование списка необходимых лекарств по ID подразделения
     * @param id id
     * @return OK
     */
    formNeedfulDrugsUsingGET(id: number): Observable<ListContainerOfDrugBean> {
        let url_ = this.baseUrl + "/api/andy/bags/formNeedfulDrugs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormNeedfulDrugsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormNeedfulDrugsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processFormNeedfulDrugsUsingGET(response: HttpResponseBase): Observable<ListContainerOfDrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugBean.fromJS(resultData200) : new ListContainerOfDrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugBean>(<any>null);
    }

    /**
     * Получение укладки лекарств по ID
     * @param id id
     * @return OK
     */
    getBagUsingGET(id: number): Observable<BagBean> {
        let url_ = this.baseUrl + "/api/andy/bags/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBagUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBagUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBagUsingGET(response: HttpResponseBase): Observable<BagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagBean.fromJS(resultData200) : new BagBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagBean>(<any>null);
    }

    /**
     * Получение списка укладок
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param brigadeId (optional) brigadeId
     * @param isFree (optional) isFree
     * @return OK
     */
    getBagBeansUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, brigadeId?: number | null | undefined, isFree?: boolean | null | undefined): Observable<ListContainerOfBagBean> {
        let url_ = this.baseUrl + "/api/andy/bags/listAll?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (brigadeId !== undefined)
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (isFree !== undefined)
            url_ += "isFree=" + encodeURIComponent("" + isFree) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBagBeansUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBagBeansUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfBagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfBagBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBagBeansUsingGET(response: HttpResponseBase): Observable<ListContainerOfBagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfBagBean.fromJS(resultData200) : new ListContainerOfBagBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfBagBean>(<any>null);
    }

    /**
     * Восстановление укладки по ID
     * @param id id
     * @return OK
     */
    restoreDrugBeanUsingPOST(id: number): Observable<BagBean> {
        let url_ = this.baseUrl + "/api/andy/bags/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugBeanUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugBeanUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugBeanUsingPOST(response: HttpResponseBase): Observable<BagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagBean.fromJS(resultData200) : new BagBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagBean>(<any>null);
    }

    /**
     * Добавление лекарств в шаблон укладки
     * @param bagId bagId
     * @param drugs drugs
     * @return OK
     */
    updateDrugInTemplateBagUsingPOST(bagId: number, drugs: DrugBean[]): Observable<ListContainerOfDrugBean> {
        let url_ = this.baseUrl + "/api/andy/bags/template/addDrug?";
        if (bagId === undefined || bagId === null)
            throw new Error("The parameter 'bagId' must be defined and cannot be null.");
        else
            url_ += "bagId=" + encodeURIComponent("" + bagId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(drugs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugInTemplateBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugInTemplateBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugInTemplateBagUsingPOST(response: HttpResponseBase): Observable<ListContainerOfDrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugBean.fromJS(resultData200) : new ListContainerOfDrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugBean>(<any>null);
    }

    /**
     * Удаление шаблона укладки лекарств
     * @param id id
     * @return OK
     */
    deleteTemplateBagUsingDELETE(id: number): Observable<BagTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/bags/template/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplateBagUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplateBagUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BagTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTemplateBagUsingDELETE(response: HttpResponseBase): Observable<BagTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagTemplateBean.fromJS(resultData200) : new BagTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagTemplateBean>(<any>null);
    }

    /**
     * Получение шаблона укладки лекарств по ID
     * @param id id
     * @return OK
     */
    getTemplateBagUsingGET(id: number): Observable<BagTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/bags/template/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateBagUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateBagUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BagTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplateBagUsingGET(response: HttpResponseBase): Observable<BagTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagTemplateBean.fromJS(resultData200) : new BagTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagTemplateBean>(<any>null);
    }

    /**
     * Получение списка шаблонов укладок
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param type (optional) type
     * @return OK
     */
    getBagTemplatesUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, type?: number | null | undefined): Observable<ListContainerOfBagTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/bags/template/listAll?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBagTemplatesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBagTemplatesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfBagTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfBagTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBagTemplatesUsingGET(response: HttpResponseBase): Observable<ListContainerOfBagTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfBagTemplateBean.fromJS(resultData200) : new ListContainerOfBagTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfBagTemplateBean>(<any>null);
    }

    /**
     * Восстановление шаблона укладки по ID
     * @param id id
     * @return OK
     */
    restoreTemplateBagUsingPOST(id: number): Observable<BagTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/bags/template/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTemplateBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTemplateBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTemplateBagUsingPOST(response: HttpResponseBase): Observable<BagTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagTemplateBean.fromJS(resultData200) : new BagTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagTemplateBean>(<any>null);
    }

    /**
     * Обновление/добавление шаблона укладки лекарств
     * @param bean bean
     * @return OK
     */
    updateTemplateBagUsingPOST(bean: BagTemplateBean): Observable<BagTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/bags/template/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplateBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplateBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTemplateBagUsingPOST(response: HttpResponseBase): Observable<BagTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagTemplateBean.fromJS(resultData200) : new BagTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagTemplateBean>(<any>null);
    }

    /**
     * Списание лекарств
     * @param bagId bagId
     * @param drugId drugId
     * @param cardId cardId
     * @param countToOff countToOff
     * @return OK
     */
    writeOffDrugsUsingPOST(bagId: number, drugId: number, cardId: number, countToOff: number): Observable<ListContainerOfDrugBean> {
        let url_ = this.baseUrl + "/api/andy/bags/writeOffDrug?";
        if (bagId === undefined || bagId === null)
            throw new Error("The parameter 'bagId' must be defined and cannot be null.");
        else
            url_ += "bagId=" + encodeURIComponent("" + bagId) + "&"; 
        if (drugId === undefined || drugId === null)
            throw new Error("The parameter 'drugId' must be defined and cannot be null.");
        else
            url_ += "drugId=" + encodeURIComponent("" + drugId) + "&"; 
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined and cannot be null.");
        else
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (countToOff === undefined || countToOff === null)
            throw new Error("The parameter 'countToOff' must be defined and cannot be null.");
        else
            url_ += "countToOff=" + encodeURIComponent("" + countToOff) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWriteOffDrugsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWriteOffDrugsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processWriteOffDrugsUsingPOST(response: HttpResponseBase): Observable<ListContainerOfDrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugBean.fromJS(resultData200) : new ListContainerOfDrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugBean>(<any>null);
    }

    /**
     * Удаление бригады по Id
     * @param id id
     * @return OK
     */
    deleteBrigadeUsingDELETE(id: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeUsingDELETE(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Получение бригады по Id
     * @param id id
     * @return OK
     */
    getBrigadeUsingGET(id: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeUsingGET(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Получение списка бригад
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param isAvia (optional) isAvia
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getBrigadeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, isAvia?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (isAvia !== undefined)
            url_ += "isAvia=" + encodeURIComponent("" + isAvia) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка бригад без укладки
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param isAvia (optional) isAvia
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getBrigadesWithoutBagUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, isAvia?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade/list/withoutBag?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (isAvia !== undefined)
            url_ += "isAvia=" + encodeURIComponent("" + isAvia) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadesWithoutBagUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadesWithoutBagUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadesWithoutBagUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение сообщения бригады по Id
     * @param id id
     * @return OK
     */
    assignedBrigadeMessageBeanUsingGET(id: number): Observable<AssignedBrigadeMessageBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignedBrigadeMessageBeanUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignedBrigadeMessageBeanUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean>><any>_observableThrow(response_);
        }));
    }

    protected processAssignedBrigadeMessageBeanUsingGET(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssignedBrigadeMessageBean.fromJS(resultData200) : new AssignedBrigadeMessageBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean>(<any>null);
    }

    /**
     * Получение списка сообщений
     * @param brigadeId brigadeId
     * @param callId callId
     * @return OK
     */
    getAssignedBrigadeMessageListUsingGET(brigadeId: number, callId: number): Observable<AssignedBrigadeMessageBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/list?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined and cannot be null.");
        else
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined and cannot be null.");
        else
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignedBrigadeMessageListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignedBrigadeMessageListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssignedBrigadeMessageListUsingGET(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssignedBrigadeMessageBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean[]>(<any>null);
    }

    /**
     * Отправка сообщения
     * @param brigadeId brigadeId
     * @param callId callId
     * @param receivingType receivingType
     * @param messageType messageType
     * @param statusCode (optional) statusCode
     * @param date (optional) date
     * @return OK
     */
    updateAssignedBrigadeMessageListUsingPOST(brigadeId: number, callId: number, receivingType: number, messageType: number, statusCode?: string | null | undefined, date?: Date | null | undefined): Observable<AssignedBrigadeMessageBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/send?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined and cannot be null.");
        else
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined and cannot be null.");
        else
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        if (receivingType === undefined || receivingType === null)
            throw new Error("The parameter 'receivingType' must be defined and cannot be null.");
        else
            url_ += "receivingType=" + encodeURIComponent("" + receivingType) + "&"; 
        if (messageType === undefined || messageType === null)
            throw new Error("The parameter 'messageType' must be defined and cannot be null.");
        else
            url_ += "messageType=" + encodeURIComponent("" + messageType) + "&"; 
        if (statusCode !== undefined)
            url_ += "statusCode=" + encodeURIComponent("" + statusCode) + "&"; 
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssignedBrigadeMessageListUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssignedBrigadeMessageListUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssignedBrigadeMessageListUsingPOST(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssignedBrigadeMessageBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean[]>(<any>null);
    }

    /**
     * Обновление сообщений бригады
     * @param list list
     * @return OK
     */
    updateAssignedBrigadeMessageListUsingPOST_1(list: AssignedBrigadeMessageBean[]): Observable<AssignedBrigadeMessageBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(list);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssignedBrigadeMessageListUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssignedBrigadeMessageListUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssignedBrigadeMessageListUsingPOST_1(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssignedBrigadeMessageBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean[]>(<any>null);
    }

    /**
     * Восстановление бригады по Id
     * @param id id
     * @return OK
     */
    restoreBrigadeUsingPOST(id: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBrigadeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBrigadeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBrigadeUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Получение расписания бригад
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param isBrigadeDeleted (optional) isBrigadeDeleted
     * @param isAvailable (optional) isAvailable
     * @param isTrimming (optional) isTrimming
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getBrigadeScheduleMapUsingGET(dateFrom: string, dateTo: string, isBrigadeDeleted?: boolean | null | undefined, isAvailable?: boolean | null | undefined, isTrimming?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/all?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isBrigadeDeleted !== undefined)
            url_ += "isBrigadeDeleted=" + encodeURIComponent("" + isBrigadeDeleted) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (isTrimming !== undefined)
            url_ += "isTrimming=" + encodeURIComponent("" + isTrimming) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Получение списка доступных для назначения в бригаду сотрудников
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param type (optional) type
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getAvailablePerformersUsingGET(dateFrom: string, dateTo: string, type?: number | null | undefined, subdivisionId?: number | null | undefined): Observable<BrigadePerformerScheduleBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/available/performer?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailablePerformersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailablePerformersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadePerformerScheduleBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadePerformerScheduleBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailablePerformersUsingGET(response: HttpResponseBase): Observable<BrigadePerformerScheduleBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadePerformerScheduleBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadePerformerScheduleBean[]>(<any>null);
    }

    /**
     * Получение списка доступного для назначения в бригаду транспорта
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getAvailableTransportsUsingGET(dateFrom: string, dateTo: string, subdivisionId?: number | null | undefined): Observable<BrigadeTransportScheduleBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/available/transport?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableTransportsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableTransportsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTransportScheduleBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTransportScheduleBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableTransportsUsingGET(response: HttpResponseBase): Observable<BrigadeTransportScheduleBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeTransportScheduleBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTransportScheduleBean[]>(<any>null);
    }

    /**
     * Получение списка актуальных составов бригад
     * @param actualDate (optional) actualDate
     * @param isAvailable (optional) isAvailable
     * @param subdivisionId (optional) subdivisionId
     * @param isAvailableTransport (optional) isAvailableTransport
     * @return OK
     */
    getActualBrigadeCrewListUsingGET(actualDate?: string | null | undefined, isAvailable?: boolean | null | undefined, subdivisionId?: number | null | undefined, isAvailableTransport?: boolean | null | undefined): Observable<BrigadeContainer[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/crew/list/actual?";
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent("" + actualDate) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (isAvailableTransport !== undefined)
            url_ += "isAvailableTransport=" + encodeURIComponent("" + isAvailableTransport) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualBrigadeCrewListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualBrigadeCrewListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualBrigadeCrewListUsingGET(response: HttpResponseBase): Observable<BrigadeContainer[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeContainer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer[]>(<any>null);
    }

    /**
     * Получение списка актуальных составов бригад
     * @param brigadeIds (optional) brigadeIds
     * @param actualDate (optional) actualDate
     * @return OK
     */
    getActualBrigadeCrewListByIdsUsingGET(brigadeIds?: number[] | null | undefined, actualDate?: Date | null | undefined): Observable<BrigadeContainer[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/crew/list/ids?";
        if (brigadeIds !== undefined)
            brigadeIds && brigadeIds.forEach(item => { url_ += "brigadeIds=" + encodeURIComponent("" + item) + "&"; });
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent(actualDate ? "" + actualDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualBrigadeCrewListByIdsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualBrigadeCrewListByIdsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualBrigadeCrewListByIdsUsingGET(response: HttpResponseBase): Observable<BrigadeContainer[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeContainer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer[]>(<any>null);
    }

    /**
     * Получение актуального состава бригады
     * @param id id
     * @param actualDate (optional) actualDate
     * @return OK
     */
    getActualBrigadeCrewUsingGET(id: number, actualDate?: Date | null | undefined): Observable<BrigadeContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/crew/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent(actualDate ? "" + actualDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualBrigadeCrewUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualBrigadeCrewUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualBrigadeCrewUsingGET(response: HttpResponseBase): Observable<BrigadeContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeContainer.fromJS(resultData200) : new BrigadeContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer>(<any>null);
    }

    /**
     * Удаление расписания бригады
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    deleteBrigadeScheduleUsingDELETE(brigadeScheduleId: number): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/delete/{brigadeScheduleId}";
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Получение расписания бригады по Id
     * @param id id
     * @return OK
     */
    getBrigadeScheduleUsingGET(id: number): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleUsingGET(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Расписание выведенных на линию бригад
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getOnLineBrigadeScheduleMapUsingGET(subdivisionId?: number | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/online?";
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnLineBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnLineBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOnLineBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Расписание невыведенных на линию бригад
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getNotOnLineBrigadeScheduleMapUsingGET(subdivisionId?: number | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/outline?";
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotOnLineBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotOnLineBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotOnLineBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Снять бригаду с линии
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    resetBrigadeFromLineUsingPOST(brigadeScheduleId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/reset_from_line/{brigadeScheduleId}";
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetBrigadeFromLineUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetBrigadeFromLineUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetBrigadeFromLineUsingPOST(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Вывести бригаду на линию
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    setBrigadeOnLineUsingPOST(brigadeScheduleId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/set_on_line/{brigadeScheduleId}";
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetBrigadeOnLineUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetBrigadeOnLineUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetBrigadeOnLineUsingPOST(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Получение расписания бригад, которые скоро выйдут на линию
     * @param isBrigadeDeleted (optional) isBrigadeDeleted
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getSoonBrigadeScheduleMapUsingGET(isBrigadeDeleted?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/soon?";
        if (isBrigadeDeleted !== undefined)
            url_ += "isBrigadeDeleted=" + encodeURIComponent("" + isBrigadeDeleted) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoonBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoonBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoonBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Создание/обновление расписания бригады
     * @param bean bean
     * @return OK
     */
    updateBrigadeScheduleUsingPOST(bean: BrigadeScheduleBean): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeScheduleUsingPOST(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Получение расписания бригады
     * @param brigadeId brigadeId
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param isAvailable (optional) isAvailable
     * @return OK
     */
    getBrigadeScheduleListUsingGET(brigadeId: number, dateFrom: string, dateTo: string, isAvailable?: boolean | null | undefined): Observable<{ [key: string] : any; }[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/{brigadeId}/list?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleListUsingGET(response: HttpResponseBase): Observable<{ [key: string] : any; }[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }[]>(<any>null);
    }

    /**
     * Установить статус бригады: "Сигнал тревоги"
     * @param brigadeId brigadeId
     * @param latitude latitude
     * @param longitude longitude
     * @return OK
     */
    setAlarmUsingPOST(brigadeId: number, latitude: number, longitude: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/alarm/{brigadeId}?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&"; 
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAlarmUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAlarmUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetAlarmUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Установить статус бригады: "На станции"
     * @param brigadeId brigadeId
     * @return OK
     */
    setOnBaseUsingPOST(brigadeId: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/base/{brigadeId}";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOnBaseUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOnBaseUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetOnBaseUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Установить статус бригады: "Не готова"
     * @param brigadeId brigadeId
     * @param statusCode statusCode
     * @return OK
     */
    setInactiveUsingPOST(brigadeId: number, statusCode: string): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/inactive/{brigadeId}?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (statusCode === undefined || statusCode === null)
            throw new Error("The parameter 'statusCode' must be defined and cannot be null.");
        else
            url_ += "statusCode=" + encodeURIComponent("" + statusCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetInactiveUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetInactiveUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetInactiveUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Установить статус бригады: "В пути на станцию"
     * @param brigadeId brigadeId
     * @return OK
     */
    setReturningUsingPOST(brigadeId: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/returning/{brigadeId}";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReturningUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReturningUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetReturningUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Обновление/добавление бригады
     * @param bean bean
     * @return OK
     */
    updateBrigadeUsingPOST(bean: BrigadeBean): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Удаление записи справочника
     * @param id id
     * @return OK
     */
    deleteBrigadeStatusUsingDELETE(id: number): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeStatusUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeStatusUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeStatusUsingDELETE(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * getBrigadeStatus
     * @param id id
     * @return OK
     */
    getBrigadeStatusUsingGET(id: number): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeStatusUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeStatusUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeStatusUsingGET(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * Получение списка статусов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param isAvailable (optional) isAvailable
     * @return OK
     */
    getBrigadeStatusListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, isAvailable?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeStatusListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeStatusListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeStatusListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление записи справочника
     * @param id id
     * @return OK
     */
    restoreBrigadeStatusUsingPOST(id: number): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBrigadeStatusUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBrigadeStatusUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBrigadeStatusUsingPOST(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * Обновление/создание записи справочника
     * @param bean bean
     * @return OK
     */
    updateBrigadeStatusUsingPOST(bean: BrigadeStatusBean): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeStatusUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeStatusUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeStatusUsingPOST(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * Версия справочника
     * @return OK
     */
    getPerformerTypeVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление записи справочника
     * @param id id
     * @return OK
     */
    deleteBrigadeTypeUsingDELETE(id: number): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeTypeUsingDELETE(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * getBrigadeType
     * @param id id
     * @return OK
     */
    getBrigadeTypeUsingGET(id: number): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeTypeUsingGET(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * Получение списка типов бригад
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    readBrigadeTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadBrigadeTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadBrigadeTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processReadBrigadeTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление записи справочника
     * @param id id
     * @return OK
     */
    restoreBrigadeTypeUsingPOST(id: number): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBrigadeTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBrigadeTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBrigadeTypeUsingPOST(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * Обновление/создание записи справочника
     * @param bean bean
     * @return OK
     */
    updateBrigadeTypeUsingPOST(bean: BrigadeTypeBean): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeTypeUsingPOST(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPerformerTypeVersionUsingGET_1(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeVersionUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeVersionUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeVersionUsingGET_1(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Скачать файл
     * @param id id
     * @return OK
     */
    downloadFileUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/call/audio/download/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Список аудизописей вызова
     * @param callId callId
     * @return OK
     */
    getFileListUsingGET(callId: number): Observable<{ [key: string] : any; }[]> {
        let url_ = this.baseUrl + "/api/andy/call/audio/list/{callId}";
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFileListUsingGET(response: HttpResponseBase): Observable<{ [key: string] : any; }[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }[]>(<any>null);
    }

    /**
     * Превью файла
     * @param id id
     * @return OK
     */
    previewFileUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/call/audio/preview/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewFileUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewFileUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPreviewFileUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Снять бригаду с вызова
     * @param callId callId
     * @param brigadeId brigadeId
     * @param reason (optional) reason
     * @return OK
     */
    deleteBrigadeFromCallUsingPOST(callId: number, brigadeId: number, reason?: string | null | undefined): Observable<CallContainer> {
        let url_ = this.baseUrl + "/api/andy/call/brigade/delete?";
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined and cannot be null.");
        else
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined and cannot be null.");
        else
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeFromCallUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeFromCallUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallContainer>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeFromCallUsingPOST(response: HttpResponseBase): Observable<CallContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallContainer.fromJS(resultData200) : new CallContainer();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallContainer>(<any>null);
    }

    /**
     * Проверка назначения бригады на вызовы
     * @param brigadeId brigadeId
     * @param callIds callIds
     * @return OK
     */
    checkBrigadeCallsUsingPOST(brigadeId: number, callIds: number[]): Observable<any[]> {
        let url_ = this.baseUrl + "/api/andy/call/check_brigade/{brigadeId}";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(callIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckBrigadeCallsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckBrigadeCallsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCheckBrigadeCallsUsingPOST(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * Получение контейнера вызовов
     * @param id id
     * @return OK
     */
    getCallContainerUsingGET(id: number): Observable<CallContainer> {
        let url_ = this.baseUrl + "/api/andy/call/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallContainerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallContainerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallContainerUsingGET(response: HttpResponseBase): Observable<CallContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallContainer.fromJS(resultData200) : new CallContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallContainer>(<any>null);
    }

    /**
     * Получение списка архива вызовов
     * @param bean bean
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @return OK
     */
    getArchiveCallListUsingPOST(bean: ArchiveCallContainer, from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArchiveCallListUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArchiveCallListUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetArchiveCallListUsingPOST(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Получение списка вызовов
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param callStatusList (optional) callStatusList
     * @param callPriorityList (optional) callPriorityList
     * @param number (optional) number
     * @param declarantName (optional) declarantName
     * @param reason (optional) reason
     * @param brigadeId (optional) brigadeId
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @param isEmergency (optional) isEmergency
     * @param isAviaRequest (optional) isAviaRequest
     * @param subdivisionId (optional) subdivisionId
     * @param isChildrenIncluded (optional) IsChildrenIncluded
     * @return OK
     */
    getCallListUsingGET(from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, callStatusList?: CallStatusList[] | null | undefined, callPriorityList?: CallPriorityList[] | null | undefined, number?: string | null | undefined, declarantName?: string | null | undefined, reason?: number | null | undefined, brigadeId?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined, isEmergency?: boolean | null | undefined, isAviaRequest?: boolean | null | undefined, subdivisionId?: number | null | undefined, isChildrenIncluded?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (callStatusList !== undefined)
            callStatusList && callStatusList.forEach(item => { url_ += "callStatusList=" + encodeURIComponent("" + item) + "&"; });
        if (callPriorityList !== undefined)
            callPriorityList && callPriorityList.forEach(item => { url_ += "callPriorityList=" + encodeURIComponent("" + item) + "&"; });
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (declarantName !== undefined)
            url_ += "declarantName=" + encodeURIComponent("" + declarantName) + "&"; 
        if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        if (brigadeId !== undefined)
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isEmergency !== undefined)
            url_ += "isEmergency=" + encodeURIComponent("" + isEmergency) + "&"; 
        if (isAviaRequest !== undefined)
            url_ += "isAviaRequest=" + encodeURIComponent("" + isAviaRequest) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (isChildrenIncluded !== undefined)
            url_ += "IsChildrenIncluded=" + encodeURIComponent("" + isChildrenIncluded) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Поиск всех вызовов от пациента
     * @param patientName patientName
     * @param patientSurname patientSurname
     * @param patientPatronymic patientPatronymic
     * @param dateBirth dateBirth
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @return OK
     */
    getAllCallListUsingGET(patientName: string, patientSurname: string, patientPatronymic: string, dateBirth: Date, from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list/allCall?";
        if (patientName === undefined || patientName === null)
            throw new Error("The parameter 'patientName' must be defined and cannot be null.");
        else
            url_ += "patientName=" + encodeURIComponent("" + patientName) + "&"; 
        if (patientSurname === undefined || patientSurname === null)
            throw new Error("The parameter 'patientSurname' must be defined and cannot be null.");
        else
            url_ += "patientSurname=" + encodeURIComponent("" + patientSurname) + "&"; 
        if (patientPatronymic === undefined || patientPatronymic === null)
            throw new Error("The parameter 'patientPatronymic' must be defined and cannot be null.");
        else
            url_ += "patientPatronymic=" + encodeURIComponent("" + patientPatronymic) + "&"; 
        if (dateBirth === undefined || dateBirth === null)
            throw new Error("The parameter 'dateBirth' must be defined and cannot be null.");
        else
            url_ += "dateBirth=" + encodeURIComponent(dateBirth ? "" + dateBirth.toJSON() : "") + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCallListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCallListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCallListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Поиск повторного вызова
     * @param patientName patientName
     * @param patientSurname patientSurname
     * @param patientPatronymic patientPatronymic
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param isRepeated (optional) isRepeated
     * @return OK
     */
    getCallListUsingGET_1(patientName: string, patientSurname: string, patientPatronymic: string, from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, isRepeated?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list/repeated?";
        if (patientName === undefined || patientName === null)
            throw new Error("The parameter 'patientName' must be defined and cannot be null.");
        else
            url_ += "patientName=" + encodeURIComponent("" + patientName) + "&"; 
        if (patientSurname === undefined || patientSurname === null)
            throw new Error("The parameter 'patientSurname' must be defined and cannot be null.");
        else
            url_ += "patientSurname=" + encodeURIComponent("" + patientSurname) + "&"; 
        if (patientPatronymic === undefined || patientPatronymic === null)
            throw new Error("The parameter 'patientPatronymic' must be defined and cannot be null.");
        else
            url_ += "patientPatronymic=" + encodeURIComponent("" + patientPatronymic) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (isRepeated !== undefined)
            url_ += "isRepeated=" + encodeURIComponent("" + isRepeated) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallListUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallListUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallListUsingGET_1(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Получение списка вызовов диспетчера ТЦМК
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param callStatusList (optional) callStatusList
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @param subdivisionId (optional) subdivisionId
     * @param isChildrenIncluded (optional) IsChildrenIncluded
     * @return OK
     */
    getTcmkCallListUsingGET(from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, callStatusList?: CallStatusList2[] | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined, subdivisionId?: number | null | undefined, isChildrenIncluded?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list/tcmk?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (callStatusList !== undefined)
            callStatusList && callStatusList.forEach(item => { url_ += "callStatusList=" + encodeURIComponent("" + item) + "&"; });
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (isChildrenIncluded !== undefined)
            url_ += "IsChildrenIncluded=" + encodeURIComponent("" + isChildrenIncluded) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTcmkCallListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTcmkCallListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTcmkCallListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Получение списка конфигов
     * @return OK
     */
    getConfigListUsingGET(): Observable<CallOperatorInfoBean[]> {
        let url_ = this.baseUrl + "/api/andy/call/operator/info/list/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallOperatorInfoBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallOperatorInfoBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigListUsingGET(response: HttpResponseBase): Observable<CallOperatorInfoBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallOperatorInfoBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallOperatorInfoBean[]>(<any>null);
    }

    /**
     * Создание/обновление конфига
     * @param bean bean
     * @return OK
     */
    updateConfigUsingPOST(bean: CallOperatorInfoBean): Observable<CallOperatorInfoBean> {
        let url_ = this.baseUrl + "/api/andy/call/operator/info/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConfigUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfigUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallOperatorInfoBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallOperatorInfoBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfigUsingPOST(response: HttpResponseBase): Observable<CallOperatorInfoBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallOperatorInfoBean.fromJS(resultData200) : new CallOperatorInfoBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallOperatorInfoBean>(<any>null);
    }

    /**
     * Получение статуса вызовов
     * @param id id
     * @return OK
     */
    getCallStatusUsingGET(id: number): Observable<Anonymous> {
        let url_ = this.baseUrl + "/api/andy/call/status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallStatusUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallStatusUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Anonymous>><any>_observableThrow(e);
                }
            } else
                return <Observable<Anonymous>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallStatusUsingGET(response: HttpResponseBase): Observable<Anonymous> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Anonymous>(<any>null);
    }

    /**
     * Получение статусаов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    getCallStatusListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/call/statusList?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallStatusListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallStatusListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallStatusListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Обновление вызова
     * @param bean bean
     * @return OK
     */
    updateCallUsingPOST(bean: CallBean): Observable<CallBean> {
        let url_ = this.baseUrl + "/api/andy/call/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCallUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCallUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCallUsingPOST(response: HttpResponseBase): Observable<CallBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBean.fromJS(resultData200) : new CallBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBean>(<any>null);
    }

    /**
     * Обновление контейнера вызовов
     * @param callContainer callContainer
     * @return OK
     */
    updateCallContainerUsingPOST(callContainer: CallContainer): Observable<CallContainer> {
        let url_ = this.baseUrl + "/api/andy/call/update_call_container";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(callContainer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCallContainerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCallContainerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallContainer>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCallContainerUsingPOST(response: HttpResponseBase): Observable<CallContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallContainer.fromJS(resultData200) : new CallContainer();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallContainer>(<any>null);
    }

    /**
     * Обновление контейнера вызовов без изменения назначенных бригад
     * @param callContainer callContainer
     * @return OK
     */
    updateCallContainerWithoutBrigadesUsingPOST(callContainer: CallContainer): Observable<CallContainer> {
        let url_ = this.baseUrl + "/api/andy/call/update_call_container/without_brigades";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(callContainer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCallContainerWithoutBrigadesUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCallContainerWithoutBrigadesUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallContainer>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCallContainerWithoutBrigadesUsingPOST(response: HttpResponseBase): Observable<CallContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallContainer.fromJS(resultData200) : new CallContainer();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallContainer>(<any>null);
    }

    /**
     * Отправка нескольких случаев в ЕГИСЗ
     * @param ids (optional) ids
     * @return OK
     */
    egiszCasesUsingGET(ids?: number[] | null | undefined): Observable<boolean[]> {
        let url_ = this.baseUrl + "/api/andy/card/egisz/list?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEgiszCasesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEgiszCasesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<boolean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean[]>><any>_observableThrow(response_);
        }));
    }

    protected processEgiszCasesUsingGET(response: HttpResponseBase): Observable<boolean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean[]>(<any>null);
    }

    /**
     * Отправка случая в ЕГИСЗ
     * @param id id
     * @return OK
     */
    egiszCaseUsingGET(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/andy/card/egisz/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEgiszCaseUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEgiszCaseUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processEgiszCaseUsingGET(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Получение формы Ф110
     * @param id id
     * @return OK
     */
    getCardUsingGET(id: number): Observable<CardBean> {
        let url_ = this.baseUrl + "/api/andy/card/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardUsingGET(response: HttpResponseBase): Observable<CardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBean.fromJS(resultData200) : new CardBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBean>(<any>null);
    }

    /**
     * Получение списка архивных форм Ф110
     * @param bean bean
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @return OK
     */
    getArchiveCardListUsingPOST(bean: ArchiveCardContainer, from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/card/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArchiveCardListUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArchiveCardListUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetArchiveCardListUsingPOST(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Получение списка форм Ф110
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param cardStatusList (optional) cardStatusList
     * @param callId (optional) callId
     * @param patientId (optional) patientId
     * @param brigadeId (optional) brigadeId
     * @param subdivisionId (optional) subdivisionId
     * @param isChildrenIncluded (optional) IsChildrenIncluded
     * @return OK
     */
    getCardListUsingGET(from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, cardStatusList?: CardStatusList[] | null | undefined, callId?: number | null | undefined, patientId?: number | null | undefined, brigadeId?: number | null | undefined, subdivisionId?: number | null | undefined, isChildrenIncluded?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/card/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (cardStatusList !== undefined)
            cardStatusList && cardStatusList.forEach(item => { url_ += "cardStatusList=" + encodeURIComponent("" + item) + "&"; });
        if (callId !== undefined)
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&"; 
        if (brigadeId !== undefined)
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (isChildrenIncluded !== undefined)
            url_ += "IsChildrenIncluded=" + encodeURIComponent("" + isChildrenIncluded) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Обновление статуса карты Ф110
     * @param cardId cardId
     * @param status status
     * @return OK
     */
    updateCardStatusUsingPOST(cardId: number, status: Status): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/card/status/{cardId}?";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardStatusUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardStatusUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardStatusUsingPOST(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Обновление формы Ф110
     * @param bean bean
     * @return OK
     */
    updateCardUsingPOST(bean: CardBean): Observable<CardBean> {
        let url_ = this.baseUrl + "/api/andy/card/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardUsingPOST(response: HttpResponseBase): Observable<CardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBean.fromJS(resultData200) : new CardBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBean>(<any>null);
    }

    /**
     * Удаление типа документа пациента по Id
     * @param id id
     * @return OK
     */
    deleteDocumentTypeUsingDELETE(id: number): Observable<DocumentTypeBean> {
        let url_ = this.baseUrl + "/api/andy/document/type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDocumentTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDocumentTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDocumentTypeUsingDELETE(response: HttpResponseBase): Observable<DocumentTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentTypeBean.fromJS(resultData200) : new DocumentTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeBean>(<any>null);
    }

    /**
     * Получение типа документа пациента по Id
     * @param id id
     * @return OK
     */
    getDocumentTypeUsingGET(id: number): Observable<DocumentTypeBean> {
        let url_ = this.baseUrl + "/api/andy/document/type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypeUsingGET(response: HttpResponseBase): Observable<DocumentTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentTypeBean.fromJS(resultData200) : new DocumentTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeBean>(<any>null);
    }

    /**
     * Получение списка типов документов пациентов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @return OK
     */
    getDocumentTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/document/type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление типа документа пациента по Id
     * @param id id
     * @return OK
     */
    restoreDocumentTypeUsingPOST(id: number): Observable<DocumentTypeBean> {
        let url_ = this.baseUrl + "/api/andy/document/type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDocumentTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDocumentTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDocumentTypeUsingPOST(response: HttpResponseBase): Observable<DocumentTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentTypeBean.fromJS(resultData200) : new DocumentTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeBean>(<any>null);
    }

    /**
     * Обновление/добавление типа документа пациента
     * @param bean bean
     * @return OK
     */
    updateDocumentTypeUsingPOST(bean: DocumentTypeBean): Observable<DocumentTypeBean> {
        let url_ = this.baseUrl + "/api/andy/document/type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDocumentTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDocumentTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDocumentTypeUsingPOST(response: HttpResponseBase): Observable<DocumentTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentTypeBean.fromJS(resultData200) : new DocumentTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeBean>(<any>null);
    }

    /**
     * Удаление лекарства по ID
     * @param id id
     * @return OK
     */
    deleteFormUsingDELETE(id: number): Observable<DrugFormBean> {
        let url_ = this.baseUrl + "/api/andy/drugFrom2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFormUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFormUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugFormBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugFormBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFormUsingDELETE(response: HttpResponseBase): Observable<DrugFormBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugFormBean.fromJS(resultData200) : new DrugFormBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugFormBean>(<any>null);
    }

    /**
     * Получение форм препаратов по ID
     * @param id id
     * @return OK
     */
    getFormUsingGET(id: number): Observable<DrugFormBean> {
        let url_ = this.baseUrl + "/api/andy/drugFrom2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugFormBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugFormBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormUsingGET(response: HttpResponseBase): Observable<DrugFormBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugFormBean.fromJS(resultData200) : new DrugFormBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugFormBean>(<any>null);
    }

    /**
     * Получение форм препаратов по ID
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listFormUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/drugFrom2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListFormUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListFormUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListFormUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востановление формы по ID
     * @param id id
     * @return OK
     */
    restoreFormUsingGET(id: number): Observable<DrugFormBean> {
        let url_ = this.baseUrl + "/api/andy/drugFrom2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreFormUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreFormUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugFormBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugFormBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreFormUsingGET(response: HttpResponseBase): Observable<DrugFormBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugFormBean.fromJS(resultData200) : new DrugFormBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugFormBean>(<any>null);
    }

    /**
     * обновление лекарства
     * @param bean bean
     * @return OK
     */
    updateFormUsingPOST(bean: DrugFormBean): Observable<DrugFormBean> {
        let url_ = this.baseUrl + "/api/andy/drugFrom2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFormUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFormUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugFormBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugFormBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFormUsingPOST(response: HttpResponseBase): Observable<DrugFormBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugFormBean.fromJS(resultData200) : new DrugFormBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugFormBean>(<any>null);
    }

    /**
     * Удаление заявки по ID
     * @param id id
     * @return OK
     */
    deleteDrugRequestUsingDELETE(id: number): Observable<DrugRequestBean> {
        let url_ = this.baseUrl + "/api/andy/drugRequest/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDrugRequestUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDrugRequestUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDrugRequestUsingDELETE(response: HttpResponseBase): Observable<DrugRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugRequestBean.fromJS(resultData200) : new DrugRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugRequestBean>(<any>null);
    }

    /**
     * Получение заявки по ID
     * @param id id
     * @return OK
     */
    getDrugRequestUsingGET(id: number): Observable<DrugRequestBean> {
        let url_ = this.baseUrl + "/api/andy/drugRequest/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugRequestUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugRequestUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugRequestUsingGET(response: HttpResponseBase): Observable<DrugRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugRequestBean.fromJS(resultData200) : new DrugRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugRequestBean>(<any>null);
    }

    /**
     * Получение списка заявок
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param accepted (optional) accepted
     * @param bagId (optional) bagId
     * @return OK
     */
    getDrugRequestsUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, accepted?: boolean | null | undefined, bagId?: number | null | undefined): Observable<ListContainerOfDrugRequestBean> {
        let url_ = this.baseUrl + "/api/andy/drugRequest/listAll?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (accepted !== undefined)
            url_ += "accepted=" + encodeURIComponent("" + accepted) + "&"; 
        if (bagId !== undefined)
            url_ += "bagId=" + encodeURIComponent("" + bagId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugRequestsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugRequestsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugRequestsUsingGET(response: HttpResponseBase): Observable<ListContainerOfDrugRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugRequestBean.fromJS(resultData200) : new ListContainerOfDrugRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugRequestBean>(<any>null);
    }

    /**
     * Удовлетворение заявки со склада
     * @param id id
     * @return OK
     */
    rechargeBagUsingPOST(id: number): Observable<BagBean> {
        let url_ = this.baseUrl + "/api/andy/drugRequest/rechargeBag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRechargeBagUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRechargeBagUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BagBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagBean>><any>_observableThrow(response_);
        }));
    }

    protected processRechargeBagUsingPOST(response: HttpResponseBase): Observable<BagBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagBean.fromJS(resultData200) : new BagBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagBean>(<any>null);
    }

    /**
     * Восстановление заявки по ID
     * @param id id
     * @return OK
     */
    restoreDrugRequestUsingPOST(id: number): Observable<DrugRequestBean> {
        let url_ = this.baseUrl + "/api/andy/drugRequest/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugRequestUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugRequestUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugRequestUsingPOST(response: HttpResponseBase): Observable<DrugRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugRequestBean.fromJS(resultData200) : new DrugRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugRequestBean>(<any>null);
    }

    /**
     * Добавление заявки
     * @param bagIds bagIds
     * @return OK
     */
    createDrugRequestUsingPOST(bagIds: number[]): Observable<ListContainerOfDrugRequestBean> {
        let url_ = this.baseUrl + "/api/andy/drugRequest/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bagIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDrugRequestUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDrugRequestUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugRequestBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugRequestBean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDrugRequestUsingPOST(response: HttpResponseBase): Observable<ListContainerOfDrugRequestBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugRequestBean.fromJS(resultData200) : new ListContainerOfDrugRequestBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugRequestBean>(<any>null);
    }

    /**
     * Удаление типа по ID
     * @param id id
     * @return OK
     */
    deleteTypeUsingDELETE(id: number): Observable<DrugTypeBean> {
        let url_ = this.baseUrl + "/api/andy/drugType2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTypeUsingDELETE(response: HttpResponseBase): Observable<DrugTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugTypeBean.fromJS(resultData200) : new DrugTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugTypeBean>(<any>null);
    }

    /**
     * Получение типа по ID
     * @param id id
     * @return OK
     */
    getTypeUsingGET(id: number): Observable<DrugTypeBean> {
        let url_ = this.baseUrl + "/api/andy/drugType2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTypeUsingGET(response: HttpResponseBase): Observable<DrugTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugTypeBean.fromJS(resultData200) : new DrugTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugTypeBean>(<any>null);
    }

    /**
     * Виды упаковок лекарств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    getDrugPackagesUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainerOfDrugPackage> {
        let url_ = this.baseUrl + "/api/andy/drugType2.0/getDrugPackages?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugPackagesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugPackagesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfDrugPackage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfDrugPackage>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugPackagesUsingGET(response: HttpResponseBase): Observable<ListContainerOfDrugPackage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfDrugPackage.fromJS(resultData200) : new ListContainerOfDrugPackage();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfDrugPackage>(<any>null);
    }

    /**
     * Получение списка типов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/drugType2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востонавление типа по ID
     * @param id id
     * @return OK
     */
    restoreTypeUsingGET(id: number): Observable<DrugTypeBean> {
        let url_ = this.baseUrl + "/api/andy/drugType2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTypeUsingGET(response: HttpResponseBase): Observable<DrugTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugTypeBean.fromJS(resultData200) : new DrugTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugTypeBean>(<any>null);
    }

    /**
     * обновление вида
     * @param bean bean
     * @return OK
     */
    updateTypeUsingPOST(bean: DrugTypeBean): Observable<DrugTypeBean> {
        let url_ = this.baseUrl + "/api/andy/drugType2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTypeUsingPOST(response: HttpResponseBase): Observable<DrugTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugTypeBean.fromJS(resultData200) : new DrugTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugTypeBean>(<any>null);
    }

    /**
     * Удаление категории лекарства по ID
     * @param id id
     * @return OK
     */
    deleteDrugCategoryUsingDELETE(id: number): Observable<DrugCategoryBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/category/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDrugCategoryUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDrugCategoryUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugCategoryBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugCategoryBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDrugCategoryUsingDELETE(response: HttpResponseBase): Observable<DrugCategoryBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugCategoryBean.fromJS(resultData200) : new DrugCategoryBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugCategoryBean>(<any>null);
    }

    /**
     * Получение категории лекарства по ID
     * @param id id
     * @return OK
     */
    getCategoryDrugUsingGET(id: number): Observable<DrugCategoryBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/category/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryDrugUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryDrugUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugCategoryBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugCategoryBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryDrugUsingGET(response: HttpResponseBase): Observable<DrugCategoryBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugCategoryBean.fromJS(resultData200) : new DrugCategoryBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugCategoryBean>(<any>null);
    }

    /**
     * Получение списка категорий лекарств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param id (optional) id
     * @param code (optional) code
     * @param name (optional) name
     * @return OK
     */
    getDrugCategoryListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, id?: number | null | undefined, code?: string | null | undefined, name?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/drugs/category/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugCategoryListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugCategoryListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugCategoryListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление категории лекарства по ID
     * @param id id
     * @return OK
     */
    restoreDrugCategoryUsingPOST(id: number): Observable<DrugCategoryBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/category/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugCategoryUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugCategoryUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugCategoryBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugCategoryBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugCategoryUsingPOST(response: HttpResponseBase): Observable<DrugCategoryBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugCategoryBean.fromJS(resultData200) : new DrugCategoryBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugCategoryBean>(<any>null);
    }

    /**
     * Обновление/добавление категории лекарства
     * @param bean bean
     * @return OK
     */
    updateDrugCategoryUsingPOST(bean: DrugCategoryBean): Observable<DrugCategoryBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugCategoryUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugCategoryUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugCategoryBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugCategoryBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugCategoryUsingPOST(response: HttpResponseBase): Observable<DrugCategoryBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugCategoryBean.fromJS(resultData200) : new DrugCategoryBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugCategoryBean>(<any>null);
    }

    /**
     * Удаление лекарства по ID
     * @param id id
     * @return OK
     */
    deleteDrugBeanUsingDELETE(id: number): Observable<DrugBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/drug/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDrugBeanUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDrugBeanUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDrugBeanUsingDELETE(response: HttpResponseBase): Observable<DrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugBean.fromJS(resultData200) : new DrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugBean>(<any>null);
    }

    /**
     * Получение лекарства по ID
     * @param id id
     * @return OK
     */
    getDrugUsingGET(id: number): Observable<DrugBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/drug/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugUsingGET(response: HttpResponseBase): Observable<DrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugBean.fromJS(resultData200) : new DrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugBean>(<any>null);
    }

    /**
     * Получение списка лекарств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param containerType (optional) containerType
     * @param measurement (optional) measurement
     * @param category (optional) category
     * @param group (optional) group
     * @param name (optional) name
     * @return OK
     */
    getDrugListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, containerType?: number | null | undefined, measurement?: number | null | undefined, category?: number | null | undefined, group?: number | null | undefined, name?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/drugs/drug/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (containerType !== undefined)
            url_ += "containerType=" + encodeURIComponent("" + containerType) + "&"; 
        if (measurement !== undefined)
            url_ += "measurement=" + encodeURIComponent("" + measurement) + "&"; 
        if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&"; 
        if (group !== undefined)
            url_ += "group=" + encodeURIComponent("" + group) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление лекарства по ID
     * @param id id
     * @return OK
     */
    restoreDrugBeanUsingPOST_1(id: number): Observable<DrugBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/drug/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugBeanUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugBeanUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<DrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugBeanUsingPOST_1(response: HttpResponseBase): Observable<DrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugBean.fromJS(resultData200) : new DrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugBean>(<any>null);
    }

    /**
     * Обновление/добавление лекарства
     * @param drugBean drugBean
     * @return OK
     */
    updateDrugUsingPOST(drugBean: DrugBean): Observable<DrugBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/drug/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(drugBean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugUsingPOST(response: HttpResponseBase): Observable<DrugBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugBean.fromJS(resultData200) : new DrugBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugBean>(<any>null);
    }

    /**
     * Удаление группы лекарств по ID
     * @param id id
     * @return OK
     */
    deleteDrugGroupUsingDELETE(id: number): Observable<DrugGroupBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/group/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDrugGroupUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDrugGroupUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDrugGroupUsingDELETE(response: HttpResponseBase): Observable<DrugGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugGroupBean.fromJS(resultData200) : new DrugGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugGroupBean>(<any>null);
    }

    /**
     * Получение группы лекарств по ID
     * @param id id
     * @return OK
     */
    getGroupDrugUsingGET(id: number): Observable<DrugGroupBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/group/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupDrugUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupDrugUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupDrugUsingGET(response: HttpResponseBase): Observable<DrugGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugGroupBean.fromJS(resultData200) : new DrugGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugGroupBean>(<any>null);
    }

    /**
     * Получение списка группы лекарств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param id (optional) id
     * @param code (optional) code
     * @param name (optional) name
     * @return OK
     */
    getDrugGroupListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, id?: number | null | undefined, code?: string | null | undefined, name?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/drugs/group/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugGroupListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugGroupListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugGroupListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление группы лекарств по ID
     * @param id id
     * @return OK
     */
    restoreDrugGroupUsingPOST(id: number): Observable<DrugGroupBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/group/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugGroupUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugGroupUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugGroupUsingPOST(response: HttpResponseBase): Observable<DrugGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugGroupBean.fromJS(resultData200) : new DrugGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugGroupBean>(<any>null);
    }

    /**
     * Обновление/добавление группы лекарств
     * @param bean bean
     * @return OK
     */
    updateDrugGroupUsingPOST(bean: DrugGroupBean): Observable<DrugGroupBean> {
        let url_ = this.baseUrl + "/api/andy/drugs/group/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugGroupUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugGroupUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugGroupUsingPOST(response: HttpResponseBase): Observable<DrugGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugGroupBean.fromJS(resultData200) : new DrugGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugGroupBean>(<any>null);
    }

    /**
     * Удаление лекарства по ID
     * @param id id
     * @return OK
     */
    deleteDrugNewUsingDELETE(id: number): Observable<DrugNewBean> {
        let url_ = this.baseUrl + "/api/andy/drugs2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDrugNewUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDrugNewUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDrugNewUsingDELETE(response: HttpResponseBase): Observable<DrugNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugNewBean.fromJS(resultData200) : new DrugNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugNewBean>(<any>null);
    }

    /**
     * Получение лекарства по ID
     * @param id id
     * @return OK
     */
    getDrugNewUsingGET(id: number): Observable<DrugNewBean> {
        let url_ = this.baseUrl + "/api/andy/drugs2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugNewUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugNewUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugNewUsingGET(response: HttpResponseBase): Observable<DrugNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugNewBean.fromJS(resultData200) : new DrugNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugNewBean>(<any>null);
    }

    /**
     * Получение списка лекарств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    getDrugNewListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/drugs2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugNewListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugNewListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugNewListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востонавление лекарства по ID
     * @param id id
     * @return OK
     */
    restoreDrugNewUsingGET(id: number): Observable<DrugNewBean> {
        let url_ = this.baseUrl + "/api/andy/drugs2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugNewUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugNewUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugNewUsingGET(response: HttpResponseBase): Observable<DrugNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugNewBean.fromJS(resultData200) : new DrugNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugNewBean>(<any>null);
    }

    /**
     * обновление лекарства
     * @param bean bean
     * @return OK
     */
    updateDrugNewUsingPOST(bean: DrugNewBean): Observable<DrugNewBean> {
        let url_ = this.baseUrl + "/api/andy/drugs2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugNewUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugNewUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugNewUsingPOST(response: HttpResponseBase): Observable<DrugNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugNewBean.fromJS(resultData200) : new DrugNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugNewBean>(<any>null);
    }

    /**
     * Удаление опросника по Id
     * @param id id
     * @return OK
     */
    deleteInquirerUsingDELETE(id: number): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInquirerUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInquirerUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInquirerUsingDELETE(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Получение записи опросника по Id
     * @param id id
     * @return OK
     */
    getInquirerUsingGET(id: number): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInquirerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInquirerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetInquirerUsingGET(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Получение следующего уровня опросника по Id родителя
     * @param rootId (optional) rootId
     * @param deleted (optional) deleted
     * @return OK
     */
    getBranchNodeUsingGET(rootId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfInquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/node/branch?";
        if (rootId !== undefined)
            url_ += "rootId=" + encodeURIComponent("" + rootId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfInquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfInquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranchNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNodeOfInquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfInquirerBean.fromJS(resultData200) : new AndyTreeNodeOfInquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfInquirerBean>(<any>null);
    }

    /**
     * Получение полного дерева опросников по Id
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullNodeUsingGET(deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfInquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/node/full?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfInquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfInquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNodeOfInquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfInquirerBean.fromJS(resultData200) : new AndyTreeNodeOfInquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfInquirerBean>(<any>null);
    }

    /**
     * Восстановление опросника по Id
     * @param id id
     * @return OK
     */
    restoreInquirerUsingPOST(id: number): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreInquirerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreInquirerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreInquirerUsingPOST(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Обновление/создание записи опросника
     * @param bean bean
     * @return OK
     */
    updateInquirerUsingPOST(bean: InquirerBean): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInquirerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInquirerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInquirerUsingPOST(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getInquirerVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/inquirer/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInquirerVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInquirerVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetInquirerVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Блокировка вызова
     * @param id id
     * @return OK
     */
    lockCallUsingGET(id: number): Observable<LockResult> {
        let url_ = this.baseUrl + "/api/andy/locks/call/lock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockResult>><any>_observableThrow(response_);
        }));
    }

    protected processLockCallUsingGET(response: HttpResponseBase): Observable<LockResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockResult.fromJS(resultData200) : new LockResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockResult>(<any>null);
    }

    /**
     * Обновление блокировки вызова
     * @param id id
     * @param token token
     * @return OK
     */
    relockCallUsingGET(id: number, token: string): Observable<LockResult> {
        let url_ = this.baseUrl + "/api/andy/locks/call/relock/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRelockCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRelockCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockResult>><any>_observableThrow(response_);
        }));
    }

    protected processRelockCallUsingGET(response: HttpResponseBase): Observable<LockResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockResult.fromJS(resultData200) : new LockResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockResult>(<any>null);
    }

    /**
     * Снятие блокировки вызова
     * @param id id
     * @param token token
     * @return OK
     */
    unlockCallUsingGET(id: number, token: string): Observable<LockResult> {
        let url_ = this.baseUrl + "/api/andy/locks/call/unlock/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockResult>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockCallUsingGET(response: HttpResponseBase): Observable<LockResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockResult.fromJS(resultData200) : new LockResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockResult>(<any>null);
    }

    /**
     * Блокировка карты
     * @param id id
     * @return OK
     */
    lockCardUsingGET(id: number): Observable<LockResult> {
        let url_ = this.baseUrl + "/api/andy/locks/card/lock/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockResult>><any>_observableThrow(response_);
        }));
    }

    protected processLockCardUsingGET(response: HttpResponseBase): Observable<LockResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockResult.fromJS(resultData200) : new LockResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockResult>(<any>null);
    }

    /**
     * Обновление блокировки карты
     * @param id id
     * @param token token
     * @return OK
     */
    relockCardUsingGET(id: number, token: string): Observable<LockResult> {
        let url_ = this.baseUrl + "/api/andy/locks/card/relock/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRelockCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRelockCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockResult>><any>_observableThrow(response_);
        }));
    }

    protected processRelockCardUsingGET(response: HttpResponseBase): Observable<LockResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockResult.fromJS(resultData200) : new LockResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockResult>(<any>null);
    }

    /**
     * Снятие блокировки карты
     * @param id id
     * @param token token
     * @return OK
     */
    unlockCardUsingGET(id: number, token: string): Observable<LockResult> {
        let url_ = this.baseUrl + "/api/andy/locks/card/unlock/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockResult>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockCardUsingGET(response: HttpResponseBase): Observable<LockResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockResult.fromJS(resultData200) : new LockResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockResult>(<any>null);
    }

    /**
     * Получение информации о периодичности обновления блокировок
     * @return OK
     */
    getOptionsUsingGET(): Observable<LockOptions> {
        let url_ = this.baseUrl + "/api/andy/locks/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOptionsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptionsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LockOptions>><any>_observableThrow(e);
                }
            } else
                return <Observable<LockOptions>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptionsUsingGET(response: HttpResponseBase): Observable<LockOptions> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LockOptions.fromJS(resultData200) : new LockOptions();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LockOptions>(<any>null);
    }

    /**
     * Получение помойки с логами целиком
     * @param from (optional) От
     * @param count (optional) Количество
     * @param logType (optional) Тип записи
     * @param performerId (optional) ID исполнителя
     * @return OK
     */
    getLogListByTableUsingGET(from?: number | null | undefined, count?: number | null | undefined, logType?: number | null | undefined, performerId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/garbage/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (logType !== undefined)
            url_ += "logType=" + encodeURIComponent("" + logType) + "&"; 
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByTableUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByTableUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByTableUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Лог по ЕГИСЗ
     * @param id (optional) ID бина
     * @return OK
     */
    getLogByIdUsingGET(id?: number | null | undefined): Observable<OutwardLogBean> {
        let url_ = this.baseUrl + "/api/andy/log/outward/get?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogByIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogByIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<OutwardLogBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutwardLogBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogByIdUsingGET(response: HttpResponseBase): Observable<OutwardLogBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutwardLogBean.fromJS(resultData200) : new OutwardLogBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutwardLogBean>(<any>null);
    }

    /**
     * Список логов по ЕГИСЗ
     * @param from (optional) От
     * @param count (optional) Количество
     * @param subdivisionId (optional) ID подразделения
     * @param isConfirm (optional) Подтверждение отправки
     * @return OK
     */
    getExtendedLogListByRecordUsingGET_1(from?: number | null | undefined, count?: number | null | undefined, subdivisionId?: number | null | undefined, isConfirm?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/outward/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (isConfirm !== undefined)
            url_ += "isConfirm=" + encodeURIComponent("" + isConfirm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExtendedLogListByRecordUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExtendedLogListByRecordUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetExtendedLogListByRecordUsingGET_1(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка действий исполнителя
     * @param from (optional) От
     * @param count (optional) Количество
     * @param performerId (optional) ID исполнителя
     * @return OK
     */
    getLogListByUserUsingGET(from?: number | null | undefined, count?: number | null | undefined, performerId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/performer/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByUserUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByUserUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByUserUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка действий для конкретной записи
     * @param from (optional) От
     * @param count (optional) Количество
     * @param recordId (optional) ID записи
     * @param recordType (optional) Тип записи
     * @return OK
     */
    getLogListByRecordUsingGET(from?: number | null | undefined, count?: number | null | undefined, recordId?: number | null | undefined, recordType?: RecordType | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/record/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (recordId !== undefined)
            url_ += "recordId=" + encodeURIComponent("" + recordId) + "&"; 
        if (recordType !== undefined)
            url_ += "recordType=" + encodeURIComponent("" + recordType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByRecordUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByRecordUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByRecordUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение расширенного списка действий для конкретной записи
     * @param from (optional) От
     * @param count (optional) Количество
     * @param recordId (optional) ID записи
     * @param logType (optional) Тип лога
     * @param recordType (optional) Тип записи
     * @return OK
     */
    getExtendedLogListByRecordUsingGET(from?: number | null | undefined, count?: number | null | undefined, recordId?: number | null | undefined, logType?: number | null | undefined, recordType?: RecordType2 | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/record/list/extended?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (recordId !== undefined)
            url_ += "recordId=" + encodeURIComponent("" + recordId) + "&"; 
        if (logType !== undefined)
            url_ += "logType=" + encodeURIComponent("" + logType) + "&"; 
        if (recordType !== undefined)
            url_ += "recordType=" + encodeURIComponent("" + recordType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExtendedLogListByRecordUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExtendedLogListByRecordUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetExtendedLogListByRecordUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка действий для типа записи(таблицы)
     * @param from (optional) От
     * @param count (optional) Количество
     * @param logType (optional) Тип записи
     * @return OK
     */
    getLogListByTableUsingGET_1(from?: number | null | undefined, count?: number | null | undefined, logType?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/table/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (logType !== undefined)
            url_ += "logType=" + encodeURIComponent("" + logType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByTableUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByTableUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByTableUsingGET_1(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Удаление классификации МКБ по Id
     * @param id id
     * @return OK
     */
    deleteClassMkbUsingDELETE(id: number): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassMkbUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassMkbUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteClassMkbUsingDELETE(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Получение классификации МКБ по Id
     * @param id id
     * @return OK
     */
    getClassMkbUsingGET(id: number): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassMkbUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassMkbUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassMkbUsingGET(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Получение списка классификации МКБ
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getFullListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/mkb/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение следующего уровня дерева классификаций МКБ по Id родителя
     * @param rootId (optional) rootId
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullMkbNodeUsingGET(rootId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/node/branch?";
        if (rootId !== undefined)
            url_ += "rootId=" + encodeURIComponent("" + rootId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullMkbNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullMkbNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullMkbNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNodeOfClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfClassMkbBean.fromJS(resultData200) : new AndyTreeNodeOfClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfClassMkbBean>(<any>null);
    }

    /**
     * Получение полного дерева классификаций МКБ по Id
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullMkbNodeUsingGET_1(deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/node/full?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullMkbNodeUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullMkbNodeUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullMkbNodeUsingGET_1(response: HttpResponseBase): Observable<AndyTreeNodeOfClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfClassMkbBean.fromJS(resultData200) : new AndyTreeNodeOfClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfClassMkbBean>(<any>null);
    }

    /**
     * Восстановление классификации МКБ по Id
     * @param id id
     * @return OK
     */
    restoreClassMkbUsingPOST(id: number): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreClassMkbUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreClassMkbUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreClassMkbUsingPOST(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Обновление классификации МКБ
     * @param bean bean
     * @return OK
     */
    updateClassMkbUsingPOST(bean: ClassMkbBean): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClassMkbUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClassMkbUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateClassMkbUsingPOST(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getClassMkbVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/mkb/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassMkbVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassMkbVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassMkbVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление операции по ID
     * @param id id
     * @return OK
     */
    deleteOperationUsingDELETE(id: number): Observable<OperationBean> {
        let url_ = this.baseUrl + "/api/andy/operation2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOperationUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOperationUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<OperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOperationUsingDELETE(response: HttpResponseBase): Observable<OperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OperationBean.fromJS(resultData200) : new OperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationBean>(<any>null);
    }

    /**
     * Получение операции по ID
     * @param id id
     * @return OK
     */
    getOperationUsingGET(id: number): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/operation2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка операций
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listOperationUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/operation2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOperationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOperationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListOperationUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востонавление операции по ID
     * @param id id
     * @return OK
     */
    restoreOperationUsingDELETE(id: number): Observable<OperationBean> {
        let url_ = this.baseUrl + "/api/andy/operation2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreOperationUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreOperationUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<OperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreOperationUsingDELETE(response: HttpResponseBase): Observable<OperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OperationBean.fromJS(resultData200) : new OperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationBean>(<any>null);
    }

    /**
     * обновление операции
     * @param bean bean
     * @return OK
     */
    updateOperationUsingPOST(bean: OperationBean): Observable<OperationBean> {
        let url_ = this.baseUrl + "/api/andy/operation2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOperationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOperationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<OperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOperationUsingPOST(response: HttpResponseBase): Observable<OperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OperationBean.fromJS(resultData200) : new OperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationBean>(<any>null);
    }

    /**
     * Полнотекстовый поиск улицы
     * @param cityAddress (optional) cityAddress
     * @param streetName (optional) streetName
     * @return OK
     */
    getBuildingListUsingGET(cityAddress?: string | null | undefined, streetName?: string | null | undefined): Observable<BuildingBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/building?";
        if (cityAddress !== undefined)
            url_ += "cityAddress=" + encodeURIComponent("" + cityAddress) + "&"; 
        if (streetName !== undefined)
            url_ += "streetName=" + encodeURIComponent("" + streetName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildingListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildingListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BuildingBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildingListUsingGET(response: HttpResponseBase): Observable<BuildingBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BuildingBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingBean[]>(<any>null);
    }

    /**
     * Полнотекстовый поиск района/области
     * @param query (optional) query
     * @return OK
     */
    getRegionListUsingGET(query?: string | null | undefined): Observable<RegionBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/region?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<RegionBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegionBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionListUsingGET(response: HttpResponseBase): Observable<RegionBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RegionBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionBean[]>(<any>null);
    }

    /**
     * Полнотекстовый поиск населенного пункта
     * @param query (optional) query
     * @return OK
     */
    getSettlementListUsingGET(query?: string | null | undefined): Observable<SettlementBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/settlement?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettlementListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettlementListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SettlementBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettlementBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettlementListUsingGET(response: HttpResponseBase): Observable<SettlementBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SettlementBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettlementBean[]>(<any>null);
    }

    /**
     * Полнотекстовый поиск улицы
     * @param query (optional) query
     * @return OK
     */
    getStreetListUsingGET(query?: string | null | undefined): Observable<StreetBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/street?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStreetListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStreetListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<StreetBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StreetBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStreetListUsingGET(response: HttpResponseBase): Observable<StreetBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StreetBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StreetBean[]>(<any>null);
    }

    /**
     * Удаление прочих средств по ID
     * @param id id
     * @return OK
     */
    deleteOtherUsingDELETE(id: number): Observable<OtherMeanBean> {
        let url_ = this.baseUrl + "/api/andy/otherMean2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOtherUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOtherUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<OtherMeanBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OtherMeanBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOtherUsingDELETE(response: HttpResponseBase): Observable<OtherMeanBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OtherMeanBean.fromJS(resultData200) : new OtherMeanBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OtherMeanBean>(<any>null);
    }

    /**
     * Получение прочих средств по ID
     * @param id id
     * @return OK
     */
    getOtherUsingGET(id: number): Observable<OtherMeanBean> {
        let url_ = this.baseUrl + "/api/andy/otherMean2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOtherUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOtherUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<OtherMeanBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OtherMeanBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetOtherUsingGET(response: HttpResponseBase): Observable<OtherMeanBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OtherMeanBean.fromJS(resultData200) : new OtherMeanBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OtherMeanBean>(<any>null);
    }

    /**
     * Получение списка прочих средств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listOtherUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/otherMean2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListOtherUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListOtherUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListOtherUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востонавление прочих средств по ID
     * @param id id
     * @return OK
     */
    restoreOtherUsingDELETE(id: number): Observable<OtherMeanBean> {
        let url_ = this.baseUrl + "/api/andy/otherMean2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreOtherUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreOtherUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<OtherMeanBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OtherMeanBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreOtherUsingDELETE(response: HttpResponseBase): Observable<OtherMeanBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OtherMeanBean.fromJS(resultData200) : new OtherMeanBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OtherMeanBean>(<any>null);
    }

    /**
     * Обновление прочих средств
     * @param bean bean
     * @return OK
     */
    updateOtherUsingPOST(bean: OtherMeanBean): Observable<OtherMeanBean> {
        let url_ = this.baseUrl + "/api/andy/otherMean2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOtherUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOtherUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<OtherMeanBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<OtherMeanBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOtherUsingPOST(response: HttpResponseBase): Observable<OtherMeanBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OtherMeanBean.fromJS(resultData200) : new OtherMeanBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OtherMeanBean>(<any>null);
    }

    /**
     * Удаление пациента по Id
     * @param id id
     * @return OK
     */
    deletePatientUsingDELETE(id: number): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePatientUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePatientUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePatientUsingDELETE(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Отправлять пациента в егисз
     * @param id id
     * @return OK
     */
    egiszPatientUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/patients/egisz/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEgiszPatientUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEgiszPatientUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEgiszPatientUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Получение пациента по Id
     * @param id id
     * @return OK
     */
    getPatientUsingGET(id: number): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatientUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatientUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPatientUsingGET(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Получение списка пациентов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param patientType (optional) patientType
     * @param surname (optional) surname
     * @param name (optional) name
     * @param patronymic (optional) patronymic
     * @param dateBirth (optional) dateBirth
     * @param series (optional) series
     * @param num (optional) num
     * @return OK
     */
    getPatientListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, patientType?: number | null | undefined, surname?: string | null | undefined, name?: string | null | undefined, patronymic?: string | null | undefined, dateBirth?: string | null | undefined, series?: string | null | undefined, num?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/patients/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (patientType !== undefined)
            url_ += "patientType=" + encodeURIComponent("" + patientType) + "&"; 
        if (surname !== undefined)
            url_ += "surname=" + encodeURIComponent("" + surname) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (patronymic !== undefined)
            url_ += "patronymic=" + encodeURIComponent("" + patronymic) + "&"; 
        if (dateBirth !== undefined)
            url_ += "dateBirth=" + encodeURIComponent("" + dateBirth) + "&"; 
        if (series !== undefined)
            url_ += "series=" + encodeURIComponent("" + series) + "&"; 
        if (num !== undefined)
            url_ += "num=" + encodeURIComponent("" + num) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatientListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatientListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPatientListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Поиск похожих пациентов
     * @param from (optional) from
     * @param count (optional) count
     * @param name (optional) name
     * @param surname (optional) surname
     * @param patronymic (optional) patronymic
     * @param fullAge (optional) fullAge
     * @param fullMonth (optional) fullMonth
     * @param fullDay (optional) fullDay
     * @return OK
     */
    getSimilarPatientListUsingGET(from?: number | null | undefined, count?: number | null | undefined, name?: string | null | undefined, surname?: string | null | undefined, patronymic?: string | null | undefined, fullAge?: number | null | undefined, fullMonth?: number | null | undefined, fullDay?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/patients/list/similar?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (surname !== undefined)
            url_ += "surname=" + encodeURIComponent("" + surname) + "&"; 
        if (patronymic !== undefined)
            url_ += "patronymic=" + encodeURIComponent("" + patronymic) + "&"; 
        if (fullAge !== undefined)
            url_ += "fullAge=" + encodeURIComponent("" + fullAge) + "&"; 
        if (fullMonth !== undefined)
            url_ += "fullMonth=" + encodeURIComponent("" + fullMonth) + "&"; 
        if (fullDay !== undefined)
            url_ += "fullDay=" + encodeURIComponent("" + fullDay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSimilarPatientListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSimilarPatientListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSimilarPatientListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление пациента по Id
     * @param id id
     * @return OK
     */
    restorePatientUsingPOST(id: number): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePatientUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePatientUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePatientUsingPOST(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Обновление пациента
     * @param bean bean
     * @return OK
     */
    updatePatientUsingPOST(bean: PatientBean): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatientUsingPOST(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Удаление расписания сотрудников
     * @param performerIds (optional) performerIds
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @param isBasic (optional) Тип удаляемых смен [true - по графику; false - БГ; null - все]
     * @return OK
     */
    scheduleClearUsingDELETE(performerIds?: number[] | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined, isBasic?: boolean | null | undefined): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/clear_schedule?";
        if (performerIds !== undefined)
            performerIds && performerIds.forEach(item => { url_ += "performerIds=" + encodeURIComponent("" + item) + "&"; });
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isBasic !== undefined)
            url_ += "isBasic=" + encodeURIComponent("" + isBasic) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleClearUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleClearUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleClearUsingDELETE(response: HttpResponseBase): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfPerformerBeanAndListOfMapOfstringAndobject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>(<any>null);
    }

    /**
     * Пролонгация расписания сотрудников
     * @param performerIds (optional) performerIds
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    scheduleProlongationUsingPOST(performerIds?: number[] | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/create_schedule?";
        if (performerIds !== undefined)
            performerIds && performerIds.forEach(item => { url_ += "performerIds=" + encodeURIComponent("" + item) + "&"; });
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleProlongationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleProlongationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleProlongationUsingPOST(response: HttpResponseBase): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfPerformerBeanAndListOfMapOfstringAndobject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>(<any>null);
    }

    /**
     * Удаление смены сотрудника
     * @param id id
     * @return OK
     */
    deletePerformerShiftUsingDELETE(id: number): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerShiftUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerShiftUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerShiftUsingDELETE(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Получение смены сотрудника
     * @param id id
     * @return OK
     */
    getPerformerShiftUsingGET(id: number): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerShiftUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerShiftUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerShiftUsingGET(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Восстановление смены сотрудника
     * @param id id
     * @return OK
     */
    restorePerformerShiftUsingPOST(id: number): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePerformerShiftUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePerformerShiftUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePerformerShiftUsingPOST(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Получение таблицы смен сотрудников
     * @param isPerformerDeleted (optional) isPerformerDeleted
     * @param isShiftDeleted (optional) isShiftDeleted
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @param isAvia (optional) isAvia
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getPerformerShiftTableUsingGET(isPerformerDeleted?: boolean | null | undefined, isShiftDeleted?: boolean | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined, isAvia?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/table?";
        if (isPerformerDeleted !== undefined)
            url_ += "isPerformerDeleted=" + encodeURIComponent("" + isPerformerDeleted) + "&"; 
        if (isShiftDeleted !== undefined)
            url_ += "isShiftDeleted=" + encodeURIComponent("" + isShiftDeleted) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isAvia !== undefined)
            url_ += "isAvia=" + encodeURIComponent("" + isAvia) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerShiftTableUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerShiftTableUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerShiftTableUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Создание/Обновление смены сотрудника
     * @param bean bean
     * @return OK
     */
    updatePerformerShiftUsingPOST(bean: PerformerShiftBean): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerShiftUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerShiftUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerShiftUsingPOST(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Удаление типа сотрудника по Id
     * @param id id
     * @return OK
     */
    deletePerformerTypeUsingDELETE(id: number): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerTypeUsingDELETE(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Получение типа сотрудника по Id
     * @param id id
     * @return OK
     */
    getPerformerTypeUsingGET(id: number): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeUsingGET(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Получение списка типов сотрудников
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getPerformerTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/performer_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление типа сотрудника по Id
     * @param id id
     * @return OK
     */
    restorePerformerTypeUsingPOST(id: number): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePerformerTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePerformerTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePerformerTypeUsingPOST(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Обновление типа сотрудника
     * @param bean bean
     * @return OK
     */
    updatePerformerTypeUsingPOST(bean: PerformerTypeBean): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerTypeUsingPOST(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPerformerTypeVersionUsingGET_2(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/performer_type/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeVersionUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeVersionUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeVersionUsingGET_2(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление исполнителя по Id
     * @param id id
     * @return OK
     */
    deletePerformerUsingDELETE(id: number): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerUsingDELETE(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Получение исполнителя по Id
     * @param id id
     * @return OK
     */
    getPerformerUsingGET(id: number): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerUsingGET(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Получение списка исполнителей
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param type (optional) type
     * @param name (optional) name
     * @param surname (optional) surname
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getPerformerListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, type?: number | null | undefined, name?: string | null | undefined, surname?: string | null | undefined, subdivisionId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/performers/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (surname !== undefined)
            url_ += "surname=" + encodeURIComponent("" + surname) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление исполнителя по Id
     * @param id id
     * @return OK
     */
    restorePerformerUsingPOST(id: number): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePerformerUsingPOST(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Обновление исполнителя
     * @param bean bean
     * @return OK
     */
    updatePerformerUsingPOST(bean: PerformerBean): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerUsingPOST(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Удаление фармокологической группы по Id
     * @param id id
     * @return OK
     */
    deletePharmacyGroupUsingDELETE(id: number): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePharmacyGroupUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePharmacyGroupUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePharmacyGroupUsingDELETE(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Получение фармокологической группы по Id
     * @param id id
     * @return OK
     */
    getPharmacyGroupUsingGET(id: number): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPharmacyGroupUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPharmacyGroupUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPharmacyGroupUsingGET(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Получение списка фармокологических групп
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getPharmacyGroupListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPharmacyGroupListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPharmacyGroupListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPharmacyGroupListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление фармокологической группы по Id
     * @param id id
     * @return OK
     */
    restorePharmacyGroupUsingPOST(id: number): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePharmacyGroupUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePharmacyGroupUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePharmacyGroupUsingPOST(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Обновление фармокологической группы
     * @param bean bean
     * @return OK
     */
    updatePharmacyGroupUsingPOST(bean: PharmacyGroupBean): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePharmacyGroupUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePharmacyGroupUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePharmacyGroupUsingPOST(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPharmacyGroupVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPharmacyGroupVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPharmacyGroupVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPharmacyGroupVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Сохранение PUSH-токена
     * @param token token
     * @return OK
     */
    createPushTokenUsingPOST(token: PushTokenBean): Observable<PushTokenBean> {
        let url_ = this.baseUrl + "/api/andy/push/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePushTokenUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePushTokenUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PushTokenBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PushTokenBean>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePushTokenUsingPOST(response: HttpResponseBase): Observable<PushTokenBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PushTokenBean.fromJS(resultData200) : new PushTokenBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PushTokenBean>(<any>null);
    }

    /**
     * Получение списка токенов
     * @return OK
     */
    getPushTokenListUsingGET(): Observable<PushTokenBean[]> {
        let url_ = this.baseUrl + "/api/andy/push/list/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPushTokenListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPushTokenListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PushTokenBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PushTokenBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPushTokenListUsingGET(response: HttpResponseBase): Observable<PushTokenBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PushTokenBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PushTokenBean[]>(<any>null);
    }

    /**
     * Тестовая отправка сообщения о новом вызове
     * @param token token
     * @return OK
     */
    testNewCallNotificationUsingPOST(token: string): Observable<string> {
        let url_ = this.baseUrl + "/api/andy/push/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNewCallNotificationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNewCallNotificationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTestNewCallNotificationUsingPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Удаление записи справочника
     * @param id id
     * @return OK
     */
    deleteReferenceTypeUsingDELETE(id: number): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReferenceTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReferenceTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReferenceTypeUsingDELETE(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Получение записи справочника
     * @param id id
     * @return OK
     */
    getReferenceTypeUsingGET(id: number): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeUsingGET(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Получение списка референсов по активному визиту
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListActiveVisitUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/active_visit?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListActiveVisitUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListActiveVisitUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListActiveVisitUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов аллергии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getAllergyTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/allergy_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllergyTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllergyTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllergyTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов поведения
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBehaviourUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/behaviour?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBehaviourUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBehaviourUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBehaviourUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сообщений бригады
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBrigadeMessageUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/brigade_message?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBrigadeMessageUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBrigadeMessageUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBrigadeMessageUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка способов передачи сообщения бригадой
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBrigadeReceivingUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/brigade_receiving?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBrigadeReceivingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBrigadeReceivingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBrigadeReceivingUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов мест, где бригада получила вызов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBrigadeReceivingPlaceUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/brigade_receiving_place?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBrigadeReceivingPlaceUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBrigadeReceivingPlaceUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBrigadeReceivingPlaceUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов мест поступления вызовов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListCallPlaceUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/call_place?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListCallPlaceUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListCallPlaceUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListCallPlaceUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов вызовов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListRingTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/call_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListRingTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListRingTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListRingTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов осложнений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListComplicationsUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/complications?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListComplicationsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListComplicationsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListComplicationsUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов оказанной помощи при осложнениях
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListComplicationsHelpUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/complications_help?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListComplicationsHelpUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListComplicationsHelpUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListComplicationsHelpUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сознания
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListConsciousUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/conscious?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListConsciousUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListConsciousUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListConsciousUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов смерти
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDeathUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/death?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDeathUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDeathUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDeathUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов заявителя
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDeclarantUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/declarant?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDeclarantUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDeclarantUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDeclarantUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка причин задержек
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDelayReasonUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/delay_reason?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDelayReasonUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDelayReasonUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDelayReasonUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов одышки
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDyspneaUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/dyspnea?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDyspneaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDyspneaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDyspneaUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов общего состояния
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListGeneralStateUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/general_state?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListGeneralStateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListGeneralStateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListGeneralStateUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сердечных шумов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListHeartNoiseUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/heart_noise?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListHeartNoiseUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListHeartNoiseUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListHeartNoiseUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов пульса
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListHeartRateUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/heart_rate?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListHeartRateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListHeartRateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListHeartRateUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сердечных тонов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListHeartToneUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/heart_tone?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListHeartToneUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListHeartToneUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListHeartToneUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов инцидента
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListIncidentUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/incident?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListIncidentUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListIncidentUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListIncidentUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов отравления
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListIntoxicationUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/intoxication?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListIntoxicationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListIntoxicationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListIntoxicationUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов хрипов в легких
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListLungsWheezingUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/lungs_wheezing?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListLungsWheezingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListLungsWheezingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListLungsWheezingUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов чувствительности лимфатических узлов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getLymphNodeSensitivityListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/lymph_node_sensitivity?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLymphNodeSensitivityListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLymphNodeSensitivityListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLymphNodeSensitivityListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка размеров лимфатических узлов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getLymphNodeSizeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/lymph_node_size?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLymphNodeSizeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLymphNodeSizeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLymphNodeSizeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов слизистой зева
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getMucousPharynxListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/mucous_pharynx?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMucousPharynxListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMucousPharynxListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetMucousPharynxListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка социальных категорий пациента
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPatientSocialTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/patient_social_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPatientSocialTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPatientSocialTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPatientSocialTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка мест жительства пациента
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPatientTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/patient_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPatientTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPatientTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPatientTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов зрачков
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPenaltiesUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/penalties?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPenaltiesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPenaltiesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPenaltiesUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов зрачков DS
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPenaltiesDSUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/penalties_d_s?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPenaltiesDSUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPenaltiesDSUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPenaltiesDSUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов перкурторных звуков легких
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPercLungsSoundUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/perc_lungs_sound?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPercLungsSoundUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPercLungsSoundUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPercLungsSoundUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов получения сообщения
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListReceivingTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/receiving_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListReceivingTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListReceivingTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListReceivingTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов рефлексов DS
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListReflexesDSUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/reflexes_d_s?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListReflexesDSUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListReflexesDSUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListReflexesDSUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов результата
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListResultUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/result?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListResultUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListResultUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListResultUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка причин в результате карты Ф110
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListResultCauseUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/result_cause?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListResultCauseUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListResultCauseUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListResultCauseUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов стула
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getShitTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/shit_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShitTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShitTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetShitTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка цветов кожи
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListSkinColorUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/skin_color?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListSkinColorUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListSkinColorUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListSkinColorUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сухожильных рефлексов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListTendonReflexesUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/tendon_reflexes?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListTendonReflexesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListTendonReflexesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListTendonReflexesUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов транспортировке
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param type (optional) type
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListTransportationUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, type?: string | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/transportation?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListTransportationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListTransportationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListTransportationUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка методов транспортировки
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListTransportationMethodUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/transportation_method?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListTransportationMethodUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListTransportationMethodUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListTransportationMethodUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление записи справочника
     * @param id id
     * @return OK
     */
    restoreReferenceTypeUsingPOST(id: number): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreReferenceTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreReferenceTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreReferenceTypeUsingPOST(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Создание/Обновление записи справочника
     * @param bean bean
     * @return OK
     */
    updateReferenceTypeUsingPOST(bean: ReferenceTypeBean): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReferenceTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReferenceTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReferenceTypeUsingPOST(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getReferenceTypeTypeVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/reference_type/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeTypeVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeTypeVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeTypeVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Карта вызова 110
     * @param id (optional) id
     * @return OK
     */
    downloadCallCardUsingGET(id?: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/callCard?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCallCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCallCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadCallCardUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Сопроводительный лист
     * @param id (optional) id
     * @return OK
     */
    downloadCarrySheetUsingGET(id?: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/carrySheet?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCarrySheetUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCarrySheetUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadCarrySheetUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Ежедневная сводка
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadDailySummaryUsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/dailySummary?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDailySummaryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDailySummaryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadDailySummaryUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * График расписания работы за период
     * @param subdivision Подразделение
     * @param dateFrom Дата с
     * @param dateTo Дата по
     * @param type Тип графика
     * @param extension (optional) Расширение файла
     * @return OK
     */
    makeReportScheduleEmployeesUsingGET(subdivision: number, dateFrom: string, dateTo: string, type: Type, extension?: Extension | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/jasperScheduleContainer?";
        if (subdivision === undefined || subdivision === null)
            throw new Error("The parameter 'subdivision' must be defined and cannot be null.");
        else
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (extension !== undefined)
            url_ += "extension=" + encodeURIComponent("" + extension) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeReportScheduleEmployeesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeReportScheduleEmployeesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeReportScheduleEmployeesUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 109
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport109UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report109?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport109UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport109UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport109UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 115
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport115UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report115?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport115UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport115UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport115UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2120
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2120UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2120?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2120UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2120UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2120UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2121
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2121UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2121?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2121UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2121UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2121UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2200
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2200UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2200?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2200UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2200UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2200UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2201
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2201UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2201?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2201UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2201UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2201UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2202
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2202UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2202?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2202UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2202UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2202UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2300
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2300UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2300?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2300UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2300UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2300UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Форма 2350
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReport2350UsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/report2350?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReport2350UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport2350UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReport2350UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Отчет по работе авиации
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadReportAviaUsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/reportAvia?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadReportAviaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReportAviaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadReportAviaUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * график бригад
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadScheduleBrigadeUsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/scheduleBrigade?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadScheduleBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadScheduleBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadScheduleBrigadeUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * график медиков
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadScheduleDoctorsUsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/scheduleDoctors?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadScheduleDoctorsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadScheduleDoctorsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadScheduleDoctorsUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * график водителей
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadScheduleDriversUsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/scheduleDrivers?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadScheduleDriversUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadScheduleDriversUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadScheduleDriversUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * график всех сотрудников
     * @param subdivision (optional) subdivision
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    downloadScheduleEmployesUsingGET(subdivision?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/andy/reports/scheduleEmployes?";
        if (subdivision !== undefined)
            url_ += "subdivision=" + encodeURIComponent("" + subdivision) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadScheduleEmployesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadScheduleEmployesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadScheduleEmployesUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Удаление типа расписания по Id
     * @param id id
     * @return OK
     */
    deleteScheduleTypeUsingDELETE(id: number): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteScheduleTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteScheduleTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteScheduleTypeUsingDELETE(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Получение типа расписания по Id
     * @param id id
     * @return OK
     */
    getScheduleTypeUsingGET(id: number): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleTypeUsingGET(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Получение списка типов расписаний
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getScheduleTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление типа расписания по Id
     * @param id id
     * @return OK
     */
    restoreScheduleTypeUsingPOST(id: number): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreScheduleTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreScheduleTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreScheduleTypeUsingPOST(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Обновление типа расписания
     * @param bean bean
     * @return OK
     */
    updateScheduleTypeUsingPOST(bean: ScheduleTypeBean): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheduleTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheduleTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheduleTypeUsingPOST(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Удаление навыка по Id
     * @param id id
     * @return OK
     */
    deleteSkillUsingDELETE(id: number): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkillUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkillUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkillUsingDELETE(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Получение навыка по Id
     * @param id id
     * @return OK
     */
    getSkillUsingGET(id: number): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillUsingGET(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Получение списка навыков
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getSkillListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/skill/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление навыка по Id
     * @param id id
     * @return OK
     */
    restoreSkillUsingPOST(id: number): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSkillUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSkillUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSkillUsingPOST(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Обновление навыка
     * @param bean bean
     * @return OK
     */
    updateSkillUsingPOST(bean: SkillBean): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkillUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkillUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkillUsingPOST(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getSkillVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/skill/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление подразделения по Id
     * @param id id
     * @return OK
     */
    deleteSubdivisionUsingDELETE(id: number): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubdivisionUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubdivisionUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubdivisionUsingDELETE(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Получение подразделения по Id
     * @param id id
     * @return OK
     */
    getSubdivisionUsingGET(id: number): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionUsingGET(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Получение списка подразделений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param types (optional) types
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getSubdivisionListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, types?: number[] | null | undefined, name?: string | null | undefined, code?: string[] | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/subdivision/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (types !== undefined)
            types && types.forEach(item => { url_ += "types=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            code && code.forEach(item => { url_ += "code=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка основных подразделений
     * @param rootId (optional) rootId
     * @param deleted (optional) deleted
     * @return OK
     */
    getDistrictListUsingGET(rootId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<SubdivisionBean[]> {
        let url_ = this.baseUrl + "/api/andy/subdivision/list/district?";
        if (rootId !== undefined)
            url_ += "rootId=" + encodeURIComponent("" + rootId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistrictListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistrictListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDistrictListUsingGET(response: HttpResponseBase): Observable<SubdivisionBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean[]>(<any>null);
    }

    /**
     * Получение списка основных подразделений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @return OK
     */
    getPrimarySubdivisionListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/subdivision/list/primary?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimarySubdivisionListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimarySubdivisionListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrimarySubdivisionListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение полного списка подразделений
     * @param rootId (optional) rootId
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullSubdivisionNodeUsingGET(rootId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<AndyTreeNode> {
        let url_ = this.baseUrl + "/api/andy/subdivision/node/full?";
        if (rootId !== undefined)
            url_ += "rootId=" + encodeURIComponent("" + rootId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullSubdivisionNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullSubdivisionNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNode>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNode>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullSubdivisionNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNode> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNode.fromJS(resultData200) : new AndyTreeNode();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNode>(<any>null);
    }

    /**
     * Получение списка основных подразделений
     * @param id id
     * @param deleted (optional) deleted
     * @return OK
     */
    getPrimarySubdivisionNodeUsingGET(id: number, deleted?: boolean | null | undefined): Observable<AndyTreeNode> {
        let url_ = this.baseUrl + "/api/andy/subdivision/node/primary/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimarySubdivisionNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimarySubdivisionNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNode>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNode>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrimarySubdivisionNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNode> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNode.fromJS(resultData200) : new AndyTreeNode();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNode>(<any>null);
    }

    /**
     * Восстановление подразделения по Id
     * @param id id
     * @return OK
     */
    restoreSubdivisionUsingPOST(id: number): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSubdivisionUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSubdivisionUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSubdivisionUsingPOST(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Обновление подразделения
     * @param bean bean
     * @return OK
     */
    updateSubdivisionUsingPOST(bean: SubdivisionBean): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubdivisionUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubdivisionUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubdivisionUsingPOST(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Удаление типа подразделения по Id
     * @param id id
     * @return OK
     */
    deleteSubdivisionTypeUsingDELETE(id: number): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubdivisionTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubdivisionTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubdivisionTypeUsingDELETE(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Получение типа подразделения по Id
     * @param id id
     * @return OK
     */
    getSubdivisionTypeUsingGET(id: number): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionTypeUsingGET(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Получение списка типов подразделений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getSubdivisionTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление типа подразделения по Id
     * @param id id
     * @return OK
     */
    restoreSubdivisionTypeUsingPOST(id: number): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSubdivisionTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSubdivisionTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSubdivisionTypeUsingPOST(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Обновление типа подразделения
     * @param bean bean
     * @return OK
     */
    updateSubdivisionTypeUsingPOST(bean: SubdivisionTypeBean): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubdivisionTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubdivisionTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubdivisionTypeUsingPOST(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Удаление шаблона терапии по Id
     * @param id id
     * @return OK
     */
    deleteTherapyTemplateUsingDELETE(id: number): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapyTemplateUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapyTemplateUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapyTemplateUsingDELETE(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Получение шаблона терапии по Id
     * @param id id
     * @return OK
     */
    getTherapyTemplateUsingGET(id: number): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateUsingGET(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Получение списка шаблонов терапии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getTherapyTemplateListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление шаблона терапии по Id
     * @param id id
     * @return OK
     */
    restoreTherapyTemplateUsingPOST(id: number): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTherapyTemplateUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTherapyTemplateUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTherapyTemplateUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Обновление шаблона терапии
     * @param bean bean
     * @return OK
     */
    updateTherapyTemplateUsingPOST(bean: TherapyTemplateBean): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapyTemplateUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapyTemplateUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapyTemplateUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getTherapyTemplateVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление предмета терапии по Id
     * @param id id
     * @return OK
     */
    deleteTherapyTemplateItemUsingDELETE(id: number): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapyTemplateItemUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapyTemplateItemUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapyTemplateItemUsingDELETE(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Получение предмета терапии по Id
     * @param id id
     * @return OK
     */
    getTherapyTemplateItemUsingGET(id: number): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateItemUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateItemUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateItemUsingGET(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Получение списка предметов терапии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getTherapyTemplateItemListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateItemListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateItemListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateItemListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление предмета терапии по Id
     * @param id id
     * @return OK
     */
    restoreTherapyTemplateItemUsingPOST(id: number): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTherapyTemplateItemUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTherapyTemplateItemUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTherapyTemplateItemUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Обновление предмета терапии
     * @param bean bean
     * @return OK
     */
    updateTherapyTemplateItemUsingPOST(bean: TherapyTemplateItemBean): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapyTemplateItemUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapyTemplateItemUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapyTemplateItemUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getTherapyTemplateItemVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateItemVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateItemVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateItemVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление транспорта по Id
     * @param id id
     * @return OK
     */
    deleteTransportUsingDELETE(id: number): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransportUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransportUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTransportUsingDELETE(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Получение транспорта по Id
     * @param id id
     * @return OK
     */
    getTransportUsingGET(id: number): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportUsingGET(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Виды транспортных средств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    getTransportTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainerOfTransportType> {
        let url_ = this.baseUrl + "/api/andy/transport/getTransportName?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfTransportType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfTransportType>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportTypeUsingGET(response: HttpResponseBase): Observable<ListContainerOfTransportType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfTransportType.fromJS(resultData200) : new ListContainerOfTransportType();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfTransportType>(<any>null);
    }

    /**
     * Получение списка транспорта
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param isHelicopter (optional) isHelicopter
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getTransportListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, isHelicopter?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/transport/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (isHelicopter !== undefined)
            url_ += "isHelicopter=" + encodeURIComponent("" + isHelicopter) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка транспорта
     * @param isAvailable (optional) isAvailable
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    getTransportMonitoringListUsingGET(isAvailable?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<TransportMonitoringData[]> {
        let url_ = this.baseUrl + "/api/andy/transport/monitoring/list?";
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportMonitoringListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportMonitoringListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportMonitoringData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportMonitoringData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportMonitoringListUsingGET(response: HttpResponseBase): Observable<TransportMonitoringData[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportMonitoringData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportMonitoringData[]>(<any>null);
    }

    /**
     * Восстановление транспорта по Id
     * @param id id
     * @return OK
     */
    restoreTransportUsingPOST(id: number): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTransportUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTransportUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTransportUsingPOST(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Обновление/добавление транспорта
     * @param bean bean
     * @return OK
     */
    updateTransportUsingPOST(bean: TransportBean): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransportUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransportUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransportUsingPOST(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getTransportVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/transport/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление укио по ID
     * @param id id
     * @return OK
     */
    deleteUkioUsingDELETE(id: string): Observable<UkioCardBean> {
        let url_ = this.baseUrl + "/api/andy/ukio/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUkioUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUkioUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<UkioCardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UkioCardBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUkioUsingDELETE(response: HttpResponseBase): Observable<UkioCardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UkioCardBean.fromJS(resultData200) : new UkioCardBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UkioCardBean>(<any>null);
    }

    /**
     * Получение укио по ID
     * @param id id
     * @return OK
     */
    getUkioUsingGET(id: string): Observable<UkioCardBean> {
        let url_ = this.baseUrl + "/api/andy/ukio/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUkioUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUkioUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UkioCardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UkioCardBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetUkioUsingGET(response: HttpResponseBase): Observable<UkioCardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UkioCardBean.fromJS(resultData200) : new UkioCardBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UkioCardBean>(<any>null);
    }

    /**
     * Получение списка укио
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listUkioUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/ukio/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUkioUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUkioUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListUkioUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востановление укио по ID
     * @param id id
     * @return OK
     */
    restoreUkioUsingGET(id: string): Observable<UkioCardBean> {
        let url_ = this.baseUrl + "/api/andy/ukio/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreUkioUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreUkioUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UkioCardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UkioCardBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreUkioUsingGET(response: HttpResponseBase): Observable<UkioCardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UkioCardBean.fromJS(resultData200) : new UkioCardBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UkioCardBean>(<any>null);
    }

    /**
     * Удаление единицы измерения по Id
     * @param id id
     * @return OK
     */
    deleteUnitUsingDELETE(id: number): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUnitUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUnitUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUnitUsingDELETE(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Получение единицы по Id
     * @param id id
     * @return OK
     */
    getUnitUsingGET(id: number): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitUsingGET(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Получение списка единиц
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getUnitListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/unit/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление единицы измерения по Id
     * @param id id
     * @return OK
     */
    restoreUnitUsingPOST(id: number): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreUnitUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreUnitUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreUnitUsingPOST(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Обновление единицы измерения
     * @param bean bean
     * @return OK
     */
    updateUnitUsingPOST(bean: UnitBean): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUnitUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUnitUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUnitUsingPOST(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getUnitVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/unit/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление по ID
     * @param id id
     * @return OK
     */
    deleteUnitUsingDELETE_1(id: number): Observable<UnitNewBean> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUnitUsingDELETE_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUnitUsingDELETE_1(<any>response_);
                } catch (e) {
                    return <Observable<UnitNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUnitUsingDELETE_1(response: HttpResponseBase): Observable<UnitNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNewBean.fromJS(resultData200) : new UnitNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNewBean>(<any>null);
    }

    /**
     * Получение по ID
     * @param id id
     * @return OK
     */
    getUnitUsingGET_1(id: number): Observable<UnitNewBean> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<UnitNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitUsingGET_1(response: HttpResponseBase): Observable<UnitNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNewBean.fromJS(resultData200) : new UnitNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNewBean>(<any>null);
    }

    /**
     * Получение списка
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param product (optional) product
     * @return OK
     */
    listUnitUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, product?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUnitUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUnitUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListUnitUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восоновление по ID
     * @param id id
     * @return OK
     */
    restoreUnitUsingGET(id: number): Observable<UnitNewBean> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreUnitUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreUnitUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UnitNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreUnitUsingGET(response: HttpResponseBase): Observable<UnitNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNewBean.fromJS(resultData200) : new UnitNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNewBean>(<any>null);
    }

    /**
     * Обновление для единиц измерения препаратов
     * @param bean bean
     * @return OK
     */
    updateUnitDrugUsingPOST(bean: UnitNewBean): Observable<UnitNewBean> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/updateDrug";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUnitDrugUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUnitDrugUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUnitDrugUsingPOST(response: HttpResponseBase): Observable<UnitNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNewBean.fromJS(resultData200) : new UnitNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNewBean>(<any>null);
    }

    /**
     * Обновление для единиц измерения прочих средств
     * @param bean bean
     * @return OK
     */
    updateOtherDrugUsingPOST(bean: UnitNewBean): Observable<UnitNewBean> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/updateOther";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOtherDrugUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOtherDrugUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOtherDrugUsingPOST(response: HttpResponseBase): Observable<UnitNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNewBean.fromJS(resultData200) : new UnitNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNewBean>(<any>null);
    }

    /**
     * Обновление для единиц измерения изделий
     * @param bean bean
     * @return OK
     */
    updateWareDrugUsingPOST(bean: UnitNewBean): Observable<UnitNewBean> {
        let url_ = this.baseUrl + "/api/andy/unitNew2.0/updateWare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWareDrugUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWareDrugUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitNewBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitNewBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWareDrugUsingPOST(response: HttpResponseBase): Observable<UnitNewBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitNewBean.fromJS(resultData200) : new UnitNewBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitNewBean>(<any>null);
    }

    /**
     * Удаление изделия по ID
     * @param id id
     * @return OK
     */
    deleteWareUsingDELETE(id: number): Observable<WareBean> {
        let url_ = this.baseUrl + "/api/andy/ware2.0/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWareUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWareUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<WareBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWareUsingDELETE(response: HttpResponseBase): Observable<WareBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareBean.fromJS(resultData200) : new WareBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareBean>(<any>null);
    }

    /**
     * Получение изделия по ID
     * @param id id
     * @return OK
     */
    getWareUsingGET(id: number): Observable<WareBean> {
        let url_ = this.baseUrl + "/api/andy/ware2.0/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWareUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWareUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<WareBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetWareUsingGET(response: HttpResponseBase): Observable<WareBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareBean.fromJS(resultData200) : new WareBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareBean>(<any>null);
    }

    /**
     * Получение списка изделий
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listWareUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/ware2.0/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListWareUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListWareUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListWareUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Востонавление изделия по ID
     * @param id id
     * @return OK
     */
    restoreWareUsingDELETE(id: number): Observable<WareBean> {
        let url_ = this.baseUrl + "/api/andy/ware2.0/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreWareUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreWareUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<WareBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreWareUsingDELETE(response: HttpResponseBase): Observable<WareBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareBean.fromJS(resultData200) : new WareBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareBean>(<any>null);
    }

    /**
     * Обновление изделия
     * @param bean bean
     * @return OK
     */
    updateWareUsingPOST(bean: WareBean): Observable<WareBean> {
        let url_ = this.baseUrl + "/api/andy/ware2.0/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWareUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWareUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<WareBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWareUsingPOST(response: HttpResponseBase): Observable<WareBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareBean.fromJS(resultData200) : new WareBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareBean>(<any>null);
    }

    /**
     * Получение списка изделий и прочих средств
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    listWaresAndOthersUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/ware2.0/waresAndOthers/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListWaresAndOthersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListWaresAndOthersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processListWaresAndOthersUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Обновление/добавление операции с лекарствами
     * @param bean bean
     * @return OK
     */
    updateDrugOperationUsingPOST(bean: DrugOperationBean): Observable<DrugOperationBean> {
        let url_ = this.baseUrl + "/api/drug/operation/bag/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugOperationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugOperationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugOperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugOperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugOperationUsingPOST(response: HttpResponseBase): Observable<DrugOperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugOperationBean.fromJS(resultData200) : new DrugOperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugOperationBean>(<any>null);
    }

    /**
     * Удаление операции с лекарствами
     * @param id id
     * @return OK
     */
    deleteDrugOperationUsingDELETE(id: number): Observable<DrugOperationBean> {
        let url_ = this.baseUrl + "/api/drug/operation/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDrugOperationUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDrugOperationUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<DrugOperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugOperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDrugOperationUsingDELETE(response: HttpResponseBase): Observable<DrugOperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugOperationBean.fromJS(resultData200) : new DrugOperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugOperationBean>(<any>null);
    }

    /**
     * Получение операции с лекарствами по ID
     * @param id id
     * @return OK
     */
    getDrugOperationUsingGET(id: number): Observable<DrugOperationBean> {
        let url_ = this.baseUrl + "/api/drug/operation/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugOperationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugOperationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DrugOperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugOperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugOperationUsingGET(response: HttpResponseBase): Observable<DrugOperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugOperationBean.fromJS(resultData200) : new DrugOperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugOperationBean>(<any>null);
    }

    /**
     * Получение списка операций с лекарствами
     * @param from (optional) from
     * @param count (optional) count
     * @param isDeleted (optional) isDeleted
     * @param isAction (optional) isAction
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param dateTime (optional) dateTime
     * @param bagId (optional) bagId
     * @param cardId (optional) cardId
     * @param callId (optional) callId
     * @param drugId (optional) drugId
     * @param performerId (optional) performerId
     * @return OK
     */
    getDrugOperationListUsingGET(from?: number | null | undefined, count?: number | null | undefined, isDeleted?: boolean | null | undefined, isAction?: boolean | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, dateTime?: string | null | undefined, bagId?: number | null | undefined, cardId?: number | null | undefined, callId?: number | null | undefined, drugId?: number | null | undefined, performerId?: number | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/drug/operation/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (isDeleted !== undefined)
            url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&"; 
        if (isAction !== undefined)
            url_ += "isAction=" + encodeURIComponent("" + isAction) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (dateTime !== undefined)
            url_ += "dateTime=" + encodeURIComponent("" + dateTime) + "&"; 
        if (bagId !== undefined)
            url_ += "bagId=" + encodeURIComponent("" + bagId) + "&"; 
        if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (callId !== undefined)
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        if (drugId !== undefined)
            url_ += "drugId=" + encodeURIComponent("" + drugId) + "&"; 
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDrugOperationListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDrugOperationListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetDrugOperationListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Восстановление операции с лекарствами
     * @param id id
     * @return OK
     */
    restoreDrugOperationUsingPOST(id: number): Observable<DrugOperationBean> {
        let url_ = this.baseUrl + "/api/drug/operation/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDrugOperationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDrugOperationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<DrugOperationBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugOperationBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDrugOperationUsingPOST(response: HttpResponseBase): Observable<DrugOperationBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrugOperationBean.fromJS(resultData200) : new DrugOperationBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugOperationBean>(<any>null);
    }

    /**
     * Проверка имени и пароля входа, получение сведений о ролях и подразделении пользователя
     * @param login login
     * @return OK
     */
    loginUsingPOST(login: LoginPair): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<LoginResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingPOST(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginResponse.fromJS(resultData200) : new LoginResponse();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(<any>null);
    }

    /**
     * Завершение сессии пользователя
     * @return OK
     */
    logoutUsingGET(): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogoutUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogoutUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LoginResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLogoutUsingGET(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginResponse.fromJS(resultData200) : new LoginResponse();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(<any>null);
    }
}

export class EquipmentBean implements IEquipmentBean {
    id?: number | null;
    /** Наименование трекера */
    modelName?: string | null;
    /** Наименование трекера */
    serialNumber?: string | null;
    /** Идентификатор, связывающий координаты и GPS-трекер */
    trackerId?: number | null;

    constructor(data?: IEquipmentBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.modelName = data["modelName"] !== undefined ? data["modelName"] : <any>null;
            this.serialNumber = data["serialNumber"] !== undefined ? data["serialNumber"] : <any>null;
            this.trackerId = data["trackerId"] !== undefined ? data["trackerId"] : <any>null;
        }
    }

    static fromJS(data: any): EquipmentBean {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["modelName"] = this.modelName !== undefined ? this.modelName : <any>null;
        data["serialNumber"] = this.serialNumber !== undefined ? this.serialNumber : <any>null;
        data["trackerId"] = this.trackerId !== undefined ? this.trackerId : <any>null;
        return data; 
    }
}

export interface IEquipmentBean {
    id?: number | null;
    /** Наименование трекера */
    modelName?: string | null;
    /** Наименование трекера */
    serialNumber?: string | null;
    /** Идентификатор, связывающий координаты и GPS-трекер */
    trackerId?: number | null;
}

export class TransportMonitoringBean implements ITransportMonitoringBean {
    /** Время создания записи */
    createdAt?: Date | null;
    /** Направление движения */
    direction?: number | null;
    id?: number | null;
    /** Признак исправления 3D (???) */
    isFix3D?: boolean | null;
    /** Признак движения автомобиля */
    isInMotion?: boolean | null;
    /** Признак валидности (?) */
    isValid?: boolean | null;
    /** Широта */
    latitude?: number | null;
    location?: string | null;
    /** Долгота */
    longitude?: number | null;
    /** Время создания записи */
    navigationTime?: Date | null;
    /** UIN GPS-трекера */
    objectId?: number | null;
    /** Показатели одометра (кол-во оборотов) */
    odometry?: number | null;
    /** Номер записи (?) */
    recordNumber?: number | null;
    /** Скорость */
    speed?: number | null;

    constructor(data?: ITransportMonitoringBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] ? new Date(data["createdAt"].toString()) : <any>null;
            this.direction = data["direction"] !== undefined ? data["direction"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isFix3D = data["isFix3D"] !== undefined ? data["isFix3D"] : <any>null;
            this.isInMotion = data["isInMotion"] !== undefined ? data["isInMotion"] : <any>null;
            this.isValid = data["isValid"] !== undefined ? data["isValid"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.navigationTime = data["navigationTime"] ? new Date(data["navigationTime"].toString()) : <any>null;
            this.objectId = data["objectId"] !== undefined ? data["objectId"] : <any>null;
            this.odometry = data["odometry"] !== undefined ? data["odometry"] : <any>null;
            this.recordNumber = data["recordNumber"] !== undefined ? data["recordNumber"] : <any>null;
            this.speed = data["speed"] !== undefined ? data["speed"] : <any>null;
        }
    }

    static fromJS(data: any): TransportMonitoringBean {
        data = typeof data === 'object' ? data : {};
        let result = new TransportMonitoringBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["direction"] = this.direction !== undefined ? this.direction : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isFix3D"] = this.isFix3D !== undefined ? this.isFix3D : <any>null;
        data["isInMotion"] = this.isInMotion !== undefined ? this.isInMotion : <any>null;
        data["isValid"] = this.isValid !== undefined ? this.isValid : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["navigationTime"] = this.navigationTime ? this.navigationTime.toISOString() : <any>null;
        data["objectId"] = this.objectId !== undefined ? this.objectId : <any>null;
        data["odometry"] = this.odometry !== undefined ? this.odometry : <any>null;
        data["recordNumber"] = this.recordNumber !== undefined ? this.recordNumber : <any>null;
        data["speed"] = this.speed !== undefined ? this.speed : <any>null;
        return data; 
    }
}

export interface ITransportMonitoringBean {
    /** Время создания записи */
    createdAt?: Date | null;
    /** Направление движения */
    direction?: number | null;
    id?: number | null;
    /** Признак исправления 3D (???) */
    isFix3D?: boolean | null;
    /** Признак движения автомобиля */
    isInMotion?: boolean | null;
    /** Признак валидности (?) */
    isValid?: boolean | null;
    /** Широта */
    latitude?: number | null;
    location?: string | null;
    /** Долгота */
    longitude?: number | null;
    /** Время создания записи */
    navigationTime?: Date | null;
    /** UIN GPS-трекера */
    objectId?: number | null;
    /** Показатели одометра (кол-во оборотов) */
    odometry?: number | null;
    /** Номер записи (?) */
    recordNumber?: number | null;
    /** Скорость */
    speed?: number | null;
}

export class ListContainerOfBagBean implements IListContainerOfBagBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBagBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBagBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBagBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBagBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfDrugTypeBean implements IListContainerOfDrugTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class AssignedBrigadeMessageBean implements IAssignedBrigadeMessageBean {
    /** ID бригады */
    brigade?: number | null;
    /** ID звонка */
    call?: number | null;
    /** Время передачи сообщения */
    date?: Date | null;
    id?: number | null;
    /** Тип переданного сообщения */
    messageTypeFK?: ReferenceTypeBean | null;
    /** Способ передачи сообщения */
    receivingTypeFK?: ReferenceTypeBean | null;

    constructor(data?: IAssignedBrigadeMessageBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade = data["brigade"] !== undefined ? data["brigade"] : <any>null;
            this.call = data["call"] !== undefined ? data["call"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.messageTypeFK = data["messageTypeFK"] ? ReferenceTypeBean.fromJS(data["messageTypeFK"]) : <any>null;
            this.receivingTypeFK = data["receivingTypeFK"] ? ReferenceTypeBean.fromJS(data["receivingTypeFK"]) : <any>null;
        }
    }

    static fromJS(data: any): AssignedBrigadeMessageBean {
        data = typeof data === 'object' ? data : {};
        let result = new AssignedBrigadeMessageBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade"] = this.brigade !== undefined ? this.brigade : <any>null;
        data["call"] = this.call !== undefined ? this.call : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["messageTypeFK"] = this.messageTypeFK ? this.messageTypeFK.toJSON() : <any>null;
        data["receivingTypeFK"] = this.receivingTypeFK ? this.receivingTypeFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IAssignedBrigadeMessageBean {
    /** ID бригады */
    brigade?: number | null;
    /** ID звонка */
    call?: number | null;
    /** Время передачи сообщения */
    date?: Date | null;
    id?: number | null;
    /** Тип переданного сообщения */
    messageTypeFK?: ReferenceTypeBean | null;
    /** Способ передачи сообщения */
    receivingTypeFK?: ReferenceTypeBean | null;
}

export class BagBean implements IBagBean {
    bagDrugList?: BagDrugBean[] | null;
    /** Бригада */
    brigadeFK?: BrigadeBean | null;
    code?: string | null;
    /** Описание */
    description?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IBagBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bagDrugList"] && data["bagDrugList"].constructor === Array) {
                this.bagDrugList = [];
                for (let item of data["bagDrugList"])
                    this.bagDrugList.push(BagDrugBean.fromJS(item));
            }
            this.brigadeFK = data["brigadeFK"] ? BrigadeBean.fromJS(data["brigadeFK"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BagBean {
        data = typeof data === 'object' ? data : {};
        let result = new BagBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bagDrugList && this.bagDrugList.constructor === Array) {
            data["bagDrugList"] = [];
            for (let item of this.bagDrugList)
                data["bagDrugList"].push(item.toJSON());
        }
        data["brigadeFK"] = this.brigadeFK ? this.brigadeFK.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBagBean {
    bagDrugList?: BagDrugBean[] | null;
    /** Бригада */
    brigadeFK?: BrigadeBean | null;
    code?: string | null;
    /** Описание */
    description?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class UnitBean implements IUnitBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IUnitBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): UnitBean {
        data = typeof data === 'object' ? data : {};
        let result = new UnitBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IUnitBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class WareBean implements IWareBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название продукта */
    name?: string | null;
    /** id единиц измеренеия */
    unitId?: number | null;

    constructor(data?: IWareBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.unitId = data["unitId"] !== undefined ? data["unitId"] : <any>null;
        }
    }

    static fromJS(data: any): WareBean {
        data = typeof data === 'object' ? data : {};
        let result = new WareBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["unitId"] = this.unitId !== undefined ? this.unitId : <any>null;
        return data; 
    }
}

export interface IWareBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название продукта */
    name?: string | null;
    /** id единиц измеренеия */
    unitId?: number | null;
}

export class ListContainerOfBrigadeTypeBean implements IListContainerOfBrigadeTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBrigadeTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBrigadeTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBrigadeTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBrigadeTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfDrugFormBean implements IListContainerOfDrugFormBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugFormBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugFormBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugFormBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugFormBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class DrugPackage implements IDrugPackage {
    name?: string | null;

    constructor(data?: IDrugPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DrugPackage {
        data = typeof data === 'object' ? data : {};
        let result = new DrugPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDrugPackage {
    name?: string | null;
}

export class BrigadeTypeBean implements IBrigadeTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IBrigadeTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class InteriorBean implements IInteriorBean {
    /** ID */
    id?: number | null;
    /** Код ДДС (по справочнику 112), привлеченной к реагированию сотрудником системы-112 */
    interiorCode?: string | null;
    /** Название ДДС (по справочнику 112), привлеченной к реагированию сотрудником системы-112 */
    interiorName?: string | null;
    /** Оператор ДДС, который внес изменения */
    interiorOperator?: string | null;
    /** Номер, под которым зарегистрирована УКИО в ДДС */
    interiorRegNumber?: string | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;

    constructor(data?: IInteriorBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.interiorCode = data["interiorCode"] !== undefined ? data["interiorCode"] : <any>null;
            this.interiorName = data["interiorName"] !== undefined ? data["interiorName"] : <any>null;
            this.interiorOperator = data["interiorOperator"] !== undefined ? data["interiorOperator"] : <any>null;
            this.interiorRegNumber = data["interiorRegNumber"] !== undefined ? data["interiorRegNumber"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
            this.ukioMessageId = data["ukioMessageId"] !== undefined ? data["ukioMessageId"] : <any>null;
        }
    }

    static fromJS(data: any): InteriorBean {
        data = typeof data === 'object' ? data : {};
        let result = new InteriorBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["interiorCode"] = this.interiorCode !== undefined ? this.interiorCode : <any>null;
        data["interiorName"] = this.interiorName !== undefined ? this.interiorName : <any>null;
        data["interiorOperator"] = this.interiorOperator !== undefined ? this.interiorOperator : <any>null;
        data["interiorRegNumber"] = this.interiorRegNumber !== undefined ? this.interiorRegNumber : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        data["ukioMessageId"] = this.ukioMessageId !== undefined ? this.ukioMessageId : <any>null;
        return data; 
    }
}

export interface IInteriorBean {
    /** ID */
    id?: number | null;
    /** Код ДДС (по справочнику 112), привлеченной к реагированию сотрудником системы-112 */
    interiorCode?: string | null;
    /** Название ДДС (по справочнику 112), привлеченной к реагированию сотрудником системы-112 */
    interiorName?: string | null;
    /** Оператор ДДС, который внес изменения */
    interiorOperator?: string | null;
    /** Номер, под которым зарегистрирована УКИО в ДДС */
    interiorRegNumber?: string | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;
}

export class DrugCategoryBean implements IDrugCategoryBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IDrugCategoryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DrugCategoryBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugCategoryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDrugCategoryBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfTransportBean implements IListContainerOfTransportBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTransportBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTransportBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTransportBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTransportBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class BrigadeContainer implements IBrigadeContainer {
    brigade?: BrigadeBean | null;
    performerList?: PerformerBean[] | null;
    transportBean?: TransportBean | null;

    constructor(data?: IBrigadeContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade = data["brigade"] ? BrigadeBean.fromJS(data["brigade"]) : <any>null;
            if (data["performerList"] && data["performerList"].constructor === Array) {
                this.performerList = [];
                for (let item of data["performerList"])
                    this.performerList.push(PerformerBean.fromJS(item));
            }
            this.transportBean = data["transportBean"] ? TransportBean.fromJS(data["transportBean"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeContainer {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade"] = this.brigade ? this.brigade.toJSON() : <any>null;
        if (this.performerList && this.performerList.constructor === Array) {
            data["performerList"] = [];
            for (let item of this.performerList)
                data["performerList"].push(item.toJSON());
        }
        data["transportBean"] = this.transportBean ? this.transportBean.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeContainer {
    brigade?: BrigadeBean | null;
    performerList?: PerformerBean[] | null;
    transportBean?: TransportBean | null;
}

export class CardObjectiveBean implements ICardObjectiveBean {
    /** Дополнительные объективные данные */
    additionObjectives?: string | null;
    /** ALCOOVERDOZE: Свежее дыхание */
    alcoBreath?: boolean | null;
    /** ALCOOVERDOZE: Лабильность */
    alcoEmotionLability?: boolean | null;
    /** ALCOOVERDOZE: Неадекват */
    alcoInadequate?: boolean | null;
    /** ALCOOVERDOZE: Поза Ромберга */
    alcoRombergPose?: boolean | null;
    /** ALCOOVERDOZE: Лунная алкопоходка */
    alcoShakyWalk?: boolean | null;
    /** ALCOOVERDOZE: Умение зачитывать по пьяни Rap God */
    alcoSpeechBehavior?: boolean | null;
    /** Наличие аллергии: признак */
    allergicAnamnesis?: boolean | null;
    /** Наличие аллергии: описание */
    allergicAnamnesisText?: string | null;
    /** Миндалины нормального размера */
    almondsNormalLarge?: boolean | null;
    /** Налеты на миндалинах */
    almondsPlaque?: boolean | null;
    /** Поведение */
    behaviourFK?: ReferenceTypeBean | null;
    /** Сухожильные рефлексы */
    breathAbsent?: boolean | null;
    /** Бронхиальное */
    breathBronchial?: boolean | null;
    /** Равномерное */
    breathEvenly?: boolean | null;
    /** Слабое/тяжелое(t/f) */
    breathIsWeak?: boolean | null;
    /** Чистое */
    breathPure?: boolean | null;
    /** Дыхание: комментарий */
    breathText?: string | null;
    /** Везикулярное */
    breathVesicular?: boolean | null;
    /** Жалобы и анамнез */
    complaintsAnamnesis?: string | null;
    /** Осложнения */
    complicationsFK?: ReferenceTypeBean | null;
    /** Сознание */
    consciousFK?: ReferenceTypeBean | null;
    /** Дата создания карты */
    date?: Date | null;
    /** Диурез: дизурия */
    diuresisDisuria?: boolean | null;
    /** Диурез: гематурия */
    diuresisHematuria?: boolean | null;
    /** Диурез отсутствует */
    diuresisNo?: boolean | null;
    /** Диурез: олигурия */
    diuresisOliguria?: boolean | null;
    /** Расстройства пищеварения: диарея */
    dyspepticDiarrhea?: boolean | null;
    /** Расстройства пищеварения: тошнота */
    dyspepticNausea?: boolean | null;
    /** Расстройства пищеварения: запор */
    dyspepticRetch?: boolean | null;
    /** Расстройства пищеварения: нет */
    dyspepticsNo?: boolean | null;
    /** Сухожильные рефлексы */
    dyspneaFK?: ReferenceTypeBean | null;
    /** Признак наличия выделительной системы */
    excreta?: boolean | null;
    /** Состояние выделительной системы */
    excretaText?: string | null;
    /** ШКГ - Тест открывания глаз (E) */
    eyeOpening?: number | null;
    /** Общее состояние */
    generalStateFK?: ReferenceTypeBean | null;
    /** Глюкометрия */
    glucometry?: string | null;
    /** Гинекологический анамнез */
    gynecologicAnamnesis?: string | null;
    /** Сердце: АД */
    heartAd?: string | null;
    /** Сердце: АД максимальное */
    heartAdMax?: string | null;
    /** Сердце: АДН */
    heartAdn?: string | null;
    /** Температура */
    heartBodyTemp?: string | null;
    /** Сердце: ЧД */
    heartChd?: string | null;
    /** Сердце: ЧСС */
    heartChss?: string | null;
    /** Сердечные шумы */
    heartNoiseFK?: ReferenceTypeBean | null;
    /** Сердце: Пульс */
    heartPs?: string | null;
    /** Пульс */
    heartPulseFK?: ReferenceTypeBean | null;
    /** Частота сердцебиения */
    heartRateFK?: ReferenceTypeBean | null;
    /** Тоны сердца */
    heartToneFK?: ReferenceTypeBean | null;
    id?: number | null;
    /** Анамнез болезней (чем сейчас болеет) */
    illnessAnamnesis?: string | null;
    /** Инфекционность */
    infectContacts?: string | null;
    /** Диурез слева */
    lionTappingLeft?: boolean | null;
    /** Диурез справа */
    lionTappingRight?: boolean | null;
    /** Печень: нормального размера */
    liverNormalLarge?: boolean | null;
    /** Печень: синдром Ортнера */
    liverOrtner?: boolean | null;
    /** Печень: размер */
    liverSizeText?: string | null;
    /** Легочные хрипы */
    lungsWheezingFK?: ReferenceTypeBean | null;
    /** Хрипы в легких: комментарий */
    lungsWheezingText?: string | null;
    /** Лимфоузлы: нормальный размер */
    lymphNodesNormalLarge?: boolean | null;
    /** Лимфоузлы: болезненные ощущения */
    lymphNodesPainful?: boolean | null;
    /** Лимфоузлы: комментарий */
    lymphNodesText?: string | null;
    /** Менингиальные синдромы */
    meningealReflexes?: boolean | null;
    /** ШКГ - Двигательный тест (M) */
    motorResponse?: number | null;
    /** Слизистая зева */
    multipleZevaCleanHyper?: boolean | null;
    /** Анамнез болезней (чем раньше болел) */
    pastIllnesses?: string | null;
    /** Патологические стопные рефлексы */
    pathologicalReflexes?: boolean | null;
    /** Анизокория */
    penaltiesAnisocoria?: boolean | null;
    /** Состояние зрачков одинаково выражено (D ? S) */
    penaltiesDsFK?: ReferenceTypeBean | null;
    /** Состояние зрачков */
    penaltiesFK?: ReferenceTypeBean | null;
    /** Реакция на свет */
    penaltiesLight?: boolean | null;
    /** Нистагм */
    penaltiesNystagmus?: boolean | null;
    /** Сравнительная перкуссия легких */
    percLungsSoundFK?: ReferenceTypeBean | null;
    /** Звук при перкуссии легких */
    percLungsSoundText?: string | null;
    /** ПульсOXXXYметрия */
    pulseOximetry?: string | null;
    /** Карантин */
    quarantine?: string | null;
    /** Рефлексы одинаково выражены (D ? S) */
    reflexesDsFK?: ReferenceTypeBean | null;
    /** Акроцианоз */
    skinAcrosianosis?: boolean | null;
    /** Цвет кожи */
    skinColorFK?: ReferenceTypeBean | null;
    /** Гиперимированность */
    skinHyperemetic?: boolean | null;
    /** Цианоз */
    skinIntegCyanotic?: boolean | null;
    /** Сухость/Потливость (t/f) */
    skinIsDry?: boolean | null;
    /** Кожа нормальная/нет */
    skinIsNormal?: boolean | null;
    /** Сыпь */
    skinRashes?: boolean | null;
    /** Желудочный асцит */
    stomachAscites?: boolean | null;
    /** Живот участвует в акте дыхания */
    stomachBreathingInvolved?: boolean | null;
    /** Желудок доскообразный */
    stomachDisklike?: boolean | null;
    /** Желудок вздутый */
    stomachInflated?: boolean | null;
    /** Желудок твердый */
    stomachIsHard?: boolean | null;
    /** Боль в желудке */
    stomachIsPainful?: boolean | null;
    /** Желудок в норме */
    stomachNormal?: boolean | null;
    /** Перитонит */
    stomachPeritonit?: boolean | null;
    /** Описание состояния брюшной полости */
    stomachText?: string | null;
    /** Сухожильные рефлексы */
    tendonReflexesFK?: ReferenceTypeBean | null;
    /** Признак наличия отеков */
    titles?: boolean | null;
    /** Локализация отеков */
    titlesText?: string | null;
    /** Признак влажности/сухости языка */
    tongueCleanFurred?: boolean | null;
    /** Признак чистоты языка */
    tongueWeatDry?: boolean | null;
    /** Мочеиспускание */
    urineText?: string | null;
    /** Вакцинация */
    vaccination?: string | null;
    /** ШКГ - Речевой тест (V) */
    verbalResponse?: number | null;

    constructor(data?: ICardObjectiveBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionObjectives = data["additionObjectives"] !== undefined ? data["additionObjectives"] : <any>null;
            this.alcoBreath = data["alcoBreath"] !== undefined ? data["alcoBreath"] : <any>null;
            this.alcoEmotionLability = data["alcoEmotionLability"] !== undefined ? data["alcoEmotionLability"] : <any>null;
            this.alcoInadequate = data["alcoInadequate"] !== undefined ? data["alcoInadequate"] : <any>null;
            this.alcoRombergPose = data["alcoRombergPose"] !== undefined ? data["alcoRombergPose"] : <any>null;
            this.alcoShakyWalk = data["alcoShakyWalk"] !== undefined ? data["alcoShakyWalk"] : <any>null;
            this.alcoSpeechBehavior = data["alcoSpeechBehavior"] !== undefined ? data["alcoSpeechBehavior"] : <any>null;
            this.allergicAnamnesis = data["allergicAnamnesis"] !== undefined ? data["allergicAnamnesis"] : <any>null;
            this.allergicAnamnesisText = data["allergicAnamnesisText"] !== undefined ? data["allergicAnamnesisText"] : <any>null;
            this.almondsNormalLarge = data["almondsNormalLarge"] !== undefined ? data["almondsNormalLarge"] : <any>null;
            this.almondsPlaque = data["almondsPlaque"] !== undefined ? data["almondsPlaque"] : <any>null;
            this.behaviourFK = data["behaviourFK"] ? ReferenceTypeBean.fromJS(data["behaviourFK"]) : <any>null;
            this.breathAbsent = data["breathAbsent"] !== undefined ? data["breathAbsent"] : <any>null;
            this.breathBronchial = data["breathBronchial"] !== undefined ? data["breathBronchial"] : <any>null;
            this.breathEvenly = data["breathEvenly"] !== undefined ? data["breathEvenly"] : <any>null;
            this.breathIsWeak = data["breathIsWeak"] !== undefined ? data["breathIsWeak"] : <any>null;
            this.breathPure = data["breathPure"] !== undefined ? data["breathPure"] : <any>null;
            this.breathText = data["breathText"] !== undefined ? data["breathText"] : <any>null;
            this.breathVesicular = data["breathVesicular"] !== undefined ? data["breathVesicular"] : <any>null;
            this.complaintsAnamnesis = data["complaintsAnamnesis"] !== undefined ? data["complaintsAnamnesis"] : <any>null;
            this.complicationsFK = data["complicationsFK"] ? ReferenceTypeBean.fromJS(data["complicationsFK"]) : <any>null;
            this.consciousFK = data["consciousFK"] ? ReferenceTypeBean.fromJS(data["consciousFK"]) : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.diuresisDisuria = data["diuresisDisuria"] !== undefined ? data["diuresisDisuria"] : <any>null;
            this.diuresisHematuria = data["diuresisHematuria"] !== undefined ? data["diuresisHematuria"] : <any>null;
            this.diuresisNo = data["diuresisNo"] !== undefined ? data["diuresisNo"] : <any>null;
            this.diuresisOliguria = data["diuresisOliguria"] !== undefined ? data["diuresisOliguria"] : <any>null;
            this.dyspepticDiarrhea = data["dyspepticDiarrhea"] !== undefined ? data["dyspepticDiarrhea"] : <any>null;
            this.dyspepticNausea = data["dyspepticNausea"] !== undefined ? data["dyspepticNausea"] : <any>null;
            this.dyspepticRetch = data["dyspepticRetch"] !== undefined ? data["dyspepticRetch"] : <any>null;
            this.dyspepticsNo = data["dyspepticsNo"] !== undefined ? data["dyspepticsNo"] : <any>null;
            this.dyspneaFK = data["dyspneaFK"] ? ReferenceTypeBean.fromJS(data["dyspneaFK"]) : <any>null;
            this.excreta = data["excreta"] !== undefined ? data["excreta"] : <any>null;
            this.excretaText = data["excretaText"] !== undefined ? data["excretaText"] : <any>null;
            this.eyeOpening = data["eyeOpening"] !== undefined ? data["eyeOpening"] : <any>null;
            this.generalStateFK = data["generalStateFK"] ? ReferenceTypeBean.fromJS(data["generalStateFK"]) : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.gynecologicAnamnesis = data["gynecologicAnamnesis"] !== undefined ? data["gynecologicAnamnesis"] : <any>null;
            this.heartAd = data["heartAd"] !== undefined ? data["heartAd"] : <any>null;
            this.heartAdMax = data["heartAdMax"] !== undefined ? data["heartAdMax"] : <any>null;
            this.heartAdn = data["heartAdn"] !== undefined ? data["heartAdn"] : <any>null;
            this.heartBodyTemp = data["heartBodyTemp"] !== undefined ? data["heartBodyTemp"] : <any>null;
            this.heartChd = data["heartChd"] !== undefined ? data["heartChd"] : <any>null;
            this.heartChss = data["heartChss"] !== undefined ? data["heartChss"] : <any>null;
            this.heartNoiseFK = data["heartNoiseFK"] ? ReferenceTypeBean.fromJS(data["heartNoiseFK"]) : <any>null;
            this.heartPs = data["heartPs"] !== undefined ? data["heartPs"] : <any>null;
            this.heartPulseFK = data["heartPulseFK"] ? ReferenceTypeBean.fromJS(data["heartPulseFK"]) : <any>null;
            this.heartRateFK = data["heartRateFK"] ? ReferenceTypeBean.fromJS(data["heartRateFK"]) : <any>null;
            this.heartToneFK = data["heartToneFK"] ? ReferenceTypeBean.fromJS(data["heartToneFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.illnessAnamnesis = data["illnessAnamnesis"] !== undefined ? data["illnessAnamnesis"] : <any>null;
            this.infectContacts = data["infectContacts"] !== undefined ? data["infectContacts"] : <any>null;
            this.lionTappingLeft = data["lionTappingLeft"] !== undefined ? data["lionTappingLeft"] : <any>null;
            this.lionTappingRight = data["lionTappingRight"] !== undefined ? data["lionTappingRight"] : <any>null;
            this.liverNormalLarge = data["liverNormalLarge"] !== undefined ? data["liverNormalLarge"] : <any>null;
            this.liverOrtner = data["liverOrtner"] !== undefined ? data["liverOrtner"] : <any>null;
            this.liverSizeText = data["liverSizeText"] !== undefined ? data["liverSizeText"] : <any>null;
            this.lungsWheezingFK = data["lungsWheezingFK"] ? ReferenceTypeBean.fromJS(data["lungsWheezingFK"]) : <any>null;
            this.lungsWheezingText = data["lungsWheezingText"] !== undefined ? data["lungsWheezingText"] : <any>null;
            this.lymphNodesNormalLarge = data["lymphNodesNormalLarge"] !== undefined ? data["lymphNodesNormalLarge"] : <any>null;
            this.lymphNodesPainful = data["lymphNodesPainful"] !== undefined ? data["lymphNodesPainful"] : <any>null;
            this.lymphNodesText = data["lymphNodesText"] !== undefined ? data["lymphNodesText"] : <any>null;
            this.meningealReflexes = data["meningealReflexes"] !== undefined ? data["meningealReflexes"] : <any>null;
            this.motorResponse = data["motorResponse"] !== undefined ? data["motorResponse"] : <any>null;
            this.multipleZevaCleanHyper = data["multipleZevaCleanHyper"] !== undefined ? data["multipleZevaCleanHyper"] : <any>null;
            this.pastIllnesses = data["pastIllnesses"] !== undefined ? data["pastIllnesses"] : <any>null;
            this.pathologicalReflexes = data["pathologicalReflexes"] !== undefined ? data["pathologicalReflexes"] : <any>null;
            this.penaltiesAnisocoria = data["penaltiesAnisocoria"] !== undefined ? data["penaltiesAnisocoria"] : <any>null;
            this.penaltiesDsFK = data["penaltiesDsFK"] ? ReferenceTypeBean.fromJS(data["penaltiesDsFK"]) : <any>null;
            this.penaltiesFK = data["penaltiesFK"] ? ReferenceTypeBean.fromJS(data["penaltiesFK"]) : <any>null;
            this.penaltiesLight = data["penaltiesLight"] !== undefined ? data["penaltiesLight"] : <any>null;
            this.penaltiesNystagmus = data["penaltiesNystagmus"] !== undefined ? data["penaltiesNystagmus"] : <any>null;
            this.percLungsSoundFK = data["percLungsSoundFK"] ? ReferenceTypeBean.fromJS(data["percLungsSoundFK"]) : <any>null;
            this.percLungsSoundText = data["percLungsSoundText"] !== undefined ? data["percLungsSoundText"] : <any>null;
            this.pulseOximetry = data["pulseOximetry"] !== undefined ? data["pulseOximetry"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.reflexesDsFK = data["reflexesDsFK"] ? ReferenceTypeBean.fromJS(data["reflexesDsFK"]) : <any>null;
            this.skinAcrosianosis = data["skinAcrosianosis"] !== undefined ? data["skinAcrosianosis"] : <any>null;
            this.skinColorFK = data["skinColorFK"] ? ReferenceTypeBean.fromJS(data["skinColorFK"]) : <any>null;
            this.skinHyperemetic = data["skinHyperemetic"] !== undefined ? data["skinHyperemetic"] : <any>null;
            this.skinIntegCyanotic = data["skinIntegCyanotic"] !== undefined ? data["skinIntegCyanotic"] : <any>null;
            this.skinIsDry = data["skinIsDry"] !== undefined ? data["skinIsDry"] : <any>null;
            this.skinIsNormal = data["skinIsNormal"] !== undefined ? data["skinIsNormal"] : <any>null;
            this.skinRashes = data["skinRashes"] !== undefined ? data["skinRashes"] : <any>null;
            this.stomachAscites = data["stomachAscites"] !== undefined ? data["stomachAscites"] : <any>null;
            this.stomachBreathingInvolved = data["stomachBreathingInvolved"] !== undefined ? data["stomachBreathingInvolved"] : <any>null;
            this.stomachDisklike = data["stomachDisklike"] !== undefined ? data["stomachDisklike"] : <any>null;
            this.stomachInflated = data["stomachInflated"] !== undefined ? data["stomachInflated"] : <any>null;
            this.stomachIsHard = data["stomachIsHard"] !== undefined ? data["stomachIsHard"] : <any>null;
            this.stomachIsPainful = data["stomachIsPainful"] !== undefined ? data["stomachIsPainful"] : <any>null;
            this.stomachNormal = data["stomachNormal"] !== undefined ? data["stomachNormal"] : <any>null;
            this.stomachPeritonit = data["stomachPeritonit"] !== undefined ? data["stomachPeritonit"] : <any>null;
            this.stomachText = data["stomachText"] !== undefined ? data["stomachText"] : <any>null;
            this.tendonReflexesFK = data["tendonReflexesFK"] ? ReferenceTypeBean.fromJS(data["tendonReflexesFK"]) : <any>null;
            this.titles = data["titles"] !== undefined ? data["titles"] : <any>null;
            this.titlesText = data["titlesText"] !== undefined ? data["titlesText"] : <any>null;
            this.tongueCleanFurred = data["tongueCleanFurred"] !== undefined ? data["tongueCleanFurred"] : <any>null;
            this.tongueWeatDry = data["tongueWeatDry"] !== undefined ? data["tongueWeatDry"] : <any>null;
            this.urineText = data["urineText"] !== undefined ? data["urineText"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
            this.verbalResponse = data["verbalResponse"] !== undefined ? data["verbalResponse"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveBean {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionObjectives"] = this.additionObjectives !== undefined ? this.additionObjectives : <any>null;
        data["alcoBreath"] = this.alcoBreath !== undefined ? this.alcoBreath : <any>null;
        data["alcoEmotionLability"] = this.alcoEmotionLability !== undefined ? this.alcoEmotionLability : <any>null;
        data["alcoInadequate"] = this.alcoInadequate !== undefined ? this.alcoInadequate : <any>null;
        data["alcoRombergPose"] = this.alcoRombergPose !== undefined ? this.alcoRombergPose : <any>null;
        data["alcoShakyWalk"] = this.alcoShakyWalk !== undefined ? this.alcoShakyWalk : <any>null;
        data["alcoSpeechBehavior"] = this.alcoSpeechBehavior !== undefined ? this.alcoSpeechBehavior : <any>null;
        data["allergicAnamnesis"] = this.allergicAnamnesis !== undefined ? this.allergicAnamnesis : <any>null;
        data["allergicAnamnesisText"] = this.allergicAnamnesisText !== undefined ? this.allergicAnamnesisText : <any>null;
        data["almondsNormalLarge"] = this.almondsNormalLarge !== undefined ? this.almondsNormalLarge : <any>null;
        data["almondsPlaque"] = this.almondsPlaque !== undefined ? this.almondsPlaque : <any>null;
        data["behaviourFK"] = this.behaviourFK ? this.behaviourFK.toJSON() : <any>null;
        data["breathAbsent"] = this.breathAbsent !== undefined ? this.breathAbsent : <any>null;
        data["breathBronchial"] = this.breathBronchial !== undefined ? this.breathBronchial : <any>null;
        data["breathEvenly"] = this.breathEvenly !== undefined ? this.breathEvenly : <any>null;
        data["breathIsWeak"] = this.breathIsWeak !== undefined ? this.breathIsWeak : <any>null;
        data["breathPure"] = this.breathPure !== undefined ? this.breathPure : <any>null;
        data["breathText"] = this.breathText !== undefined ? this.breathText : <any>null;
        data["breathVesicular"] = this.breathVesicular !== undefined ? this.breathVesicular : <any>null;
        data["complaintsAnamnesis"] = this.complaintsAnamnesis !== undefined ? this.complaintsAnamnesis : <any>null;
        data["complicationsFK"] = this.complicationsFK ? this.complicationsFK.toJSON() : <any>null;
        data["consciousFK"] = this.consciousFK ? this.consciousFK.toJSON() : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["diuresisDisuria"] = this.diuresisDisuria !== undefined ? this.diuresisDisuria : <any>null;
        data["diuresisHematuria"] = this.diuresisHematuria !== undefined ? this.diuresisHematuria : <any>null;
        data["diuresisNo"] = this.diuresisNo !== undefined ? this.diuresisNo : <any>null;
        data["diuresisOliguria"] = this.diuresisOliguria !== undefined ? this.diuresisOliguria : <any>null;
        data["dyspepticDiarrhea"] = this.dyspepticDiarrhea !== undefined ? this.dyspepticDiarrhea : <any>null;
        data["dyspepticNausea"] = this.dyspepticNausea !== undefined ? this.dyspepticNausea : <any>null;
        data["dyspepticRetch"] = this.dyspepticRetch !== undefined ? this.dyspepticRetch : <any>null;
        data["dyspepticsNo"] = this.dyspepticsNo !== undefined ? this.dyspepticsNo : <any>null;
        data["dyspneaFK"] = this.dyspneaFK ? this.dyspneaFK.toJSON() : <any>null;
        data["excreta"] = this.excreta !== undefined ? this.excreta : <any>null;
        data["excretaText"] = this.excretaText !== undefined ? this.excretaText : <any>null;
        data["eyeOpening"] = this.eyeOpening !== undefined ? this.eyeOpening : <any>null;
        data["generalStateFK"] = this.generalStateFK ? this.generalStateFK.toJSON() : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["gynecologicAnamnesis"] = this.gynecologicAnamnesis !== undefined ? this.gynecologicAnamnesis : <any>null;
        data["heartAd"] = this.heartAd !== undefined ? this.heartAd : <any>null;
        data["heartAdMax"] = this.heartAdMax !== undefined ? this.heartAdMax : <any>null;
        data["heartAdn"] = this.heartAdn !== undefined ? this.heartAdn : <any>null;
        data["heartBodyTemp"] = this.heartBodyTemp !== undefined ? this.heartBodyTemp : <any>null;
        data["heartChd"] = this.heartChd !== undefined ? this.heartChd : <any>null;
        data["heartChss"] = this.heartChss !== undefined ? this.heartChss : <any>null;
        data["heartNoiseFK"] = this.heartNoiseFK ? this.heartNoiseFK.toJSON() : <any>null;
        data["heartPs"] = this.heartPs !== undefined ? this.heartPs : <any>null;
        data["heartPulseFK"] = this.heartPulseFK ? this.heartPulseFK.toJSON() : <any>null;
        data["heartRateFK"] = this.heartRateFK ? this.heartRateFK.toJSON() : <any>null;
        data["heartToneFK"] = this.heartToneFK ? this.heartToneFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["illnessAnamnesis"] = this.illnessAnamnesis !== undefined ? this.illnessAnamnesis : <any>null;
        data["infectContacts"] = this.infectContacts !== undefined ? this.infectContacts : <any>null;
        data["lionTappingLeft"] = this.lionTappingLeft !== undefined ? this.lionTappingLeft : <any>null;
        data["lionTappingRight"] = this.lionTappingRight !== undefined ? this.lionTappingRight : <any>null;
        data["liverNormalLarge"] = this.liverNormalLarge !== undefined ? this.liverNormalLarge : <any>null;
        data["liverOrtner"] = this.liverOrtner !== undefined ? this.liverOrtner : <any>null;
        data["liverSizeText"] = this.liverSizeText !== undefined ? this.liverSizeText : <any>null;
        data["lungsWheezingFK"] = this.lungsWheezingFK ? this.lungsWheezingFK.toJSON() : <any>null;
        data["lungsWheezingText"] = this.lungsWheezingText !== undefined ? this.lungsWheezingText : <any>null;
        data["lymphNodesNormalLarge"] = this.lymphNodesNormalLarge !== undefined ? this.lymphNodesNormalLarge : <any>null;
        data["lymphNodesPainful"] = this.lymphNodesPainful !== undefined ? this.lymphNodesPainful : <any>null;
        data["lymphNodesText"] = this.lymphNodesText !== undefined ? this.lymphNodesText : <any>null;
        data["meningealReflexes"] = this.meningealReflexes !== undefined ? this.meningealReflexes : <any>null;
        data["motorResponse"] = this.motorResponse !== undefined ? this.motorResponse : <any>null;
        data["multipleZevaCleanHyper"] = this.multipleZevaCleanHyper !== undefined ? this.multipleZevaCleanHyper : <any>null;
        data["pastIllnesses"] = this.pastIllnesses !== undefined ? this.pastIllnesses : <any>null;
        data["pathologicalReflexes"] = this.pathologicalReflexes !== undefined ? this.pathologicalReflexes : <any>null;
        data["penaltiesAnisocoria"] = this.penaltiesAnisocoria !== undefined ? this.penaltiesAnisocoria : <any>null;
        data["penaltiesDsFK"] = this.penaltiesDsFK ? this.penaltiesDsFK.toJSON() : <any>null;
        data["penaltiesFK"] = this.penaltiesFK ? this.penaltiesFK.toJSON() : <any>null;
        data["penaltiesLight"] = this.penaltiesLight !== undefined ? this.penaltiesLight : <any>null;
        data["penaltiesNystagmus"] = this.penaltiesNystagmus !== undefined ? this.penaltiesNystagmus : <any>null;
        data["percLungsSoundFK"] = this.percLungsSoundFK ? this.percLungsSoundFK.toJSON() : <any>null;
        data["percLungsSoundText"] = this.percLungsSoundText !== undefined ? this.percLungsSoundText : <any>null;
        data["pulseOximetry"] = this.pulseOximetry !== undefined ? this.pulseOximetry : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["reflexesDsFK"] = this.reflexesDsFK ? this.reflexesDsFK.toJSON() : <any>null;
        data["skinAcrosianosis"] = this.skinAcrosianosis !== undefined ? this.skinAcrosianosis : <any>null;
        data["skinColorFK"] = this.skinColorFK ? this.skinColorFK.toJSON() : <any>null;
        data["skinHyperemetic"] = this.skinHyperemetic !== undefined ? this.skinHyperemetic : <any>null;
        data["skinIntegCyanotic"] = this.skinIntegCyanotic !== undefined ? this.skinIntegCyanotic : <any>null;
        data["skinIsDry"] = this.skinIsDry !== undefined ? this.skinIsDry : <any>null;
        data["skinIsNormal"] = this.skinIsNormal !== undefined ? this.skinIsNormal : <any>null;
        data["skinRashes"] = this.skinRashes !== undefined ? this.skinRashes : <any>null;
        data["stomachAscites"] = this.stomachAscites !== undefined ? this.stomachAscites : <any>null;
        data["stomachBreathingInvolved"] = this.stomachBreathingInvolved !== undefined ? this.stomachBreathingInvolved : <any>null;
        data["stomachDisklike"] = this.stomachDisklike !== undefined ? this.stomachDisklike : <any>null;
        data["stomachInflated"] = this.stomachInflated !== undefined ? this.stomachInflated : <any>null;
        data["stomachIsHard"] = this.stomachIsHard !== undefined ? this.stomachIsHard : <any>null;
        data["stomachIsPainful"] = this.stomachIsPainful !== undefined ? this.stomachIsPainful : <any>null;
        data["stomachNormal"] = this.stomachNormal !== undefined ? this.stomachNormal : <any>null;
        data["stomachPeritonit"] = this.stomachPeritonit !== undefined ? this.stomachPeritonit : <any>null;
        data["stomachText"] = this.stomachText !== undefined ? this.stomachText : <any>null;
        data["tendonReflexesFK"] = this.tendonReflexesFK ? this.tendonReflexesFK.toJSON() : <any>null;
        data["titles"] = this.titles !== undefined ? this.titles : <any>null;
        data["titlesText"] = this.titlesText !== undefined ? this.titlesText : <any>null;
        data["tongueCleanFurred"] = this.tongueCleanFurred !== undefined ? this.tongueCleanFurred : <any>null;
        data["tongueWeatDry"] = this.tongueWeatDry !== undefined ? this.tongueWeatDry : <any>null;
        data["urineText"] = this.urineText !== undefined ? this.urineText : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        data["verbalResponse"] = this.verbalResponse !== undefined ? this.verbalResponse : <any>null;
        return data; 
    }
}

export interface ICardObjectiveBean {
    /** Дополнительные объективные данные */
    additionObjectives?: string | null;
    /** ALCOOVERDOZE: Свежее дыхание */
    alcoBreath?: boolean | null;
    /** ALCOOVERDOZE: Лабильность */
    alcoEmotionLability?: boolean | null;
    /** ALCOOVERDOZE: Неадекват */
    alcoInadequate?: boolean | null;
    /** ALCOOVERDOZE: Поза Ромберга */
    alcoRombergPose?: boolean | null;
    /** ALCOOVERDOZE: Лунная алкопоходка */
    alcoShakyWalk?: boolean | null;
    /** ALCOOVERDOZE: Умение зачитывать по пьяни Rap God */
    alcoSpeechBehavior?: boolean | null;
    /** Наличие аллергии: признак */
    allergicAnamnesis?: boolean | null;
    /** Наличие аллергии: описание */
    allergicAnamnesisText?: string | null;
    /** Миндалины нормального размера */
    almondsNormalLarge?: boolean | null;
    /** Налеты на миндалинах */
    almondsPlaque?: boolean | null;
    /** Поведение */
    behaviourFK?: ReferenceTypeBean | null;
    /** Сухожильные рефлексы */
    breathAbsent?: boolean | null;
    /** Бронхиальное */
    breathBronchial?: boolean | null;
    /** Равномерное */
    breathEvenly?: boolean | null;
    /** Слабое/тяжелое(t/f) */
    breathIsWeak?: boolean | null;
    /** Чистое */
    breathPure?: boolean | null;
    /** Дыхание: комментарий */
    breathText?: string | null;
    /** Везикулярное */
    breathVesicular?: boolean | null;
    /** Жалобы и анамнез */
    complaintsAnamnesis?: string | null;
    /** Осложнения */
    complicationsFK?: ReferenceTypeBean | null;
    /** Сознание */
    consciousFK?: ReferenceTypeBean | null;
    /** Дата создания карты */
    date?: Date | null;
    /** Диурез: дизурия */
    diuresisDisuria?: boolean | null;
    /** Диурез: гематурия */
    diuresisHematuria?: boolean | null;
    /** Диурез отсутствует */
    diuresisNo?: boolean | null;
    /** Диурез: олигурия */
    diuresisOliguria?: boolean | null;
    /** Расстройства пищеварения: диарея */
    dyspepticDiarrhea?: boolean | null;
    /** Расстройства пищеварения: тошнота */
    dyspepticNausea?: boolean | null;
    /** Расстройства пищеварения: запор */
    dyspepticRetch?: boolean | null;
    /** Расстройства пищеварения: нет */
    dyspepticsNo?: boolean | null;
    /** Сухожильные рефлексы */
    dyspneaFK?: ReferenceTypeBean | null;
    /** Признак наличия выделительной системы */
    excreta?: boolean | null;
    /** Состояние выделительной системы */
    excretaText?: string | null;
    /** ШКГ - Тест открывания глаз (E) */
    eyeOpening?: number | null;
    /** Общее состояние */
    generalStateFK?: ReferenceTypeBean | null;
    /** Глюкометрия */
    glucometry?: string | null;
    /** Гинекологический анамнез */
    gynecologicAnamnesis?: string | null;
    /** Сердце: АД */
    heartAd?: string | null;
    /** Сердце: АД максимальное */
    heartAdMax?: string | null;
    /** Сердце: АДН */
    heartAdn?: string | null;
    /** Температура */
    heartBodyTemp?: string | null;
    /** Сердце: ЧД */
    heartChd?: string | null;
    /** Сердце: ЧСС */
    heartChss?: string | null;
    /** Сердечные шумы */
    heartNoiseFK?: ReferenceTypeBean | null;
    /** Сердце: Пульс */
    heartPs?: string | null;
    /** Пульс */
    heartPulseFK?: ReferenceTypeBean | null;
    /** Частота сердцебиения */
    heartRateFK?: ReferenceTypeBean | null;
    /** Тоны сердца */
    heartToneFK?: ReferenceTypeBean | null;
    id?: number | null;
    /** Анамнез болезней (чем сейчас болеет) */
    illnessAnamnesis?: string | null;
    /** Инфекционность */
    infectContacts?: string | null;
    /** Диурез слева */
    lionTappingLeft?: boolean | null;
    /** Диурез справа */
    lionTappingRight?: boolean | null;
    /** Печень: нормального размера */
    liverNormalLarge?: boolean | null;
    /** Печень: синдром Ортнера */
    liverOrtner?: boolean | null;
    /** Печень: размер */
    liverSizeText?: string | null;
    /** Легочные хрипы */
    lungsWheezingFK?: ReferenceTypeBean | null;
    /** Хрипы в легких: комментарий */
    lungsWheezingText?: string | null;
    /** Лимфоузлы: нормальный размер */
    lymphNodesNormalLarge?: boolean | null;
    /** Лимфоузлы: болезненные ощущения */
    lymphNodesPainful?: boolean | null;
    /** Лимфоузлы: комментарий */
    lymphNodesText?: string | null;
    /** Менингиальные синдромы */
    meningealReflexes?: boolean | null;
    /** ШКГ - Двигательный тест (M) */
    motorResponse?: number | null;
    /** Слизистая зева */
    multipleZevaCleanHyper?: boolean | null;
    /** Анамнез болезней (чем раньше болел) */
    pastIllnesses?: string | null;
    /** Патологические стопные рефлексы */
    pathologicalReflexes?: boolean | null;
    /** Анизокория */
    penaltiesAnisocoria?: boolean | null;
    /** Состояние зрачков одинаково выражено (D ? S) */
    penaltiesDsFK?: ReferenceTypeBean | null;
    /** Состояние зрачков */
    penaltiesFK?: ReferenceTypeBean | null;
    /** Реакция на свет */
    penaltiesLight?: boolean | null;
    /** Нистагм */
    penaltiesNystagmus?: boolean | null;
    /** Сравнительная перкуссия легких */
    percLungsSoundFK?: ReferenceTypeBean | null;
    /** Звук при перкуссии легких */
    percLungsSoundText?: string | null;
    /** ПульсOXXXYметрия */
    pulseOximetry?: string | null;
    /** Карантин */
    quarantine?: string | null;
    /** Рефлексы одинаково выражены (D ? S) */
    reflexesDsFK?: ReferenceTypeBean | null;
    /** Акроцианоз */
    skinAcrosianosis?: boolean | null;
    /** Цвет кожи */
    skinColorFK?: ReferenceTypeBean | null;
    /** Гиперимированность */
    skinHyperemetic?: boolean | null;
    /** Цианоз */
    skinIntegCyanotic?: boolean | null;
    /** Сухость/Потливость (t/f) */
    skinIsDry?: boolean | null;
    /** Кожа нормальная/нет */
    skinIsNormal?: boolean | null;
    /** Сыпь */
    skinRashes?: boolean | null;
    /** Желудочный асцит */
    stomachAscites?: boolean | null;
    /** Живот участвует в акте дыхания */
    stomachBreathingInvolved?: boolean | null;
    /** Желудок доскообразный */
    stomachDisklike?: boolean | null;
    /** Желудок вздутый */
    stomachInflated?: boolean | null;
    /** Желудок твердый */
    stomachIsHard?: boolean | null;
    /** Боль в желудке */
    stomachIsPainful?: boolean | null;
    /** Желудок в норме */
    stomachNormal?: boolean | null;
    /** Перитонит */
    stomachPeritonit?: boolean | null;
    /** Описание состояния брюшной полости */
    stomachText?: string | null;
    /** Сухожильные рефлексы */
    tendonReflexesFK?: ReferenceTypeBean | null;
    /** Признак наличия отеков */
    titles?: boolean | null;
    /** Локализация отеков */
    titlesText?: string | null;
    /** Признак влажности/сухости языка */
    tongueCleanFurred?: boolean | null;
    /** Признак чистоты языка */
    tongueWeatDry?: boolean | null;
    /** Мочеиспускание */
    urineText?: string | null;
    /** Вакцинация */
    vaccination?: string | null;
    /** ШКГ - Речевой тест (V) */
    verbalResponse?: number | null;
}

export class DocumentTypeBean implements IDocumentTypeBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    isIdentity?: boolean | null;
    name?: string | null;

    constructor(data?: IDocumentTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.isIdentity = data["isIdentity"] !== undefined ? data["isIdentity"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["isIdentity"] = this.isIdentity !== undefined ? this.isIdentity : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDocumentTypeBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    isIdentity?: boolean | null;
    name?: string | null;
}

export class ListContainerOfPatientBean implements IListContainerOfPatientBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPatientBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPatientBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPatientBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPatientBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ReferenceTypeBean implements IReferenceTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
    type?: string | null;

    constructor(data?: IReferenceTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): ReferenceTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReferenceTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
    type?: string | null;
}

export class PerformerTypeBean implements IPerformerTypeBean {
    code?: string | null;
    /** Группа сотрудника */
    groupCode?: number | null;
    groupName?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Краткое наименование */
    shortName?: string | null;

    constructor(data?: IPerformerTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.groupCode = data["groupCode"] !== undefined ? data["groupCode"] : <any>null;
            this.groupName = data["groupName"] !== undefined ? data["groupName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["groupCode"] = this.groupCode !== undefined ? this.groupCode : <any>null;
        data["groupName"] = this.groupName !== undefined ? this.groupName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        return data; 
    }
}

export interface IPerformerTypeBean {
    code?: string | null;
    /** Группа сотрудника */
    groupCode?: number | null;
    groupName?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Краткое наименование */
    shortName?: string | null;
}

export class HelipadBean implements IHelipadBean {
    /** Код вертолетной площадки */
    code?: string | null;
    id?: number | null;
    /** Признак удаленной записи */
    isDeleted?: boolean | null;
    /** Наименование вертолетной площадки */
    name?: string | null;
    /** ID подразделения */
    subdivision?: number | null;

    constructor(data?: IHelipadBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivision = data["subdivision"] !== undefined ? data["subdivision"] : <any>null;
        }
    }

    static fromJS(data: any): HelipadBean {
        data = typeof data === 'object' ? data : {};
        let result = new HelipadBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivision"] = this.subdivision !== undefined ? this.subdivision : <any>null;
        return data; 
    }
}

export interface IHelipadBean {
    /** Код вертолетной площадки */
    code?: string | null;
    id?: number | null;
    /** Признак удаленной записи */
    isDeleted?: boolean | null;
    /** Наименование вертолетной площадки */
    name?: string | null;
    /** ID подразделения */
    subdivision?: number | null;
}

export class AndyTreeNodeOfClassMkbBean implements IAndyTreeNodeOfClassMkbBean {
    children?: AndyTreeNodeOfClassMkbBean[] | null;
    data?: ClassMkbBean | null;

    constructor(data?: IAndyTreeNodeOfClassMkbBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(AndyTreeNodeOfClassMkbBean.fromJS(item));
            }
            this.data = data["data"] ? ClassMkbBean.fromJS(data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): AndyTreeNodeOfClassMkbBean {
        data = typeof data === 'object' ? data : {};
        let result = new AndyTreeNodeOfClassMkbBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IAndyTreeNodeOfClassMkbBean {
    children?: AndyTreeNodeOfClassMkbBean[] | null;
    data?: ClassMkbBean | null;
}

export class LockResult implements ILockResult {
    locker?: string | null;
    relockIntervalSeconds?: number | null;
    success?: boolean | null;
    token?: string | null;

    constructor(data?: ILockResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locker = data["locker"] !== undefined ? data["locker"] : <any>null;
            this.relockIntervalSeconds = data["relockIntervalSeconds"] !== undefined ? data["relockIntervalSeconds"] : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            this.token = data["token"] !== undefined ? data["token"] : <any>null;
        }
    }

    static fromJS(data: any): LockResult {
        data = typeof data === 'object' ? data : {};
        let result = new LockResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locker"] = this.locker !== undefined ? this.locker : <any>null;
        data["relockIntervalSeconds"] = this.relockIntervalSeconds !== undefined ? this.relockIntervalSeconds : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface ILockResult {
    locker?: string | null;
    relockIntervalSeconds?: number | null;
    success?: boolean | null;
    token?: string | null;
}

export class ListContainerOfOtherMeanBean implements IListContainerOfOtherMeanBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfOtherMeanBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfOtherMeanBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfOtherMeanBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfOtherMeanBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class LoginPair implements ILoginPair {
    password?: string | null;
    username?: string | null;

    constructor(data?: ILoginPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
        }
    }

    static fromJS(data: any): LoginPair {
        data = typeof data === 'object' ? data : {};
        let result = new LoginPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        return data; 
    }
}

export interface ILoginPair {
    password?: string | null;
    username?: string | null;
}

export class TransportBean implements ITransportBean {
    /** Номер */
    code?: string | null;
    id?: number | null;
    /** Признак возможности использования (только для вертолетов) */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    /** Признак вжух-вжух-вжух */
    isHelicopter?: boolean | null;
    /** VIN */
    manufactureYear?: number | null;
    /** Марка/модель ТС */
    name?: string | null;
    /** ID подразделения */
    subdivision?: number | null;
    /** Связанный с транспортом трекер */
    transportEquipmentFK?: TransportEquipmentBean | null;
    /** Категория ТС */
    vehicleCategory?: string | null;
    /** Описание категории ТС */
    vehicleCategoryDescription?: string | null;
    /** VIN */
    vin?: string | null;

    constructor(data?: ITransportBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAvailable = data["isAvailable"] !== undefined ? data["isAvailable"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.isHelicopter = data["isHelicopter"] !== undefined ? data["isHelicopter"] : <any>null;
            this.manufactureYear = data["manufactureYear"] !== undefined ? data["manufactureYear"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivision = data["subdivision"] !== undefined ? data["subdivision"] : <any>null;
            this.transportEquipmentFK = data["transportEquipmentFK"] ? TransportEquipmentBean.fromJS(data["transportEquipmentFK"]) : <any>null;
            this.vehicleCategory = data["vehicleCategory"] !== undefined ? data["vehicleCategory"] : <any>null;
            this.vehicleCategoryDescription = data["vehicleCategoryDescription"] !== undefined ? data["vehicleCategoryDescription"] : <any>null;
            this.vin = data["vin"] !== undefined ? data["vin"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBean {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["isHelicopter"] = this.isHelicopter !== undefined ? this.isHelicopter : <any>null;
        data["manufactureYear"] = this.manufactureYear !== undefined ? this.manufactureYear : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivision"] = this.subdivision !== undefined ? this.subdivision : <any>null;
        data["transportEquipmentFK"] = this.transportEquipmentFK ? this.transportEquipmentFK.toJSON() : <any>null;
        data["vehicleCategory"] = this.vehicleCategory !== undefined ? this.vehicleCategory : <any>null;
        data["vehicleCategoryDescription"] = this.vehicleCategoryDescription !== undefined ? this.vehicleCategoryDescription : <any>null;
        data["vin"] = this.vin !== undefined ? this.vin : <any>null;
        return data; 
    }
}

export interface ITransportBean {
    /** Номер */
    code?: string | null;
    id?: number | null;
    /** Признак возможности использования (только для вертолетов) */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    /** Признак вжух-вжух-вжух */
    isHelicopter?: boolean | null;
    /** VIN */
    manufactureYear?: number | null;
    /** Марка/модель ТС */
    name?: string | null;
    /** ID подразделения */
    subdivision?: number | null;
    /** Связанный с транспортом трекер */
    transportEquipmentFK?: TransportEquipmentBean | null;
    /** Категория ТС */
    vehicleCategory?: string | null;
    /** Описание категории ТС */
    vehicleCategoryDescription?: string | null;
    /** VIN */
    vin?: string | null;
}

export class BrigadePerformerScheduleBean implements IBrigadePerformerScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;

    constructor(data?: IBrigadePerformerScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeSchedule = data["brigadeSchedule"] !== undefined ? data["brigadeSchedule"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.dutyEndDate = data["dutyEndDate"] ? new Date(data["dutyEndDate"].toString()) : <any>null;
            this.dutyStartDate = data["dutyStartDate"] ? new Date(data["dutyStartDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadePerformerScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadePerformerScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeSchedule"] = this.brigadeSchedule !== undefined ? this.brigadeSchedule : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["dutyEndDate"] = this.dutyEndDate ? this.dutyEndDate.toISOString() : <any>null;
        data["dutyStartDate"] = this.dutyStartDate ? this.dutyStartDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadePerformerScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;
}

export class SettlementBean implements ISettlementBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Район */
    district?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Землепользование */
    landuse?: string | null;
    /** Наименование населенного пункта */
    name?: string | null;
    /** Регион */
    regionAddress?: string | null;

    constructor(data?: ISettlementBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityAddress = data["cityAddress"] !== undefined ? data["cityAddress"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.geometry = data["geometry"] ? PGgeometry.fromJS(data["geometry"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.idOSM = data["idOSM"] !== undefined ? data["idOSM"] : <any>null;
            this.landuse = data["landuse"] !== undefined ? data["landuse"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.regionAddress = data["regionAddress"] !== undefined ? data["regionAddress"] : <any>null;
        }
    }

    static fromJS(data: any): SettlementBean {
        data = typeof data === 'object' ? data : {};
        let result = new SettlementBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityAddress"] = this.cityAddress !== undefined ? this.cityAddress : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["idOSM"] = this.idOSM !== undefined ? this.idOSM : <any>null;
        data["landuse"] = this.landuse !== undefined ? this.landuse : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["regionAddress"] = this.regionAddress !== undefined ? this.regionAddress : <any>null;
        return data; 
    }
}

export interface ISettlementBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Район */
    district?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Землепользование */
    landuse?: string | null;
    /** Наименование населенного пункта */
    name?: string | null;
    /** Регион */
    regionAddress?: string | null;
}

export class ArchiveCardContainer implements IArchiveCardContainer {
    birthday?: string | null;
    brigadeId?: number | null;
    callNumber?: string | null;
    cardStatus?: number | null;
    dateFrom?: string | null;
    dateTo?: string | null;
    isChildrenIncluded?: boolean | null;
    mkbName?: string | null;
    name?: string | null;
    number?: string | null;
    patronymic?: string | null;
    subdivisionId?: number | null;
    surname?: string | null;

    constructor(data?: IArchiveCardContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.birthday = data["birthday"] !== undefined ? data["birthday"] : <any>null;
            this.brigadeId = data["brigadeId"] !== undefined ? data["brigadeId"] : <any>null;
            this.callNumber = data["callNumber"] !== undefined ? data["callNumber"] : <any>null;
            this.cardStatus = data["cardStatus"] !== undefined ? data["cardStatus"] : <any>null;
            this.dateFrom = data["dateFrom"] !== undefined ? data["dateFrom"] : <any>null;
            this.dateTo = data["dateTo"] !== undefined ? data["dateTo"] : <any>null;
            this.isChildrenIncluded = data["isChildrenIncluded"] !== undefined ? data["isChildrenIncluded"] : <any>null;
            this.mkbName = data["mkbName"] !== undefined ? data["mkbName"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
        }
    }

    static fromJS(data: any): ArchiveCardContainer {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveCardContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthday"] = this.birthday !== undefined ? this.birthday : <any>null;
        data["brigadeId"] = this.brigadeId !== undefined ? this.brigadeId : <any>null;
        data["callNumber"] = this.callNumber !== undefined ? this.callNumber : <any>null;
        data["cardStatus"] = this.cardStatus !== undefined ? this.cardStatus : <any>null;
        data["dateFrom"] = this.dateFrom !== undefined ? this.dateFrom : <any>null;
        data["dateTo"] = this.dateTo !== undefined ? this.dateTo : <any>null;
        data["isChildrenIncluded"] = this.isChildrenIncluded !== undefined ? this.isChildrenIncluded : <any>null;
        data["mkbName"] = this.mkbName !== undefined ? this.mkbName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        return data; 
    }
}

export interface IArchiveCardContainer {
    birthday?: string | null;
    brigadeId?: number | null;
    callNumber?: string | null;
    cardStatus?: number | null;
    dateFrom?: string | null;
    dateTo?: string | null;
    isChildrenIncluded?: boolean | null;
    mkbName?: string | null;
    name?: string | null;
    number?: string | null;
    patronymic?: string | null;
    subdivisionId?: number | null;
    surname?: string | null;
}

export class ListContainerOfUnitBean implements IListContainerOfUnitBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfUnitBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfUnitBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfUnitBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfUnitBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class SubdivisionSpecializationBean implements ISubdivisionSpecializationBean {
    id?: number | null;
    specialization?: number | null;
    subdivisionId?: number | null;

    constructor(data?: ISubdivisionSpecializationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.specialization = data["specialization"] !== undefined ? data["specialization"] : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionSpecializationBean {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionSpecializationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["specialization"] = this.specialization !== undefined ? this.specialization : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        return data; 
    }
}

export interface ISubdivisionSpecializationBean {
    id?: number | null;
    specialization?: number | null;
    subdivisionId?: number | null;
}

export class ListContainerOfSkillBean implements IListContainerOfSkillBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfSkillBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfSkillBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfSkillBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfSkillBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class DrugTypeBean implements IDrugTypeBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** тип препарата */
    name?: string | null;

    constructor(data?: IDrugTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DrugTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDrugTypeBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** тип препарата */
    name?: string | null;
}

export class ListContainerOfSubdivisionTypeBean implements IListContainerOfSubdivisionTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfSubdivisionTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfSubdivisionTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfSubdivisionTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfSubdivisionTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CallOperatorInfoBean implements ICallOperatorInfoBean {
    /** AOR SIP-терминала диспетчера (IP-телефон) */
    aor?: string | null;
    /** IP ПК, привязанного к телефону */
    ip?: string | null;
    /** Сотрудник, работающий за ПК */
    performerFK?: PerformerBean | null;

    constructor(data?: ICallOperatorInfoBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.aor = data["aor"] !== undefined ? data["aor"] : <any>null;
            this.ip = data["ip"] !== undefined ? data["ip"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
        }
    }

    static fromJS(data: any): CallOperatorInfoBean {
        data = typeof data === 'object' ? data : {};
        let result = new CallOperatorInfoBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aor"] = this.aor !== undefined ? this.aor : <any>null;
        data["ip"] = this.ip !== undefined ? this.ip : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        return data; 
    }
}

export interface ICallOperatorInfoBean {
    /** AOR SIP-терминала диспетчера (IP-телефон) */
    aor?: string | null;
    /** IP ПК, привязанного к телефону */
    ip?: string | null;
    /** Сотрудник, работающий за ПК */
    performerFK?: PerformerBean | null;
}

export class ListContainerOfDocumentTypeBean implements IListContainerOfDocumentTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDocumentTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDocumentTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDocumentTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDocumentTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfBagTemplateBean implements IListContainerOfBagTemplateBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBagTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBagTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBagTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBagTemplateBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfWareBean implements IListContainerOfWareBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfWareBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfWareBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfWareBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfWareBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfReferenceTypeBean implements IListContainerOfReferenceTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfReferenceTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfReferenceTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfReferenceTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfReferenceTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardBean implements ICardBean {
    arriveTimeExceed?: boolean | null;
    brigadeArriveDate?: Date | null;
    brigadeDepartureDate?: Date | null;
    /** Врач бригады, принявшей вызов */
    brigadeDoctorFK?: PerformerBean | null;
    brigadeDoctorIsChecked?: boolean | null;
    brigadeDoneDate?: Date | null;
    /** Бригада */
    brigadeFK?: BrigadeBean | null;
    brigadeHospitalizationDate?: Date | null;
    brigadeInHospitalDate?: Date | null;
    brigadeReceivingDate?: Date | null;
    /** Место, где вызов был принят бригадой */
    brigadeReceivingPlaceFK?: ReferenceTypeBean | null;
    /** Способ получения бригадой вызов */
    brigadeReceivingTypeFK?: ReferenceTypeBean | null;
    brigadeReturnDate?: Date | null;
    /** Постоянная регистрация (Корпус) */
    buildingNum?: string | null;
    /** ID вызова */
    call?: number | null;
    /** Card objective */
    cardObjectiveBean?: CardObjectiveBean | null;
    /** CardResult */
    cardResultBean?: CardResultBean | null;
    /** Статус карты вызова */
    cardStatus?: number | null;
    /** Постоянная регистрация (Страна) */
    country?: string | null;
    /** Дата создания карты */
    date?: Date | null;
    /** Дата закрытия карты */
    dateClose?: Date | null;
    /** Врач бригады, принявшей вызов */
    dispatcherReceivedFK?: PerformerBean | null;
    /** Постоянная регистрация (Район) */
    district?: string | null;
    /** Постоянная регистрация (Квартира) */
    flatNum?: string | null;
    fullTimeInterval?: string | null;
    /** Постоянная регистрация (Номер дома) */
    houseNum?: string | null;
    id?: number | null;
    /** Согласие на мед.вмешательство */
    isConsentMedIntervention?: boolean | null;
    /** Отказ от транспортировки для госпитализации в стационар */
    isDeclineHospitalization?: boolean | null;
    /** Отказ от мед.вмешательства */
    isDeclineMedIntervention?: boolean | null;
    /** Номер карты */
    number?: string | null;
    /** Пациент */
    patientFK?: PatientBean | null;
    /** Социальное положение пациента */
    patientSocialStatusFK?: ReferenceTypeBean | null;
    /** Пациент из вызова */
    patientTemplateFK?: PatientTemplateBean | null;
    /** ID сотрудника, заполняющего карту */
    performerFK?: PerformerBean | null;
    /** Должность */
    post?: string | null;
    receivingTimeExceed?: boolean | null;
    /** Постоянная регистрация (Регион) */
    region?: string | null;
    /** Тип результа выезда */
    resultTypeFK?: ReferenceTypeBean | null;
    shiftSeniorDoctorComment?: string | null;
    /** Главный врач смены */
    shiftSeniorDoctorFK?: PerformerBean | null;
    shiftSeniorDoctorIsChecked?: boolean | null;
    /** Постоянная регистрация (Улица) */
    street?: string | null;
    /** ID подразделения */
    subdivisionFK?: SubdivisionBean | null;
    /** Постоянная регистрация (Населенный пункт) */
    town?: string | null;
    /** Место работы */
    workplace?: string | null;

    constructor(data?: ICardBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.arriveTimeExceed = data["arriveTimeExceed"] !== undefined ? data["arriveTimeExceed"] : <any>null;
            this.brigadeArriveDate = data["brigadeArriveDate"] ? new Date(data["brigadeArriveDate"].toString()) : <any>null;
            this.brigadeDepartureDate = data["brigadeDepartureDate"] ? new Date(data["brigadeDepartureDate"].toString()) : <any>null;
            this.brigadeDoctorFK = data["brigadeDoctorFK"] ? PerformerBean.fromJS(data["brigadeDoctorFK"]) : <any>null;
            this.brigadeDoctorIsChecked = data["brigadeDoctorIsChecked"] !== undefined ? data["brigadeDoctorIsChecked"] : <any>null;
            this.brigadeDoneDate = data["brigadeDoneDate"] ? new Date(data["brigadeDoneDate"].toString()) : <any>null;
            this.brigadeFK = data["brigadeFK"] ? BrigadeBean.fromJS(data["brigadeFK"]) : <any>null;
            this.brigadeHospitalizationDate = data["brigadeHospitalizationDate"] ? new Date(data["brigadeHospitalizationDate"].toString()) : <any>null;
            this.brigadeInHospitalDate = data["brigadeInHospitalDate"] ? new Date(data["brigadeInHospitalDate"].toString()) : <any>null;
            this.brigadeReceivingDate = data["brigadeReceivingDate"] ? new Date(data["brigadeReceivingDate"].toString()) : <any>null;
            this.brigadeReceivingPlaceFK = data["brigadeReceivingPlaceFK"] ? ReferenceTypeBean.fromJS(data["brigadeReceivingPlaceFK"]) : <any>null;
            this.brigadeReceivingTypeFK = data["brigadeReceivingTypeFK"] ? ReferenceTypeBean.fromJS(data["brigadeReceivingTypeFK"]) : <any>null;
            this.brigadeReturnDate = data["brigadeReturnDate"] ? new Date(data["brigadeReturnDate"].toString()) : <any>null;
            this.buildingNum = data["buildingNum"] !== undefined ? data["buildingNum"] : <any>null;
            this.call = data["call"] !== undefined ? data["call"] : <any>null;
            this.cardObjectiveBean = data["cardObjectiveBean"] ? CardObjectiveBean.fromJS(data["cardObjectiveBean"]) : <any>null;
            this.cardResultBean = data["cardResultBean"] ? CardResultBean.fromJS(data["cardResultBean"]) : <any>null;
            this.cardStatus = data["cardStatus"] !== undefined ? data["cardStatus"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.dateClose = data["dateClose"] ? new Date(data["dateClose"].toString()) : <any>null;
            this.dispatcherReceivedFK = data["dispatcherReceivedFK"] ? PerformerBean.fromJS(data["dispatcherReceivedFK"]) : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.flatNum = data["flatNum"] !== undefined ? data["flatNum"] : <any>null;
            this.fullTimeInterval = data["fullTimeInterval"] !== undefined ? data["fullTimeInterval"] : <any>null;
            this.houseNum = data["houseNum"] !== undefined ? data["houseNum"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isConsentMedIntervention = data["isConsentMedIntervention"] !== undefined ? data["isConsentMedIntervention"] : <any>null;
            this.isDeclineHospitalization = data["isDeclineHospitalization"] !== undefined ? data["isDeclineHospitalization"] : <any>null;
            this.isDeclineMedIntervention = data["isDeclineMedIntervention"] !== undefined ? data["isDeclineMedIntervention"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patientFK = data["patientFK"] ? PatientBean.fromJS(data["patientFK"]) : <any>null;
            this.patientSocialStatusFK = data["patientSocialStatusFK"] ? ReferenceTypeBean.fromJS(data["patientSocialStatusFK"]) : <any>null;
            this.patientTemplateFK = data["patientTemplateFK"] ? PatientTemplateBean.fromJS(data["patientTemplateFK"]) : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.post = data["post"] !== undefined ? data["post"] : <any>null;
            this.receivingTimeExceed = data["receivingTimeExceed"] !== undefined ? data["receivingTimeExceed"] : <any>null;
            this.region = data["region"] !== undefined ? data["region"] : <any>null;
            this.resultTypeFK = data["resultTypeFK"] ? ReferenceTypeBean.fromJS(data["resultTypeFK"]) : <any>null;
            this.shiftSeniorDoctorComment = data["shiftSeniorDoctorComment"] !== undefined ? data["shiftSeniorDoctorComment"] : <any>null;
            this.shiftSeniorDoctorFK = data["shiftSeniorDoctorFK"] ? PerformerBean.fromJS(data["shiftSeniorDoctorFK"]) : <any>null;
            this.shiftSeniorDoctorIsChecked = data["shiftSeniorDoctorIsChecked"] !== undefined ? data["shiftSeniorDoctorIsChecked"] : <any>null;
            this.street = data["street"] !== undefined ? data["street"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.town = data["town"] !== undefined ? data["town"] : <any>null;
            this.workplace = data["workplace"] !== undefined ? data["workplace"] : <any>null;
        }
    }

    static fromJS(data: any): CardBean {
        data = typeof data === 'object' ? data : {};
        let result = new CardBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arriveTimeExceed"] = this.arriveTimeExceed !== undefined ? this.arriveTimeExceed : <any>null;
        data["brigadeArriveDate"] = this.brigadeArriveDate ? this.brigadeArriveDate.toISOString() : <any>null;
        data["brigadeDepartureDate"] = this.brigadeDepartureDate ? this.brigadeDepartureDate.toISOString() : <any>null;
        data["brigadeDoctorFK"] = this.brigadeDoctorFK ? this.brigadeDoctorFK.toJSON() : <any>null;
        data["brigadeDoctorIsChecked"] = this.brigadeDoctorIsChecked !== undefined ? this.brigadeDoctorIsChecked : <any>null;
        data["brigadeDoneDate"] = this.brigadeDoneDate ? this.brigadeDoneDate.toISOString() : <any>null;
        data["brigadeFK"] = this.brigadeFK ? this.brigadeFK.toJSON() : <any>null;
        data["brigadeHospitalizationDate"] = this.brigadeHospitalizationDate ? this.brigadeHospitalizationDate.toISOString() : <any>null;
        data["brigadeInHospitalDate"] = this.brigadeInHospitalDate ? this.brigadeInHospitalDate.toISOString() : <any>null;
        data["brigadeReceivingDate"] = this.brigadeReceivingDate ? this.brigadeReceivingDate.toISOString() : <any>null;
        data["brigadeReceivingPlaceFK"] = this.brigadeReceivingPlaceFK ? this.brigadeReceivingPlaceFK.toJSON() : <any>null;
        data["brigadeReceivingTypeFK"] = this.brigadeReceivingTypeFK ? this.brigadeReceivingTypeFK.toJSON() : <any>null;
        data["brigadeReturnDate"] = this.brigadeReturnDate ? this.brigadeReturnDate.toISOString() : <any>null;
        data["buildingNum"] = this.buildingNum !== undefined ? this.buildingNum : <any>null;
        data["call"] = this.call !== undefined ? this.call : <any>null;
        data["cardObjectiveBean"] = this.cardObjectiveBean ? this.cardObjectiveBean.toJSON() : <any>null;
        data["cardResultBean"] = this.cardResultBean ? this.cardResultBean.toJSON() : <any>null;
        data["cardStatus"] = this.cardStatus !== undefined ? this.cardStatus : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["dateClose"] = this.dateClose ? this.dateClose.toISOString() : <any>null;
        data["dispatcherReceivedFK"] = this.dispatcherReceivedFK ? this.dispatcherReceivedFK.toJSON() : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["flatNum"] = this.flatNum !== undefined ? this.flatNum : <any>null;
        data["fullTimeInterval"] = this.fullTimeInterval !== undefined ? this.fullTimeInterval : <any>null;
        data["houseNum"] = this.houseNum !== undefined ? this.houseNum : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isConsentMedIntervention"] = this.isConsentMedIntervention !== undefined ? this.isConsentMedIntervention : <any>null;
        data["isDeclineHospitalization"] = this.isDeclineHospitalization !== undefined ? this.isDeclineHospitalization : <any>null;
        data["isDeclineMedIntervention"] = this.isDeclineMedIntervention !== undefined ? this.isDeclineMedIntervention : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patientFK"] = this.patientFK ? this.patientFK.toJSON() : <any>null;
        data["patientSocialStatusFK"] = this.patientSocialStatusFK ? this.patientSocialStatusFK.toJSON() : <any>null;
        data["patientTemplateFK"] = this.patientTemplateFK ? this.patientTemplateFK.toJSON() : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["post"] = this.post !== undefined ? this.post : <any>null;
        data["receivingTimeExceed"] = this.receivingTimeExceed !== undefined ? this.receivingTimeExceed : <any>null;
        data["region"] = this.region !== undefined ? this.region : <any>null;
        data["resultTypeFK"] = this.resultTypeFK ? this.resultTypeFK.toJSON() : <any>null;
        data["shiftSeniorDoctorComment"] = this.shiftSeniorDoctorComment !== undefined ? this.shiftSeniorDoctorComment : <any>null;
        data["shiftSeniorDoctorFK"] = this.shiftSeniorDoctorFK ? this.shiftSeniorDoctorFK.toJSON() : <any>null;
        data["shiftSeniorDoctorIsChecked"] = this.shiftSeniorDoctorIsChecked !== undefined ? this.shiftSeniorDoctorIsChecked : <any>null;
        data["street"] = this.street !== undefined ? this.street : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["town"] = this.town !== undefined ? this.town : <any>null;
        data["workplace"] = this.workplace !== undefined ? this.workplace : <any>null;
        return data; 
    }
}

export interface ICardBean {
    arriveTimeExceed?: boolean | null;
    brigadeArriveDate?: Date | null;
    brigadeDepartureDate?: Date | null;
    /** Врач бригады, принявшей вызов */
    brigadeDoctorFK?: PerformerBean | null;
    brigadeDoctorIsChecked?: boolean | null;
    brigadeDoneDate?: Date | null;
    /** Бригада */
    brigadeFK?: BrigadeBean | null;
    brigadeHospitalizationDate?: Date | null;
    brigadeInHospitalDate?: Date | null;
    brigadeReceivingDate?: Date | null;
    /** Место, где вызов был принят бригадой */
    brigadeReceivingPlaceFK?: ReferenceTypeBean | null;
    /** Способ получения бригадой вызов */
    brigadeReceivingTypeFK?: ReferenceTypeBean | null;
    brigadeReturnDate?: Date | null;
    /** Постоянная регистрация (Корпус) */
    buildingNum?: string | null;
    /** ID вызова */
    call?: number | null;
    /** Card objective */
    cardObjectiveBean?: CardObjectiveBean | null;
    /** CardResult */
    cardResultBean?: CardResultBean | null;
    /** Статус карты вызова */
    cardStatus?: number | null;
    /** Постоянная регистрация (Страна) */
    country?: string | null;
    /** Дата создания карты */
    date?: Date | null;
    /** Дата закрытия карты */
    dateClose?: Date | null;
    /** Врач бригады, принявшей вызов */
    dispatcherReceivedFK?: PerformerBean | null;
    /** Постоянная регистрация (Район) */
    district?: string | null;
    /** Постоянная регистрация (Квартира) */
    flatNum?: string | null;
    fullTimeInterval?: string | null;
    /** Постоянная регистрация (Номер дома) */
    houseNum?: string | null;
    id?: number | null;
    /** Согласие на мед.вмешательство */
    isConsentMedIntervention?: boolean | null;
    /** Отказ от транспортировки для госпитализации в стационар */
    isDeclineHospitalization?: boolean | null;
    /** Отказ от мед.вмешательства */
    isDeclineMedIntervention?: boolean | null;
    /** Номер карты */
    number?: string | null;
    /** Пациент */
    patientFK?: PatientBean | null;
    /** Социальное положение пациента */
    patientSocialStatusFK?: ReferenceTypeBean | null;
    /** Пациент из вызова */
    patientTemplateFK?: PatientTemplateBean | null;
    /** ID сотрудника, заполняющего карту */
    performerFK?: PerformerBean | null;
    /** Должность */
    post?: string | null;
    receivingTimeExceed?: boolean | null;
    /** Постоянная регистрация (Регион) */
    region?: string | null;
    /** Тип результа выезда */
    resultTypeFK?: ReferenceTypeBean | null;
    shiftSeniorDoctorComment?: string | null;
    /** Главный врач смены */
    shiftSeniorDoctorFK?: PerformerBean | null;
    shiftSeniorDoctorIsChecked?: boolean | null;
    /** Постоянная регистрация (Улица) */
    street?: string | null;
    /** ID подразделения */
    subdivisionFK?: SubdivisionBean | null;
    /** Постоянная регистрация (Населенный пункт) */
    town?: string | null;
    /** Место работы */
    workplace?: string | null;
}

export class ListContainerOfPerformerTypeBean implements IListContainerOfPerformerTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPerformerTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPerformerTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPerformerTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPerformerTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class WaresInBagBean implements IWaresInBagBean {
    /** ID укладки */
    bagId?: number | null;
    /** кол-во изделий */
    volume?: number | null;
    /** препарат */
    wareFK?: WareBean | null;
    /** ID изделия */
    wareId?: number | null;

    constructor(data?: IWaresInBagBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bagId = data["bagId"] !== undefined ? data["bagId"] : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.wareFK = data["wareFK"] ? WareBean.fromJS(data["wareFK"]) : <any>null;
            this.wareId = data["wareId"] !== undefined ? data["wareId"] : <any>null;
        }
    }

    static fromJS(data: any): WaresInBagBean {
        data = typeof data === 'object' ? data : {};
        let result = new WaresInBagBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bagId"] = this.bagId !== undefined ? this.bagId : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["wareFK"] = this.wareFK ? this.wareFK.toJSON() : <any>null;
        data["wareId"] = this.wareId !== undefined ? this.wareId : <any>null;
        return data; 
    }
}

export interface IWaresInBagBean {
    /** ID укладки */
    bagId?: number | null;
    /** кол-во изделий */
    volume?: number | null;
    /** препарат */
    wareFK?: WareBean | null;
    /** ID изделия */
    wareId?: number | null;
}

export class DrugBean implements IDrugBean {
    /** Примечание */
    additionally?: string | null;
    /** Количество лекарств в упаковке */
    amount?: number | null;
    /** Категория */
    categoryFK?: DrugCategoryBean | null;
    code?: string | null;
    /** Тип упаковки(минимальная единица, списываемая со склада) */
    containerTypeFK?: UnitBean | null;
    /** Группа */
    groupFK?: DrugGroupBean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Единица измерения лекарства в упаковке */
    measurementFK?: UnitBean | null;
    name?: string | null;

    constructor(data?: IDrugBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionally = data["additionally"] !== undefined ? data["additionally"] : <any>null;
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.categoryFK = data["categoryFK"] ? DrugCategoryBean.fromJS(data["categoryFK"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.containerTypeFK = data["containerTypeFK"] ? UnitBean.fromJS(data["containerTypeFK"]) : <any>null;
            this.groupFK = data["groupFK"] ? DrugGroupBean.fromJS(data["groupFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.measurementFK = data["measurementFK"] ? UnitBean.fromJS(data["measurementFK"]) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DrugBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionally"] = this.additionally !== undefined ? this.additionally : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["categoryFK"] = this.categoryFK ? this.categoryFK.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["containerTypeFK"] = this.containerTypeFK ? this.containerTypeFK.toJSON() : <any>null;
        data["groupFK"] = this.groupFK ? this.groupFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["measurementFK"] = this.measurementFK ? this.measurementFK.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDrugBean {
    /** Примечание */
    additionally?: string | null;
    /** Количество лекарств в упаковке */
    amount?: number | null;
    /** Категория */
    categoryFK?: DrugCategoryBean | null;
    code?: string | null;
    /** Тип упаковки(минимальная единица, списываемая со склада) */
    containerTypeFK?: UnitBean | null;
    /** Группа */
    groupFK?: DrugGroupBean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Единица измерения лекарства в упаковке */
    measurementFK?: UnitBean | null;
    name?: string | null;
}

export class ListContainerOfPharmacyGroupBean implements IListContainerOfPharmacyGroupBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPharmacyGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPharmacyGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPharmacyGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPharmacyGroupBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class DrugFormBean implements IDrugFormBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** форма */
    name?: string | null;

    constructor(data?: IDrugFormBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DrugFormBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugFormBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDrugFormBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** форма */
    name?: string | null;
}

export class AndyTreeNode implements IAndyTreeNode {
    children?: AndyTreeNode[] | null;
    data?: any | null;

    constructor(data?: IAndyTreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(AndyTreeNode.fromJS(item));
            }
            this.data = data["data"] !== undefined ? data["data"] : <any>null;
        }
    }

    static fromJS(data: any): AndyTreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new AndyTreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["data"] = this.data !== undefined ? this.data : <any>null;
        return data; 
    }
}

export interface IAndyTreeNode {
    children?: AndyTreeNode[] | null;
    data?: any | null;
}

export class UkioPatientBean implements IUkioPatientBean {
    /** Способность пострадавшего лица самостоятельно передвигаться */
    ableToMove?: string | null;
    /** Возраст пострадавшего лица */
    age?: number | null;
    /** Дата рождения пострадавшего лица */
    birthDate?: string | null;
    /** Причина обращения пострадавшего лица */
    callReason?: string | null;
    /** пол пациента */
    gender?: number | null;
    /** ID */
    id?: number | null;
    /** имя пациента */
    name?: string | null;
    /** имя пациента */
    secondName?: string | null;
    /** фамилия пациента */
    surname?: string | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;

    constructor(data?: IUkioPatientBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ableToMove = data["ableToMove"] !== undefined ? data["ableToMove"] : <any>null;
            this.age = data["age"] !== undefined ? data["age"] : <any>null;
            this.birthDate = data["birthDate"] !== undefined ? data["birthDate"] : <any>null;
            this.callReason = data["callReason"] !== undefined ? data["callReason"] : <any>null;
            this.gender = data["gender"] !== undefined ? data["gender"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.secondName = data["secondName"] !== undefined ? data["secondName"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
            this.ukioMessageId = data["ukioMessageId"] !== undefined ? data["ukioMessageId"] : <any>null;
        }
    }

    static fromJS(data: any): UkioPatientBean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioPatientBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ableToMove"] = this.ableToMove !== undefined ? this.ableToMove : <any>null;
        data["age"] = this.age !== undefined ? this.age : <any>null;
        data["birthDate"] = this.birthDate !== undefined ? this.birthDate : <any>null;
        data["callReason"] = this.callReason !== undefined ? this.callReason : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["secondName"] = this.secondName !== undefined ? this.secondName : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        data["ukioMessageId"] = this.ukioMessageId !== undefined ? this.ukioMessageId : <any>null;
        return data; 
    }
}

export interface IUkioPatientBean {
    /** Способность пострадавшего лица самостоятельно передвигаться */
    ableToMove?: string | null;
    /** Возраст пострадавшего лица */
    age?: number | null;
    /** Дата рождения пострадавшего лица */
    birthDate?: string | null;
    /** Причина обращения пострадавшего лица */
    callReason?: string | null;
    /** пол пациента */
    gender?: number | null;
    /** ID */
    id?: number | null;
    /** имя пациента */
    name?: string | null;
    /** имя пациента */
    secondName?: string | null;
    /** фамилия пациента */
    surname?: string | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;
}

export class ListContainerOfTransportType implements IListContainerOfTransportType {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTransportType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTransportType {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTransportType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTransportType {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class EraInfoBean implements IEraInfoBean {
    /** Признак того, что терминал «ЭРА ГЛОНАСС» сработал автоматически */
    autoSignal?: boolean | null;
    /** Время события «ЭРА-ГОЛНАСС» в формате UTC */
    callTimestamp?: string | null;
    /** Язык общения с заявителем
Код языка.
 */
    declarantLanguageCode?: string | null;
    /** Направление движения ТС от направления на северный магнитный полюс по часовой стрелке, с шагом 2° (от 0 до 179) */
    direction?: number | null;
    /** ФИО заявителя */
    driverFullName?: string | null;
    /** Контактный телефонный номер заявителя */
    driverPhone?: string | null;
    /** Признак удара спереди */
    frontCrash?: boolean | null;
    /** ID */
    id?: number | null;
    /** Количество пострадавших в ТС
1 – не известно,
0 – нет пострадавших,
127 – пострадавшие есть, но точное число неизвестно,
1..126 – точное число пострадавших
 */
    injuredPersons?: number | null;
    /** Краткий ссылочный идентификатор (КСИ) карточки вызова «ЭРА  ГЛОНАСС» */
    ksi?: string | null;
    /** Широта местоположения ТС (в угловых миллисекундах от -324000000 до 324000000) */
    latitude?: number | null;
    /** Координаты недавнего местоположения №1: широта */
    latitude1?: number | null;
    /** Координаты недавнего местоположения №2: широта */
    latitude2?: number | null;
    /** Признак удара слева */
    leftCrash?: boolean | null;
    /** «Флаг», указывающий достоверность данных о местоположении */
    locationInfoCorrect?: boolean | null;
    /** Долгота местоположения ТС (в угловых миллисекундах от -648000000 до 648000000) */
    longitude?: number | null;
    /** Координаты недавнего местоположения №1: долгота */
    longtitude1?: number | null;
    /** Координаты недавнего местоположения №2: долгота */
    longtitude2?: number | null;
    /** Признак иного типа удара */
    otherCrashType?: boolean | null;
    /** Число пассажиров в ТС (от 0 до 255) */
    passengerCount?: number | null;
    /** «Флаг» наличия пострадавших, требующих первой помощи */
    peopleInjured?: boolean | null;
    /** Низкая или высокая достоверность определения предыдущего местоположения ТС */
    positionCanBeTrusted1?: boolean | null;
    /** Низкая или высокая достоверность определения предыдущего местоположения ТС */
    positionCanBeTrusted2?: boolean | null;
    /** Признак удара сзади */
    rearCrash?: boolean | null;
    /** Признак удара справа */
    rightCrash?: boolean | null;
    /** Признак переворота */
    rollover?: boolean | null;
    /** Оценка тяжести ДТП (0 = низкая вероятность ущерба здоровью людей, 10 = максимальная вероятность...) */
    severeCrashEstimate?: number | null;
    /** Признак удара сбоку */
    sideCrash?: boolean | null;
    /** Телефонный номер АС
Строка длиной от 1 до 18 символов, состоящая из цифр, может быть символ плюс (+) на первой позиции в строке
 */
    terminalPhone?: string | null;
    /** Тип вызова (экстренный/
тестовый)
 */
    testSignal?: boolean | null;
    /** Момент определения местоположения (Время в UTC) */
    timestamp?: string | null;
    /** Момент определения предыдущего местоположения (UTC).
Время в UTC.
 */
    timestamp1?: string | null;
    /** Момент определения предыдущего местоположения (UTC).
Время в UTC.
 */
    timestamp2?: string | null;
    /** «Флаг» наличия голосового соединения с ТС */
    transferCall?: boolean | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;
    /** Уникальный ссылочный идентификатор (УСИ) карточки вызова «ЭРА ГЛОНАСС» */
    usi?: string | null;
    /** Цвет кузова ТС (от 0 до 32 символов) */
    vehicleBodyColor?: string | null;
    /** Адресная информация о местоположении ТС в текстовом виде */
    vehicleLocationDescription?: string | null;
    /** Марка и/или модель ТС (от 0 до 32 символов) */
    vehicleModel?: string | null;
    /** Тип энергоносителя ТС (число от 0 до 63 - битовая маска)
Возможные значения:
Bit 5: 1 = водород
Bit 4: 1 = электричество (более 42 В и 100 А/)
Bit 3: 1 = жидкий пропан (LPG)
Bit 2: 1 = сжиженный природный газ (CNG)
Bit 1: 1 = дизель
Bit 0: 1 = бензин
 */
    vehiclePropulsionStorageType?: number | null;
    /** Государственный регистрационный номер ТС (от 0 до 16 символов) */
    vehicleRegistryNumber?: string | null;
    /** Состояние голосового канала и его характеристика.
Справочник, одно из значений:
«unknown»
«none»
«duplex»
«simplex»
 */
    vehicleType?: number | null;
    /** Идентификатор ТС по ISO 3779 */
    vin?: string | null;
    /** Состояние голосового канала и его характеристика.
Справочник, одно из значений:
«unknown»
«none»
«duplex»
«simplex»
 */
    voiceChannelState?: string | null;

    constructor(data?: IEraInfoBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoSignal = data["autoSignal"] !== undefined ? data["autoSignal"] : <any>null;
            this.callTimestamp = data["callTimestamp"] !== undefined ? data["callTimestamp"] : <any>null;
            this.declarantLanguageCode = data["declarantLanguageCode"] !== undefined ? data["declarantLanguageCode"] : <any>null;
            this.direction = data["direction"] !== undefined ? data["direction"] : <any>null;
            this.driverFullName = data["driverFullName"] !== undefined ? data["driverFullName"] : <any>null;
            this.driverPhone = data["driverPhone"] !== undefined ? data["driverPhone"] : <any>null;
            this.frontCrash = data["frontCrash"] !== undefined ? data["frontCrash"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.injuredPersons = data["injuredPersons"] !== undefined ? data["injuredPersons"] : <any>null;
            this.ksi = data["ksi"] !== undefined ? data["ksi"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.latitude1 = data["latitude1"] !== undefined ? data["latitude1"] : <any>null;
            this.latitude2 = data["latitude2"] !== undefined ? data["latitude2"] : <any>null;
            this.leftCrash = data["leftCrash"] !== undefined ? data["leftCrash"] : <any>null;
            this.locationInfoCorrect = data["locationInfoCorrect"] !== undefined ? data["locationInfoCorrect"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.longtitude1 = data["longtitude1"] !== undefined ? data["longtitude1"] : <any>null;
            this.longtitude2 = data["longtitude2"] !== undefined ? data["longtitude2"] : <any>null;
            this.otherCrashType = data["otherCrashType"] !== undefined ? data["otherCrashType"] : <any>null;
            this.passengerCount = data["passengerCount"] !== undefined ? data["passengerCount"] : <any>null;
            this.peopleInjured = data["peopleInjured"] !== undefined ? data["peopleInjured"] : <any>null;
            this.positionCanBeTrusted1 = data["positionCanBeTrusted1"] !== undefined ? data["positionCanBeTrusted1"] : <any>null;
            this.positionCanBeTrusted2 = data["positionCanBeTrusted2"] !== undefined ? data["positionCanBeTrusted2"] : <any>null;
            this.rearCrash = data["rearCrash"] !== undefined ? data["rearCrash"] : <any>null;
            this.rightCrash = data["rightCrash"] !== undefined ? data["rightCrash"] : <any>null;
            this.rollover = data["rollover"] !== undefined ? data["rollover"] : <any>null;
            this.severeCrashEstimate = data["severeCrashEstimate"] !== undefined ? data["severeCrashEstimate"] : <any>null;
            this.sideCrash = data["sideCrash"] !== undefined ? data["sideCrash"] : <any>null;
            this.terminalPhone = data["terminalPhone"] !== undefined ? data["terminalPhone"] : <any>null;
            this.testSignal = data["testSignal"] !== undefined ? data["testSignal"] : <any>null;
            this.timestamp = data["timestamp"] !== undefined ? data["timestamp"] : <any>null;
            this.timestamp1 = data["timestamp1"] !== undefined ? data["timestamp1"] : <any>null;
            this.timestamp2 = data["timestamp2"] !== undefined ? data["timestamp2"] : <any>null;
            this.transferCall = data["transferCall"] !== undefined ? data["transferCall"] : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
            this.ukioMessageId = data["ukioMessageId"] !== undefined ? data["ukioMessageId"] : <any>null;
            this.usi = data["usi"] !== undefined ? data["usi"] : <any>null;
            this.vehicleBodyColor = data["vehicleBodyColor"] !== undefined ? data["vehicleBodyColor"] : <any>null;
            this.vehicleLocationDescription = data["vehicleLocationDescription"] !== undefined ? data["vehicleLocationDescription"] : <any>null;
            this.vehicleModel = data["vehicleModel"] !== undefined ? data["vehicleModel"] : <any>null;
            this.vehiclePropulsionStorageType = data["vehiclePropulsionStorageType"] !== undefined ? data["vehiclePropulsionStorageType"] : <any>null;
            this.vehicleRegistryNumber = data["vehicleRegistryNumber"] !== undefined ? data["vehicleRegistryNumber"] : <any>null;
            this.vehicleType = data["vehicleType"] !== undefined ? data["vehicleType"] : <any>null;
            this.vin = data["vin"] !== undefined ? data["vin"] : <any>null;
            this.voiceChannelState = data["voiceChannelState"] !== undefined ? data["voiceChannelState"] : <any>null;
        }
    }

    static fromJS(data: any): EraInfoBean {
        data = typeof data === 'object' ? data : {};
        let result = new EraInfoBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoSignal"] = this.autoSignal !== undefined ? this.autoSignal : <any>null;
        data["callTimestamp"] = this.callTimestamp !== undefined ? this.callTimestamp : <any>null;
        data["declarantLanguageCode"] = this.declarantLanguageCode !== undefined ? this.declarantLanguageCode : <any>null;
        data["direction"] = this.direction !== undefined ? this.direction : <any>null;
        data["driverFullName"] = this.driverFullName !== undefined ? this.driverFullName : <any>null;
        data["driverPhone"] = this.driverPhone !== undefined ? this.driverPhone : <any>null;
        data["frontCrash"] = this.frontCrash !== undefined ? this.frontCrash : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["injuredPersons"] = this.injuredPersons !== undefined ? this.injuredPersons : <any>null;
        data["ksi"] = this.ksi !== undefined ? this.ksi : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["latitude1"] = this.latitude1 !== undefined ? this.latitude1 : <any>null;
        data["latitude2"] = this.latitude2 !== undefined ? this.latitude2 : <any>null;
        data["leftCrash"] = this.leftCrash !== undefined ? this.leftCrash : <any>null;
        data["locationInfoCorrect"] = this.locationInfoCorrect !== undefined ? this.locationInfoCorrect : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["longtitude1"] = this.longtitude1 !== undefined ? this.longtitude1 : <any>null;
        data["longtitude2"] = this.longtitude2 !== undefined ? this.longtitude2 : <any>null;
        data["otherCrashType"] = this.otherCrashType !== undefined ? this.otherCrashType : <any>null;
        data["passengerCount"] = this.passengerCount !== undefined ? this.passengerCount : <any>null;
        data["peopleInjured"] = this.peopleInjured !== undefined ? this.peopleInjured : <any>null;
        data["positionCanBeTrusted1"] = this.positionCanBeTrusted1 !== undefined ? this.positionCanBeTrusted1 : <any>null;
        data["positionCanBeTrusted2"] = this.positionCanBeTrusted2 !== undefined ? this.positionCanBeTrusted2 : <any>null;
        data["rearCrash"] = this.rearCrash !== undefined ? this.rearCrash : <any>null;
        data["rightCrash"] = this.rightCrash !== undefined ? this.rightCrash : <any>null;
        data["rollover"] = this.rollover !== undefined ? this.rollover : <any>null;
        data["severeCrashEstimate"] = this.severeCrashEstimate !== undefined ? this.severeCrashEstimate : <any>null;
        data["sideCrash"] = this.sideCrash !== undefined ? this.sideCrash : <any>null;
        data["terminalPhone"] = this.terminalPhone !== undefined ? this.terminalPhone : <any>null;
        data["testSignal"] = this.testSignal !== undefined ? this.testSignal : <any>null;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : <any>null;
        data["timestamp1"] = this.timestamp1 !== undefined ? this.timestamp1 : <any>null;
        data["timestamp2"] = this.timestamp2 !== undefined ? this.timestamp2 : <any>null;
        data["transferCall"] = this.transferCall !== undefined ? this.transferCall : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        data["ukioMessageId"] = this.ukioMessageId !== undefined ? this.ukioMessageId : <any>null;
        data["usi"] = this.usi !== undefined ? this.usi : <any>null;
        data["vehicleBodyColor"] = this.vehicleBodyColor !== undefined ? this.vehicleBodyColor : <any>null;
        data["vehicleLocationDescription"] = this.vehicleLocationDescription !== undefined ? this.vehicleLocationDescription : <any>null;
        data["vehicleModel"] = this.vehicleModel !== undefined ? this.vehicleModel : <any>null;
        data["vehiclePropulsionStorageType"] = this.vehiclePropulsionStorageType !== undefined ? this.vehiclePropulsionStorageType : <any>null;
        data["vehicleRegistryNumber"] = this.vehicleRegistryNumber !== undefined ? this.vehicleRegistryNumber : <any>null;
        data["vehicleType"] = this.vehicleType !== undefined ? this.vehicleType : <any>null;
        data["vin"] = this.vin !== undefined ? this.vin : <any>null;
        data["voiceChannelState"] = this.voiceChannelState !== undefined ? this.voiceChannelState : <any>null;
        return data; 
    }
}

export interface IEraInfoBean {
    /** Признак того, что терминал «ЭРА ГЛОНАСС» сработал автоматически */
    autoSignal?: boolean | null;
    /** Время события «ЭРА-ГОЛНАСС» в формате UTC */
    callTimestamp?: string | null;
    /** Язык общения с заявителем
Код языка.
 */
    declarantLanguageCode?: string | null;
    /** Направление движения ТС от направления на северный магнитный полюс по часовой стрелке, с шагом 2° (от 0 до 179) */
    direction?: number | null;
    /** ФИО заявителя */
    driverFullName?: string | null;
    /** Контактный телефонный номер заявителя */
    driverPhone?: string | null;
    /** Признак удара спереди */
    frontCrash?: boolean | null;
    /** ID */
    id?: number | null;
    /** Количество пострадавших в ТС
1 – не известно,
0 – нет пострадавших,
127 – пострадавшие есть, но точное число неизвестно,
1..126 – точное число пострадавших
 */
    injuredPersons?: number | null;
    /** Краткий ссылочный идентификатор (КСИ) карточки вызова «ЭРА  ГЛОНАСС» */
    ksi?: string | null;
    /** Широта местоположения ТС (в угловых миллисекундах от -324000000 до 324000000) */
    latitude?: number | null;
    /** Координаты недавнего местоположения №1: широта */
    latitude1?: number | null;
    /** Координаты недавнего местоположения №2: широта */
    latitude2?: number | null;
    /** Признак удара слева */
    leftCrash?: boolean | null;
    /** «Флаг», указывающий достоверность данных о местоположении */
    locationInfoCorrect?: boolean | null;
    /** Долгота местоположения ТС (в угловых миллисекундах от -648000000 до 648000000) */
    longitude?: number | null;
    /** Координаты недавнего местоположения №1: долгота */
    longtitude1?: number | null;
    /** Координаты недавнего местоположения №2: долгота */
    longtitude2?: number | null;
    /** Признак иного типа удара */
    otherCrashType?: boolean | null;
    /** Число пассажиров в ТС (от 0 до 255) */
    passengerCount?: number | null;
    /** «Флаг» наличия пострадавших, требующих первой помощи */
    peopleInjured?: boolean | null;
    /** Низкая или высокая достоверность определения предыдущего местоположения ТС */
    positionCanBeTrusted1?: boolean | null;
    /** Низкая или высокая достоверность определения предыдущего местоположения ТС */
    positionCanBeTrusted2?: boolean | null;
    /** Признак удара сзади */
    rearCrash?: boolean | null;
    /** Признак удара справа */
    rightCrash?: boolean | null;
    /** Признак переворота */
    rollover?: boolean | null;
    /** Оценка тяжести ДТП (0 = низкая вероятность ущерба здоровью людей, 10 = максимальная вероятность...) */
    severeCrashEstimate?: number | null;
    /** Признак удара сбоку */
    sideCrash?: boolean | null;
    /** Телефонный номер АС
Строка длиной от 1 до 18 символов, состоящая из цифр, может быть символ плюс (+) на первой позиции в строке
 */
    terminalPhone?: string | null;
    /** Тип вызова (экстренный/
тестовый)
 */
    testSignal?: boolean | null;
    /** Момент определения местоположения (Время в UTC) */
    timestamp?: string | null;
    /** Момент определения предыдущего местоположения (UTC).
Время в UTC.
 */
    timestamp1?: string | null;
    /** Момент определения предыдущего местоположения (UTC).
Время в UTC.
 */
    timestamp2?: string | null;
    /** «Флаг» наличия голосового соединения с ТС */
    transferCall?: boolean | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;
    /** Уникальный ссылочный идентификатор (УСИ) карточки вызова «ЭРА ГЛОНАСС» */
    usi?: string | null;
    /** Цвет кузова ТС (от 0 до 32 символов) */
    vehicleBodyColor?: string | null;
    /** Адресная информация о местоположении ТС в текстовом виде */
    vehicleLocationDescription?: string | null;
    /** Марка и/или модель ТС (от 0 до 32 символов) */
    vehicleModel?: string | null;
    /** Тип энергоносителя ТС (число от 0 до 63 - битовая маска)
Возможные значения:
Bit 5: 1 = водород
Bit 4: 1 = электричество (более 42 В и 100 А/)
Bit 3: 1 = жидкий пропан (LPG)
Bit 2: 1 = сжиженный природный газ (CNG)
Bit 1: 1 = дизель
Bit 0: 1 = бензин
 */
    vehiclePropulsionStorageType?: number | null;
    /** Государственный регистрационный номер ТС (от 0 до 16 символов) */
    vehicleRegistryNumber?: string | null;
    /** Состояние голосового канала и его характеристика.
Справочник, одно из значений:
«unknown»
«none»
«duplex»
«simplex»
 */
    vehicleType?: number | null;
    /** Идентификатор ТС по ISO 3779 */
    vin?: string | null;
    /** Состояние голосового канала и его характеристика.
Справочник, одно из значений:
«unknown»
«none»
«duplex»
«simplex»
 */
    voiceChannelState?: string | null;
}

export class BagDrugBean implements IBagDrugBean {
    counter?: number | null;
    drugFK?: DrugBean | null;
    id?: number | null;
    isDeleted?: boolean | null;

    constructor(data?: IBagDrugBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.counter = data["counter"] !== undefined ? data["counter"] : <any>null;
            this.drugFK = data["drugFK"] ? DrugBean.fromJS(data["drugFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
        }
    }

    static fromJS(data: any): BagDrugBean {
        data = typeof data === 'object' ? data : {};
        let result = new BagDrugBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counter"] = this.counter !== undefined ? this.counter : <any>null;
        data["drugFK"] = this.drugFK ? this.drugFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        return data; 
    }
}

export interface IBagDrugBean {
    counter?: number | null;
    drugFK?: DrugBean | null;
    id?: number | null;
    isDeleted?: boolean | null;
}

export class PairOfPerformerBeanAndListOfMapOfstringAndobject implements IPairOfPerformerBeanAndListOfMapOfstringAndobject {
    first?: PerformerBean | null;
    second?: { [key: string] : any; }[] | null;

    constructor(data?: IPairOfPerformerBeanAndListOfMapOfstringAndobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? PerformerBean.fromJS(data["first"]) : <any>null;
            if (data["second"] && data["second"].constructor === Array) {
                this.second = [];
                for (let item of data["second"])
                    this.second.push(item);
            }
        }
    }

    static fromJS(data: any): PairOfPerformerBeanAndListOfMapOfstringAndobject {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfPerformerBeanAndListOfMapOfstringAndobject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        if (this.second && this.second.constructor === Array) {
            data["second"] = [];
            for (let item of this.second)
                data["second"].push(item);
        }
        return data; 
    }
}

export interface IPairOfPerformerBeanAndListOfMapOfstringAndobject {
    first?: PerformerBean | null;
    second?: { [key: string] : any; }[] | null;
}

export class ListContainerOfPerformerBean implements IListContainerOfPerformerBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPerformerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPerformerBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPerformerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPerformerBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardResultBean implements ICardResultBean {
    /** Время визита */
    activeVisitDate?: Date | null;
    /** Визит */
    activeVisitFK?: ReferenceTypeBean | null;
    /** Продолжительность визита */
    activeVisitHours?: number | null;
    /** Id результата помощи */
    assistanceResultId?: number | null;
    /** Задержка бригады */
    brigadeDelay?: boolean | null;
    /** Задержка бригады: комментарий */
    brigadeDelayText?: string | null;
    /** Тип задержки бригады */
    brigadeDelayType?: number | null;
    /** Комментарии */
    comments?: string | null;
    /** Осложнения */
    complicationFK?: ReferenceTypeBean | null;
    /** Результат помощи при осложнении */
    complicationHelpFK?: ReferenceTypeBean | null;
    /** Сопутствующий диагноз */
    concomitantDiagnosisFK?: ClassMkbBean | null;
    /** Время смерти */
    deathTime?: Date | null;
    /** Задержка бригады */
    delayFK?: ReferenceTypeBean | null;
    /** ЭКГ: ЧСС */
    ekgChSS?: number | null;
    /** ЭКГ: ЧСС после оказания МП */
    ekgChSSAfter?: number | null;
    /** ЭКГ: комментарий */
    ekgComments?: string | null;
    /** ЭКГ: комментарий после оказания МП */
    ekgCommentsAfter?: string | null;
    /** ЭКГ: ритм */
    ekgRhytm?: string | null;
    /** ЭКГ: ритм после оказания МП */
    ekgRhytmAfter?: string | null;
    /** Признак оказания помощи в городи */
    helpInCity?: boolean | null;
    /** Осложнения при госпитализации */
    hospComplications?: boolean | null;
    /** Осложнения при госпитализации: комментарий */
    hospComplicationsText?: string | null;
    /** Больница отправления */
    hospFromFK?: SubdivisionBean | null;
    /** Больница прибытия */
    hospToFK?: SubdivisionBean | null;
    id?: number | null;
    /** Инцидент */
    incidentFK?: ReferenceTypeBean | null;
    /** Id инцидента */
    incidentId?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Артериальное давление на месте */
    localAd?: string | null;
    /** Частота дыхания на месте */
    localChd?: string | null;
    /** ЧСС на месте */
    localChss?: string | null;
    /** Глюкометрия на месте */
    localGlucometry?: string | null;
    /** Пульс на месте */
    localPulse?: string | null;
    /** ПульсOXXXYметрия на месте */
    localPulseOximetry?: string | null;
    /** Температура на месте */
    localTemperature?: string | null;
    /** Рабочее артериальное давление на месте */
    localWorkAd?: string | null;
    /** Id основного диагноза */
    mainDiagnosisId?: number | null;
    /** Классификация МКБ */
    mkbFK?: ClassMkbBean | null;
    /** Причина результата */
    resultCauseFK?: ReferenceTypeBean | null;
    /** Список терапий , привязанных к карте */
    therapyList?: TherapyBean[] | null;
    /** Бригада трансфера пациента */
    transferPatientBrigade?: string | null;
    /** Дата трансфера пациента */
    transferPatientDate?: Date | null;
    /** Артериальное давление при транспортировке */
    transportAd?: string | null;
    /** Частота дыхания при транспортировке */
    transportChd?: string | null;
    /** ЧСС при транспортировке */
    transportChss?: string | null;
    /** Глюкометрия при транспортировке */
    transportGlucometry?: string | null;
    /** Оксиметрия пульса при транспортировке */
    transportOximetry?: string | null;
    /** Пульс при транспортировке */
    transportPulse?: string | null;
    /** Температура при транспортировке */
    transportTemperature?: string | null;
    /** Рабочее артериальное давление при транспортировке */
    transportWorkAd?: string | null;
    /** Транспортировка */
    transportationFK?: ReferenceTypeBean | null;
    /** Метод транспортировки */
    transportationMethodFK?: ReferenceTypeBean | null;
    /** Дата транспортировки */
    transportingDate?: Date | null;

    constructor(data?: ICardResultBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activeVisitDate = data["activeVisitDate"] ? new Date(data["activeVisitDate"].toString()) : <any>null;
            this.activeVisitFK = data["activeVisitFK"] ? ReferenceTypeBean.fromJS(data["activeVisitFK"]) : <any>null;
            this.activeVisitHours = data["activeVisitHours"] !== undefined ? data["activeVisitHours"] : <any>null;
            this.assistanceResultId = data["assistanceResultId"] !== undefined ? data["assistanceResultId"] : <any>null;
            this.brigadeDelay = data["brigadeDelay"] !== undefined ? data["brigadeDelay"] : <any>null;
            this.brigadeDelayText = data["brigadeDelayText"] !== undefined ? data["brigadeDelayText"] : <any>null;
            this.brigadeDelayType = data["brigadeDelayType"] !== undefined ? data["brigadeDelayType"] : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.complicationFK = data["complicationFK"] ? ReferenceTypeBean.fromJS(data["complicationFK"]) : <any>null;
            this.complicationHelpFK = data["complicationHelpFK"] ? ReferenceTypeBean.fromJS(data["complicationHelpFK"]) : <any>null;
            this.concomitantDiagnosisFK = data["concomitantDiagnosisFK"] ? ClassMkbBean.fromJS(data["concomitantDiagnosisFK"]) : <any>null;
            this.deathTime = data["deathTime"] ? new Date(data["deathTime"].toString()) : <any>null;
            this.delayFK = data["delayFK"] ? ReferenceTypeBean.fromJS(data["delayFK"]) : <any>null;
            this.ekgChSS = data["ekgChSS"] !== undefined ? data["ekgChSS"] : <any>null;
            this.ekgChSSAfter = data["ekgChSSAfter"] !== undefined ? data["ekgChSSAfter"] : <any>null;
            this.ekgComments = data["ekgComments"] !== undefined ? data["ekgComments"] : <any>null;
            this.ekgCommentsAfter = data["ekgCommentsAfter"] !== undefined ? data["ekgCommentsAfter"] : <any>null;
            this.ekgRhytm = data["ekgRhytm"] !== undefined ? data["ekgRhytm"] : <any>null;
            this.ekgRhytmAfter = data["ekgRhytmAfter"] !== undefined ? data["ekgRhytmAfter"] : <any>null;
            this.helpInCity = data["helpInCity"] !== undefined ? data["helpInCity"] : <any>null;
            this.hospComplications = data["hospComplications"] !== undefined ? data["hospComplications"] : <any>null;
            this.hospComplicationsText = data["hospComplicationsText"] !== undefined ? data["hospComplicationsText"] : <any>null;
            this.hospFromFK = data["hospFromFK"] ? SubdivisionBean.fromJS(data["hospFromFK"]) : <any>null;
            this.hospToFK = data["hospToFK"] ? SubdivisionBean.fromJS(data["hospToFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.incidentFK = data["incidentFK"] ? ReferenceTypeBean.fromJS(data["incidentFK"]) : <any>null;
            this.incidentId = data["incidentId"] !== undefined ? data["incidentId"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.localAd = data["localAd"] !== undefined ? data["localAd"] : <any>null;
            this.localChd = data["localChd"] !== undefined ? data["localChd"] : <any>null;
            this.localChss = data["localChss"] !== undefined ? data["localChss"] : <any>null;
            this.localGlucometry = data["localGlucometry"] !== undefined ? data["localGlucometry"] : <any>null;
            this.localPulse = data["localPulse"] !== undefined ? data["localPulse"] : <any>null;
            this.localPulseOximetry = data["localPulseOximetry"] !== undefined ? data["localPulseOximetry"] : <any>null;
            this.localTemperature = data["localTemperature"] !== undefined ? data["localTemperature"] : <any>null;
            this.localWorkAd = data["localWorkAd"] !== undefined ? data["localWorkAd"] : <any>null;
            this.mainDiagnosisId = data["mainDiagnosisId"] !== undefined ? data["mainDiagnosisId"] : <any>null;
            this.mkbFK = data["mkbFK"] ? ClassMkbBean.fromJS(data["mkbFK"]) : <any>null;
            this.resultCauseFK = data["resultCauseFK"] ? ReferenceTypeBean.fromJS(data["resultCauseFK"]) : <any>null;
            if (data["therapyList"] && data["therapyList"].constructor === Array) {
                this.therapyList = [];
                for (let item of data["therapyList"])
                    this.therapyList.push(TherapyBean.fromJS(item));
            }
            this.transferPatientBrigade = data["transferPatientBrigade"] !== undefined ? data["transferPatientBrigade"] : <any>null;
            this.transferPatientDate = data["transferPatientDate"] ? new Date(data["transferPatientDate"].toString()) : <any>null;
            this.transportAd = data["transportAd"] !== undefined ? data["transportAd"] : <any>null;
            this.transportChd = data["transportChd"] !== undefined ? data["transportChd"] : <any>null;
            this.transportChss = data["transportChss"] !== undefined ? data["transportChss"] : <any>null;
            this.transportGlucometry = data["transportGlucometry"] !== undefined ? data["transportGlucometry"] : <any>null;
            this.transportOximetry = data["transportOximetry"] !== undefined ? data["transportOximetry"] : <any>null;
            this.transportPulse = data["transportPulse"] !== undefined ? data["transportPulse"] : <any>null;
            this.transportTemperature = data["transportTemperature"] !== undefined ? data["transportTemperature"] : <any>null;
            this.transportWorkAd = data["transportWorkAd"] !== undefined ? data["transportWorkAd"] : <any>null;
            this.transportationFK = data["transportationFK"] ? ReferenceTypeBean.fromJS(data["transportationFK"]) : <any>null;
            this.transportationMethodFK = data["transportationMethodFK"] ? ReferenceTypeBean.fromJS(data["transportationMethodFK"]) : <any>null;
            this.transportingDate = data["transportingDate"] ? new Date(data["transportingDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CardResultBean {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeVisitDate"] = this.activeVisitDate ? this.activeVisitDate.toISOString() : <any>null;
        data["activeVisitFK"] = this.activeVisitFK ? this.activeVisitFK.toJSON() : <any>null;
        data["activeVisitHours"] = this.activeVisitHours !== undefined ? this.activeVisitHours : <any>null;
        data["assistanceResultId"] = this.assistanceResultId !== undefined ? this.assistanceResultId : <any>null;
        data["brigadeDelay"] = this.brigadeDelay !== undefined ? this.brigadeDelay : <any>null;
        data["brigadeDelayText"] = this.brigadeDelayText !== undefined ? this.brigadeDelayText : <any>null;
        data["brigadeDelayType"] = this.brigadeDelayType !== undefined ? this.brigadeDelayType : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["complicationFK"] = this.complicationFK ? this.complicationFK.toJSON() : <any>null;
        data["complicationHelpFK"] = this.complicationHelpFK ? this.complicationHelpFK.toJSON() : <any>null;
        data["concomitantDiagnosisFK"] = this.concomitantDiagnosisFK ? this.concomitantDiagnosisFK.toJSON() : <any>null;
        data["deathTime"] = this.deathTime ? this.deathTime.toISOString() : <any>null;
        data["delayFK"] = this.delayFK ? this.delayFK.toJSON() : <any>null;
        data["ekgChSS"] = this.ekgChSS !== undefined ? this.ekgChSS : <any>null;
        data["ekgChSSAfter"] = this.ekgChSSAfter !== undefined ? this.ekgChSSAfter : <any>null;
        data["ekgComments"] = this.ekgComments !== undefined ? this.ekgComments : <any>null;
        data["ekgCommentsAfter"] = this.ekgCommentsAfter !== undefined ? this.ekgCommentsAfter : <any>null;
        data["ekgRhytm"] = this.ekgRhytm !== undefined ? this.ekgRhytm : <any>null;
        data["ekgRhytmAfter"] = this.ekgRhytmAfter !== undefined ? this.ekgRhytmAfter : <any>null;
        data["helpInCity"] = this.helpInCity !== undefined ? this.helpInCity : <any>null;
        data["hospComplications"] = this.hospComplications !== undefined ? this.hospComplications : <any>null;
        data["hospComplicationsText"] = this.hospComplicationsText !== undefined ? this.hospComplicationsText : <any>null;
        data["hospFromFK"] = this.hospFromFK ? this.hospFromFK.toJSON() : <any>null;
        data["hospToFK"] = this.hospToFK ? this.hospToFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["incidentFK"] = this.incidentFK ? this.incidentFK.toJSON() : <any>null;
        data["incidentId"] = this.incidentId !== undefined ? this.incidentId : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["localAd"] = this.localAd !== undefined ? this.localAd : <any>null;
        data["localChd"] = this.localChd !== undefined ? this.localChd : <any>null;
        data["localChss"] = this.localChss !== undefined ? this.localChss : <any>null;
        data["localGlucometry"] = this.localGlucometry !== undefined ? this.localGlucometry : <any>null;
        data["localPulse"] = this.localPulse !== undefined ? this.localPulse : <any>null;
        data["localPulseOximetry"] = this.localPulseOximetry !== undefined ? this.localPulseOximetry : <any>null;
        data["localTemperature"] = this.localTemperature !== undefined ? this.localTemperature : <any>null;
        data["localWorkAd"] = this.localWorkAd !== undefined ? this.localWorkAd : <any>null;
        data["mainDiagnosisId"] = this.mainDiagnosisId !== undefined ? this.mainDiagnosisId : <any>null;
        data["mkbFK"] = this.mkbFK ? this.mkbFK.toJSON() : <any>null;
        data["resultCauseFK"] = this.resultCauseFK ? this.resultCauseFK.toJSON() : <any>null;
        if (this.therapyList && this.therapyList.constructor === Array) {
            data["therapyList"] = [];
            for (let item of this.therapyList)
                data["therapyList"].push(item.toJSON());
        }
        data["transferPatientBrigade"] = this.transferPatientBrigade !== undefined ? this.transferPatientBrigade : <any>null;
        data["transferPatientDate"] = this.transferPatientDate ? this.transferPatientDate.toISOString() : <any>null;
        data["transportAd"] = this.transportAd !== undefined ? this.transportAd : <any>null;
        data["transportChd"] = this.transportChd !== undefined ? this.transportChd : <any>null;
        data["transportChss"] = this.transportChss !== undefined ? this.transportChss : <any>null;
        data["transportGlucometry"] = this.transportGlucometry !== undefined ? this.transportGlucometry : <any>null;
        data["transportOximetry"] = this.transportOximetry !== undefined ? this.transportOximetry : <any>null;
        data["transportPulse"] = this.transportPulse !== undefined ? this.transportPulse : <any>null;
        data["transportTemperature"] = this.transportTemperature !== undefined ? this.transportTemperature : <any>null;
        data["transportWorkAd"] = this.transportWorkAd !== undefined ? this.transportWorkAd : <any>null;
        data["transportationFK"] = this.transportationFK ? this.transportationFK.toJSON() : <any>null;
        data["transportationMethodFK"] = this.transportationMethodFK ? this.transportationMethodFK.toJSON() : <any>null;
        data["transportingDate"] = this.transportingDate ? this.transportingDate.toISOString() : <any>null;
        return data; 
    }
}

export interface ICardResultBean {
    /** Время визита */
    activeVisitDate?: Date | null;
    /** Визит */
    activeVisitFK?: ReferenceTypeBean | null;
    /** Продолжительность визита */
    activeVisitHours?: number | null;
    /** Id результата помощи */
    assistanceResultId?: number | null;
    /** Задержка бригады */
    brigadeDelay?: boolean | null;
    /** Задержка бригады: комментарий */
    brigadeDelayText?: string | null;
    /** Тип задержки бригады */
    brigadeDelayType?: number | null;
    /** Комментарии */
    comments?: string | null;
    /** Осложнения */
    complicationFK?: ReferenceTypeBean | null;
    /** Результат помощи при осложнении */
    complicationHelpFK?: ReferenceTypeBean | null;
    /** Сопутствующий диагноз */
    concomitantDiagnosisFK?: ClassMkbBean | null;
    /** Время смерти */
    deathTime?: Date | null;
    /** Задержка бригады */
    delayFK?: ReferenceTypeBean | null;
    /** ЭКГ: ЧСС */
    ekgChSS?: number | null;
    /** ЭКГ: ЧСС после оказания МП */
    ekgChSSAfter?: number | null;
    /** ЭКГ: комментарий */
    ekgComments?: string | null;
    /** ЭКГ: комментарий после оказания МП */
    ekgCommentsAfter?: string | null;
    /** ЭКГ: ритм */
    ekgRhytm?: string | null;
    /** ЭКГ: ритм после оказания МП */
    ekgRhytmAfter?: string | null;
    /** Признак оказания помощи в городи */
    helpInCity?: boolean | null;
    /** Осложнения при госпитализации */
    hospComplications?: boolean | null;
    /** Осложнения при госпитализации: комментарий */
    hospComplicationsText?: string | null;
    /** Больница отправления */
    hospFromFK?: SubdivisionBean | null;
    /** Больница прибытия */
    hospToFK?: SubdivisionBean | null;
    id?: number | null;
    /** Инцидент */
    incidentFK?: ReferenceTypeBean | null;
    /** Id инцидента */
    incidentId?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Артериальное давление на месте */
    localAd?: string | null;
    /** Частота дыхания на месте */
    localChd?: string | null;
    /** ЧСС на месте */
    localChss?: string | null;
    /** Глюкометрия на месте */
    localGlucometry?: string | null;
    /** Пульс на месте */
    localPulse?: string | null;
    /** ПульсOXXXYметрия на месте */
    localPulseOximetry?: string | null;
    /** Температура на месте */
    localTemperature?: string | null;
    /** Рабочее артериальное давление на месте */
    localWorkAd?: string | null;
    /** Id основного диагноза */
    mainDiagnosisId?: number | null;
    /** Классификация МКБ */
    mkbFK?: ClassMkbBean | null;
    /** Причина результата */
    resultCauseFK?: ReferenceTypeBean | null;
    /** Список терапий , привязанных к карте */
    therapyList?: TherapyBean[] | null;
    /** Бригада трансфера пациента */
    transferPatientBrigade?: string | null;
    /** Дата трансфера пациента */
    transferPatientDate?: Date | null;
    /** Артериальное давление при транспортировке */
    transportAd?: string | null;
    /** Частота дыхания при транспортировке */
    transportChd?: string | null;
    /** ЧСС при транспортировке */
    transportChss?: string | null;
    /** Глюкометрия при транспортировке */
    transportGlucometry?: string | null;
    /** Оксиметрия пульса при транспортировке */
    transportOximetry?: string | null;
    /** Пульс при транспортировке */
    transportPulse?: string | null;
    /** Температура при транспортировке */
    transportTemperature?: string | null;
    /** Рабочее артериальное давление при транспортировке */
    transportWorkAd?: string | null;
    /** Транспортировка */
    transportationFK?: ReferenceTypeBean | null;
    /** Метод транспортировки */
    transportationMethodFK?: ReferenceTypeBean | null;
    /** Дата транспортировки */
    transportingDate?: Date | null;
}

export class ListContainerOfUkioCardBean implements IListContainerOfUkioCardBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfUkioCardBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfUkioCardBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfUkioCardBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfUkioCardBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class Geometry implements IGeometry {
    dimension?: number | null;
    firstPoint?: any | null;
    haveMeasure?: boolean | null;
    lastPoint?: any | null;
    measured?: boolean | null;
    srid?: number | null;
    type?: number | null;
    typeString?: string | null;
    value?: string | null;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dimension = data["dimension"] !== undefined ? data["dimension"] : <any>null;
            this.firstPoint = data["firstPoint"] !== undefined ? data["firstPoint"] : <any>null;
            this.haveMeasure = data["haveMeasure"] !== undefined ? data["haveMeasure"] : <any>null;
            this.lastPoint = data["lastPoint"] !== undefined ? data["lastPoint"] : <any>null;
            this.measured = data["measured"] !== undefined ? data["measured"] : <any>null;
            this.srid = data["srid"] !== undefined ? data["srid"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeString = data["typeString"] !== undefined ? data["typeString"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension !== undefined ? this.dimension : <any>null;
        data["firstPoint"] = this.firstPoint !== undefined ? this.firstPoint : <any>null;
        data["haveMeasure"] = this.haveMeasure !== undefined ? this.haveMeasure : <any>null;
        data["lastPoint"] = this.lastPoint !== undefined ? this.lastPoint : <any>null;
        data["measured"] = this.measured !== undefined ? this.measured : <any>null;
        data["srid"] = this.srid !== undefined ? this.srid : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeString"] = this.typeString !== undefined ? this.typeString : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IGeometry {
    dimension?: number | null;
    firstPoint?: any | null;
    haveMeasure?: boolean | null;
    lastPoint?: any | null;
    measured?: boolean | null;
    srid?: number | null;
    type?: number | null;
    typeString?: string | null;
    value?: string | null;
}

export class UkioCardStatusBean implements IUkioCardStatusBean {
    /** Оператор системы 112, который зарегистрировал УКИО */
    actorInfo?: string | null;
    /** Основание (комментарий) для изменения статуса УКИО в ДДС */
    description?: string | null;
    /** ID */
    id?: number | null;
    /** Текстовое описание результата вызова. */
    message?: string | null;
    /** Результат вызова:
0 – информация принята;
> 0 – ошибка
 */
    response?: number | null;
    /** Статус карты в ТЦМК */
    status?: number | null;
    /** время отправки сообщения */
    time?: Date | null;
    /** Уникальный идентификатор УКИО в системе-112 */
    ukioCardId?: string | null;

    constructor(data?: IUkioCardStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actorInfo = data["actorInfo"] !== undefined ? data["actorInfo"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.message = data["message"] !== undefined ? data["message"] : <any>null;
            this.response = data["response"] !== undefined ? data["response"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
        }
    }

    static fromJS(data: any): UkioCardStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioCardStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorInfo"] = this.actorInfo !== undefined ? this.actorInfo : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["response"] = this.response !== undefined ? this.response : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        return data; 
    }
}

export interface IUkioCardStatusBean {
    /** Оператор системы 112, который зарегистрировал УКИО */
    actorInfo?: string | null;
    /** Основание (комментарий) для изменения статуса УКИО в ДДС */
    description?: string | null;
    /** ID */
    id?: number | null;
    /** Текстовое описание результата вызова. */
    message?: string | null;
    /** Результат вызова:
0 – информация принята;
> 0 – ошибка
 */
    response?: number | null;
    /** Статус карты в ТЦМК */
    status?: number | null;
    /** время отправки сообщения */
    time?: Date | null;
    /** Уникальный идентификатор УКИО в системе-112 */
    ukioCardId?: string | null;
}

export class PerformerContainer implements IPerformerContainer {
    brigadeBean?: BrigadeBean | null;
    brigadeSchedule?: BrigadeScheduleBean | null;
    callOperatorInfoBean?: CallOperatorInfoBean | null;
    clientIp?: string | null;
    performer?: PerformerBean | null;
    subordinateIds?: number[] | null;

    constructor(data?: IPerformerContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeBean = data["brigadeBean"] ? BrigadeBean.fromJS(data["brigadeBean"]) : <any>null;
            this.brigadeSchedule = data["brigadeSchedule"] ? BrigadeScheduleBean.fromJS(data["brigadeSchedule"]) : <any>null;
            this.callOperatorInfoBean = data["callOperatorInfoBean"] ? CallOperatorInfoBean.fromJS(data["callOperatorInfoBean"]) : <any>null;
            this.clientIp = data["clientIp"] !== undefined ? data["clientIp"] : <any>null;
            this.performer = data["performer"] ? PerformerBean.fromJS(data["performer"]) : <any>null;
            if (data["subordinateIds"] && data["subordinateIds"].constructor === Array) {
                this.subordinateIds = [];
                for (let item of data["subordinateIds"])
                    this.subordinateIds.push(item);
            }
        }
    }

    static fromJS(data: any): PerformerContainer {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeBean"] = this.brigadeBean ? this.brigadeBean.toJSON() : <any>null;
        data["brigadeSchedule"] = this.brigadeSchedule ? this.brigadeSchedule.toJSON() : <any>null;
        data["callOperatorInfoBean"] = this.callOperatorInfoBean ? this.callOperatorInfoBean.toJSON() : <any>null;
        data["clientIp"] = this.clientIp !== undefined ? this.clientIp : <any>null;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>null;
        if (this.subordinateIds && this.subordinateIds.constructor === Array) {
            data["subordinateIds"] = [];
            for (let item of this.subordinateIds)
                data["subordinateIds"].push(item);
        }
        return data; 
    }
}

export interface IPerformerContainer {
    brigadeBean?: BrigadeBean | null;
    brigadeSchedule?: BrigadeScheduleBean | null;
    callOperatorInfoBean?: CallOperatorInfoBean | null;
    clientIp?: string | null;
    performer?: PerformerBean | null;
    subordinateIds?: number[] | null;
}

export class DocumentBean implements IDocumentBean {
    /** Когда выдан документ */
    date?: Date | null;
    /** Описание документа */
    description?: string | null;
    /** ID */
    id?: number | null;
    isDeleted?: boolean | null;
    /** Номер документа */
    num?: string | null;
    /** Кем выдан документ */
    organization?: string | null;
    /** ID пациента */
    patient?: number | null;
    /** Серия документа */
    series?: string | null;
    /** Тип документа */
    typeFK?: DocumentTypeBean | null;

    constructor(data?: IDocumentBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.num = data["num"] !== undefined ? data["num"] : <any>null;
            this.organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            this.patient = data["patient"] !== undefined ? data["patient"] : <any>null;
            this.series = data["series"] !== undefined ? data["series"] : <any>null;
            this.typeFK = data["typeFK"] ? DocumentTypeBean.fromJS(data["typeFK"]) : <any>null;
        }
    }

    static fromJS(data: any): DocumentBean {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["num"] = this.num !== undefined ? this.num : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["patient"] = this.patient !== undefined ? this.patient : <any>null;
        data["series"] = this.series !== undefined ? this.series : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IDocumentBean {
    /** Когда выдан документ */
    date?: Date | null;
    /** Описание документа */
    description?: string | null;
    /** ID */
    id?: number | null;
    isDeleted?: boolean | null;
    /** Номер документа */
    num?: string | null;
    /** Кем выдан документ */
    organization?: string | null;
    /** ID пациента */
    patient?: number | null;
    /** Серия документа */
    series?: string | null;
    /** Тип документа */
    typeFK?: DocumentTypeBean | null;
}

export class LogBean implements ILogBean {
    actionType?: number | null;
    date?: Date | null;
    description?: string | null;
    id?: number | null;
    logType?: number | null;
    parentRecordId?: number | null;
    parentRecordType?: number | null;
    performerFK?: PerformerBean | null;
    performerId?: number | null;
    recordId?: number | null;

    constructor(data?: ILogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionType = data["actionType"] !== undefined ? data["actionType"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.logType = data["logType"] !== undefined ? data["logType"] : <any>null;
            this.parentRecordId = data["parentRecordId"] !== undefined ? data["parentRecordId"] : <any>null;
            this.parentRecordType = data["parentRecordType"] !== undefined ? data["parentRecordType"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.performerId = data["performerId"] !== undefined ? data["performerId"] : <any>null;
            this.recordId = data["recordId"] !== undefined ? data["recordId"] : <any>null;
        }
    }

    static fromJS(data: any): LogBean {
        data = typeof data === 'object' ? data : {};
        let result = new LogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType !== undefined ? this.actionType : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["logType"] = this.logType !== undefined ? this.logType : <any>null;
        data["parentRecordId"] = this.parentRecordId !== undefined ? this.parentRecordId : <any>null;
        data["parentRecordType"] = this.parentRecordType !== undefined ? this.parentRecordType : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["performerId"] = this.performerId !== undefined ? this.performerId : <any>null;
        data["recordId"] = this.recordId !== undefined ? this.recordId : <any>null;
        return data; 
    }
}

export interface ILogBean {
    actionType?: number | null;
    date?: Date | null;
    description?: string | null;
    id?: number | null;
    logType?: number | null;
    parentRecordId?: number | null;
    parentRecordType?: number | null;
    performerFK?: PerformerBean | null;
    performerId?: number | null;
    recordId?: number | null;
}

export class ListContainerOfSubdivisionBean implements IListContainerOfSubdivisionBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfSubdivisionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfSubdivisionBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfSubdivisionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfSubdivisionBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class DrugOperationBean implements IDrugOperationBean {
    /** Укладка */
    bagFK?: BagBean | null;
    /** Карта */
    cardFK?: CardBean | null;
    /** Кол-во таблеток(при списании)/пачек(при пополнении) */
    counter?: number | null;
    date?: Date | null;
    /** Описание */
    description?: string | null;
    /** Исполнитель */
    drugFK?: DrugBean | null;
    id?: number | null;
    /** t - пополнение, f - списание */
    isAction?: boolean | null;
    isDeleted?: boolean | null;
    /** Исполнитель */
    performerFK?: PerformerBean | null;

    constructor(data?: IDrugOperationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bagFK = data["bagFK"] ? BagBean.fromJS(data["bagFK"]) : <any>null;
            this.cardFK = data["cardFK"] ? CardBean.fromJS(data["cardFK"]) : <any>null;
            this.counter = data["counter"] !== undefined ? data["counter"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.drugFK = data["drugFK"] ? DrugBean.fromJS(data["drugFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAction = data["isAction"] !== undefined ? data["isAction"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
        }
    }

    static fromJS(data: any): DrugOperationBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugOperationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bagFK"] = this.bagFK ? this.bagFK.toJSON() : <any>null;
        data["cardFK"] = this.cardFK ? this.cardFK.toJSON() : <any>null;
        data["counter"] = this.counter !== undefined ? this.counter : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["drugFK"] = this.drugFK ? this.drugFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAction"] = this.isAction !== undefined ? this.isAction : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IDrugOperationBean {
    /** Укладка */
    bagFK?: BagBean | null;
    /** Карта */
    cardFK?: CardBean | null;
    /** Кол-во таблеток(при списании)/пачек(при пополнении) */
    counter?: number | null;
    date?: Date | null;
    /** Описание */
    description?: string | null;
    /** Исполнитель */
    drugFK?: DrugBean | null;
    id?: number | null;
    /** t - пополнение, f - списание */
    isAction?: boolean | null;
    isDeleted?: boolean | null;
    /** Исполнитель */
    performerFK?: PerformerBean | null;
}

export class ListContainerOfAthBean implements IListContainerOfAthBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfAthBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfAthBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfAthBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfAthBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class PatientBean implements IPatientBean {
    /** Возраст (полных дней) */
    ageDays?: number | null;
    /** Возраст (полных месяцев) */
    ageMonths?: number | null;
    /** Возраст (полных лет) */
    ageYears?: number | null;
    /** Дата рождения */
    birthday?: Date | null;
    cardCount?: number | null;
    /** Документы пациента */
    documentList?: DocumentBean[] | null;
    /** Гендер (и клал я свой огромный болт на то, что кто-то считает, что гендер и пол - разные вещи!) */
    gender?: boolean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Тип пациента */
    patientTypeFK?: ReferenceTypeBean | null;
    /** Отчетство */
    patronymic?: string | null;
    /** Фамилия */
    surname?: string | null;

    constructor(data?: IPatientBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ageDays = data["ageDays"] !== undefined ? data["ageDays"] : <any>null;
            this.ageMonths = data["ageMonths"] !== undefined ? data["ageMonths"] : <any>null;
            this.ageYears = data["ageYears"] !== undefined ? data["ageYears"] : <any>null;
            this.birthday = data["birthday"] ? new Date(data["birthday"].toString()) : <any>null;
            this.cardCount = data["cardCount"] !== undefined ? data["cardCount"] : <any>null;
            if (data["documentList"] && data["documentList"].constructor === Array) {
                this.documentList = [];
                for (let item of data["documentList"])
                    this.documentList.push(DocumentBean.fromJS(item));
            }
            this.gender = data["gender"] !== undefined ? data["gender"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.patientTypeFK = data["patientTypeFK"] ? ReferenceTypeBean.fromJS(data["patientTypeFK"]) : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
        }
    }

    static fromJS(data: any): PatientBean {
        data = typeof data === 'object' ? data : {};
        let result = new PatientBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageDays"] = this.ageDays !== undefined ? this.ageDays : <any>null;
        data["ageMonths"] = this.ageMonths !== undefined ? this.ageMonths : <any>null;
        data["ageYears"] = this.ageYears !== undefined ? this.ageYears : <any>null;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>null;
        data["cardCount"] = this.cardCount !== undefined ? this.cardCount : <any>null;
        if (this.documentList && this.documentList.constructor === Array) {
            data["documentList"] = [];
            for (let item of this.documentList)
                data["documentList"].push(item.toJSON());
        }
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["patientTypeFK"] = this.patientTypeFK ? this.patientTypeFK.toJSON() : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        return data; 
    }
}

export interface IPatientBean {
    /** Возраст (полных дней) */
    ageDays?: number | null;
    /** Возраст (полных месяцев) */
    ageMonths?: number | null;
    /** Возраст (полных лет) */
    ageYears?: number | null;
    /** Дата рождения */
    birthday?: Date | null;
    cardCount?: number | null;
    /** Документы пациента */
    documentList?: DocumentBean[] | null;
    /** Гендер (и клал я свой огромный болт на то, что кто-то считает, что гендер и пол - разные вещи!) */
    gender?: boolean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Тип пациента */
    patientTypeFK?: ReferenceTypeBean | null;
    /** Отчетство */
    patronymic?: string | null;
    /** Фамилия */
    surname?: string | null;
}

export class AthBean implements IAthBean {
    /** атх код */
    athCode?: string | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** Анатомо-терапевтическо-химическая(атх) классификация */
    name?: string | null;

    constructor(data?: IAthBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.athCode = data["athCode"] !== undefined ? data["athCode"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): AthBean {
        data = typeof data === 'object' ? data : {};
        let result = new AthBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["athCode"] = this.athCode !== undefined ? this.athCode : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IAthBean {
    /** атх код */
    athCode?: string | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** Анатомо-терапевтическо-химическая(атх) классификация */
    name?: string | null;
}

export class OperationBean implements IOperationBean {
    /** препарат */
    bagFK?: BagNewBean | null;
    /** id укладки */
    bagId?: number | null;
    /** название укладки */
    bagName?: string | null;
    /** препарат */
    drugFK?: DrugNewBean | null;
    /** id препарата */
    drugId?: number | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** списание */
    isWriteDown?: boolean | null;
    /** изделие */
    otherFK?: OtherMeanBean | null;
    /** id изделия */
    otherId?: number | null;
    /** исполнитель */
    performerFK?: PerformerBean | null;
    /** id исполнителя */
    performerId?: number | null;
    /** время списания */
    time?: Date | null;
    /** кол-во списаного */
    volume?: number | null;
    /** изделие */
    wareFK?: WareBean | null;
    /** id изделия */
    wareId?: number | null;

    constructor(data?: IOperationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bagFK = data["bagFK"] ? BagNewBean.fromJS(data["bagFK"]) : <any>null;
            this.bagId = data["bagId"] !== undefined ? data["bagId"] : <any>null;
            this.bagName = data["bagName"] !== undefined ? data["bagName"] : <any>null;
            this.drugFK = data["drugFK"] ? DrugNewBean.fromJS(data["drugFK"]) : <any>null;
            this.drugId = data["drugId"] !== undefined ? data["drugId"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.isWriteDown = data["isWriteDown"] !== undefined ? data["isWriteDown"] : <any>null;
            this.otherFK = data["otherFK"] ? OtherMeanBean.fromJS(data["otherFK"]) : <any>null;
            this.otherId = data["otherId"] !== undefined ? data["otherId"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.performerId = data["performerId"] !== undefined ? data["performerId"] : <any>null;
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.wareFK = data["wareFK"] ? WareBean.fromJS(data["wareFK"]) : <any>null;
            this.wareId = data["wareId"] !== undefined ? data["wareId"] : <any>null;
        }
    }

    static fromJS(data: any): OperationBean {
        data = typeof data === 'object' ? data : {};
        let result = new OperationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bagFK"] = this.bagFK ? this.bagFK.toJSON() : <any>null;
        data["bagId"] = this.bagId !== undefined ? this.bagId : <any>null;
        data["bagName"] = this.bagName !== undefined ? this.bagName : <any>null;
        data["drugFK"] = this.drugFK ? this.drugFK.toJSON() : <any>null;
        data["drugId"] = this.drugId !== undefined ? this.drugId : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["isWriteDown"] = this.isWriteDown !== undefined ? this.isWriteDown : <any>null;
        data["otherFK"] = this.otherFK ? this.otherFK.toJSON() : <any>null;
        data["otherId"] = this.otherId !== undefined ? this.otherId : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["performerId"] = this.performerId !== undefined ? this.performerId : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["wareFK"] = this.wareFK ? this.wareFK.toJSON() : <any>null;
        data["wareId"] = this.wareId !== undefined ? this.wareId : <any>null;
        return data; 
    }
}

export interface IOperationBean {
    /** препарат */
    bagFK?: BagNewBean | null;
    /** id укладки */
    bagId?: number | null;
    /** название укладки */
    bagName?: string | null;
    /** препарат */
    drugFK?: DrugNewBean | null;
    /** id препарата */
    drugId?: number | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** списание */
    isWriteDown?: boolean | null;
    /** изделие */
    otherFK?: OtherMeanBean | null;
    /** id изделия */
    otherId?: number | null;
    /** исполнитель */
    performerFK?: PerformerBean | null;
    /** id исполнителя */
    performerId?: number | null;
    /** время списания */
    time?: Date | null;
    /** кол-во списаного */
    volume?: number | null;
    /** изделие */
    wareFK?: WareBean | null;
    /** id изделия */
    wareId?: number | null;
}

export class ListContainerOfDrugRequestBean implements IListContainerOfDrugRequestBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugRequestBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class RoleBean implements IRoleBean {
    authority?: string | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): RoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new RoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IRoleBean {
    authority?: string | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfMapOfstringAndobject implements IListContainerOfMapOfstringAndobject {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfMapOfstringAndobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfMapOfstringAndobject {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfMapOfstringAndobject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfMapOfstringAndobject {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfDrugNewBean implements IListContainerOfDrugNewBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugNewBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugNewBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugNewBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugNewBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class BrigadeTransportScheduleBean implements IBrigadeTransportScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** ID транспорта */
    transport?: number | null;
    /** Транспорт */
    transportFK?: TransportBean | null;

    constructor(data?: IBrigadeTransportScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeSchedule = data["brigadeSchedule"] !== undefined ? data["brigadeSchedule"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.dutyEndDate = data["dutyEndDate"] ? new Date(data["dutyEndDate"].toString()) : <any>null;
            this.dutyStartDate = data["dutyStartDate"] ? new Date(data["dutyStartDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.transport = data["transport"] !== undefined ? data["transport"] : <any>null;
            this.transportFK = data["transportFK"] ? TransportBean.fromJS(data["transportFK"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeTransportScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeTransportScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeSchedule"] = this.brigadeSchedule !== undefined ? this.brigadeSchedule : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["dutyEndDate"] = this.dutyEndDate ? this.dutyEndDate.toISOString() : <any>null;
        data["dutyStartDate"] = this.dutyStartDate ? this.dutyStartDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["transport"] = this.transport !== undefined ? this.transport : <any>null;
        data["transportFK"] = this.transportFK ? this.transportFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeTransportScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** ID транспорта */
    transport?: number | null;
    /** Транспорт */
    transportFK?: TransportBean | null;
}

export class ListContainerOfClassMkbBean implements IListContainerOfClassMkbBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfClassMkbBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfClassMkbBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfClassMkbBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfClassMkbBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class AndyTreeNodeOfInquirerBean implements IAndyTreeNodeOfInquirerBean {
    children?: AndyTreeNodeOfInquirerBean[] | null;
    data?: InquirerBean | null;

    constructor(data?: IAndyTreeNodeOfInquirerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(AndyTreeNodeOfInquirerBean.fromJS(item));
            }
            this.data = data["data"] ? InquirerBean.fromJS(data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): AndyTreeNodeOfInquirerBean {
        data = typeof data === 'object' ? data : {};
        let result = new AndyTreeNodeOfInquirerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IAndyTreeNodeOfInquirerBean {
    children?: AndyTreeNodeOfInquirerBean[] | null;
    data?: InquirerBean | null;
}

export class BuildingBean implements IBuildingBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Геометрия */
    geometry?: string | null;
    /** Наименование постройки */
    houseName?: string | null;
    /** Номер дома */
    houseNumber?: string | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование улицы */
    streetName?: string | null;

    constructor(data?: IBuildingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityAddress = data["cityAddress"] !== undefined ? data["cityAddress"] : <any>null;
            this.geometry = data["geometry"] !== undefined ? data["geometry"] : <any>null;
            this.houseName = data["houseName"] !== undefined ? data["houseName"] : <any>null;
            this.houseNumber = data["houseNumber"] !== undefined ? data["houseNumber"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.idOSM = data["idOSM"] !== undefined ? data["idOSM"] : <any>null;
            this.streetName = data["streetName"] !== undefined ? data["streetName"] : <any>null;
        }
    }

    static fromJS(data: any): BuildingBean {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityAddress"] = this.cityAddress !== undefined ? this.cityAddress : <any>null;
        data["geometry"] = this.geometry !== undefined ? this.geometry : <any>null;
        data["houseName"] = this.houseName !== undefined ? this.houseName : <any>null;
        data["houseNumber"] = this.houseNumber !== undefined ? this.houseNumber : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["idOSM"] = this.idOSM !== undefined ? this.idOSM : <any>null;
        data["streetName"] = this.streetName !== undefined ? this.streetName : <any>null;
        return data; 
    }
}

export interface IBuildingBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Геометрия */
    geometry?: string | null;
    /** Наименование постройки */
    houseName?: string | null;
    /** Номер дома */
    houseNumber?: string | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование улицы */
    streetName?: string | null;
}

export class ListContainerOfTherapyTemplateItemBean implements IListContainerOfTherapyTemplateItemBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTherapyTemplateItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTherapyTemplateItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTherapyTemplateItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTherapyTemplateItemBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfOutwardLogBean implements IListContainerOfOutwardLogBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfOutwardLogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfOutwardLogBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfOutwardLogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfOutwardLogBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class SkillBean implements ISkillBean {
    code?: string | null;
    commonName?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: ISkillBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.commonName = data["commonName"] !== undefined ? data["commonName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SkillBean {
        data = typeof data === 'object' ? data : {};
        let result = new SkillBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["commonName"] = this.commonName !== undefined ? this.commonName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ISkillBean {
    code?: string | null;
    commonName?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class BrigadeScheduleBean implements IBrigadeScheduleBean {
    /** ID бригады */
    brigade?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Признак вывода бригады на линию */
    isAvailable?: boolean | null;
    name?: string | null;
    performerScheduleList?: BrigadePerformerScheduleBean[] | null;
    transportScheduleList?: BrigadeTransportScheduleBean[] | null;

    constructor(data?: IBrigadeScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade = data["brigade"] !== undefined ? data["brigade"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.dutyEndDate = data["dutyEndDate"] ? new Date(data["dutyEndDate"].toString()) : <any>null;
            this.dutyStartDate = data["dutyStartDate"] ? new Date(data["dutyStartDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAvailable = data["isAvailable"] !== undefined ? data["isAvailable"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["performerScheduleList"] && data["performerScheduleList"].constructor === Array) {
                this.performerScheduleList = [];
                for (let item of data["performerScheduleList"])
                    this.performerScheduleList.push(BrigadePerformerScheduleBean.fromJS(item));
            }
            if (data["transportScheduleList"] && data["transportScheduleList"].constructor === Array) {
                this.transportScheduleList = [];
                for (let item of data["transportScheduleList"])
                    this.transportScheduleList.push(BrigadeTransportScheduleBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrigadeScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade"] = this.brigade !== undefined ? this.brigade : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["dutyEndDate"] = this.dutyEndDate ? this.dutyEndDate.toISOString() : <any>null;
        data["dutyStartDate"] = this.dutyStartDate ? this.dutyStartDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.performerScheduleList && this.performerScheduleList.constructor === Array) {
            data["performerScheduleList"] = [];
            for (let item of this.performerScheduleList)
                data["performerScheduleList"].push(item.toJSON());
        }
        if (this.transportScheduleList && this.transportScheduleList.constructor === Array) {
            data["transportScheduleList"] = [];
            for (let item of this.transportScheduleList)
                data["transportScheduleList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrigadeScheduleBean {
    /** ID бригады */
    brigade?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Признак вывода бригады на линию */
    isAvailable?: boolean | null;
    name?: string | null;
    performerScheduleList?: BrigadePerformerScheduleBean[] | null;
    transportScheduleList?: BrigadeTransportScheduleBean[] | null;
}

export class TransportType implements ITransportType {
    type?: string | null;

    constructor(data?: ITransportType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): TransportType {
        data = typeof data === 'object' ? data : {};
        let result = new TransportType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface ITransportType {
    type?: string | null;
}

export class AviaRequestBean implements IAviaRequestBean {
    /** Создавший заявку */
    approvedPerformerFK?: PerformerBean | null;
    /** Исполняющая заявку авиабригада */
    brigadeFK?: BrigadeBean | null;
    /** ID вызова, по которому была сделана заявка */
    call?: number | null;
    /** Состав авиабригады в произвольной форме */
    crew?: string | null;
    /** Дата/время регистрации заявки */
    date?: Date | null;
    /** Адрес пункта отправки (город, улица и пр.) */
    departureAddress?: string | null;
    /** Адрес пункта отправки (номер квартиры) */
    departureFlatNum?: string | null;
    /** Вертолетная площадка (пункт отправки) */
    departureHelipadFK?: HelipadBean | null;
    /** Адрес пункта отправки (номер дома) */
    departureHouseNum?: string | null;
    /** Местоположение пункта отправки */
    departureLocation?: string | null;
    /** Подразделение (пункт отправки) */
    departureSubdivisionFK?: SubdivisionBean | null;
    /** Описание заявки */
    description?: string | null;
    /** Вертолетная площадка (пункт назначения) */
    destinationHelipadFK?: HelipadBean | null;
    /** Подразделение (пункт назначения) */
    destinationSubdivisionFK?: SubdivisionBean | null;
    id?: number | null;
    /** Признак одобрения заявки */
    isAccept?: boolean | null;
    /** Признак межгоспитальной эвакуации */
    isInterHospital?: boolean | null;
    /** Подтвердившый заявку */
    performerFK?: PerformerBean | null;

    constructor(data?: IAviaRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvedPerformerFK = data["approvedPerformerFK"] ? PerformerBean.fromJS(data["approvedPerformerFK"]) : <any>null;
            this.brigadeFK = data["brigadeFK"] ? BrigadeBean.fromJS(data["brigadeFK"]) : <any>null;
            this.call = data["call"] !== undefined ? data["call"] : <any>null;
            this.crew = data["crew"] !== undefined ? data["crew"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.departureAddress = data["departureAddress"] !== undefined ? data["departureAddress"] : <any>null;
            this.departureFlatNum = data["departureFlatNum"] !== undefined ? data["departureFlatNum"] : <any>null;
            this.departureHelipadFK = data["departureHelipadFK"] ? HelipadBean.fromJS(data["departureHelipadFK"]) : <any>null;
            this.departureHouseNum = data["departureHouseNum"] !== undefined ? data["departureHouseNum"] : <any>null;
            this.departureLocation = data["departureLocation"] !== undefined ? data["departureLocation"] : <any>null;
            this.departureSubdivisionFK = data["departureSubdivisionFK"] ? SubdivisionBean.fromJS(data["departureSubdivisionFK"]) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.destinationHelipadFK = data["destinationHelipadFK"] ? HelipadBean.fromJS(data["destinationHelipadFK"]) : <any>null;
            this.destinationSubdivisionFK = data["destinationSubdivisionFK"] ? SubdivisionBean.fromJS(data["destinationSubdivisionFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAccept = data["isAccept"] !== undefined ? data["isAccept"] : <any>null;
            this.isInterHospital = data["isInterHospital"] !== undefined ? data["isInterHospital"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
        }
    }

    static fromJS(data: any): AviaRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new AviaRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvedPerformerFK"] = this.approvedPerformerFK ? this.approvedPerformerFK.toJSON() : <any>null;
        data["brigadeFK"] = this.brigadeFK ? this.brigadeFK.toJSON() : <any>null;
        data["call"] = this.call !== undefined ? this.call : <any>null;
        data["crew"] = this.crew !== undefined ? this.crew : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["departureAddress"] = this.departureAddress !== undefined ? this.departureAddress : <any>null;
        data["departureFlatNum"] = this.departureFlatNum !== undefined ? this.departureFlatNum : <any>null;
        data["departureHelipadFK"] = this.departureHelipadFK ? this.departureHelipadFK.toJSON() : <any>null;
        data["departureHouseNum"] = this.departureHouseNum !== undefined ? this.departureHouseNum : <any>null;
        data["departureLocation"] = this.departureLocation !== undefined ? this.departureLocation : <any>null;
        data["departureSubdivisionFK"] = this.departureSubdivisionFK ? this.departureSubdivisionFK.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["destinationHelipadFK"] = this.destinationHelipadFK ? this.destinationHelipadFK.toJSON() : <any>null;
        data["destinationSubdivisionFK"] = this.destinationSubdivisionFK ? this.destinationSubdivisionFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAccept"] = this.isAccept !== undefined ? this.isAccept : <any>null;
        data["isInterHospital"] = this.isInterHospital !== undefined ? this.isInterHospital : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IAviaRequestBean {
    /** Создавший заявку */
    approvedPerformerFK?: PerformerBean | null;
    /** Исполняющая заявку авиабригада */
    brigadeFK?: BrigadeBean | null;
    /** ID вызова, по которому была сделана заявка */
    call?: number | null;
    /** Состав авиабригады в произвольной форме */
    crew?: string | null;
    /** Дата/время регистрации заявки */
    date?: Date | null;
    /** Адрес пункта отправки (город, улица и пр.) */
    departureAddress?: string | null;
    /** Адрес пункта отправки (номер квартиры) */
    departureFlatNum?: string | null;
    /** Вертолетная площадка (пункт отправки) */
    departureHelipadFK?: HelipadBean | null;
    /** Адрес пункта отправки (номер дома) */
    departureHouseNum?: string | null;
    /** Местоположение пункта отправки */
    departureLocation?: string | null;
    /** Подразделение (пункт отправки) */
    departureSubdivisionFK?: SubdivisionBean | null;
    /** Описание заявки */
    description?: string | null;
    /** Вертолетная площадка (пункт назначения) */
    destinationHelipadFK?: HelipadBean | null;
    /** Подразделение (пункт назначения) */
    destinationSubdivisionFK?: SubdivisionBean | null;
    id?: number | null;
    /** Признак одобрения заявки */
    isAccept?: boolean | null;
    /** Признак межгоспитальной эвакуации */
    isInterHospital?: boolean | null;
    /** Подтвердившый заявку */
    performerFK?: PerformerBean | null;
}

export class PGgeometry implements IPGgeometry {
    geoType?: number | null;
    geometry?: Geometry | null;
    type?: string | null;
    value?: string | null;

    constructor(data?: IPGgeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.geoType = data["geoType"] !== undefined ? data["geoType"] : <any>null;
            this.geometry = data["geometry"] ? Geometry.fromJS(data["geometry"]) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PGgeometry {
        data = typeof data === 'object' ? data : {};
        let result = new PGgeometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geoType"] = this.geoType !== undefined ? this.geoType : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IPGgeometry {
    geoType?: number | null;
    geometry?: Geometry | null;
    type?: string | null;
    value?: string | null;
}

export class ListContainerOfAviaRequestBean implements IListContainerOfAviaRequestBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfAviaRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfAviaRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfAviaRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfAviaRequestBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ArchiveCallContainer implements IArchiveCallContainer {
    brigadeId?: number | null;
    callPriorityList?: number[] | null;
    callStatusList?: number[] | null;
    callTypeId?: number | null;
    dateFrom?: string | null;
    dateTo?: string | null;
    declarantName?: string | null;
    declarantPhone?: string | null;
    declarantTypeId?: number | null;
    isChildrenIncluded?: boolean | null;
    number?: string | null;
    patientAgeDays?: number | null;
    patientAgeMonths?: number | null;
    patientAgeYears?: number | null;
    patientName?: string | null;
    patientPatronymic?: string | null;
    patientSurname?: string | null;
    reason?: number | null;
    subdivisionId?: number | null;

    constructor(data?: IArchiveCallContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeId = data["brigadeId"] !== undefined ? data["brigadeId"] : <any>null;
            if (data["callPriorityList"] && data["callPriorityList"].constructor === Array) {
                this.callPriorityList = [];
                for (let item of data["callPriorityList"])
                    this.callPriorityList.push(item);
            }
            if (data["callStatusList"] && data["callStatusList"].constructor === Array) {
                this.callStatusList = [];
                for (let item of data["callStatusList"])
                    this.callStatusList.push(item);
            }
            this.callTypeId = data["callTypeId"] !== undefined ? data["callTypeId"] : <any>null;
            this.dateFrom = data["dateFrom"] !== undefined ? data["dateFrom"] : <any>null;
            this.dateTo = data["dateTo"] !== undefined ? data["dateTo"] : <any>null;
            this.declarantName = data["declarantName"] !== undefined ? data["declarantName"] : <any>null;
            this.declarantPhone = data["declarantPhone"] !== undefined ? data["declarantPhone"] : <any>null;
            this.declarantTypeId = data["declarantTypeId"] !== undefined ? data["declarantTypeId"] : <any>null;
            this.isChildrenIncluded = data["isChildrenIncluded"] !== undefined ? data["isChildrenIncluded"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patientAgeDays = data["patientAgeDays"] !== undefined ? data["patientAgeDays"] : <any>null;
            this.patientAgeMonths = data["patientAgeMonths"] !== undefined ? data["patientAgeMonths"] : <any>null;
            this.patientAgeYears = data["patientAgeYears"] !== undefined ? data["patientAgeYears"] : <any>null;
            this.patientName = data["patientName"] !== undefined ? data["patientName"] : <any>null;
            this.patientPatronymic = data["patientPatronymic"] !== undefined ? data["patientPatronymic"] : <any>null;
            this.patientSurname = data["patientSurname"] !== undefined ? data["patientSurname"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
        }
    }

    static fromJS(data: any): ArchiveCallContainer {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveCallContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeId"] = this.brigadeId !== undefined ? this.brigadeId : <any>null;
        if (this.callPriorityList && this.callPriorityList.constructor === Array) {
            data["callPriorityList"] = [];
            for (let item of this.callPriorityList)
                data["callPriorityList"].push(item);
        }
        if (this.callStatusList && this.callStatusList.constructor === Array) {
            data["callStatusList"] = [];
            for (let item of this.callStatusList)
                data["callStatusList"].push(item);
        }
        data["callTypeId"] = this.callTypeId !== undefined ? this.callTypeId : <any>null;
        data["dateFrom"] = this.dateFrom !== undefined ? this.dateFrom : <any>null;
        data["dateTo"] = this.dateTo !== undefined ? this.dateTo : <any>null;
        data["declarantName"] = this.declarantName !== undefined ? this.declarantName : <any>null;
        data["declarantPhone"] = this.declarantPhone !== undefined ? this.declarantPhone : <any>null;
        data["declarantTypeId"] = this.declarantTypeId !== undefined ? this.declarantTypeId : <any>null;
        data["isChildrenIncluded"] = this.isChildrenIncluded !== undefined ? this.isChildrenIncluded : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patientAgeDays"] = this.patientAgeDays !== undefined ? this.patientAgeDays : <any>null;
        data["patientAgeMonths"] = this.patientAgeMonths !== undefined ? this.patientAgeMonths : <any>null;
        data["patientAgeYears"] = this.patientAgeYears !== undefined ? this.patientAgeYears : <any>null;
        data["patientName"] = this.patientName !== undefined ? this.patientName : <any>null;
        data["patientPatronymic"] = this.patientPatronymic !== undefined ? this.patientPatronymic : <any>null;
        data["patientSurname"] = this.patientSurname !== undefined ? this.patientSurname : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        return data; 
    }
}

export interface IArchiveCallContainer {
    brigadeId?: number | null;
    callPriorityList?: number[] | null;
    callStatusList?: number[] | null;
    callTypeId?: number | null;
    dateFrom?: string | null;
    dateTo?: string | null;
    declarantName?: string | null;
    declarantPhone?: string | null;
    declarantTypeId?: number | null;
    isChildrenIncluded?: boolean | null;
    number?: string | null;
    patientAgeDays?: number | null;
    patientAgeMonths?: number | null;
    patientAgeYears?: number | null;
    patientName?: string | null;
    patientPatronymic?: string | null;
    patientSurname?: string | null;
    reason?: number | null;
    subdivisionId?: number | null;
}

export class ListContainerOfDrugPackage implements IListContainerOfDrugPackage {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugPackage {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugPackage {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class PushTokenBean implements IPushTokenBean {
    /** Версия приложения */
    appVersion?: string | null;
    /** ID бригады, использующей устргойство */
    brigadeId?: number | null;
    /** Hashcode */
    hash?: string | null;
    /** Производитель устройства */
    manufacturer?: string | null;
    /** Модель устройства */
    model?: string | null;
    /** Операционная система */
    os?: string | null;
    /** Версия ОС */
    osVersion?: string | null;
    /** Токен */
    token?: string | null;

    constructor(data?: IPushTokenBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appVersion = data["appVersion"] !== undefined ? data["appVersion"] : <any>null;
            this.brigadeId = data["brigadeId"] !== undefined ? data["brigadeId"] : <any>null;
            this.hash = data["hash"] !== undefined ? data["hash"] : <any>null;
            this.manufacturer = data["manufacturer"] !== undefined ? data["manufacturer"] : <any>null;
            this.model = data["model"] !== undefined ? data["model"] : <any>null;
            this.os = data["os"] !== undefined ? data["os"] : <any>null;
            this.osVersion = data["osVersion"] !== undefined ? data["osVersion"] : <any>null;
            this.token = data["token"] !== undefined ? data["token"] : <any>null;
        }
    }

    static fromJS(data: any): PushTokenBean {
        data = typeof data === 'object' ? data : {};
        let result = new PushTokenBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appVersion"] = this.appVersion !== undefined ? this.appVersion : <any>null;
        data["brigadeId"] = this.brigadeId !== undefined ? this.brigadeId : <any>null;
        data["hash"] = this.hash !== undefined ? this.hash : <any>null;
        data["manufacturer"] = this.manufacturer !== undefined ? this.manufacturer : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        data["os"] = this.os !== undefined ? this.os : <any>null;
        data["osVersion"] = this.osVersion !== undefined ? this.osVersion : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface IPushTokenBean {
    /** Версия приложения */
    appVersion?: string | null;
    /** ID бригады, использующей устргойство */
    brigadeId?: number | null;
    /** Hashcode */
    hash?: string | null;
    /** Производитель устройства */
    manufacturer?: string | null;
    /** Модель устройства */
    model?: string | null;
    /** Операционная система */
    os?: string | null;
    /** Версия ОС */
    osVersion?: string | null;
    /** Токен */
    token?: string | null;
}

export class LoginResponse implements ILoginResponse {
    code?: number | null;
    message?: string | null;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.message = data["message"] !== undefined ? data["message"] : <any>null;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data; 
    }
}

export interface ILoginResponse {
    code?: number | null;
    message?: string | null;
}

export class PerformerBean implements IPerformerBean {
    /** Пароль */
    clearPassword?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Отчество */
    patronymic?: string | null;
    /** Телефон */
    phone?: string | null;
    roleList?: RoleBean[] | null;
    /** Специализация сотрудника */
    specializationFK?: SkillBean | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Фамилия */
    surname?: string | null;
    /** Тип сотрудника */
    typeFK?: PerformerTypeBean | null;
    /** Логин */
    username?: string | null;
    /** Рабочее подразделение */
    workplaceSubdivisionFK?: SubdivisionBean | null;

    constructor(data?: IPerformerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clearPassword = data["clearPassword"] !== undefined ? data["clearPassword"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            if (data["roleList"] && data["roleList"].constructor === Array) {
                this.roleList = [];
                for (let item of data["roleList"])
                    this.roleList.push(RoleBean.fromJS(item));
            }
            this.specializationFK = data["specializationFK"] ? SkillBean.fromJS(data["specializationFK"]) : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.typeFK = data["typeFK"] ? PerformerTypeBean.fromJS(data["typeFK"]) : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.workplaceSubdivisionFK = data["workplaceSubdivisionFK"] ? SubdivisionBean.fromJS(data["workplaceSubdivisionFK"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerBean {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clearPassword"] = this.clearPassword !== undefined ? this.clearPassword : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        if (this.roleList && this.roleList.constructor === Array) {
            data["roleList"] = [];
            for (let item of this.roleList)
                data["roleList"].push(item.toJSON());
        }
        data["specializationFK"] = this.specializationFK ? this.specializationFK.toJSON() : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["workplaceSubdivisionFK"] = this.workplaceSubdivisionFK ? this.workplaceSubdivisionFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerBean {
    /** Пароль */
    clearPassword?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Отчество */
    patronymic?: string | null;
    /** Телефон */
    phone?: string | null;
    roleList?: RoleBean[] | null;
    /** Специализация сотрудника */
    specializationFK?: SkillBean | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Фамилия */
    surname?: string | null;
    /** Тип сотрудника */
    typeFK?: PerformerTypeBean | null;
    /** Логин */
    username?: string | null;
    /** Рабочее подразделение */
    workplaceSubdivisionFK?: SubdivisionBean | null;
}

export class CallContainer implements ICallContainer {
    brigadeList?: BrigadeContainer[] | null;
    call?: CallBean | null;

    constructor(data?: ICallContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["brigadeList"] && data["brigadeList"].constructor === Array) {
                this.brigadeList = [];
                for (let item of data["brigadeList"])
                    this.brigadeList.push(BrigadeContainer.fromJS(item));
            }
            this.call = data["call"] ? CallBean.fromJS(data["call"]) : <any>null;
        }
    }

    static fromJS(data: any): CallContainer {
        data = typeof data === 'object' ? data : {};
        let result = new CallContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.brigadeList && this.brigadeList.constructor === Array) {
            data["brigadeList"] = [];
            for (let item of this.brigadeList)
                data["brigadeList"].push(item.toJSON());
        }
        data["call"] = this.call ? this.call.toJSON() : <any>null;
        return data; 
    }
}

export interface ICallContainer {
    brigadeList?: BrigadeContainer[] | null;
    call?: CallBean | null;
}

export class ListContainerOfDrugCategoryBean implements IListContainerOfDrugCategoryBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugCategoryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugCategoryBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugCategoryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugCategoryBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class TherapyTemplateItemBean implements ITherapyTemplateItemBean {
    code?: string | null;
    /** Группа */
    groupFK?: PharmacyGroupBean | null;
    /** Id группы */
    groupId?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Id шаблона */
    templateId?: number | null;
    /** Шаблон */
    therapyTemplateFK?: TherapyTemplateBean | null;

    constructor(data?: ITherapyTemplateItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.groupFK = data["groupFK"] ? PharmacyGroupBean.fromJS(data["groupFK"]) : <any>null;
            this.groupId = data["groupId"] !== undefined ? data["groupId"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.templateId = data["templateId"] !== undefined ? data["templateId"] : <any>null;
            this.therapyTemplateFK = data["therapyTemplateFK"] ? TherapyTemplateBean.fromJS(data["therapyTemplateFK"]) : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["groupFK"] = this.groupFK ? this.groupFK.toJSON() : <any>null;
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["templateId"] = this.templateId !== undefined ? this.templateId : <any>null;
        data["therapyTemplateFK"] = this.therapyTemplateFK ? this.therapyTemplateFK.toJSON() : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateItemBean {
    code?: string | null;
    /** Группа */
    groupFK?: PharmacyGroupBean | null;
    /** Id группы */
    groupId?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Id шаблона */
    templateId?: number | null;
    /** Шаблон */
    therapyTemplateFK?: TherapyTemplateBean | null;
}

export class OtherMeanBean implements IOtherMeanBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название прочего средства */
    name?: string | null;
    /** id единиц измерения прочего средства */
    unitId?: number | null;

    constructor(data?: IOtherMeanBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.unitId = data["unitId"] !== undefined ? data["unitId"] : <any>null;
        }
    }

    static fromJS(data: any): OtherMeanBean {
        data = typeof data === 'object' ? data : {};
        let result = new OtherMeanBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["unitId"] = this.unitId !== undefined ? this.unitId : <any>null;
        return data; 
    }
}

export interface IOtherMeanBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название прочего средства */
    name?: string | null;
    /** id единиц измерения прочего средства */
    unitId?: number | null;
}

export class DrugRequestBean implements IDrugRequestBean {
    /** Укладка */
    bagFK?: BagBean | null;
    id?: number | null;
    isAccepted?: boolean | null;
    isDeleted?: boolean | null;
    needDrugs?: BagDrugBean[] | null;

    constructor(data?: IDrugRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bagFK = data["bagFK"] ? BagBean.fromJS(data["bagFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAccepted = data["isAccepted"] !== undefined ? data["isAccepted"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            if (data["needDrugs"] && data["needDrugs"].constructor === Array) {
                this.needDrugs = [];
                for (let item of data["needDrugs"])
                    this.needDrugs.push(BagDrugBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DrugRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bagFK"] = this.bagFK ? this.bagFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAccepted"] = this.isAccepted !== undefined ? this.isAccepted : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        if (this.needDrugs && this.needDrugs.constructor === Array) {
            data["needDrugs"] = [];
            for (let item of this.needDrugs)
                data["needDrugs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDrugRequestBean {
    /** Укладка */
    bagFK?: BagBean | null;
    id?: number | null;
    isAccepted?: boolean | null;
    isDeleted?: boolean | null;
    needDrugs?: BagDrugBean[] | null;
}

export class ListContainerOfLogBean implements IListContainerOfLogBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfLogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfLogBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfLogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfLogBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class InquirerBean implements IInquirerBean {
    answer?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    parentId?: number | null;
    /** Основной повод к вызову */
    primaryInquirerFK?: InquirerBean | null;
    query?: string | null;
    reason?: string | null;
    /** Тип бригады, который соотве */
    specializationFK?: BrigadeTypeBean | null;

    constructor(data?: IInquirerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer = data["answer"] !== undefined ? data["answer"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
            this.primaryInquirerFK = data["primaryInquirerFK"] ? InquirerBean.fromJS(data["primaryInquirerFK"]) : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.specializationFK = data["specializationFK"] ? BrigadeTypeBean.fromJS(data["specializationFK"]) : <any>null;
        }
    }

    static fromJS(data: any): InquirerBean {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer !== undefined ? this.answer : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        data["primaryInquirerFK"] = this.primaryInquirerFK ? this.primaryInquirerFK.toJSON() : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["specializationFK"] = this.specializationFK ? this.specializationFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IInquirerBean {
    answer?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    parentId?: number | null;
    /** Основной повод к вызову */
    primaryInquirerFK?: InquirerBean | null;
    query?: string | null;
    reason?: string | null;
    /** Тип бригады, который соотве */
    specializationFK?: BrigadeTypeBean | null;
}

export class ListContainerOfDrugBean implements IListContainerOfDrugBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfTherapyTemplateBean implements IListContainerOfTherapyTemplateBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTherapyTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTherapyTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTherapyTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTherapyTemplateBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class PharmacyGroupBean implements IPharmacyGroupBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IPharmacyGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IPharmacyGroupBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfOperationBean implements IListContainerOfOperationBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfOperationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfOperationBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfOperationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfOperationBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ScheduleTypeBean implements IScheduleTypeBean {
    code?: string | null;
    /** Количество рабочих дней */
    daysOff?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Начало смены */
    timeFrom?: string | null;
    /** Окончание смены */
    timeTo?: string | null;
    /** Количество рабочих дней */
    workingDays?: number | null;
    /** Количество рабочих минут */
    workingMinutes?: number | null;

    constructor(data?: IScheduleTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.daysOff = data["daysOff"] !== undefined ? data["daysOff"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.timeFrom = data["timeFrom"] !== undefined ? data["timeFrom"] : <any>null;
            this.timeTo = data["timeTo"] !== undefined ? data["timeTo"] : <any>null;
            this.workingDays = data["workingDays"] !== undefined ? data["workingDays"] : <any>null;
            this.workingMinutes = data["workingMinutes"] !== undefined ? data["workingMinutes"] : <any>null;
        }
    }

    static fromJS(data: any): ScheduleTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["daysOff"] = this.daysOff !== undefined ? this.daysOff : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["timeFrom"] = this.timeFrom !== undefined ? this.timeFrom : <any>null;
        data["timeTo"] = this.timeTo !== undefined ? this.timeTo : <any>null;
        data["workingDays"] = this.workingDays !== undefined ? this.workingDays : <any>null;
        data["workingMinutes"] = this.workingMinutes !== undefined ? this.workingMinutes : <any>null;
        return data; 
    }
}

export interface IScheduleTypeBean {
    code?: string | null;
    /** Количество рабочих дней */
    daysOff?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Начало смены */
    timeFrom?: string | null;
    /** Окончание смены */
    timeTo?: string | null;
    /** Количество рабочих дней */
    workingDays?: number | null;
    /** Количество рабочих минут */
    workingMinutes?: number | null;
}

export class BagTemplateBean implements IBagTemplateBean {
    /** Тип */
    brigadeTypeFK?: BrigadeTypeBean | null;
    code?: string | null;
    /** Описание */
    description?: string | null;
    drugList?: DrugBean[] | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IBagTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeTypeFK = data["brigadeTypeFK"] ? BrigadeTypeBean.fromJS(data["brigadeTypeFK"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            if (data["drugList"] && data["drugList"].constructor === Array) {
                this.drugList = [];
                for (let item of data["drugList"])
                    this.drugList.push(DrugBean.fromJS(item));
            }
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BagTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new BagTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeTypeFK"] = this.brigadeTypeFK ? this.brigadeTypeFK.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (this.drugList && this.drugList.constructor === Array) {
            data["drugList"] = [];
            for (let item of this.drugList)
                data["drugList"].push(item.toJSON());
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBagTemplateBean {
    /** Тип */
    brigadeTypeFK?: BrigadeTypeBean | null;
    code?: string | null;
    /** Описание */
    description?: string | null;
    drugList?: DrugBean[] | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class StreetBean implements IStreetBean {
    cityAddress?: string | null;
    fullName?: string | null;
    highway?: boolean | null;
    name?: string | null;

    constructor(data?: IStreetBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityAddress = data["cityAddress"] !== undefined ? data["cityAddress"] : <any>null;
            this.fullName = data["fullName"] !== undefined ? data["fullName"] : <any>null;
            this.highway = data["highway"] !== undefined ? data["highway"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): StreetBean {
        data = typeof data === 'object' ? data : {};
        let result = new StreetBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityAddress"] = this.cityAddress !== undefined ? this.cityAddress : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["highway"] = this.highway !== undefined ? this.highway : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IStreetBean {
    cityAddress?: string | null;
    fullName?: string | null;
    highway?: boolean | null;
    name?: string | null;
}

export class DeferredResult implements IDeferredResult {
    result?: any | null;
    setOrExpired?: boolean | null;

    constructor(data?: IDeferredResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"] !== undefined ? data["result"] : <any>null;
            this.setOrExpired = data["setOrExpired"] !== undefined ? data["setOrExpired"] : <any>null;
        }
    }

    static fromJS(data: any): DeferredResult {
        data = typeof data === 'object' ? data : {};
        let result = new DeferredResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result !== undefined ? this.result : <any>null;
        data["setOrExpired"] = this.setOrExpired !== undefined ? this.setOrExpired : <any>null;
        return data; 
    }
}

export interface IDeferredResult {
    result?: any | null;
    setOrExpired?: boolean | null;
}

export class BrigadeBean implements IBrigadeBean {
    /** Статус бригады */
    brigadeStatus?: number | null;
    /** Статус бригады */
    brigadeStatusFK?: BrigadeStatusBean | null;
    /** Тип бригады */
    brigadeType?: number | null;
    /** Тип бригады */
    brigadeTypeFK?: BrigadeTypeBean | null;
    code?: string | null;
    id?: number | null;
    /** Признак авиабригады */
    isAviaBrigade?: boolean | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;

    constructor(data?: IBrigadeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeStatus = data["brigadeStatus"] !== undefined ? data["brigadeStatus"] : <any>null;
            this.brigadeStatusFK = data["brigadeStatusFK"] ? BrigadeStatusBean.fromJS(data["brigadeStatusFK"]) : <any>null;
            this.brigadeType = data["brigadeType"] !== undefined ? data["brigadeType"] : <any>null;
            this.brigadeTypeFK = data["brigadeTypeFK"] ? BrigadeTypeBean.fromJS(data["brigadeTypeFK"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAviaBrigade = data["isAviaBrigade"] !== undefined ? data["isAviaBrigade"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeStatus"] = this.brigadeStatus !== undefined ? this.brigadeStatus : <any>null;
        data["brigadeStatusFK"] = this.brigadeStatusFK ? this.brigadeStatusFK.toJSON() : <any>null;
        data["brigadeType"] = this.brigadeType !== undefined ? this.brigadeType : <any>null;
        data["brigadeTypeFK"] = this.brigadeTypeFK ? this.brigadeTypeFK.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAviaBrigade"] = this.isAviaBrigade !== undefined ? this.isAviaBrigade : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeBean {
    /** Статус бригады */
    brigadeStatus?: number | null;
    /** Статус бригады */
    brigadeStatusFK?: BrigadeStatusBean | null;
    /** Тип бригады */
    brigadeType?: number | null;
    /** Тип бригады */
    brigadeTypeFK?: BrigadeTypeBean | null;
    code?: string | null;
    id?: number | null;
    /** Признак авиабригады */
    isAviaBrigade?: boolean | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
}

export class PairOfDrugBeanAndint implements IPairOfDrugBeanAndint {
    first?: DrugBean | null;
    second?: number | null;

    constructor(data?: IPairOfDrugBeanAndint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? DrugBean.fromJS(data["first"]) : <any>null;
            this.second = data["second"] !== undefined ? data["second"] : <any>null;
        }
    }

    static fromJS(data: any): PairOfDrugBeanAndint {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfDrugBeanAndint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        data["second"] = this.second !== undefined ? this.second : <any>null;
        return data; 
    }
}

export interface IPairOfDrugBeanAndint {
    first?: DrugBean | null;
    second?: number | null;
}

export class UkioCallerInfoBean implements IUkioCallerInfoBean {
    /** Адрес проживания заявителя или адрес установки абонентского терминала или адрес юридического лица */
    address?: string | null;
    /** Внутренний радиус */
    arcbandInnerRadius?: string | null;
    /** Широта */
    arcbandLatitude?: string | null;
    /** Долгота */
    arcbandLongitude?: string | null;
    /** Угол раскрытия */
    arcbandOpeningAngle?: string | null;
    /** Внешний радиус */
    arcbandOuterRadius?: string | null;
    /** Начальный угол */
    arcbandStartAngle?: string | null;
    /** Дата рождения заявителя */
    birthdate?: string | null;
    /** точности окружности */
    circleAccuracy?: number | null;
    /** Широта окружности */
    circleLatitude?: string | null;
    /** Долгота окружности */
    circleLongitude?: string | null;
    /** Подьезд */
    entrance?: string | null;
    /** Уникальный идентификатор дома в формате ФИАС */
    houseGUID?: string | null;
    /** ID */
    id?: number | null;
    /** Наименование языка, отличного от русского, на котором обратился заявитель */
    language?: string | null;
    /** Этаж */
    level?: string | null;
    /** Имя заявителя */
    name?: string | null;
    /** Название организации (передается только в случае принадлежности абонентского терминала, с которого поступил вызов в систему-112, юридическому лицу) */
    organizationName?: string | null;
    /** Номер телефона для связи с заявителем */
    phone?: string | null;
    /** Широта точки */
    pointLatitude?: string | null;
    /** Долгота точки */
    pointLongitude?: string | null;
    /** Квартира */
    room?: string | null;
    /** Отчество заявителя */
    secondName?: string | null;
    /** Идентификатор оператора связи */
    serviceProviderId?: number | null;
    /** Наименование оператора связи */
    serviceProviderName?: string | null;
    /** Фамилия заявителя */
    surname?: string | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;

    constructor(data?: IUkioCallerInfoBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.arcbandInnerRadius = data["arcbandInnerRadius"] !== undefined ? data["arcbandInnerRadius"] : <any>null;
            this.arcbandLatitude = data["arcbandLatitude"] !== undefined ? data["arcbandLatitude"] : <any>null;
            this.arcbandLongitude = data["arcbandLongitude"] !== undefined ? data["arcbandLongitude"] : <any>null;
            this.arcbandOpeningAngle = data["arcbandOpeningAngle"] !== undefined ? data["arcbandOpeningAngle"] : <any>null;
            this.arcbandOuterRadius = data["arcbandOuterRadius"] !== undefined ? data["arcbandOuterRadius"] : <any>null;
            this.arcbandStartAngle = data["arcbandStartAngle"] !== undefined ? data["arcbandStartAngle"] : <any>null;
            this.birthdate = data["birthdate"] !== undefined ? data["birthdate"] : <any>null;
            this.circleAccuracy = data["circleAccuracy"] !== undefined ? data["circleAccuracy"] : <any>null;
            this.circleLatitude = data["circleLatitude"] !== undefined ? data["circleLatitude"] : <any>null;
            this.circleLongitude = data["circleLongitude"] !== undefined ? data["circleLongitude"] : <any>null;
            this.entrance = data["entrance"] !== undefined ? data["entrance"] : <any>null;
            this.houseGUID = data["houseGUID"] !== undefined ? data["houseGUID"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.language = data["language"] !== undefined ? data["language"] : <any>null;
            this.level = data["level"] !== undefined ? data["level"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.organizationName = data["organizationName"] !== undefined ? data["organizationName"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.pointLatitude = data["pointLatitude"] !== undefined ? data["pointLatitude"] : <any>null;
            this.pointLongitude = data["pointLongitude"] !== undefined ? data["pointLongitude"] : <any>null;
            this.room = data["room"] !== undefined ? data["room"] : <any>null;
            this.secondName = data["secondName"] !== undefined ? data["secondName"] : <any>null;
            this.serviceProviderId = data["serviceProviderId"] !== undefined ? data["serviceProviderId"] : <any>null;
            this.serviceProviderName = data["serviceProviderName"] !== undefined ? data["serviceProviderName"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
            this.ukioMessageId = data["ukioMessageId"] !== undefined ? data["ukioMessageId"] : <any>null;
        }
    }

    static fromJS(data: any): UkioCallerInfoBean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioCallerInfoBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["arcbandInnerRadius"] = this.arcbandInnerRadius !== undefined ? this.arcbandInnerRadius : <any>null;
        data["arcbandLatitude"] = this.arcbandLatitude !== undefined ? this.arcbandLatitude : <any>null;
        data["arcbandLongitude"] = this.arcbandLongitude !== undefined ? this.arcbandLongitude : <any>null;
        data["arcbandOpeningAngle"] = this.arcbandOpeningAngle !== undefined ? this.arcbandOpeningAngle : <any>null;
        data["arcbandOuterRadius"] = this.arcbandOuterRadius !== undefined ? this.arcbandOuterRadius : <any>null;
        data["arcbandStartAngle"] = this.arcbandStartAngle !== undefined ? this.arcbandStartAngle : <any>null;
        data["birthdate"] = this.birthdate !== undefined ? this.birthdate : <any>null;
        data["circleAccuracy"] = this.circleAccuracy !== undefined ? this.circleAccuracy : <any>null;
        data["circleLatitude"] = this.circleLatitude !== undefined ? this.circleLatitude : <any>null;
        data["circleLongitude"] = this.circleLongitude !== undefined ? this.circleLongitude : <any>null;
        data["entrance"] = this.entrance !== undefined ? this.entrance : <any>null;
        data["houseGUID"] = this.houseGUID !== undefined ? this.houseGUID : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["language"] = this.language !== undefined ? this.language : <any>null;
        data["level"] = this.level !== undefined ? this.level : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["organizationName"] = this.organizationName !== undefined ? this.organizationName : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["pointLatitude"] = this.pointLatitude !== undefined ? this.pointLatitude : <any>null;
        data["pointLongitude"] = this.pointLongitude !== undefined ? this.pointLongitude : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["secondName"] = this.secondName !== undefined ? this.secondName : <any>null;
        data["serviceProviderId"] = this.serviceProviderId !== undefined ? this.serviceProviderId : <any>null;
        data["serviceProviderName"] = this.serviceProviderName !== undefined ? this.serviceProviderName : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        data["ukioMessageId"] = this.ukioMessageId !== undefined ? this.ukioMessageId : <any>null;
        return data; 
    }
}

export interface IUkioCallerInfoBean {
    /** Адрес проживания заявителя или адрес установки абонентского терминала или адрес юридического лица */
    address?: string | null;
    /** Внутренний радиус */
    arcbandInnerRadius?: string | null;
    /** Широта */
    arcbandLatitude?: string | null;
    /** Долгота */
    arcbandLongitude?: string | null;
    /** Угол раскрытия */
    arcbandOpeningAngle?: string | null;
    /** Внешний радиус */
    arcbandOuterRadius?: string | null;
    /** Начальный угол */
    arcbandStartAngle?: string | null;
    /** Дата рождения заявителя */
    birthdate?: string | null;
    /** точности окружности */
    circleAccuracy?: number | null;
    /** Широта окружности */
    circleLatitude?: string | null;
    /** Долгота окружности */
    circleLongitude?: string | null;
    /** Подьезд */
    entrance?: string | null;
    /** Уникальный идентификатор дома в формате ФИАС */
    houseGUID?: string | null;
    /** ID */
    id?: number | null;
    /** Наименование языка, отличного от русского, на котором обратился заявитель */
    language?: string | null;
    /** Этаж */
    level?: string | null;
    /** Имя заявителя */
    name?: string | null;
    /** Название организации (передается только в случае принадлежности абонентского терминала, с которого поступил вызов в систему-112, юридическому лицу) */
    organizationName?: string | null;
    /** Номер телефона для связи с заявителем */
    phone?: string | null;
    /** Широта точки */
    pointLatitude?: string | null;
    /** Долгота точки */
    pointLongitude?: string | null;
    /** Квартира */
    room?: string | null;
    /** Отчество заявителя */
    secondName?: string | null;
    /** Идентификатор оператора связи */
    serviceProviderId?: number | null;
    /** Наименование оператора связи */
    serviceProviderName?: string | null;
    /** Фамилия заявителя */
    surname?: string | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;
}

export class RegionBean implements IRegionBean {
    /** Родительский район */
    district?: string | null;
    /** Полное наименование региона */
    fullName?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование региона */
    name?: string | null;
    /** Родительский регион */
    region?: string | null;

    constructor(data?: IRegionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.fullName = data["fullName"] !== undefined ? data["fullName"] : <any>null;
            this.geometry = data["geometry"] ? PGgeometry.fromJS(data["geometry"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.idOSM = data["idOSM"] !== undefined ? data["idOSM"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.region = data["region"] !== undefined ? data["region"] : <any>null;
        }
    }

    static fromJS(data: any): RegionBean {
        data = typeof data === 'object' ? data : {};
        let result = new RegionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["idOSM"] = this.idOSM !== undefined ? this.idOSM : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["region"] = this.region !== undefined ? this.region : <any>null;
        return data; 
    }
}

export interface IRegionBean {
    /** Родительский район */
    district?: string | null;
    /** Полное наименование региона */
    fullName?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование региона */
    name?: string | null;
    /** Родительский регион */
    region?: string | null;
}

export class LockOptions implements ILockOptions {
    relockIntervalSeconds?: number | null;

    constructor(data?: ILockOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.relockIntervalSeconds = data["relockIntervalSeconds"] !== undefined ? data["relockIntervalSeconds"] : <any>null;
        }
    }

    static fromJS(data: any): LockOptions {
        data = typeof data === 'object' ? data : {};
        let result = new LockOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relockIntervalSeconds"] = this.relockIntervalSeconds !== undefined ? this.relockIntervalSeconds : <any>null;
        return data; 
    }
}

export interface ILockOptions {
    relockIntervalSeconds?: number | null;
}

export class TransportEquipmentBean implements ITransportEquipmentBean {
    /** Связанный с транспортом трекер */
    equipmentFK?: EquipmentBean | null;
    /** ID GPS-трекера */
    equipmentId?: number | null;
    /** ID */
    id?: number | null;
    /** Наименование трекера */
    timeBegin?: Date | null;
    /** Наименование трекера */
    timeEnd?: Date | null;
    /** ID транспорта */
    vehicleId?: number | null;

    constructor(data?: ITransportEquipmentBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.equipmentFK = data["equipmentFK"] ? EquipmentBean.fromJS(data["equipmentFK"]) : <any>null;
            this.equipmentId = data["equipmentId"] !== undefined ? data["equipmentId"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.timeBegin = data["timeBegin"] ? new Date(data["timeBegin"].toString()) : <any>null;
            this.timeEnd = data["timeEnd"] ? new Date(data["timeEnd"].toString()) : <any>null;
            this.vehicleId = data["vehicleId"] !== undefined ? data["vehicleId"] : <any>null;
        }
    }

    static fromJS(data: any): TransportEquipmentBean {
        data = typeof data === 'object' ? data : {};
        let result = new TransportEquipmentBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentFK"] = this.equipmentFK ? this.equipmentFK.toJSON() : <any>null;
        data["equipmentId"] = this.equipmentId !== undefined ? this.equipmentId : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["timeBegin"] = this.timeBegin ? this.timeBegin.toISOString() : <any>null;
        data["timeEnd"] = this.timeEnd ? this.timeEnd.toISOString() : <any>null;
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        return data; 
    }
}

export interface ITransportEquipmentBean {
    /** Связанный с транспортом трекер */
    equipmentFK?: EquipmentBean | null;
    /** ID GPS-трекера */
    equipmentId?: number | null;
    /** ID */
    id?: number | null;
    /** Наименование трекера */
    timeBegin?: Date | null;
    /** Наименование трекера */
    timeEnd?: Date | null;
    /** ID транспорта */
    vehicleId?: number | null;
}

export class PairOfBrigadeBeanAndListOfMapOfstringAndobject implements IPairOfBrigadeBeanAndListOfMapOfstringAndobject {
    first?: BrigadeBean | null;
    second?: { [key: string] : any; }[] | null;

    constructor(data?: IPairOfBrigadeBeanAndListOfMapOfstringAndobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? BrigadeBean.fromJS(data["first"]) : <any>null;
            if (data["second"] && data["second"].constructor === Array) {
                this.second = [];
                for (let item of data["second"])
                    this.second.push(item);
            }
        }
    }

    static fromJS(data: any): PairOfBrigadeBeanAndListOfMapOfstringAndobject {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfBrigadeBeanAndListOfMapOfstringAndobject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        if (this.second && this.second.constructor === Array) {
            data["second"] = [];
            for (let item of this.second)
                data["second"].push(item);
        }
        return data; 
    }
}

export interface IPairOfBrigadeBeanAndListOfMapOfstringAndobject {
    first?: BrigadeBean | null;
    second?: { [key: string] : any; }[] | null;
}

export class TherapyItemBean implements ITherapyItemBean {
    /** Количество использованных лекарств */
    count?: number | null;
    /** Лекарство */
    drugFK?: DrugNewBean | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Id терапии */
    therapyId?: number | null;
    /** Изделие */
    wareFK?: WareBean | null;

    constructor(data?: ITherapyItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.drugFK = data["drugFK"] ? DrugNewBean.fromJS(data["drugFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.therapyId = data["therapyId"] !== undefined ? data["therapyId"] : <any>null;
            this.wareFK = data["wareFK"] ? WareBean.fromJS(data["wareFK"]) : <any>null;
        }
    }

    static fromJS(data: any): TherapyItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["drugFK"] = this.drugFK ? this.drugFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["therapyId"] = this.therapyId !== undefined ? this.therapyId : <any>null;
        data["wareFK"] = this.wareFK ? this.wareFK.toJSON() : <any>null;
        return data; 
    }
}

export interface ITherapyItemBean {
    /** Количество использованных лекарств */
    count?: number | null;
    /** Лекарство */
    drugFK?: DrugNewBean | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Id терапии */
    therapyId?: number | null;
    /** Изделие */
    wareFK?: WareBean | null;
}

export class CallBean implements ICallBean {
    /** Адрес вызова (город, улица и пр.) */
    address?: string | null;
    /** Заявка на использование ссанавиации */
    aviaRequest?: AviaRequestBean | null;
    /** Дата/время вызова */
    date?: Date | null;
    /** Ф.И.О. заявителя */
    declarantName?: string | null;
    /** Номер телефона заявителя */
    declarantPhone?: string | null;
    /** Тип заявителя */
    declarantTypeFK?: ReferenceTypeBean | null;
    /** чрезвычайная ситуация */
    emergencySituation?: number | null;
    /** Код домофона */
    entranceCode?: string | null;
    /** Номер подъезда */
    entranceNum?: string | null;
    /** Адрес вызова (номер квартиры) */
    flatNum?: string | null;
    /** Адрес вызова (номер дома) */
    houseNum?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Признак ЧС */
    isEmergency?: boolean | null;
    /** Местоположение */
    location?: string | null;
    /** № вызова */
    number?: string | null;
    /** Список пациентов, привязанных к вызову */
    patientList?: PatientTemplateBean[] | null;
    /** Сотрудник, принявший вызов */
    performer?: number | null;
    /** Сотрудник, принимающий вызов */
    performerFK?: PerformerBean | null;
    /** Тип места вызова */
    placeTypeFK?: ReferenceTypeBean | null;
    /** ID первичного вызова (только для повторных) */
    primaryCall?: number | null;
    /** Приоритет */
    priority?: number | null;
    /** Комментарий к причине вызова */
    reasonComment?: string | null;
    /** Причина вызова */
    reasonFK?: InquirerBean | null;
    /** ID SIP-сессии */
    sessionId?: string | null;
    /** Статус */
    status?: number | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Тип вызова */
    typeFK?: ReferenceTypeBean | null;
    /** Карта укио */
    ukioCardBean?: UkioCardBean | null;

    constructor(data?: ICallBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.aviaRequest = data["aviaRequest"] ? AviaRequestBean.fromJS(data["aviaRequest"]) : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.declarantName = data["declarantName"] !== undefined ? data["declarantName"] : <any>null;
            this.declarantPhone = data["declarantPhone"] !== undefined ? data["declarantPhone"] : <any>null;
            this.declarantTypeFK = data["declarantTypeFK"] ? ReferenceTypeBean.fromJS(data["declarantTypeFK"]) : <any>null;
            this.emergencySituation = data["emergencySituation"] !== undefined ? data["emergencySituation"] : <any>null;
            this.entranceCode = data["entranceCode"] !== undefined ? data["entranceCode"] : <any>null;
            this.entranceNum = data["entranceNum"] !== undefined ? data["entranceNum"] : <any>null;
            this.flatNum = data["flatNum"] !== undefined ? data["flatNum"] : <any>null;
            this.houseNum = data["houseNum"] !== undefined ? data["houseNum"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.isEmergency = data["isEmergency"] !== undefined ? data["isEmergency"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            if (data["patientList"] && data["patientList"].constructor === Array) {
                this.patientList = [];
                for (let item of data["patientList"])
                    this.patientList.push(PatientTemplateBean.fromJS(item));
            }
            this.performer = data["performer"] !== undefined ? data["performer"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.placeTypeFK = data["placeTypeFK"] ? ReferenceTypeBean.fromJS(data["placeTypeFK"]) : <any>null;
            this.primaryCall = data["primaryCall"] !== undefined ? data["primaryCall"] : <any>null;
            this.priority = data["priority"] !== undefined ? data["priority"] : <any>null;
            this.reasonComment = data["reasonComment"] !== undefined ? data["reasonComment"] : <any>null;
            this.reasonFK = data["reasonFK"] ? InquirerBean.fromJS(data["reasonFK"]) : <any>null;
            this.sessionId = data["sessionId"] !== undefined ? data["sessionId"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.typeFK = data["typeFK"] ? ReferenceTypeBean.fromJS(data["typeFK"]) : <any>null;
            this.ukioCardBean = data["ukioCardBean"] ? UkioCardBean.fromJS(data["ukioCardBean"]) : <any>null;
        }
    }

    static fromJS(data: any): CallBean {
        data = typeof data === 'object' ? data : {};
        let result = new CallBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["aviaRequest"] = this.aviaRequest ? this.aviaRequest.toJSON() : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["declarantName"] = this.declarantName !== undefined ? this.declarantName : <any>null;
        data["declarantPhone"] = this.declarantPhone !== undefined ? this.declarantPhone : <any>null;
        data["declarantTypeFK"] = this.declarantTypeFK ? this.declarantTypeFK.toJSON() : <any>null;
        data["emergencySituation"] = this.emergencySituation !== undefined ? this.emergencySituation : <any>null;
        data["entranceCode"] = this.entranceCode !== undefined ? this.entranceCode : <any>null;
        data["entranceNum"] = this.entranceNum !== undefined ? this.entranceNum : <any>null;
        data["flatNum"] = this.flatNum !== undefined ? this.flatNum : <any>null;
        data["houseNum"] = this.houseNum !== undefined ? this.houseNum : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["isEmergency"] = this.isEmergency !== undefined ? this.isEmergency : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        if (this.patientList && this.patientList.constructor === Array) {
            data["patientList"] = [];
            for (let item of this.patientList)
                data["patientList"].push(item.toJSON());
        }
        data["performer"] = this.performer !== undefined ? this.performer : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["placeTypeFK"] = this.placeTypeFK ? this.placeTypeFK.toJSON() : <any>null;
        data["primaryCall"] = this.primaryCall !== undefined ? this.primaryCall : <any>null;
        data["priority"] = this.priority !== undefined ? this.priority : <any>null;
        data["reasonComment"] = this.reasonComment !== undefined ? this.reasonComment : <any>null;
        data["reasonFK"] = this.reasonFK ? this.reasonFK.toJSON() : <any>null;
        data["sessionId"] = this.sessionId !== undefined ? this.sessionId : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        data["ukioCardBean"] = this.ukioCardBean ? this.ukioCardBean.toJSON() : <any>null;
        return data; 
    }
}

export interface ICallBean {
    /** Адрес вызова (город, улица и пр.) */
    address?: string | null;
    /** Заявка на использование ссанавиации */
    aviaRequest?: AviaRequestBean | null;
    /** Дата/время вызова */
    date?: Date | null;
    /** Ф.И.О. заявителя */
    declarantName?: string | null;
    /** Номер телефона заявителя */
    declarantPhone?: string | null;
    /** Тип заявителя */
    declarantTypeFK?: ReferenceTypeBean | null;
    /** чрезвычайная ситуация */
    emergencySituation?: number | null;
    /** Код домофона */
    entranceCode?: string | null;
    /** Номер подъезда */
    entranceNum?: string | null;
    /** Адрес вызова (номер квартиры) */
    flatNum?: string | null;
    /** Адрес вызова (номер дома) */
    houseNum?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Признак ЧС */
    isEmergency?: boolean | null;
    /** Местоположение */
    location?: string | null;
    /** № вызова */
    number?: string | null;
    /** Список пациентов, привязанных к вызову */
    patientList?: PatientTemplateBean[] | null;
    /** Сотрудник, принявший вызов */
    performer?: number | null;
    /** Сотрудник, принимающий вызов */
    performerFK?: PerformerBean | null;
    /** Тип места вызова */
    placeTypeFK?: ReferenceTypeBean | null;
    /** ID первичного вызова (только для повторных) */
    primaryCall?: number | null;
    /** Приоритет */
    priority?: number | null;
    /** Комментарий к причине вызова */
    reasonComment?: string | null;
    /** Причина вызова */
    reasonFK?: InquirerBean | null;
    /** ID SIP-сессии */
    sessionId?: string | null;
    /** Статус */
    status?: number | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Тип вызова */
    typeFK?: ReferenceTypeBean | null;
    /** Карта укио */
    ukioCardBean?: UkioCardBean | null;
}

export class ListContainerOfBagNewBean implements IListContainerOfBagNewBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBagNewBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBagNewBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBagNewBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBagNewBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class SubdivisionTypeBean implements ISubdivisionTypeBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    parentId?: number | null;

    constructor(data?: ISubdivisionTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        return data; 
    }
}

export interface ISubdivisionTypeBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    parentId?: number | null;
}

export class BagNewBean implements IBagNewBean {
    /** бригада которой выдана укладка/набор */
    brigadeBeanFK?: BrigadeBean | null;
    /** id бригады */
    brigadeId?: number | null;
    /** препараты в укладке */
    drugsInBagBeanFK?: DrugsInBagBean[] | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название шаблона */
    name?: string | null;
    /** прочие средства в укладке */
    othersInBagBeanFK?: OthersInBagBean[] | null;
    /** изделия в укладке */
    waresInBagBeanFK?: WaresInBagBean[] | null;

    constructor(data?: IBagNewBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeBeanFK = data["brigadeBeanFK"] ? BrigadeBean.fromJS(data["brigadeBeanFK"]) : <any>null;
            this.brigadeId = data["brigadeId"] !== undefined ? data["brigadeId"] : <any>null;
            if (data["drugsInBagBeanFK"] && data["drugsInBagBeanFK"].constructor === Array) {
                this.drugsInBagBeanFK = [];
                for (let item of data["drugsInBagBeanFK"])
                    this.drugsInBagBeanFK.push(DrugsInBagBean.fromJS(item));
            }
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["othersInBagBeanFK"] && data["othersInBagBeanFK"].constructor === Array) {
                this.othersInBagBeanFK = [];
                for (let item of data["othersInBagBeanFK"])
                    this.othersInBagBeanFK.push(OthersInBagBean.fromJS(item));
            }
            if (data["waresInBagBeanFK"] && data["waresInBagBeanFK"].constructor === Array) {
                this.waresInBagBeanFK = [];
                for (let item of data["waresInBagBeanFK"])
                    this.waresInBagBeanFK.push(WaresInBagBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BagNewBean {
        data = typeof data === 'object' ? data : {};
        let result = new BagNewBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeBeanFK"] = this.brigadeBeanFK ? this.brigadeBeanFK.toJSON() : <any>null;
        data["brigadeId"] = this.brigadeId !== undefined ? this.brigadeId : <any>null;
        if (this.drugsInBagBeanFK && this.drugsInBagBeanFK.constructor === Array) {
            data["drugsInBagBeanFK"] = [];
            for (let item of this.drugsInBagBeanFK)
                data["drugsInBagBeanFK"].push(item.toJSON());
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.othersInBagBeanFK && this.othersInBagBeanFK.constructor === Array) {
            data["othersInBagBeanFK"] = [];
            for (let item of this.othersInBagBeanFK)
                data["othersInBagBeanFK"].push(item.toJSON());
        }
        if (this.waresInBagBeanFK && this.waresInBagBeanFK.constructor === Array) {
            data["waresInBagBeanFK"] = [];
            for (let item of this.waresInBagBeanFK)
                data["waresInBagBeanFK"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBagNewBean {
    /** бригада которой выдана укладка/набор */
    brigadeBeanFK?: BrigadeBean | null;
    /** id бригады */
    brigadeId?: number | null;
    /** препараты в укладке */
    drugsInBagBeanFK?: DrugsInBagBean[] | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название шаблона */
    name?: string | null;
    /** прочие средства в укладке */
    othersInBagBeanFK?: OthersInBagBean[] | null;
    /** изделия в укладке */
    waresInBagBeanFK?: WaresInBagBean[] | null;
}

export class ClassMkbBean implements IClassMkbBean {
    additionalInfo?: string | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parentCode?: string | null;
    parentFK?: ClassMkbBean | null;
    parentId?: number | null;

    constructor(data?: IClassMkbBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionalInfo = data["additionalInfo"] !== undefined ? data["additionalInfo"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nodeCount = data["nodeCount"] !== undefined ? data["nodeCount"] : <any>null;
            this.parentCode = data["parentCode"] !== undefined ? data["parentCode"] : <any>null;
            this.parentFK = data["parentFK"] ? ClassMkbBean.fromJS(data["parentFK"]) : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
        }
    }

    static fromJS(data: any): ClassMkbBean {
        data = typeof data === 'object' ? data : {};
        let result = new ClassMkbBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalInfo"] = this.additionalInfo !== undefined ? this.additionalInfo : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nodeCount"] = this.nodeCount !== undefined ? this.nodeCount : <any>null;
        data["parentCode"] = this.parentCode !== undefined ? this.parentCode : <any>null;
        data["parentFK"] = this.parentFK ? this.parentFK.toJSON() : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        return data; 
    }
}

export interface IClassMkbBean {
    additionalInfo?: string | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parentCode?: string | null;
    parentFK?: ClassMkbBean | null;
    parentId?: number | null;
}

export class UkioRegionBean implements IUkioRegionBean {
    /** ID */
    id?: number | null;
    /** код региона */
    regionCode?: string | null;
    /** название региона */
    regionName?: string | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;

    constructor(data?: IUkioRegionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.regionCode = data["regionCode"] !== undefined ? data["regionCode"] : <any>null;
            this.regionName = data["regionName"] !== undefined ? data["regionName"] : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
            this.ukioMessageId = data["ukioMessageId"] !== undefined ? data["ukioMessageId"] : <any>null;
        }
    }

    static fromJS(data: any): UkioRegionBean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioRegionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["regionCode"] = this.regionCode !== undefined ? this.regionCode : <any>null;
        data["regionName"] = this.regionName !== undefined ? this.regionName : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        data["ukioMessageId"] = this.ukioMessageId !== undefined ? this.ukioMessageId : <any>null;
        return data; 
    }
}

export interface IUkioRegionBean {
    /** ID */
    id?: number | null;
    /** код региона */
    regionCode?: string | null;
    /** название региона */
    regionName?: string | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** id сообщения */
    ukioMessageId?: string | null;
}

export class TherapyBean implements ITherapyBean {
    /** Дата */
    date?: Date | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** На месте/при транспортировке (t/f) */
    isLocal?: boolean | null;
    /** Id CardResult */
    resultId?: number | null;
    /** Описание */
    text?: string | null;
    /** Список принятых мер с использованием лекарств */
    therapyItemList?: TherapyItemBean[] | null;

    constructor(data?: ITherapyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.isLocal = data["isLocal"] !== undefined ? data["isLocal"] : <any>null;
            this.resultId = data["resultId"] !== undefined ? data["resultId"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            if (data["therapyItemList"] && data["therapyItemList"].constructor === Array) {
                this.therapyItemList = [];
                for (let item of data["therapyItemList"])
                    this.therapyItemList.push(TherapyItemBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TherapyBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["isLocal"] = this.isLocal !== undefined ? this.isLocal : <any>null;
        data["resultId"] = this.resultId !== undefined ? this.resultId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        if (this.therapyItemList && this.therapyItemList.constructor === Array) {
            data["therapyItemList"] = [];
            for (let item of this.therapyItemList)
                data["therapyItemList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITherapyBean {
    /** Дата */
    date?: Date | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** На месте/при транспортировке (t/f) */
    isLocal?: boolean | null;
    /** Id CardResult */
    resultId?: number | null;
    /** Описание */
    text?: string | null;
    /** Список принятых мер с использованием лекарств */
    therapyItemList?: TherapyItemBean[] | null;
}

export class ListContainerOfUnitNewBean implements IListContainerOfUnitNewBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfUnitNewBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfUnitNewBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfUnitNewBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfUnitNewBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainer implements IListContainer {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainer {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainer {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfBrigadeStatusBean implements IListContainerOfBrigadeStatusBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBrigadeStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBrigadeStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBrigadeStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBrigadeStatusBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class Pair implements IPair {
    first?: any | null;
    second?: any | null;

    constructor(data?: IPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] !== undefined ? data["first"] : <any>null;
            this.second = data["second"] !== undefined ? data["second"] : <any>null;
        }
    }

    static fromJS(data: any): Pair {
        data = typeof data === 'object' ? data : {};
        let result = new Pair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first !== undefined ? this.first : <any>null;
        data["second"] = this.second !== undefined ? this.second : <any>null;
        return data; 
    }
}

export interface IPair {
    first?: any | null;
    second?: any | null;
}

export class DrugsInBagBean implements IDrugsInBagBean {
    /** ID укладки */
    bagId?: number | null;
    /** препарат */
    drugFK?: DrugNewBean | null;
    /** ID препарата */
    drugId?: number | null;
    /** кол-во препарата */
    volume?: number | null;

    constructor(data?: IDrugsInBagBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bagId = data["bagId"] !== undefined ? data["bagId"] : <any>null;
            this.drugFK = data["drugFK"] ? DrugNewBean.fromJS(data["drugFK"]) : <any>null;
            this.drugId = data["drugId"] !== undefined ? data["drugId"] : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
        }
    }

    static fromJS(data: any): DrugsInBagBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugsInBagBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bagId"] = this.bagId !== undefined ? this.bagId : <any>null;
        data["drugFK"] = this.drugFK ? this.drugFK.toJSON() : <any>null;
        data["drugId"] = this.drugId !== undefined ? this.drugId : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        return data; 
    }
}

export interface IDrugsInBagBean {
    /** ID укладки */
    bagId?: number | null;
    /** препарат */
    drugFK?: DrugNewBean | null;
    /** ID препарата */
    drugId?: number | null;
    /** кол-во препарата */
    volume?: number | null;
}

export class TherapyTemplateBean implements ITherapyTemplateBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Комментарий */
    text?: string | null;

    constructor(data?: ITherapyTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Комментарий */
    text?: string | null;
}

export class BrigadeStatusBean implements IBrigadeStatusBean {
    code?: string | null;
    id?: number | null;
    /** Признак возможности использования бригады */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IBrigadeStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAvailable = data["isAvailable"] !== undefined ? data["isAvailable"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeStatusBean {
    code?: string | null;
    id?: number | null;
    /** Признак возможности использования бригады */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfDrugGroupBean implements IListContainerOfDrugGroupBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfDrugGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfDrugGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfDrugGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfDrugGroupBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfBrigadeBean implements IListContainerOfBrigadeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBrigadeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBrigadeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBrigadeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBrigadeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class PatientTemplateBean implements IPatientTemplateBean {
    /** Возраст (полных дней) */
    ageDays?: number | null;
    /** Возраст (полных месяцев) */
    ageMonths?: number | null;
    /** Возраст (полных лет) */
    ageYears?: number | null;
    /** Дата рождения */
    birthday?: Date | null;
    /** ID звонка */
    call?: number | null;
    /** Гендер (кладу болт на различие между гендером и полом уже второй раз!) */
    gender?: boolean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Тип пациента */
    patientTypeFK?: ReferenceTypeBean | null;
    /** Отчетство */
    patronymic?: string | null;
    /** Фамилия */
    surname?: string | null;

    constructor(data?: IPatientTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ageDays = data["ageDays"] !== undefined ? data["ageDays"] : <any>null;
            this.ageMonths = data["ageMonths"] !== undefined ? data["ageMonths"] : <any>null;
            this.ageYears = data["ageYears"] !== undefined ? data["ageYears"] : <any>null;
            this.birthday = data["birthday"] ? new Date(data["birthday"].toString()) : <any>null;
            this.call = data["call"] !== undefined ? data["call"] : <any>null;
            this.gender = data["gender"] !== undefined ? data["gender"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.patientTypeFK = data["patientTypeFK"] ? ReferenceTypeBean.fromJS(data["patientTypeFK"]) : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
        }
    }

    static fromJS(data: any): PatientTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new PatientTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageDays"] = this.ageDays !== undefined ? this.ageDays : <any>null;
        data["ageMonths"] = this.ageMonths !== undefined ? this.ageMonths : <any>null;
        data["ageYears"] = this.ageYears !== undefined ? this.ageYears : <any>null;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>null;
        data["call"] = this.call !== undefined ? this.call : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["patientTypeFK"] = this.patientTypeFK ? this.patientTypeFK.toJSON() : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        return data; 
    }
}

export interface IPatientTemplateBean {
    /** Возраст (полных дней) */
    ageDays?: number | null;
    /** Возраст (полных месяцев) */
    ageMonths?: number | null;
    /** Возраст (полных лет) */
    ageYears?: number | null;
    /** Дата рождения */
    birthday?: Date | null;
    /** ID звонка */
    call?: number | null;
    /** Гендер (кладу болт на различие между гендером и полом уже второй раз!) */
    gender?: boolean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Тип пациента */
    patientTypeFK?: ReferenceTypeBean | null;
    /** Отчетство */
    patronymic?: string | null;
    /** Фамилия */
    surname?: string | null;
}

export class SubdivisionBean implements ISubdivisionBean {
    code?: string | null;
    district?: string | null;
    email?: string | null;
    /** Список вертолетных площадок подразделения */
    helipadList?: HelipadBean[] | null;
    houseNumber?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    parentId?: number | null;
    phone?: string | null;
    settlement?: string | null;
    shortName?: string | null;
    street?: string | null;
    /** Список специализаций подразделения */
    subdivisionSpecializationBeanList?: SubdivisionSpecializationBean[] | null;
    type?: number | null;
    /** Тип подразделения */
    typeFK?: SubdivisionTypeBean | null;
    website?: string | null;

    constructor(data?: ISubdivisionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            if (data["helipadList"] && data["helipadList"].constructor === Array) {
                this.helipadList = [];
                for (let item of data["helipadList"])
                    this.helipadList.push(HelipadBean.fromJS(item));
            }
            this.houseNumber = data["houseNumber"] !== undefined ? data["houseNumber"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.settlement = data["settlement"] !== undefined ? data["settlement"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            this.street = data["street"] !== undefined ? data["street"] : <any>null;
            if (data["subdivisionSpecializationBeanList"] && data["subdivisionSpecializationBeanList"].constructor === Array) {
                this.subdivisionSpecializationBeanList = [];
                for (let item of data["subdivisionSpecializationBeanList"])
                    this.subdivisionSpecializationBeanList.push(SubdivisionSpecializationBean.fromJS(item));
            }
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeFK = data["typeFK"] ? SubdivisionTypeBean.fromJS(data["typeFK"]) : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionBean {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        if (this.helipadList && this.helipadList.constructor === Array) {
            data["helipadList"] = [];
            for (let item of this.helipadList)
                data["helipadList"].push(item.toJSON());
        }
        data["houseNumber"] = this.houseNumber !== undefined ? this.houseNumber : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["settlement"] = this.settlement !== undefined ? this.settlement : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        data["street"] = this.street !== undefined ? this.street : <any>null;
        if (this.subdivisionSpecializationBeanList && this.subdivisionSpecializationBeanList.constructor === Array) {
            data["subdivisionSpecializationBeanList"] = [];
            for (let item of this.subdivisionSpecializationBeanList)
                data["subdivisionSpecializationBeanList"].push(item.toJSON());
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        return data; 
    }
}

export interface ISubdivisionBean {
    code?: string | null;
    district?: string | null;
    email?: string | null;
    /** Список вертолетных площадок подразделения */
    helipadList?: HelipadBean[] | null;
    houseNumber?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    parentId?: number | null;
    phone?: string | null;
    settlement?: string | null;
    shortName?: string | null;
    street?: string | null;
    /** Список специализаций подразделения */
    subdivisionSpecializationBeanList?: SubdivisionSpecializationBean[] | null;
    type?: number | null;
    /** Тип подразделения */
    typeFK?: SubdivisionTypeBean | null;
    website?: string | null;
}

export class UkioCardBean implements IUkioCardBean {
    /** id карты вызова в ТЦМК */
    callCardId?: number | null;
    /** Уникальный идентификатор УКИО в системе-112 */
    cardID?: string | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** Статусы обработки карты */
    listUkioCardStatusBeanFK?: UkioCardStatusBean[] | null;
    /** Сообщения касающиеся карточки */
    listUkioMessageBeanFK?: UkioMessageBean[] | null;
    /** Обновления карты поступающие от 103 в 112 */
    listUkioUpdateFrom103BeanFK?: UkioUpdateFrom103Bean[] | null;

    constructor(data?: IUkioCardBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.callCardId = data["callCardId"] !== undefined ? data["callCardId"] : <any>null;
            this.cardID = data["cardID"] !== undefined ? data["cardID"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            if (data["listUkioCardStatusBeanFK"] && data["listUkioCardStatusBeanFK"].constructor === Array) {
                this.listUkioCardStatusBeanFK = [];
                for (let item of data["listUkioCardStatusBeanFK"])
                    this.listUkioCardStatusBeanFK.push(UkioCardStatusBean.fromJS(item));
            }
            if (data["listUkioMessageBeanFK"] && data["listUkioMessageBeanFK"].constructor === Array) {
                this.listUkioMessageBeanFK = [];
                for (let item of data["listUkioMessageBeanFK"])
                    this.listUkioMessageBeanFK.push(UkioMessageBean.fromJS(item));
            }
            if (data["listUkioUpdateFrom103BeanFK"] && data["listUkioUpdateFrom103BeanFK"].constructor === Array) {
                this.listUkioUpdateFrom103BeanFK = [];
                for (let item of data["listUkioUpdateFrom103BeanFK"])
                    this.listUkioUpdateFrom103BeanFK.push(UkioUpdateFrom103Bean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UkioCardBean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioCardBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["callCardId"] = this.callCardId !== undefined ? this.callCardId : <any>null;
        data["cardID"] = this.cardID !== undefined ? this.cardID : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        if (this.listUkioCardStatusBeanFK && this.listUkioCardStatusBeanFK.constructor === Array) {
            data["listUkioCardStatusBeanFK"] = [];
            for (let item of this.listUkioCardStatusBeanFK)
                data["listUkioCardStatusBeanFK"].push(item.toJSON());
        }
        if (this.listUkioMessageBeanFK && this.listUkioMessageBeanFK.constructor === Array) {
            data["listUkioMessageBeanFK"] = [];
            for (let item of this.listUkioMessageBeanFK)
                data["listUkioMessageBeanFK"].push(item.toJSON());
        }
        if (this.listUkioUpdateFrom103BeanFK && this.listUkioUpdateFrom103BeanFK.constructor === Array) {
            data["listUkioUpdateFrom103BeanFK"] = [];
            for (let item of this.listUkioUpdateFrom103BeanFK)
                data["listUkioUpdateFrom103BeanFK"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUkioCardBean {
    /** id карты вызова в ТЦМК */
    callCardId?: number | null;
    /** Уникальный идентификатор УКИО в системе-112 */
    cardID?: string | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** Статусы обработки карты */
    listUkioCardStatusBeanFK?: UkioCardStatusBean[] | null;
    /** Сообщения касающиеся карточки */
    listUkioMessageBeanFK?: UkioMessageBean[] | null;
    /** Обновления карты поступающие от 103 в 112 */
    listUkioUpdateFrom103BeanFK?: UkioUpdateFrom103Bean[] | null;
}

export class DrugGroupBean implements IDrugGroupBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IDrugGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DrugGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDrugGroupBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class DrugNewBean implements IDrugNewBean {
    /** атх препарата */
    athBeanFK?: AthBean | null;
    /** форма препарата */
    drugFormBeanFK?: DrugFormBean | null;
    /** лекарственный препарат */
    drugTypeBeanFK?: DrugTypeBean | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название продукта */
    name?: string | null;
    /** единица измеренеия препарата */
    unitNewBeanFK?: UnitNewBean | null;

    constructor(data?: IDrugNewBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.athBeanFK = data["athBeanFK"] ? AthBean.fromJS(data["athBeanFK"]) : <any>null;
            this.drugFormBeanFK = data["drugFormBeanFK"] ? DrugFormBean.fromJS(data["drugFormBeanFK"]) : <any>null;
            this.drugTypeBeanFK = data["drugTypeBeanFK"] ? DrugTypeBean.fromJS(data["drugTypeBeanFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.unitNewBeanFK = data["unitNewBeanFK"] ? UnitNewBean.fromJS(data["unitNewBeanFK"]) : <any>null;
        }
    }

    static fromJS(data: any): DrugNewBean {
        data = typeof data === 'object' ? data : {};
        let result = new DrugNewBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["athBeanFK"] = this.athBeanFK ? this.athBeanFK.toJSON() : <any>null;
        data["drugFormBeanFK"] = this.drugFormBeanFK ? this.drugFormBeanFK.toJSON() : <any>null;
        data["drugTypeBeanFK"] = this.drugTypeBeanFK ? this.drugTypeBeanFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["unitNewBeanFK"] = this.unitNewBeanFK ? this.unitNewBeanFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IDrugNewBean {
    /** атх препарата */
    athBeanFK?: AthBean | null;
    /** форма препарата */
    drugFormBeanFK?: DrugFormBean | null;
    /** лекарственный препарат */
    drugTypeBeanFK?: DrugTypeBean | null;
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** название продукта */
    name?: string | null;
    /** единица измеренеия препарата */
    unitNewBeanFK?: UnitNewBean | null;
}

export class UnitNewBean implements IUnitNewBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** единицы измерения */
    name?: string | null;
    /** какому продукту пренадлежит измерение */
    product?: string | null;

    constructor(data?: IUnitNewBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.product = data["product"] !== undefined ? data["product"] : <any>null;
        }
    }

    static fromJS(data: any): UnitNewBean {
        data = typeof data === 'object' ? data : {};
        let result = new UnitNewBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["product"] = this.product !== undefined ? this.product : <any>null;
        return data; 
    }
}

export interface IUnitNewBean {
    /** ID */
    id?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** единицы измерения */
    name?: string | null;
    /** какому продукту пренадлежит измерение */
    product?: string | null;
}

export class ListContainerOfScheduleTypeBean implements IListContainerOfScheduleTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfScheduleTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfScheduleTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfScheduleTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfScheduleTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class UkioMessageBean implements IUkioMessageBean {
    /** Точность вычисления координат */
    accuracy?: number | null;
    /** Оператор системы 112, который зарегистрировал УКИО */
    actorInfo?: string | null;
    /** Признак чрезвычайной ситуации 
Допустимые значения:
«0» – Нет угрозы ЧС;
«1» – Угроза ЧС;
«2» – ЧС
 */
    additionalIncidentInformation?: string | null;
    /** Дополнительная информация к адресу. При необходимости, содержит информацию о перекрестке */
    additionalInfo?: string | null;
    /** Именованный участок местности, не имеющий адреса в классическом виде */
    addressName?: string | null;
    /** Литера или корпус дома */
    building?: string | null;
    /** Дата-время поступления вызова */
    callDateTime?: string | null;
    /** Идентификатор телефонного вызова, с которым передано сообщение о происшествии */
    callId?: string | null;
    /** Тип вызова.
Допустимые значения:
CALL – автоматическое создание УКИО при поступлении входящего телефонного вызова на номер 112;
HAND – ручное создание УКИО сотрудником системы-112;
GLONASS – автоматическое создание УКИО при приеме сообщения от системы «ЭРА-ГЛОНАСС»;
SMS – автоматическое создание УКИО при поступлении входящего СМС сообщения на номер 112.
 */
    callType?: string | null;
    /** Уникальный идентификатор УКИО в системе-112 */
    cardId?: string | null;
    /** Номер телефона (АОН) заявителя. 
Не передается для карточек, созданных в ручном режиме (без звонка заявителя)
 */
    cardInfoPhone?: string | null;
    /** Номер строения */
    construction?: string | null;
    /** Не передается */
    crossStreetId?: string | null;
    /** Не передается */
    crossStreetName?: string | null;
    /** догадайся */
    emergencySituation?: number | null;
    /** Номер подъезда */
    entrance?: string | null;
    /** Код с примечанием (в подъезд, во двор, код домофона и т.п.) */
    entranceCode?: string | null;
    /** Данные полученые с ЭРА ГЛОНАСС */
    eraInfoBeanFK?: EraInfoBean | null;
    /** Номер владение */
    estate?: string | null;
    /** Номер дома */
    house?: string | null;
    /** ФИАС идентификатор дома, включая корпус, строение, владение и пр. */
    houseId?: string | null;
    /** ID */
    id?: number | null;
    /** Код вида происшествия */
    incidentCode?: string | null;
    /** Описание происшествия */
    incidentDescription?: string | null;
    /** Наименование вида происшествия */
    incidentName?: string | null;
    /** Количество пострадавших */
    injuredPeople?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** Километр дороги, трассы, шоссе */
    kilometer?: string | null;
    /** Широта */
    latitude?: string | null;
    /** Номер этажа (подвальные этажи указываются отрицательными числами) */
    level?: string | null;
    /** Данные о происшествии */
    listInteriorBeanFK?: InteriorBean[] | null;
    /** Данные о пациентах */
    listUkioPatientBeanFK?: UkioPatientBean[] | null;
    /** Места происшествий */
    listUkioRegionBeanFK?: UkioRegionBean[] | null;
    /** Долгота */
    longitude?: string | null;
    /** Уникальный идентификатор запроса из системы-112 в ИС 103  */
    messageId?: string | null;
    /** Тип сообщения */
    messageType?: string | null;
    /** Уточнение места происшествия на дороге с точностью до 100 м. */
    meter?: string | null;
    /** Флаг, уточняющий, что фактическое расположение находится рядом с указанным местом */
    near?: string | null;
    /** Количество умерших */
    numberOfDeaths?: number | null;
    /** Именованный объект, который известен в местности расположения не по адресу, а по названию (например, «Плющихинский Химзавод») */
    objectName?: string | null;
    /** id родительской карты */
    parentCardID?: string | null;
    /** Ссылка на файл с записью разговора оператора системы 112 и заявителя */
    recordURL?: string | null;
    /** Код региона */
    regionCode?: string | null;
    /** Наименование региона */
    regionName?: string | null;
    /** Название дороги, трассы, шоссе */
    road?: string | null;
    /** Номер квартира или офиса */
    room?: string | null;
    /** отправитель сообщения */
    sender?: string | null;
    /** ФИАС идентификатор улицы */
    streetId?: string | null;
    /** Название улицы, название населенного пункта, название района */
    streetName?: string | null;
    /** время получения сообщения */
    time?: Date | null;
    /** Данные о заявителе */
    ukioCallerInfoBeanFK?: UkioCallerInfoBean | null;
    /** Полученое/отправленое сообщение */
    xmlMessage?: string | null;

    constructor(data?: IUkioMessageBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accuracy = data["accuracy"] !== undefined ? data["accuracy"] : <any>null;
            this.actorInfo = data["actorInfo"] !== undefined ? data["actorInfo"] : <any>null;
            this.additionalIncidentInformation = data["additionalIncidentInformation"] !== undefined ? data["additionalIncidentInformation"] : <any>null;
            this.additionalInfo = data["additionalInfo"] !== undefined ? data["additionalInfo"] : <any>null;
            this.addressName = data["addressName"] !== undefined ? data["addressName"] : <any>null;
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.callDateTime = data["callDateTime"] !== undefined ? data["callDateTime"] : <any>null;
            this.callId = data["callId"] !== undefined ? data["callId"] : <any>null;
            this.callType = data["callType"] !== undefined ? data["callType"] : <any>null;
            this.cardId = data["cardId"] !== undefined ? data["cardId"] : <any>null;
            this.cardInfoPhone = data["cardInfoPhone"] !== undefined ? data["cardInfoPhone"] : <any>null;
            this.construction = data["construction"] !== undefined ? data["construction"] : <any>null;
            this.crossStreetId = data["crossStreetId"] !== undefined ? data["crossStreetId"] : <any>null;
            this.crossStreetName = data["crossStreetName"] !== undefined ? data["crossStreetName"] : <any>null;
            this.emergencySituation = data["emergencySituation"] !== undefined ? data["emergencySituation"] : <any>null;
            this.entrance = data["entrance"] !== undefined ? data["entrance"] : <any>null;
            this.entranceCode = data["entranceCode"] !== undefined ? data["entranceCode"] : <any>null;
            this.eraInfoBeanFK = data["eraInfoBeanFK"] ? EraInfoBean.fromJS(data["eraInfoBeanFK"]) : <any>null;
            this.estate = data["estate"] !== undefined ? data["estate"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.houseId = data["houseId"] !== undefined ? data["houseId"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.incidentCode = data["incidentCode"] !== undefined ? data["incidentCode"] : <any>null;
            this.incidentDescription = data["incidentDescription"] !== undefined ? data["incidentDescription"] : <any>null;
            this.incidentName = data["incidentName"] !== undefined ? data["incidentName"] : <any>null;
            this.injuredPeople = data["injuredPeople"] !== undefined ? data["injuredPeople"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.kilometer = data["kilometer"] !== undefined ? data["kilometer"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.level = data["level"] !== undefined ? data["level"] : <any>null;
            if (data["listInteriorBeanFK"] && data["listInteriorBeanFK"].constructor === Array) {
                this.listInteriorBeanFK = [];
                for (let item of data["listInteriorBeanFK"])
                    this.listInteriorBeanFK.push(InteriorBean.fromJS(item));
            }
            if (data["listUkioPatientBeanFK"] && data["listUkioPatientBeanFK"].constructor === Array) {
                this.listUkioPatientBeanFK = [];
                for (let item of data["listUkioPatientBeanFK"])
                    this.listUkioPatientBeanFK.push(UkioPatientBean.fromJS(item));
            }
            if (data["listUkioRegionBeanFK"] && data["listUkioRegionBeanFK"].constructor === Array) {
                this.listUkioRegionBeanFK = [];
                for (let item of data["listUkioRegionBeanFK"])
                    this.listUkioRegionBeanFK.push(UkioRegionBean.fromJS(item));
            }
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.messageId = data["messageId"] !== undefined ? data["messageId"] : <any>null;
            this.messageType = data["messageType"] !== undefined ? data["messageType"] : <any>null;
            this.meter = data["meter"] !== undefined ? data["meter"] : <any>null;
            this.near = data["near"] !== undefined ? data["near"] : <any>null;
            this.numberOfDeaths = data["numberOfDeaths"] !== undefined ? data["numberOfDeaths"] : <any>null;
            this.objectName = data["objectName"] !== undefined ? data["objectName"] : <any>null;
            this.parentCardID = data["parentCardID"] !== undefined ? data["parentCardID"] : <any>null;
            this.recordURL = data["recordURL"] !== undefined ? data["recordURL"] : <any>null;
            this.regionCode = data["regionCode"] !== undefined ? data["regionCode"] : <any>null;
            this.regionName = data["regionName"] !== undefined ? data["regionName"] : <any>null;
            this.road = data["road"] !== undefined ? data["road"] : <any>null;
            this.room = data["room"] !== undefined ? data["room"] : <any>null;
            this.sender = data["sender"] !== undefined ? data["sender"] : <any>null;
            this.streetId = data["streetId"] !== undefined ? data["streetId"] : <any>null;
            this.streetName = data["streetName"] !== undefined ? data["streetName"] : <any>null;
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>null;
            this.ukioCallerInfoBeanFK = data["ukioCallerInfoBeanFK"] ? UkioCallerInfoBean.fromJS(data["ukioCallerInfoBeanFK"]) : <any>null;
            this.xmlMessage = data["xmlMessage"] !== undefined ? data["xmlMessage"] : <any>null;
        }
    }

    static fromJS(data: any): UkioMessageBean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioMessageBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accuracy"] = this.accuracy !== undefined ? this.accuracy : <any>null;
        data["actorInfo"] = this.actorInfo !== undefined ? this.actorInfo : <any>null;
        data["additionalIncidentInformation"] = this.additionalIncidentInformation !== undefined ? this.additionalIncidentInformation : <any>null;
        data["additionalInfo"] = this.additionalInfo !== undefined ? this.additionalInfo : <any>null;
        data["addressName"] = this.addressName !== undefined ? this.addressName : <any>null;
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["callDateTime"] = this.callDateTime !== undefined ? this.callDateTime : <any>null;
        data["callId"] = this.callId !== undefined ? this.callId : <any>null;
        data["callType"] = this.callType !== undefined ? this.callType : <any>null;
        data["cardId"] = this.cardId !== undefined ? this.cardId : <any>null;
        data["cardInfoPhone"] = this.cardInfoPhone !== undefined ? this.cardInfoPhone : <any>null;
        data["construction"] = this.construction !== undefined ? this.construction : <any>null;
        data["crossStreetId"] = this.crossStreetId !== undefined ? this.crossStreetId : <any>null;
        data["crossStreetName"] = this.crossStreetName !== undefined ? this.crossStreetName : <any>null;
        data["emergencySituation"] = this.emergencySituation !== undefined ? this.emergencySituation : <any>null;
        data["entrance"] = this.entrance !== undefined ? this.entrance : <any>null;
        data["entranceCode"] = this.entranceCode !== undefined ? this.entranceCode : <any>null;
        data["eraInfoBeanFK"] = this.eraInfoBeanFK ? this.eraInfoBeanFK.toJSON() : <any>null;
        data["estate"] = this.estate !== undefined ? this.estate : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["houseId"] = this.houseId !== undefined ? this.houseId : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["incidentCode"] = this.incidentCode !== undefined ? this.incidentCode : <any>null;
        data["incidentDescription"] = this.incidentDescription !== undefined ? this.incidentDescription : <any>null;
        data["incidentName"] = this.incidentName !== undefined ? this.incidentName : <any>null;
        data["injuredPeople"] = this.injuredPeople !== undefined ? this.injuredPeople : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["kilometer"] = this.kilometer !== undefined ? this.kilometer : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["level"] = this.level !== undefined ? this.level : <any>null;
        if (this.listInteriorBeanFK && this.listInteriorBeanFK.constructor === Array) {
            data["listInteriorBeanFK"] = [];
            for (let item of this.listInteriorBeanFK)
                data["listInteriorBeanFK"].push(item.toJSON());
        }
        if (this.listUkioPatientBeanFK && this.listUkioPatientBeanFK.constructor === Array) {
            data["listUkioPatientBeanFK"] = [];
            for (let item of this.listUkioPatientBeanFK)
                data["listUkioPatientBeanFK"].push(item.toJSON());
        }
        if (this.listUkioRegionBeanFK && this.listUkioRegionBeanFK.constructor === Array) {
            data["listUkioRegionBeanFK"] = [];
            for (let item of this.listUkioRegionBeanFK)
                data["listUkioRegionBeanFK"].push(item.toJSON());
        }
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["messageId"] = this.messageId !== undefined ? this.messageId : <any>null;
        data["messageType"] = this.messageType !== undefined ? this.messageType : <any>null;
        data["meter"] = this.meter !== undefined ? this.meter : <any>null;
        data["near"] = this.near !== undefined ? this.near : <any>null;
        data["numberOfDeaths"] = this.numberOfDeaths !== undefined ? this.numberOfDeaths : <any>null;
        data["objectName"] = this.objectName !== undefined ? this.objectName : <any>null;
        data["parentCardID"] = this.parentCardID !== undefined ? this.parentCardID : <any>null;
        data["recordURL"] = this.recordURL !== undefined ? this.recordURL : <any>null;
        data["regionCode"] = this.regionCode !== undefined ? this.regionCode : <any>null;
        data["regionName"] = this.regionName !== undefined ? this.regionName : <any>null;
        data["road"] = this.road !== undefined ? this.road : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["sender"] = this.sender !== undefined ? this.sender : <any>null;
        data["streetId"] = this.streetId !== undefined ? this.streetId : <any>null;
        data["streetName"] = this.streetName !== undefined ? this.streetName : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        data["ukioCallerInfoBeanFK"] = this.ukioCallerInfoBeanFK ? this.ukioCallerInfoBeanFK.toJSON() : <any>null;
        data["xmlMessage"] = this.xmlMessage !== undefined ? this.xmlMessage : <any>null;
        return data; 
    }
}

export interface IUkioMessageBean {
    /** Точность вычисления координат */
    accuracy?: number | null;
    /** Оператор системы 112, который зарегистрировал УКИО */
    actorInfo?: string | null;
    /** Признак чрезвычайной ситуации 
Допустимые значения:
«0» – Нет угрозы ЧС;
«1» – Угроза ЧС;
«2» – ЧС
 */
    additionalIncidentInformation?: string | null;
    /** Дополнительная информация к адресу. При необходимости, содержит информацию о перекрестке */
    additionalInfo?: string | null;
    /** Именованный участок местности, не имеющий адреса в классическом виде */
    addressName?: string | null;
    /** Литера или корпус дома */
    building?: string | null;
    /** Дата-время поступления вызова */
    callDateTime?: string | null;
    /** Идентификатор телефонного вызова, с которым передано сообщение о происшествии */
    callId?: string | null;
    /** Тип вызова.
Допустимые значения:
CALL – автоматическое создание УКИО при поступлении входящего телефонного вызова на номер 112;
HAND – ручное создание УКИО сотрудником системы-112;
GLONASS – автоматическое создание УКИО при приеме сообщения от системы «ЭРА-ГЛОНАСС»;
SMS – автоматическое создание УКИО при поступлении входящего СМС сообщения на номер 112.
 */
    callType?: string | null;
    /** Уникальный идентификатор УКИО в системе-112 */
    cardId?: string | null;
    /** Номер телефона (АОН) заявителя. 
Не передается для карточек, созданных в ручном режиме (без звонка заявителя)
 */
    cardInfoPhone?: string | null;
    /** Номер строения */
    construction?: string | null;
    /** Не передается */
    crossStreetId?: string | null;
    /** Не передается */
    crossStreetName?: string | null;
    /** догадайся */
    emergencySituation?: number | null;
    /** Номер подъезда */
    entrance?: string | null;
    /** Код с примечанием (в подъезд, во двор, код домофона и т.п.) */
    entranceCode?: string | null;
    /** Данные полученые с ЭРА ГЛОНАСС */
    eraInfoBeanFK?: EraInfoBean | null;
    /** Номер владение */
    estate?: string | null;
    /** Номер дома */
    house?: string | null;
    /** ФИАС идентификатор дома, включая корпус, строение, владение и пр. */
    houseId?: string | null;
    /** ID */
    id?: number | null;
    /** Код вида происшествия */
    incidentCode?: string | null;
    /** Описание происшествия */
    incidentDescription?: string | null;
    /** Наименование вида происшествия */
    incidentName?: string | null;
    /** Количество пострадавших */
    injuredPeople?: number | null;
    /** признак удаления записи */
    isDeleted?: boolean | null;
    /** Километр дороги, трассы, шоссе */
    kilometer?: string | null;
    /** Широта */
    latitude?: string | null;
    /** Номер этажа (подвальные этажи указываются отрицательными числами) */
    level?: string | null;
    /** Данные о происшествии */
    listInteriorBeanFK?: InteriorBean[] | null;
    /** Данные о пациентах */
    listUkioPatientBeanFK?: UkioPatientBean[] | null;
    /** Места происшествий */
    listUkioRegionBeanFK?: UkioRegionBean[] | null;
    /** Долгота */
    longitude?: string | null;
    /** Уникальный идентификатор запроса из системы-112 в ИС 103  */
    messageId?: string | null;
    /** Тип сообщения */
    messageType?: string | null;
    /** Уточнение места происшествия на дороге с точностью до 100 м. */
    meter?: string | null;
    /** Флаг, уточняющий, что фактическое расположение находится рядом с указанным местом */
    near?: string | null;
    /** Количество умерших */
    numberOfDeaths?: number | null;
    /** Именованный объект, который известен в местности расположения не по адресу, а по названию (например, «Плющихинский Химзавод») */
    objectName?: string | null;
    /** id родительской карты */
    parentCardID?: string | null;
    /** Ссылка на файл с записью разговора оператора системы 112 и заявителя */
    recordURL?: string | null;
    /** Код региона */
    regionCode?: string | null;
    /** Наименование региона */
    regionName?: string | null;
    /** Название дороги, трассы, шоссе */
    road?: string | null;
    /** Номер квартира или офиса */
    room?: string | null;
    /** отправитель сообщения */
    sender?: string | null;
    /** ФИАС идентификатор улицы */
    streetId?: string | null;
    /** Название улицы, название населенного пункта, название района */
    streetName?: string | null;
    /** время получения сообщения */
    time?: Date | null;
    /** Данные о заявителе */
    ukioCallerInfoBeanFK?: UkioCallerInfoBean | null;
    /** Полученое/отправленое сообщение */
    xmlMessage?: string | null;
}

export class TransportMonitoringData implements ITransportMonitoringData {
    brigadeContainer?: BrigadeContainer | null;
    transportMonitoringBean?: TransportMonitoringBean | null;

    constructor(data?: ITransportMonitoringData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeContainer = data["brigadeContainer"] ? BrigadeContainer.fromJS(data["brigadeContainer"]) : <any>null;
            this.transportMonitoringBean = data["transportMonitoringBean"] ? TransportMonitoringBean.fromJS(data["transportMonitoringBean"]) : <any>null;
        }
    }

    static fromJS(data: any): TransportMonitoringData {
        data = typeof data === 'object' ? data : {};
        let result = new TransportMonitoringData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeContainer"] = this.brigadeContainer ? this.brigadeContainer.toJSON() : <any>null;
        data["transportMonitoringBean"] = this.transportMonitoringBean ? this.transportMonitoringBean.toJSON() : <any>null;
        return data; 
    }
}

export interface ITransportMonitoringData {
    brigadeContainer?: BrigadeContainer | null;
    transportMonitoringBean?: TransportMonitoringBean | null;
}

export class OutwardLogBean implements IOutwardLogBean {
    /** ID вызова */
    callId?: number | null;
    /** номер вызова */
    callNumber?: string | null;
    /** ID карты */
    cardId?: number | null;
    /** номер карты */
    cardNumber?: string | null;
    /** Дата/время действия */
    date?: Date | null;
    /** фио пациента */
    fio?: string | null;
    id?: number | null;
    /** Организация для инфообмена */
    organization?: number | null;
    /** Сотрудник, выполнивший действие */
    performerFK?: PerformerBean | null;
    /** ID сотрудника, выполнившего действие */
    performerId?: number | null;
    /** Связанный лог */
    relatedLogFK?: OutwardLogBean | null;
    /** ID к связанному логу */
    relatedLogId?: number | null;
    /** тело запроса в формате XML */
    request?: string | null;
    /** тело ответа в формате XML */
    response?: string | null;
    /** Подразделение сотрудника */
    subdivisionFK?: SubdivisionBean | null;
    /** ID подразделения сотрудника */
    subdivisionId?: number | null;
    /** удачная отправка */
    successfulSending?: boolean | null;

    constructor(data?: IOutwardLogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.callId = data["callId"] !== undefined ? data["callId"] : <any>null;
            this.callNumber = data["callNumber"] !== undefined ? data["callNumber"] : <any>null;
            this.cardId = data["cardId"] !== undefined ? data["cardId"] : <any>null;
            this.cardNumber = data["cardNumber"] !== undefined ? data["cardNumber"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.fio = data["fio"] !== undefined ? data["fio"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.performerId = data["performerId"] !== undefined ? data["performerId"] : <any>null;
            this.relatedLogFK = data["relatedLogFK"] ? OutwardLogBean.fromJS(data["relatedLogFK"]) : <any>null;
            this.relatedLogId = data["relatedLogId"] !== undefined ? data["relatedLogId"] : <any>null;
            this.request = data["request"] !== undefined ? data["request"] : <any>null;
            this.response = data["response"] !== undefined ? data["response"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.successfulSending = data["successfulSending"] !== undefined ? data["successfulSending"] : <any>null;
        }
    }

    static fromJS(data: any): OutwardLogBean {
        data = typeof data === 'object' ? data : {};
        let result = new OutwardLogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["callId"] = this.callId !== undefined ? this.callId : <any>null;
        data["callNumber"] = this.callNumber !== undefined ? this.callNumber : <any>null;
        data["cardId"] = this.cardId !== undefined ? this.cardId : <any>null;
        data["cardNumber"] = this.cardNumber !== undefined ? this.cardNumber : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["fio"] = this.fio !== undefined ? this.fio : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["performerId"] = this.performerId !== undefined ? this.performerId : <any>null;
        data["relatedLogFK"] = this.relatedLogFK ? this.relatedLogFK.toJSON() : <any>null;
        data["relatedLogId"] = this.relatedLogId !== undefined ? this.relatedLogId : <any>null;
        data["request"] = this.request !== undefined ? this.request : <any>null;
        data["response"] = this.response !== undefined ? this.response : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["successfulSending"] = this.successfulSending !== undefined ? this.successfulSending : <any>null;
        return data; 
    }
}

export interface IOutwardLogBean {
    /** ID вызова */
    callId?: number | null;
    /** номер вызова */
    callNumber?: string | null;
    /** ID карты */
    cardId?: number | null;
    /** номер карты */
    cardNumber?: string | null;
    /** Дата/время действия */
    date?: Date | null;
    /** фио пациента */
    fio?: string | null;
    id?: number | null;
    /** Организация для инфообмена */
    organization?: number | null;
    /** Сотрудник, выполнивший действие */
    performerFK?: PerformerBean | null;
    /** ID сотрудника, выполнившего действие */
    performerId?: number | null;
    /** Связанный лог */
    relatedLogFK?: OutwardLogBean | null;
    /** ID к связанному логу */
    relatedLogId?: number | null;
    /** тело запроса в формате XML */
    request?: string | null;
    /** тело ответа в формате XML */
    response?: string | null;
    /** Подразделение сотрудника */
    subdivisionFK?: SubdivisionBean | null;
    /** ID подразделения сотрудника */
    subdivisionId?: number | null;
    /** удачная отправка */
    successfulSending?: boolean | null;
}

export class UkioUpdateFrom103Bean implements IUkioUpdateFrom103Bean {
    /** кто обновил */
    actorInfo?: string | null;
    /** id */
    id?: number | null;
    /** код результата */
    responseCode?: number | null;
    /** текст результата */
    responseMessage?: string | null;
    /** время отправки сообщения */
    time?: Date | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** тип обновления */
    updateType?: string | null;

    constructor(data?: IUkioUpdateFrom103Bean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actorInfo = data["actorInfo"] !== undefined ? data["actorInfo"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.responseCode = data["responseCode"] !== undefined ? data["responseCode"] : <any>null;
            this.responseMessage = data["responseMessage"] !== undefined ? data["responseMessage"] : <any>null;
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>null;
            this.ukioCardId = data["ukioCardId"] !== undefined ? data["ukioCardId"] : <any>null;
            this.updateType = data["updateType"] !== undefined ? data["updateType"] : <any>null;
        }
    }

    static fromJS(data: any): UkioUpdateFrom103Bean {
        data = typeof data === 'object' ? data : {};
        let result = new UkioUpdateFrom103Bean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorInfo"] = this.actorInfo !== undefined ? this.actorInfo : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["responseCode"] = this.responseCode !== undefined ? this.responseCode : <any>null;
        data["responseMessage"] = this.responseMessage !== undefined ? this.responseMessage : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        data["ukioCardId"] = this.ukioCardId !== undefined ? this.ukioCardId : <any>null;
        data["updateType"] = this.updateType !== undefined ? this.updateType : <any>null;
        return data; 
    }
}

export interface IUkioUpdateFrom103Bean {
    /** кто обновил */
    actorInfo?: string | null;
    /** id */
    id?: number | null;
    /** код результата */
    responseCode?: number | null;
    /** текст результата */
    responseMessage?: string | null;
    /** время отправки сообщения */
    time?: Date | null;
    /** id карты укио */
    ukioCardId?: string | null;
    /** тип обновления */
    updateType?: string | null;
}

export class OthersInBagBean implements IOthersInBagBean {
    /** ID укладки */
    bagId?: number | null;
    /** прочее средство */
    otherFK?: OtherMeanBean | null;
    /** ID вредства */
    otherId?: number | null;
    /** кол-во средство */
    volume?: number | null;

    constructor(data?: IOthersInBagBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bagId = data["bagId"] !== undefined ? data["bagId"] : <any>null;
            this.otherFK = data["otherFK"] ? OtherMeanBean.fromJS(data["otherFK"]) : <any>null;
            this.otherId = data["otherId"] !== undefined ? data["otherId"] : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
        }
    }

    static fromJS(data: any): OthersInBagBean {
        data = typeof data === 'object' ? data : {};
        let result = new OthersInBagBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bagId"] = this.bagId !== undefined ? this.bagId : <any>null;
        data["otherFK"] = this.otherFK ? this.otherFK.toJSON() : <any>null;
        data["otherId"] = this.otherId !== undefined ? this.otherId : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        return data; 
    }
}

export interface IOthersInBagBean {
    /** ID укладки */
    bagId?: number | null;
    /** прочее средство */
    otherFK?: OtherMeanBean | null;
    /** ID вредства */
    otherId?: number | null;
    /** кол-во средство */
    volume?: number | null;
}

export class PerformerShiftBean implements IPerformerShiftBean {
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    id?: number | null;
    /** Признак базовой смены */
    isBasic?: boolean | null;
    /** Признак удаленной смены */
    isDeleted?: boolean | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;
    /** Тип графика */
    scheduleTypeFK?: ScheduleTypeBean | null;

    constructor(data?: IPerformerShiftBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isBasic = data["isBasic"] !== undefined ? data["isBasic"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.scheduleTypeFK = data["scheduleTypeFK"] ? ScheduleTypeBean.fromJS(data["scheduleTypeFK"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerShiftBean {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerShiftBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isBasic"] = this.isBasic !== undefined ? this.isBasic : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["scheduleTypeFK"] = this.scheduleTypeFK ? this.scheduleTypeFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerShiftBean {
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    id?: number | null;
    /** Признак базовой смены */
    isBasic?: boolean | null;
    /** Признак удаленной смены */
    isDeleted?: boolean | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;
    /** Тип графика */
    scheduleTypeFK?: ScheduleTypeBean | null;
}

export enum CallStatusList {
    UNDONE = "UNDONE", 
    UNCONFIRM = "UNCONFIRM", 
    CONFIRM = "CONFIRM", 
    ACTIVE = "ACTIVE", 
    DONE = "DONE", 
    EVACUATION_REQUIRED = "EVACUATION_REQUIRED", 
    TRANSPORTING = "TRANSPORTING", 
}

export enum CallPriorityList {
    URGENT = "URGENT", 
    EMERGENCY = "EMERGENCY", 
}

export enum CallStatusList2 {
    UNDONE = "UNDONE", 
    UNCONFIRM = "UNCONFIRM", 
    CONFIRM = "CONFIRM", 
    ACTIVE = "ACTIVE", 
    DONE = "DONE", 
    EVACUATION_REQUIRED = "EVACUATION_REQUIRED", 
    TRANSPORTING = "TRANSPORTING", 
}

export enum CardStatusList {
    UNFILLED = "UNFILLED", 
    VERIFYING = "VERIFYING", 
    CHECKED = "CHECKED", 
    ARCHIVED = "ARCHIVED", 
    ARCHIVED_AND_EGISZ = "ARCHIVED_AND_EGISZ", 
}

/** status */
export enum Status {
    UNFILLED = "UNFILLED", 
    VERIFYING = "VERIFYING", 
    CHECKED = "CHECKED", 
    ARCHIVED = "ARCHIVED", 
    ARCHIVED_AND_EGISZ = "ARCHIVED_AND_EGISZ", 
}

/** Тип записи */
export enum RecordType {
    BRIGADE = "BRIGADE", 
    BRIGADE_STATUS = "BRIGADE_STATUS", 
    BRIGADE_TYPE = "BRIGADE_TYPE", 
    SCHEDULE_TYPE = "SCHEDULE_TYPE", 
    SUBDIVISION = "SUBDIVISION", 
    SUBDIVISION_TYPE = "SUBDIVISION_TYPE", 
    PERFORMER = "PERFORMER", 
    PERFORMER_TYPE = "PERFORMER_TYPE", 
    PERFORMER_SHIFT = "PERFORMER_SHIFT", 
    BRIGADE_SCHEDULE = "BRIGADE_SCHEDULE", 
    INQUIRER = "INQUIRER", 
    REFERENCE_TYPE = "REFERENCE_TYPE", 
    SKILL = "SKILL", 
    TRANSPORT = "TRANSPORT", 
    UNIT = "UNIT", 
    CALL = "CALL", 
    ASSIGNED_BRIGADE_MESSAGE = "ASSIGNED_BRIGADE_MESSAGE", 
    CARD = "CARD", 
}

/** Тип записи */
export enum RecordType2 {
    BRIGADE = "BRIGADE", 
    BRIGADE_STATUS = "BRIGADE_STATUS", 
    BRIGADE_TYPE = "BRIGADE_TYPE", 
    SCHEDULE_TYPE = "SCHEDULE_TYPE", 
    SUBDIVISION = "SUBDIVISION", 
    SUBDIVISION_TYPE = "SUBDIVISION_TYPE", 
    PERFORMER = "PERFORMER", 
    PERFORMER_TYPE = "PERFORMER_TYPE", 
    PERFORMER_SHIFT = "PERFORMER_SHIFT", 
    BRIGADE_SCHEDULE = "BRIGADE_SCHEDULE", 
    INQUIRER = "INQUIRER", 
    REFERENCE_TYPE = "REFERENCE_TYPE", 
    SKILL = "SKILL", 
    TRANSPORT = "TRANSPORT", 
    UNIT = "UNIT", 
    CALL = "CALL", 
    ASSIGNED_BRIGADE_MESSAGE = "ASSIGNED_BRIGADE_MESSAGE", 
    CARD = "CARD", 
}

/** Тип графика */
export enum Type {
    BRIGADE = "BRIGADE", 
    DOCTORS = "DOCTORS", 
    DRIVERS = "DRIVERS", 
    EMPLOYEES = "EMPLOYEES", 
}

/** Расширение файла */
export enum Extension {
    DOCX = "DOCX", 
    XLS = "XLS", 
    PDF = "PDF", 
    RTF = "RTF", 
}

export enum Anonymous {
    UNDONE = "UNDONE", 
    UNCONFIRM = "UNCONFIRM", 
    CONFIRM = "CONFIRM", 
    ACTIVE = "ACTIVE", 
    DONE = "DONE", 
    EVACUATION_REQUIRED = "EVACUATION_REQUIRED", 
    TRANSPORTING = "TRANSPORTING", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}