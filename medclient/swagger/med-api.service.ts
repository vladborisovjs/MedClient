/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.7.0 (NJsonSchema v9.10.70.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MedApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "172.16.6.166:8080/tcmk";
    }

    /**
     * [CREATE] роли -> получение списка пользователей по роли
     * @param subId (optional) subId
     * @param action (optional) action
     * @param date_from (optional) date_from
     * @param date_to (optional) date_to
     * @return OK
     */
    getLogsUsingGET(subId?: number | null | undefined, action?: Action | null | undefined, date_from?: string | null | undefined, date_to?: string | null | undefined): Observable<ListDtoOfLogDto> {
        let url_ = this.baseUrl + "/api/admin/logs?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&"; 
        if (date_from !== undefined)
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to !== undefined)
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogsUsingGET(response: HttpResponseBase): Observable<ListDtoOfLogDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfLogDto.fromJS(resultData200) : new ListDtoOfLogDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfLogDto>(<any>null);
    }

    /**
     * [READ] роли -> получение списка всех ролей
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET(deleted?: boolean | null | undefined): Observable<ListDtoOfRole> {
        let url_ = this.baseUrl + "/api/admin/roles?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfRole>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET(response: HttpResponseBase): Observable<ListDtoOfRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfRole.fromJS(resultData200) : new ListDtoOfRole();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfRole>(<any>null);
    }

    /**
     * [CREATE] роли -> создание новой роли
     * @param role role
     * @return OK
     */
    createUsingPOST(role: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/admin/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Role.fromJS(resultData200) : new Role();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    /**
     * [READ] роли -> получение роли по id
     * @param id id
     * @return OK
     */
    readOneUsingGET(id: number): Observable<Role> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Role.fromJS(resultData200) : new Role();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    /**
     * [UPDATE] роли -> изменение роли
     * @param id id
     * @param role role
     * @return OK
     */
    updateUsingPUT(id: number, role: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Role.fromJS(resultData200) : new Role();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    /**
     * [CREATE] роли -> получение списка пользователей по роли
     * @param id id
     * @return OK
     */
    getPerformersUsingGET(id: number): Observable<ListDtoOfPerformer> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}/performers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfPerformer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfPerformer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformersUsingGET(response: HttpResponseBase): Observable<ListDtoOfPerformer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfPerformer.fromJS(resultData200) : new ListDtoOfPerformer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfPerformer>(<any>null);
    }

    /**
     * [CREATE] роли -> получение структуры прав и разрешений
     * @param id id
     * @return OK
     */
    createUsingGET(id: number): Observable<ListDtoOfPermission> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfPermission>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfPermission>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingGET(response: HttpResponseBase): Observable<ListDtoOfPermission> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfPermission.fromJS(resultData200) : new ListDtoOfPermission();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfPermission>(<any>null);
    }

    /**
     * [CREATE] роли -> обновление прав и разрешений
     * @param id id
     * @param permissions permissions
     * @return OK
     */
    createPermissionsUsingPUT(id: number, permissions: string[]): Observable<ListDtoOfString> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissions);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePermissionsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePermissionsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfString>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePermissionsUsingPUT(response: HttpResponseBase): Observable<ListDtoOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfString.fromJS(resultData200) : new ListDtoOfString();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfString>(<any>null);
    }

    /**
     * возвращает список типов бригад
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_5(subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<BrigadeTypeDto[]> {
        let url_ = this.baseUrl + "/api/brigade_types?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_5(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_5(response: HttpResponseBase): Observable<BrigadeTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto[]>(<any>null);
    }

    /**
     * создание нового типа бригад
     * @param dto dto
     * @return OK
     */
    createUsingPOST_4(dto: BrigadeTypeDto): Observable<BrigadeTypeDto> {
        let url_ = this.baseUrl + "/api/brigade_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_4(response: HttpResponseBase): Observable<BrigadeTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeDto.fromJS(resultData200) : new BrigadeTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto>(<any>null);
    }

    /**
     * возвращает тип бригад по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_4(id: number): Observable<BrigadeTypeDto> {
        let url_ = this.baseUrl + "/api/brigade_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_4(response: HttpResponseBase): Observable<BrigadeTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeDto.fromJS(resultData200) : new BrigadeTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto>(<any>null);
    }

    /**
     * обновление сведений о типе бригад
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_4(dto: BrigadeTypeDto): Observable<BrigadeTypeDto> {
        let url_ = this.baseUrl + "/api/brigade_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_4(response: HttpResponseBase): Observable<BrigadeTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeDto.fromJS(resultData200) : new BrigadeTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto>(<any>null);
    }

    /**
     * DEPRECATED возвращает список бригад по заданным параметрам
     * @param deleted (optional) deleted
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    readAllUsingGET_4(deleted?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<BrigadeDto[]> {
        let url_ = this.baseUrl + "/api/brigades?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_4(response: HttpResponseBase): Observable<BrigadeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto[]>(<any>null);
    }

    /**
     * создание новой бригады
     * @param dto dto
     * @return OK
     */
    createUsingPOST_3(dto: BrigadeDto): Observable<BrigadeDto> {
        let url_ = this.baseUrl + "/api/brigades";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_3(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_3(response: HttpResponseBase): Observable<BrigadeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeDto.fromJS(resultData200) : new BrigadeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto>(<any>null);
    }

    /**
     * возвращает бригаду по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_3(id: number): Observable<BrigadeDto> {
        let url_ = this.baseUrl + "/api/brigades/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_3(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_3(response: HttpResponseBase): Observable<BrigadeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeDto.fromJS(resultData200) : new BrigadeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto>(<any>null);
    }

    /**
     * обновление сведений о бригаде кроме статуса
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_3(dto: BrigadeDto): Observable<BrigadeDto> {
        let url_ = this.baseUrl + "/api/brigades/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_3(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_3(response: HttpResponseBase): Observable<BrigadeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeDto.fromJS(resultData200) : new BrigadeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto>(<any>null);
    }

    /**
     * [READ] бригада -> сотрудники
     * @param id id
     * @return OK
     */
    readPerformersInBrigadeUsingGET(id: number): Observable<PerformerDto[]> {
        let url_ = this.baseUrl + "/api/brigades/{id}/performers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPerformersInBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPerformersInBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadPerformersInBrigadeUsingGET(response: HttpResponseBase): Observable<PerformerDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto[]>(<any>null);
    }

    /**
     * возвращает список карт вызова в подразделении
     * @param mode (optional) mode
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_7(mode?: string | null | undefined, subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/cards?";
        if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_7(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_7(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * возвращает список записей МКБ 10 по текстовому поиску в коде/названии
     * @param s s
     * @return OK
     */
    findMkbListUsingGET(s: string): Observable<Mkb[]> {
        let url_ = this.baseUrl + "/api/cards/mkb?";
        if (s === undefined || s === null)
            throw new Error("The parameter 's' must be defined and cannot be null.");
        else
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindMkbListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindMkbListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Mkb[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mkb[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindMkbListUsingGET(response: HttpResponseBase): Observable<Mkb[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Mkb.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mkb[]>(<any>null);
    }

    /**
     * возвращает вложенные записи МКБ 10 по id parent-записи
     * @param id id
     * @return OK
     */
    readMkbListUsingGET(id: number): Observable<MkbDto[]> {
        let url_ = this.baseUrl + "/api/cards/mkb/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadMkbListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadMkbListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<MkbDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MkbDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadMkbListUsingGET(response: HttpResponseBase): Observable<MkbDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MkbDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MkbDto[]>(<any>null);
    }

    /**
     * возвращает список карт вызова по заданным параметрам поиска
     * @param subdivisionId (optional) 
     * @param number (optional) 
     * @param declarantName (optional) 
     * @param declarantPhone (optional) 
     * @param patientName (optional) 
     * @param patientSex (optional) 
     * @param patientAgeYears (optional) 
     * @param patientAgeMonths (optional) 
     * @param patientAgeDays (optional) 
     * @param incidentAoName (optional) 
     * @param incidentDistrictId (optional) 
     * @param performer (optional) 
     * @param callTypeId (optional) 
     * @param declarantTypeId (optional) 
     * @param callPlaceTypeId (optional) 
     * @param reasonTypeId (optional) 
     * @return OK
     */
    readAllUsingPOST_1(subdivisionId?: number | null | undefined, number?: string | null | undefined, declarantName?: string | null | undefined, declarantPhone?: string | null | undefined, patientName?: string | null | undefined, patientSex?: number | null | undefined, patientAgeYears?: number | null | undefined, patientAgeMonths?: number | null | undefined, patientAgeDays?: number | null | undefined, incidentAoName?: string | null | undefined, incidentDistrictId?: number | null | undefined, performer?: string | null | undefined, callTypeId?: number | null | undefined, declarantTypeId?: number | null | undefined, callPlaceTypeId?: number | null | undefined, reasonTypeId?: number | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/cards/request?";
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (declarantName !== undefined)
            url_ += "declarantName=" + encodeURIComponent("" + declarantName) + "&"; 
        if (declarantPhone !== undefined)
            url_ += "declarantPhone=" + encodeURIComponent("" + declarantPhone) + "&"; 
        if (patientName !== undefined)
            url_ += "patientName=" + encodeURIComponent("" + patientName) + "&"; 
        if (patientSex !== undefined)
            url_ += "patientSex=" + encodeURIComponent("" + patientSex) + "&"; 
        if (patientAgeYears !== undefined)
            url_ += "patientAgeYears=" + encodeURIComponent("" + patientAgeYears) + "&"; 
        if (patientAgeMonths !== undefined)
            url_ += "patientAgeMonths=" + encodeURIComponent("" + patientAgeMonths) + "&"; 
        if (patientAgeDays !== undefined)
            url_ += "patientAgeDays=" + encodeURIComponent("" + patientAgeDays) + "&"; 
        if (incidentAoName !== undefined)
            url_ += "incidentAoName=" + encodeURIComponent("" + incidentAoName) + "&"; 
        if (incidentDistrictId !== undefined)
            url_ += "incidentDistrictId=" + encodeURIComponent("" + incidentDistrictId) + "&"; 
        if (performer !== undefined)
            url_ += "performer=" + encodeURIComponent("" + performer) + "&"; 
        if (callTypeId !== undefined)
            url_ += "callTypeId=" + encodeURIComponent("" + callTypeId) + "&"; 
        if (declarantTypeId !== undefined)
            url_ += "declarantTypeId=" + encodeURIComponent("" + declarantTypeId) + "&"; 
        if (callPlaceTypeId !== undefined)
            url_ += "callPlaceTypeId=" + encodeURIComponent("" + callPlaceTypeId) + "&"; 
        if (reasonTypeId !== undefined)
            url_ += "reasonTypeId=" + encodeURIComponent("" + reasonTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingPOST_1(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> опросник
     * @param id (optional) id
     * @return OK
     */
    readOneUsingGET_6(id?: number | null | undefined): Observable<InquirerInCallDto> {
        let url_ = this.baseUrl + "/api/cards/side_one/inquirer?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_6(<any>response_);
                } catch (e) {
                    return <Observable<InquirerInCallDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerInCallDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_6(response: HttpResponseBase): Observable<InquirerInCallDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerInCallDto.fromJS(resultData200) : new InquirerInCallDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerInCallDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> быстрые поводы к вызову
     * @return OK
     */
    readBasicReasonsUsingGET(): Observable<InquirerInCallDto[]> {
        let url_ = this.baseUrl + "/api/cards/side_one/reasons/fast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadBasicReasonsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadBasicReasonsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerInCallDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerInCallDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadBasicReasonsUsingGET(response: HttpResponseBase): Observable<InquirerInCallDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InquirerInCallDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerInCallDto[]>(<any>null);
    }

    /**
     * только для генерации Api
     * @return OK
     */
    messageDtoForApiUsingGET(): Observable<MessageDto> {
        let url_ = this.baseUrl + "/api/cards/simple-message-dto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessageDtoForApiUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessageDtoForApiUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<MessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processMessageDtoForApiUsingGET(response: HttpResponseBase): Observable<MessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MessageDto.fromJS(resultData200) : new MessageDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageDto>(<any>null);
    }

    /**
     * [DELETE] аннулирование карты вызова.
     * @param cardId cardId
     * @param message message
     * @return OK
     */
    updateResultIllegalActionsPartUsingDELETE(cardId: number, message: MessageDto): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultIllegalActionsPartUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultIllegalActionsPartUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultIllegalActionsPartUsingDELETE(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> изъять из архива
     * @param cardId cardId
     * @param comment comment
     * @return OK
     */
    returnToVerifyUsingPUT(cardId: number, comment: string): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/get_from_archive";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnToVerifyUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnToVerifyUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processReturnToVerifyUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> укладка
     * @param cardId cardId
     * @return OK
     */
    readAllШnventoryUsingGET(cardId: number): Observable<Inventory[]> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/inventories";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllШnventoryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllШnventoryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Inventory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllШnventoryUsingGET(response: HttpResponseBase): Observable<Inventory[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Inventory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory[]>(<any>null);
    }

    /**
     * карта вызова -> протокол
     * @param cardId cardId
     * @return OK
     */
    readProtocolUsingGET_1(cardId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/protocol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolUsingGET_1(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * карта вызова -> результат
     * @param cardId cardId
     * @return OK
     */
    readCardResultUsingGET(cardId: number): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultUsingGET(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultUsingPUT(cardId: number, dto: CardResultDtoFLAT): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultUsingPUT(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> активное посещение
     * @param cardId cardId
     * @return OK
     */
    readCardResultActiveVisitPartUsingGET(cardId: number): Observable<CardResultActiveVisitDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/active_visit";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultActiveVisitPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultActiveVisitPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultActiveVisitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultActiveVisitDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultActiveVisitPartUsingGET(response: HttpResponseBase): Observable<CardResultActiveVisitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultActiveVisitDto.fromJS(resultData200) : new CardResultActiveVisitDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultActiveVisitDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> активное посещение
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultActiveVisitPartUsingPUT(cardId: number, dto: CardResultActiveVisitDto): Observable<CardResultActiveVisitDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/active_visit";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultActiveVisitPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultActiveVisitPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultActiveVisitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultActiveVisitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultActiveVisitPartUsingPUT(response: HttpResponseBase): Observable<CardResultActiveVisitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultActiveVisitDto.fromJS(resultData200) : new CardResultActiveVisitDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultActiveVisitDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> результат мероприятий
     * @param cardId cardId
     * @return OK
     */
    readAssistanceResultPartUsingGET(cardId: number): Observable<CardResultAssistanceResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/assistance_result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAssistanceResultPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAssistanceResultPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadAssistanceResultPartUsingGET(response: HttpResponseBase): Observable<CardResultAssistanceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultAssistanceResultDto.fromJS(resultData200) : new CardResultAssistanceResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultAssistanceResultDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> результат мероприятий
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAssistanceResultPartUsingPUT(cardId: number, dto: CardResultAssistanceResultDto): Observable<CardResultAssistanceResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/assistance_result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssistanceResultPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssistanceResultPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssistanceResultPartUsingPUT(response: HttpResponseBase): Observable<CardResultAssistanceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultAssistanceResultDto.fromJS(resultData200) : new CardResultAssistanceResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultAssistanceResultDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> Примечания
     * @param cardId cardId
     * @return OK
     */
    readCardResultCommentsPartUsingGET(cardId: number): Observable<CardResultCommentsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/comments";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultCommentsPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultCommentsPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultCommentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultCommentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultCommentsPartUsingGET(response: HttpResponseBase): Observable<CardResultCommentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultCommentsDto.fromJS(resultData200) : new CardResultCommentsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultCommentsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> примечания
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultCommentsPartUsingPUT(cardId: number, dto: CardResultCommentsDto): Observable<CardResultCommentsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/comments";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultCommentsPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultCommentsPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultCommentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultCommentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultCommentsPartUsingPUT(response: HttpResponseBase): Observable<CardResultCommentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultCommentsDto.fromJS(resultData200) : new CardResultCommentsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultCommentsDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> смерть
     * @param cardId cardId
     * @return OK
     */
    readDeathPartUsingGET(cardId: number): Observable<CardResultDeathDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/death";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadDeathPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadDeathPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDeathDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDeathDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadDeathPartUsingGET(response: HttpResponseBase): Observable<CardResultDeathDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDeathDto.fromJS(resultData200) : new CardResultDeathDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDeathDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> смерть
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateDeathPartUsingPUT(cardId: number, dto: CardResultDeathDto): Observable<CardResultDeathDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/death";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeathPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeathPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDeathDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDeathDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeathPartUsingPUT(response: HttpResponseBase): Observable<CardResultDeathDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDeathDto.fromJS(resultData200) : new CardResultDeathDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDeathDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> диагноз
     * @param cardId cardId
     * @return OK
     */
    readCardResultDiagnosisPartUsingGET(cardId: number): Observable<CardResultDiagnosisDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/diagnosis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultDiagnosisPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultDiagnosisPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDiagnosisDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDiagnosisDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultDiagnosisPartUsingGET(response: HttpResponseBase): Observable<CardResultDiagnosisDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDiagnosisDto.fromJS(resultData200) : new CardResultDiagnosisDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDiagnosisDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> диагноз
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultDiagnosisPartUsingPUT(cardId: number, dto: CardResultDiagnosisDto): Observable<CardResultDiagnosisDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/diagnosis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultDiagnosisPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultDiagnosisPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDiagnosisDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDiagnosisDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultDiagnosisPartUsingPUT(response: HttpResponseBase): Observable<CardResultDiagnosisDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDiagnosisDto.fromJS(resultData200) : new CardResultDiagnosisDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDiagnosisDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> ЭКГ
     * @param cardId cardId
     * @return OK
     */
    readCardResultEkgPartUsingGET(cardId: number): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultEkgPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultEkgPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultEkgPartUsingGET(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> экг
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultEkgPartUsingPUT(cardId: number, dto: CardResultEkg): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultEkgPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultEkgPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultEkgPartUsingPUT(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * карта вызова -> результат -> ЭКГ после мероприятий
     * @param cardId cardId
     * @return OK
     */
    readCardResultEkgAfterPartUsingGET(cardId: number): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg_after";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultEkgAfterPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultEkgAfterPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultEkgAfterPartUsingGET(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> экг после мероприятий
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultEkgAfterPartUsingPUT(cardId: number, dto: CardResultEkg): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg_after";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultEkgAfterPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultEkgAfterPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultEkgAfterPartUsingPUT(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * карта вызова -> результат -> противоправные действия
     * @param cardId cardId
     * @return OK
     */
    readCardResultIllegalActionsPartUsingGET(cardId: number): Observable<CardResultIllegalActionsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/illegal_actions";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultIllegalActionsPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultIllegalActionsPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultIllegalActionsPartUsingGET(response: HttpResponseBase): Observable<CardResultIllegalActionsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultIllegalActionsDto.fromJS(resultData200) : new CardResultIllegalActionsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultIllegalActionsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> противоправные действия
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultIllegalActionsPartUsingPUT(cardId: number, dto: CardResultIllegalActionsDto): Observable<CardResultIllegalActionsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/illegal_actions";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultIllegalActionsPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultIllegalActionsPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultIllegalActionsPartUsingPUT(response: HttpResponseBase): Observable<CardResultIllegalActionsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultIllegalActionsDto.fromJS(resultData200) : new CardResultIllegalActionsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultIllegalActionsDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий на месте
     * @param cardId cardId
     * @return OK
     */
    readCardResultLocalEfficiencyAssistancePartUsingGET(cardId: number): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/local_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultLocalEfficiencyAssistancePartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultLocalEfficiencyAssistancePartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultLocalEfficiencyAssistancePartUsingGET(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий на месте
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardResultLocalEfficiencyAssistancePartUsingPUT(cardId: number, dto: CardResultEfficiencyAssistance): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/local_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardResultLocalEfficiencyAssistancePartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardResultLocalEfficiencyAssistancePartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardResultLocalEfficiencyAssistancePartUsingPUT(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> расходные материалы
     * @param cardId cardId
     * @return OK
     */
    readCardResultMaterialsPartUsingGET(cardId: number): Observable<CardResultMaterialsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/materials";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultMaterialsPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultMaterialsPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultMaterialsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultMaterialsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultMaterialsPartUsingGET(response: HttpResponseBase): Observable<CardResultMaterialsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultMaterialsDto.fromJS(resultData200) : new CardResultMaterialsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultMaterialsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> материалы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultMaterialsPartUsingPUT(cardId: number, dto: CardResultMaterialsDto): Observable<CardResultMaterialsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/materials";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultMaterialsPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultMaterialsPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultMaterialsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultMaterialsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultMaterialsPartUsingPUT(response: HttpResponseBase): Observable<CardResultMaterialsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultMaterialsDto.fromJS(resultData200) : new CardResultMaterialsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultMaterialsDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> причина
     * @param cardId cardId
     * @return OK
     */
    readCardResultReasonPartUsingGET(cardId: number): Observable<CardResultReasonDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/reason";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultReasonPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultReasonPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultReasonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultReasonDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultReasonPartUsingGET(response: HttpResponseBase): Observable<CardResultReasonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultReasonDto.fromJS(resultData200) : new CardResultReasonDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultReasonDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> причина
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultReasonPartUsingPUT(cardId: number, dto: CardResultReasonDto): Observable<CardResultReasonDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/reason";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultReasonPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultReasonPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultReasonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultReasonDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultReasonPartUsingPUT(response: HttpResponseBase): Observable<CardResultReasonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultReasonDto.fromJS(resultData200) : new CardResultReasonDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultReasonDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> терапия
     * @param cardId cardId
     * @return OK
     */
    readCardResultМyPartUsingGET(cardId: number): Observable<CardResultTherapyPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/therapy";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultМyPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultМyPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTherapyPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTherapyPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultМyPartUsingGET(response: HttpResponseBase): Observable<CardResultTherapyPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTherapyPartDto.fromJS(resultData200) : new CardResultTherapyPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTherapyPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> терапия
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultTherapyPartUsingPUT(cardId: number, dto: CardResultTherapyPartDto): Observable<CardResultTherapyPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/therapy";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultTherapyPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultTherapyPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTherapyPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTherapyPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultTherapyPartUsingPUT(response: HttpResponseBase): Observable<CardResultTherapyPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTherapyPartDto.fromJS(resultData200) : new CardResultTherapyPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTherapyPartDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> передача спец. бригаде
     * @param cardId cardId
     * @return OK
     */
    readTransferPatientPartUsingGET(cardId: number): Observable<CardResultTransferPatientDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transfer_patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTransferPatientPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTransferPatientPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransferPatientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransferPatientDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadTransferPatientPartUsingGET(response: HttpResponseBase): Observable<CardResultTransferPatientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransferPatientDto.fromJS(resultData200) : new CardResultTransferPatientDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransferPatientDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> передача спец. бригаде
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateTransferPatientPartUsingPUT(cardId: number, dto: CardResultTransferPatientDto): Observable<CardResultTransferPatientDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transfer_patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransferPatientPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransferPatientPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransferPatientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransferPatientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransferPatientPartUsingPUT(response: HttpResponseBase): Observable<CardResultTransferPatientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransferPatientDto.fromJS(resultData200) : new CardResultTransferPatientDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransferPatientDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий в машине
     * @param cardId cardId
     * @return OK
     */
    readCardResultTransportEfficiencyAssistancePartUsingGET(cardId: number): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transport_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultTransportEfficiencyAssistancePartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultTransportEfficiencyAssistancePartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultTransportEfficiencyAssistancePartUsingGET(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий в машине
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardResultTransportEfficiencyAssistancePartUsingPUT(cardId: number, dto: CardResultEfficiencyAssistance): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transport_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardResultTransportEfficiencyAssistancePartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardResultTransportEfficiencyAssistancePartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardResultTransportEfficiencyAssistancePartUsingPUT(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> транспортировка
     * @param cardId cardId
     * @return OK
     */
    readCardResultTransportingPartUsingGET(cardId: number): Observable<CardResultTransportingDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transporting";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultTransportingPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultTransportingPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransportingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransportingDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultTransportingPartUsingGET(response: HttpResponseBase): Observable<CardResultTransportingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransportingDto.fromJS(resultData200) : new CardResultTransportingDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransportingDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> транспортировка
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultTransportingPartUsingPUT(cardId: number, dto: CardResultTransportingDto): Observable<CardResultTransportingDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transporting";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultTransportingPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultTransportingPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransportingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransportingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultTransportingPartUsingPUT(response: HttpResponseBase): Observable<CardResultTransportingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransportingDto.fromJS(resultData200) : new CardResultTransportingDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransportingDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> тип результата
     * @param cardId cardId
     * @return OK
     */
    readCardResultTypePartUsingGET(cardId: number): Observable<CardResultTypeDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/type";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultTypePartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultTypePartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultTypePartUsingGET(response: HttpResponseBase): Observable<CardResultTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTypeDto.fromJS(resultData200) : new CardResultTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTypeDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> тип результата
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultTypePartUsingPUT(cardId: number, dto: CardResultTypeDto): Observable<CardResultTypeDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/type";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultTypePartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultTypePartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultTypePartUsingPUT(response: HttpResponseBase): Observable<CardResultTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTypeDto.fromJS(resultData200) : new CardResultTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTypeDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> передать в архив
     * @param cardId cardId
     * @return OK
     */
    setToArchiveUsingPUT(cardId: number): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/set_to_archive";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetToArchiveUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetToArchiveUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetToArchiveUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> вернуть сотруднику
     * @param cardId cardId
     * @param comment comment
     * @return OK
     */
    returnToUndilledUsingPUT(cardId: number, comment: string): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/set_to_unfilled";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnToUndilledUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnToUndilledUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processReturnToUndilledUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> передать на проверку
     * @param cardId cardId
     * @return OK
     */
    setVerifiedUsingPUT(cardId: number): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/set_to_verify";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetVerifiedUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetVerifiedUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetVerifiedUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона
     * @param cardId cardId
     * @return OK
     */
    readSideOneUsingGET(cardId: number): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneUsingGET(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> основные сведения
     * @param cardId cardId
     * @return OK
     */
    readSideOneGeneralPartUsingGET_1(cardId: number): Observable<CardGeneralPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneGeneralPartUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneGeneralPartUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<CardGeneralPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGeneralPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneGeneralPartUsingGET_1(response: HttpResponseBase): Observable<CardGeneralPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardGeneralPartDto.fromJS(resultData200) : new CardGeneralPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGeneralPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> временные этапы
     * @param cardId cardId
     * @return OK
     */
    getBasicDatesUsingGET(cardId: number): Observable<CardBasicDatesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/basic_dates";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBasicDatesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBasicDatesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardBasicDatesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBasicDatesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBasicDatesUsingGET(response: HttpResponseBase): Observable<CardBasicDatesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBasicDatesPartDto.fromJS(resultData200) : new CardBasicDatesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBasicDatesPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> первая сторона -> основные данные -> временные этапы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateBasicDatesUsingPUT(cardId: number, dto: CardBasicDatesPartDto): Observable<CardBasicDatesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/basic_dates";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBasicDatesUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBasicDatesUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardBasicDatesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBasicDatesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBasicDatesUsingPUT(response: HttpResponseBase): Observable<CardBasicDatesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBasicDatesPartDto.fromJS(resultData200) : new CardBasicDatesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBasicDatesPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> ответственный врач бригады
     * @param cardId cardId
     * @return OK
     */
    getBrigadeDoctorInfoUsingGET(cardId: number): Observable<CardBrigadeDoctorPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/brigade_doctor";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeDoctorInfoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeDoctorInfoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardBrigadeDoctorPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBrigadeDoctorPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeDoctorInfoUsingGET(response: HttpResponseBase): Observable<CardBrigadeDoctorPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBrigadeDoctorPartDto.fromJS(resultData200) : new CardBrigadeDoctorPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBrigadeDoctorPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> старший врач смены
     * @param cardId cardId
     * @return OK
     */
    getShiftSeniorDoctorInfoUsingGET(cardId: number): Observable<CardShiftSeniorDoctorPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/shift_senior_doctor";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShiftSeniorDoctorInfoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShiftSeniorDoctorInfoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardShiftSeniorDoctorPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardShiftSeniorDoctorPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShiftSeniorDoctorInfoUsingGET(response: HttpResponseBase): Observable<CardShiftSeniorDoctorPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardShiftSeniorDoctorPartDto.fromJS(resultData200) : new CardShiftSeniorDoctorPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardShiftSeniorDoctorPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> заведущий отделением
     * @param cardId cardId
     * @return OK
     */
    getSubdivisionHeadDoctorInfoUsingGET(cardId: number): Observable<CardSubdivisionHeadDoctorPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/subdivision_head_doctor";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionHeadDoctorInfoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionHeadDoctorInfoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardSubdivisionHeadDoctorPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSubdivisionHeadDoctorPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionHeadDoctorInfoUsingGET(response: HttpResponseBase): Observable<CardSubdivisionHeadDoctorPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSubdivisionHeadDoctorPartDto.fromJS(resultData200) : new CardSubdivisionHeadDoctorPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSubdivisionHeadDoctorPartDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> пациент
     * @param cardId cardId
     * @return OK
     */
    readSideOnePatientPartUsingGET(cardId: number): Observable<CardPatientPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOnePatientPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOnePatientPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOnePatientPartUsingGET(response: HttpResponseBase): Observable<CardPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardPatientPartDto.fromJS(resultData200) : new CardPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardPatientPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> первая сторона -> пациент
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updatePatientPartUsingPUT(cardId: number, dto: CardPatientPartDto): Observable<CardPatientPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatientPartUsingPUT(response: HttpResponseBase): Observable<CardPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardPatientPartDto.fromJS(resultData200) : new CardPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardPatientPartDto>(<any>null);
    }

    /**
     * карта вызова -> состояние -> протокол
     * @param cardId cardId
     * @param activityId activityId
     * @return OK
     */
    readStateProtocolUsingGET(cardId: number, activityId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/state/{activityId}/protocol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadStateProtocolUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadStateProtocolUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadStateProtocolUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона
     * @param cardId cardId
     * @return OK
     */
    readSideTwoUsingGET(cardId: number): Observable<CardSideTwoDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardSideTwoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideTwoDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoUsingGET(response: HttpResponseBase): Observable<CardSideTwoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideTwoDto.fromJS(resultData200) : new CardSideTwoDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideTwoDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез
     * @param cardId cardId
     * @return OK
     */
    readSideTwoAnamnesisUsingGET(cardId: number): Observable<CardAnamnesisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoAnamnesisUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoAnamnesisUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoAnamnesisUsingGET(response: HttpResponseBase): Observable<CardAnamnesisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisPartDto.fromJS(resultData200) : new CardAnamnesisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAnamnesisUsingPUT(cardId: number, dto: CardAnamnesisPartDtoFLAT): Observable<CardAnamnesisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnamnesisUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnamnesisUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnamnesisUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisPartDto.fromJS(resultData200) : new CardAnamnesisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> аллергический
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisAllergicUsingGET(cardId: number): Observable<CardAnamnesisEpidemicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/allergic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisAllergicUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisAllergicUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisAllergicUsingGET(response: HttpResponseBase): Observable<CardAnamnesisEpidemicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisEpidemicPartDto.fromJS(resultData200) : new CardAnamnesisEpidemicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisEpidemicPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> аллергический
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAllergicUsingPUT(cardId: number, dto: CardAnamnesisAllergicPartDto): Observable<CardAnamnesisAllergicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/allergic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllergicUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllergicUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisAllergicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisAllergicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllergicUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisAllergicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisAllergicPartDto.fromJS(resultData200) : new CardAnamnesisAllergicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisAllergicPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> жалобы
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisComplaintsUsingGET(cardId: number): Observable<CardAnamnesisComplaintsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/complaints";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisComplaintsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisComplaintsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisComplaintsUsingGET(response: HttpResponseBase): Observable<CardAnamnesisComplaintsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisComplaintsPartDto.fromJS(resultData200) : new CardAnamnesisComplaintsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisComplaintsPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> жалобы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateComplaintsUsingPUT(cardId: number, dto: CardAnamnesisComplaintsPartDto): Observable<CardAnamnesisComplaintsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/complaints";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComplaintsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComplaintsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComplaintsUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisComplaintsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisComplaintsPartDto.fromJS(resultData200) : new CardAnamnesisComplaintsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisComplaintsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> эпидемиологический
     * @param cardId cardId
     * @return OK
     */
    readSideTwoAnamnesisEpidemicUsingGET(cardId: number): Observable<CardAnamnesisEpidemicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/epidemic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoAnamnesisEpidemicUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoAnamnesisEpidemicUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoAnamnesisEpidemicUsingGET(response: HttpResponseBase): Observable<CardAnamnesisEpidemicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisEpidemicPartDto.fromJS(resultData200) : new CardAnamnesisEpidemicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisEpidemicPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> эпидемиологический
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateEpidemicUsingPUT(cardId: number, dto: CardAnamnesisEpidemicPartDto): Observable<CardAnamnesisEpidemicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/epidemic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEpidemicUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEpidemicUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEpidemicUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisEpidemicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisEpidemicPartDto.fromJS(resultData200) : new CardAnamnesisEpidemicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisEpidemicPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> гинекологический
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisGynecologicUsingGET(cardId: number): Observable<CardAnamnesisGynecologicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/gynecologic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisGynecologicUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisGynecologicUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisGynecologicUsingGET(response: HttpResponseBase): Observable<CardAnamnesisGynecologicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisGynecologicPartDto.fromJS(resultData200) : new CardAnamnesisGynecologicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisGynecologicPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> гинекологический
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateGynecologicUsingPUT(cardId: number, dto: CardAnamnesisGynecologicPartDto): Observable<CardAnamnesisGynecologicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/gynecologic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGynecologicUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGynecologicUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGynecologicUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisGynecologicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisGynecologicPartDto.fromJS(resultData200) : new CardAnamnesisGynecologicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisGynecologicPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> заболевания
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisIllnesUsingGET(cardId: number): Observable<CardAnamnesisIllnesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/illnes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisIllnesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisIllnesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisIllnesUsingGET(response: HttpResponseBase): Observable<CardAnamnesisIllnesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisIllnesPartDto.fromJS(resultData200) : new CardAnamnesisIllnesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisIllnesPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> заболевания
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateIllnesUsingPUT(cardId: number, dto: CardAnamnesisIllnesPartDto): Observable<CardAnamnesisIllnesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/illnes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIllnesUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIllnesUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIllnesUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisIllnesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisIllnesPartDto.fromJS(resultData200) : new CardAnamnesisIllnesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisIllnesPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объек.данные
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesUsingGET(cardId: number): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesUsingGET(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardObjectiveUsingPUT(cardId: number, dto: CardObjectivePartDtoFLAT): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardObjectiveUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardObjectiveUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardObjectiveUsingPUT(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> дополнительные данные
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesAdditionUsingGET(cardId: number): Observable<CardObjectiveAdditionPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/addition";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesAdditionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesAdditionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesAdditionUsingGET(response: HttpResponseBase): Observable<CardObjectiveAdditionPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAdditionPartDto.fromJS(resultData200) : new CardObjectiveAdditionPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAdditionPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> дополнительные данные
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAdditionsUsingPUT(cardId: number, dto: CardObjectiveAdditionPartDto): Observable<CardObjectiveAdditionPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/addition";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdditionsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdditionsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdditionsUsingPUT(response: HttpResponseBase): Observable<CardObjectiveAdditionPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAdditionPartDto.fromJS(resultData200) : new CardObjectiveAdditionPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAdditionPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> призн.алк.опьянения
     * @param cardId cardId
     * @return OK
     */
    readCardObjectiveIAlcoUsingGET(cardId: number): Observable<CardObjectiveAlcoPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/alcohol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardObjectiveIAlcoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardObjectiveIAlcoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardObjectiveIAlcoUsingGET(response: HttpResponseBase): Observable<CardObjectiveAlcoPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAlcoPartDto.fromJS(resultData200) : new CardObjectiveAlcoPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAlcoPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> призн.алк.опьянения
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAlcoholUsingPUT(cardId: number, dto: CardObjectiveAlcoPartDto): Observable<CardObjectiveAlcoPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/alcohol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAlcoholUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAlcoholUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAlcoholUsingPUT(response: HttpResponseBase): Observable<CardObjectiveAlcoPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAlcoPartDto.fromJS(resultData200) : new CardObjectiveAlcoPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAlcoPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> дыхание
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesBreathUsingGET(cardId: number): Observable<CardObjectiveBreathPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/breath";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesBreathUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesBreathUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesBreathUsingGET(response: HttpResponseBase): Observable<CardObjectiveBreathPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveBreathPartDto.fromJS(resultData200) : new CardObjectiveBreathPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveBreathPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> дыхание
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateBreathUsingPUT(cardId: number, dto: CardObjectiveBreathPartDto): Observable<CardObjectiveBreathPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/breath";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBreathUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBreathUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBreathUsingPUT(response: HttpResponseBase): Observable<CardObjectiveBreathPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveBreathPartDto.fromJS(resultData200) : new CardObjectiveBreathPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveBreathPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> осложнения
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateComplicationsUsingPUT(cardId: number, dto: CardObjectiveComplicationsPartDto): Observable<CardObjectiveComplicationsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/complications";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComplicationsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComplicationsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveComplicationsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveComplicationsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComplicationsUsingPUT(response: HttpResponseBase): Observable<CardObjectiveComplicationsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveComplicationsPartDto.fromJS(resultData200) : new CardObjectiveComplicationsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveComplicationsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> диурез
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesDiuresisUsingGET(cardId: number): Observable<CardObjectiveDiuresisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/diuresis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesDiuresisUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesDiuresisUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesDiuresisUsingGET(response: HttpResponseBase): Observable<CardObjectiveDiuresisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDiuresisPartDto.fromJS(resultData200) : new CardObjectiveDiuresisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDiuresisPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> диурез
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateDiuresisUsingPUT(cardId: number, dto: CardObjectiveDiuresisPartDto): Observable<CardObjectiveDiuresisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/diuresis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDiuresisUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDiuresisUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDiuresisUsingPUT(response: HttpResponseBase): Observable<CardObjectiveDiuresisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDiuresisPartDto.fromJS(resultData200) : new CardObjectiveDiuresisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDiuresisPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> дисп.явления
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesDyspepticUsingGET(cardId: number): Observable<CardObjectiveDyspepticPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/dyspeptic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesDyspepticUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesDyspepticUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesDyspepticUsingGET(response: HttpResponseBase): Observable<CardObjectiveDyspepticPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDyspepticPartDto.fromJS(resultData200) : new CardObjectiveDyspepticPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDyspepticPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> дисп.явления
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateDyspepticUsingPUT(cardId: number, dto: CardObjectiveDyspepticPartDto): Observable<CardObjectiveDyspepticPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/dyspeptic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDyspepticUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDyspepticUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDyspepticUsingPUT(response: HttpResponseBase): Observable<CardObjectiveDyspepticPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDyspepticPartDto.fromJS(resultData200) : new CardObjectiveDyspepticPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDyspepticPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> отеки
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesEdemaUsingGET(cardId: number): Observable<CardObjectiveEdemaPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/edema";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesEdemaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesEdemaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesEdemaUsingGET(response: HttpResponseBase): Observable<CardObjectiveEdemaPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveEdemaPartDto.fromJS(resultData200) : new CardObjectiveEdemaPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveEdemaPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> отеки
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateEdemaUsingPUT(cardId: number, dto: CardObjectiveEdemaPartDto): Observable<CardObjectiveEdemaPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/edema";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdemaUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdemaUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdemaUsingPUT(response: HttpResponseBase): Observable<CardObjectiveEdemaPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveEdemaPartDto.fromJS(resultData200) : new CardObjectiveEdemaPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveEdemaPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез-> cтул и мочеиспускание
     * @param cardId cardId
     * @return OK
     */
    readSideTwoAnamnesisExcretaUrineUsingGET(cardId: number): Observable<CardObjectiveExcretaUrinePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/excreta";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoAnamnesisExcretaUrineUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoAnamnesisExcretaUrineUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoAnamnesisExcretaUrineUsingGET(response: HttpResponseBase): Observable<CardObjectiveExcretaUrinePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveExcretaUrinePartDto.fromJS(resultData200) : new CardObjectiveExcretaUrinePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveExcretaUrinePartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> стул и мочеиспускание
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateExcretaUrineUsingPUT(cardId: number, dto: CardObjectiveExcretaUrinePartDto): Observable<CardObjectiveExcretaUrinePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/excreta";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateExcretaUrineUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExcretaUrineUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateExcretaUrineUsingPUT(response: HttpResponseBase): Observable<CardObjectiveExcretaUrinePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveExcretaUrinePartDto.fromJS(resultData200) : new CardObjectiveExcretaUrinePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveExcretaUrinePartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> общ.состояние
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesGeneralUsingGET(cardId: number): Observable<CardObjectiveGeneralStatePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/general_state";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesGeneralUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesGeneralUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesGeneralUsingGET(response: HttpResponseBase): Observable<CardObjectiveGeneralStatePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGeneralStatePartDto.fromJS(resultData200) : new CardObjectiveGeneralStatePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGeneralStatePartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> общ.состояние
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardObjectiveGeneralUsingPUT(cardId: number, dto: CardObjectiveGeneralStatePartDto): Observable<CardObjectiveGeneralStatePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/general_state";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardObjectiveGeneralUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardObjectiveGeneralUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardObjectiveGeneralUsingPUT(response: HttpResponseBase): Observable<CardObjectiveGeneralStatePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGeneralStatePartDto.fromJS(resultData200) : new CardObjectiveGeneralStatePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGeneralStatePartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> GLASGOW
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesGlasgowUsingGET(cardId: number): Observable<CardObjectiveGlasgowPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/glasgow";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesGlasgowUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesGlasgowUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesGlasgowUsingGET(response: HttpResponseBase): Observable<CardObjectiveGlasgowPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGlasgowPartDto.fromJS(resultData200) : new CardObjectiveGlasgowPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGlasgowPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> GLASGOW
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAdditionsUsingPUT_1(cardId: number, dto: CardObjectiveGlasgowPartDto): Observable<CardObjectiveGlasgowPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/glasgow";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdditionsUsingPUT_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdditionsUsingPUT_1(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdditionsUsingPUT_1(response: HttpResponseBase): Observable<CardObjectiveGlasgowPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGlasgowPartDto.fromJS(resultData200) : new CardObjectiveGlasgowPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGlasgowPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> сердце
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesHeartUsingGET(cardId: number): Observable<CardObjectiveHeartPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/heart";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesHeartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesHeartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesHeartUsingGET(response: HttpResponseBase): Observable<CardObjectiveHeartPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveHeartPartDto.fromJS(resultData200) : new CardObjectiveHeartPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveHeartPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> сердце
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateHeartUsingPUT(cardId: number, dto: CardObjectiveHeartPartDto): Observable<CardObjectiveHeartPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/heart";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHeartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHeartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHeartUsingPUT(response: HttpResponseBase): Observable<CardObjectiveHeartPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveHeartPartDto.fromJS(resultData200) : new CardObjectiveHeartPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveHeartPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> гемодинамика
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisHemodynamicsUsingGET(cardId: number): Observable<CardAnamnesisHemodynamicsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/hemodynamics";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisHemodynamicsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisHemodynamicsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisHemodynamicsUsingGET(response: HttpResponseBase): Observable<CardAnamnesisHemodynamicsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisHemodynamicsPartDto.fromJS(resultData200) : new CardAnamnesisHemodynamicsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisHemodynamicsPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> гемодинамика
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateHemodynamicsUsingPUT(cardId: number, dto: CardAnamnesisHemodynamicsPartDto): Observable<CardAnamnesisHemodynamicsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/hemodynamics";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHemodynamicsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHemodynamicsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHemodynamicsUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisHemodynamicsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisHemodynamicsPartDto.fromJS(resultData200) : new CardAnamnesisHemodynamicsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisHemodynamicsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> печень
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesLiverUsingGET(cardId: number): Observable<CardObjectiveLiverPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/liver";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesLiverUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesLiverUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesLiverUsingGET(response: HttpResponseBase): Observable<CardObjectiveLiverPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLiverPartDto.fromJS(resultData200) : new CardObjectiveLiverPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLiverPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> печень
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateLiverUsingPUT(cardId: number, dto: CardObjectiveLiverPartDto): Observable<CardObjectiveLiverPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/liver";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLiverUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLiverUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLiverUsingPUT(response: HttpResponseBase): Observable<CardObjectiveLiverPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLiverPartDto.fromJS(resultData200) : new CardObjectiveLiverPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLiverPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные - -> лимф.узлы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesLymphUsingGET(cardId: number): Observable<CardObjectiveLymphPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/lymph";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesLymphUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesLymphUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesLymphUsingGET(response: HttpResponseBase): Observable<CardObjectiveLymphPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLymphPartDto.fromJS(resultData200) : new CardObjectiveLymphPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLymphPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> лимф.узлы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateLymphUsingPUT(cardId: number, dto: CardObjectiveLymphPartDto): Observable<CardObjectiveLymphPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/lymph";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLymphUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLymphUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLymphUsingPUT(response: HttpResponseBase): Observable<CardObjectiveLymphPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLymphPartDto.fromJS(resultData200) : new CardObjectiveLymphPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLymphPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> другие показания
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesOtherUsingGET(cardId: number): Observable<CardObjectiveOtherPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/other";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesOtherUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesOtherUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesOtherUsingGET(response: HttpResponseBase): Observable<CardObjectiveOtherPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveOtherPartDto.fromJS(resultData200) : new CardObjectiveOtherPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveOtherPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> другие показания
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateOtherUsingPUT(cardId: number, dto: CardObjectiveOtherPartDto): Observable<CardObjectiveOtherPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/other";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOtherUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOtherUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOtherUsingPUT(response: HttpResponseBase): Observable<CardObjectiveOtherPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveOtherPartDto.fromJS(resultData200) : new CardObjectiveOtherPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveOtherPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> перкуторно
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesPercUsingGET(cardId: number): Observable<CardObjectivePercPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/perc";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesPercUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesPercUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePercPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePercPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesPercUsingGET(response: HttpResponseBase): Observable<CardObjectivePercPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePercPartDto.fromJS(resultData200) : new CardObjectivePercPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePercPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> перкуторно
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updatePercUsingPUT(cardId: number, dto: CardObjectivePercPartDto): Observable<CardObjectivePercPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/perc";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePercUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePercUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePercPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePercPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePercUsingPUT(response: HttpResponseBase): Observable<CardObjectivePercPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePercPartDto.fromJS(resultData200) : new CardObjectivePercPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePercPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные --> зрачки
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesPupilsUsingGET(cardId: number): Observable<CardObjectivePupilsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/pupils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesPupilsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesPupilsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePupilsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePupilsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesPupilsUsingGET(response: HttpResponseBase): Observable<CardObjectivePupilsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePupilsDto.fromJS(resultData200) : new CardObjectivePupilsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePupilsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> зрачки
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updatePupilsUsingPUT(cardId: number, dto: CardObjectivePupilsDto): Observable<CardObjectivePupilsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/pupils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePupilsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePupilsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePupilsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePupilsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePupilsUsingPUT(response: HttpResponseBase): Observable<CardObjectivePupilsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePupilsDto.fromJS(resultData200) : new CardObjectivePupilsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePupilsDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> рефлексы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesReflexesUsingGET(cardId: number): Observable<CardObjectiveReflexesDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/reflexes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesReflexesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesReflexesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesReflexesUsingGET(response: HttpResponseBase): Observable<CardObjectiveReflexesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveReflexesDto.fromJS(resultData200) : new CardObjectiveReflexesDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveReflexesDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> рефлексы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardObjectiveGeneralUsingPUT_1(cardId: number, dto: CardObjectiveReflexesDto): Observable<CardObjectiveReflexesDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/reflexes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardObjectiveGeneralUsingPUT_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardObjectiveGeneralUsingPUT_1(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardObjectiveGeneralUsingPUT_1(response: HttpResponseBase): Observable<CardObjectiveReflexesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveReflexesDto.fromJS(resultData200) : new CardObjectiveReflexesDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveReflexesDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> кож.покровы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesSkinUsingGET(cardId: number): Observable<CardObjectiveSkinPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/skin";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesSkinUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesSkinUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesSkinUsingGET(response: HttpResponseBase): Observable<CardObjectiveSkinPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveSkinPartDto.fromJS(resultData200) : new CardObjectiveSkinPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveSkinPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> кож.покровы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateSkinUsingPUT(cardId: number, dto: CardObjectiveSkinPartDto): Observable<CardObjectiveSkinPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/skin";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkinUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkinUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkinUsingPUT(response: HttpResponseBase): Observable<CardObjectiveSkinPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveSkinPartDto.fromJS(resultData200) : new CardObjectiveSkinPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveSkinPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> живот
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesStomachUsingGET(cardId: number): Observable<CardObjectiveStomachPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/stomach";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesStomachUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesStomachUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesStomachUsingGET(response: HttpResponseBase): Observable<CardObjectiveStomachPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveStomachPartDto.fromJS(resultData200) : new CardObjectiveStomachPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveStomachPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> живот
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateStomachUsingPUT(cardId: number, dto: CardObjectiveStomachPartDto): Observable<CardObjectiveStomachPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/stomach";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStomachUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStomachUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStomachUsingPUT(response: HttpResponseBase): Observable<CardObjectiveStomachPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveStomachPartDto.fromJS(resultData200) : new CardObjectiveStomachPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveStomachPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> слиз.зева
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesThroatUsingGET(cardId: number): Observable<CardObjectiveThroatPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/throat";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesThroatUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesThroatUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesThroatUsingGET(response: HttpResponseBase): Observable<CardObjectiveThroatPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveThroatPartDto.fromJS(resultData200) : new CardObjectiveThroatPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveThroatPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> слиз.зева
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateThroatUsingPUT(cardId: number, dto: CardObjectiveThroatPartDto): Observable<CardObjectiveThroatPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/throat";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateThroatUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateThroatUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateThroatUsingPUT(response: HttpResponseBase): Observable<CardObjectiveThroatPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveThroatPartDto.fromJS(resultData200) : new CardObjectiveThroatPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveThroatPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> язык
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesTongueUsingGET(cardId: number): Observable<CardObjectiveTonguePart> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tongue";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesTongueUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesTongueUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonguePart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonguePart>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesTongueUsingGET(response: HttpResponseBase): Observable<CardObjectiveTonguePart> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonguePart.fromJS(resultData200) : new CardObjectiveTonguePart();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonguePart>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> язык
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateTongueUsingPUT(cardId: number, dto: CardObjectiveTonguePart): Observable<CardObjectiveTonguePart> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tongue";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTongueUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTongueUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonguePart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonguePart>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTongueUsingPUT(response: HttpResponseBase): Observable<CardObjectiveTonguePart> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonguePart.fromJS(resultData200) : new CardObjectiveTonguePart();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonguePart>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> миндалины
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesTonsilsUsingGET(cardId: number): Observable<CardObjectiveTonsilsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tonsils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesTonsilsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesTonsilsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesTonsilsUsingGET(response: HttpResponseBase): Observable<CardObjectiveTonsilsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonsilsPartDto.fromJS(resultData200) : new CardObjectiveTonsilsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonsilsPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> миндалины
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateTonsilsUsingPUT(cardId: number, dto: CardObjectiveTonsilsPartDto): Observable<CardObjectiveTonsilsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tonsils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTonsilsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTonsilsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTonsilsUsingPUT(response: HttpResponseBase): Observable<CardObjectiveTonsilsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonsilsPartDto.fromJS(resultData200) : new CardObjectiveTonsilsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonsilsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> хрипы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesWheezingUsingGET(cardId: number): Observable<CardObjectiveWheezingPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/wheezing";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesWheezingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesWheezingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesWheezingUsingGET(response: HttpResponseBase): Observable<CardObjectiveWheezingPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveWheezingPartDto.fromJS(resultData200) : new CardObjectiveWheezingPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveWheezingPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> хрипы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateWheezingUsingPUT(cardId: number, dto: CardObjectiveWheezingPartDto): Observable<CardObjectiveWheezingPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/wheezing";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWheezingUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWheezingUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWheezingUsingPUT(response: HttpResponseBase): Observable<CardObjectiveWheezingPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveWheezingPartDto.fromJS(resultData200) : new CardObjectiveWheezingPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveWheezingPartDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_7(id: number): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards_objective/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_7(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_7(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_6(dto: CardObjectivePartDto): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards_objective/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_6(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_6(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * readAll
     * @param chatId (optional) chatId
     * @param query (optional) query
     * @return OK
     */
    readAllUsingGET_9(chatId?: number | null | undefined, query?: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/chat_messages?";
        if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&"; 
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_9(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_9(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * create
     * @param chatMessage chatMessage
     * @return OK
     */
    createUsingPOST_7(chatMessage: ChatMessage): Observable<ChatMessage> {
        let url_ = this.baseUrl + "/api/chat_messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chatMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_7(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessage>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_7(response: HttpResponseBase): Observable<ChatMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessage.fromJS(resultData200) : new ChatMessage();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessage>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_10(id: number): Observable<ChatMessage> {
        let url_ = this.baseUrl + "/api/chat_messages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_10(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessage>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_10(response: HttpResponseBase): Observable<ChatMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessage.fromJS(resultData200) : new ChatMessage();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessage>(<any>null);
    }

    /**
     * update
     * @param chatMessage chatMessage
     * @return OK
     */
    updateUsingPUT_9(chatMessage: ChatMessage): Observable<ChatMessage> {
        let url_ = this.baseUrl + "/api/chat_messages/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chatMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_9(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessage>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_9(response: HttpResponseBase): Observable<ChatMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessage.fromJS(resultData200) : new ChatMessage();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessage>(<any>null);
    }

    /**
     * readAll
     * @param query (optional) query
     * @return OK
     */
    readAllUsingGET_8(query?: string | null | undefined): Observable<Chat[]> {
        let url_ = this.baseUrl + "/api/chats?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_8(<any>response_);
                } catch (e) {
                    return <Observable<Chat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_8(response: HttpResponseBase): Observable<Chat[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Chat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat[]>(<any>null);
    }

    /**
     * create
     * @param chat chat
     * @return OK
     */
    createUsingPOST_6(chat: Chat): Observable<Chat> {
        let url_ = this.baseUrl + "/api/chats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chat);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_6(<any>response_);
                } catch (e) {
                    return <Observable<Chat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_6(response: HttpResponseBase): Observable<Chat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Chat.fromJS(resultData200) : new Chat();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat>(<any>null);
    }

    /**
     * readAllPlaces
     * @return OK
     */
    readAllPlacesUsingGET(): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/chats/places";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPlacesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPlacesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPlacesUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_9(id: number): Observable<Chat> {
        let url_ = this.baseUrl + "/api/chats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_9(<any>response_);
                } catch (e) {
                    return <Observable<Chat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_9(response: HttpResponseBase): Observable<Chat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Chat.fromJS(resultData200) : new Chat();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat>(<any>null);
    }

    /**
     * update
     * @param chat chat
     * @return OK
     */
    updateUsingPUT_8(chat: Chat): Observable<Chat> {
        let url_ = this.baseUrl + "/api/chats/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chat);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_8(<any>response_);
                } catch (e) {
                    return <Observable<Chat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_8(response: HttpResponseBase): Observable<Chat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Chat.fromJS(resultData200) : new Chat();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat>(<any>null);
    }

    /**
     * previewUnreadMessages
     * @param id id
     * @param performerId performerId
     * @return OK
     */
    previewUnreadMessagesUsingPUT(id: number, performerId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/chats/{id}/performers/{performerId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewUnreadMessagesUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewUnreadMessagesUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPreviewUnreadMessagesUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * read
     * @return OK
     */
    readUsingGET(): Observable<Config> {
        let url_ = this.baseUrl + "/api/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Config>><any>_observableThrow(e);
                }
            } else
                return <Observable<Config>><any>_observableThrow(response_);
        }));
    }

    protected processReadUsingGET(response: HttpResponseBase): Observable<Config> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : new Config();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Config>(<any>null);
    }

    /**
     * readAll
     * @param deleted (optional) deleted
     * @param with_geom (optional) with_geom
     * @return OK
     */
    readAllUsingGET_10(deleted?: boolean | null | undefined, with_geom?: boolean | null | undefined): Observable<DistrictDto[]> {
        let url_ = this.baseUrl + "/api/districts?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (with_geom !== undefined)
            url_ += "with_geom=" + encodeURIComponent("" + with_geom) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_10(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_10(response: HttpResponseBase): Observable<DistrictDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DistrictDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_8(dto: DistrictDto): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_8(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_8(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readOneByCode
     * @param code code
     * @return OK
     */
    readOneByCodeUsingGET(code: string): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/by_code/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneByCodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneByCodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneByCodeUsingGET(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readOneByFiasId
     * @param id id
     * @return OK
     */
    readOneByFiasIdUsingGET(id: number): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/by_fiasId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneByFiasIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneByFiasIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneByFiasIdUsingGET(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_11(id: number): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_11(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_11(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_10(dto: DistrictDto): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_10(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_10(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readAll
     * @param document_id document_id
     * @return OK
     */
    readAllUsingGET_12(document_id: number): Observable<DocumentNomenclature[]> {
        let url_ = this.baseUrl + "/api/document_nomenclatures?";
        if (document_id === undefined || document_id === null)
            throw new Error("The parameter 'document_id' must be defined and cannot be null.");
        else
            url_ += "document_id=" + encodeURIComponent("" + document_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_12(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_12(response: HttpResponseBase): Observable<DocumentNomenclature[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentNomenclature.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature[]>(<any>null);
    }

    /**
     * create
     * @param documentNomenclature documentNomenclature
     * @return OK
     */
    createUsingPOST_10(documentNomenclature: DocumentNomenclature): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentNomenclature);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_10(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_10(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_13(id: number): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_13(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_13(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * update
     * @param documentNomenclature documentNomenclature
     * @return OK
     */
    updateUsingPUT_12(documentNomenclature: DocumentNomenclature): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentNomenclature);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_12(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_12(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE_1(id: number): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_1(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_1(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * readAll
     * @param is_archived (optional) is_archived
     * @return OK
     */
    readAllUsingGET_11(is_archived?: boolean | null | undefined): Observable<Document[]> {
        let url_ = this.baseUrl + "/api/documents?";
        if (is_archived !== undefined)
            url_ += "is_archived=" + encodeURIComponent("" + is_archived) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_11(<any>response_);
                } catch (e) {
                    return <Observable<Document[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_11(response: HttpResponseBase): Observable<Document[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Document.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document[]>(<any>null);
    }

    /**
     * create
     * @param document document
     * @param accept (optional) accept
     * @return OK
     */
    createUsingPOST_9(document: Document, accept?: boolean | null | undefined): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents?";
        if (accept !== undefined)
            url_ += "accept=" + encodeURIComponent("" + accept) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_9(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_9(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * removeAccept
     * @param id id
     * @return OK
     */
    removeAcceptUsingGET(id: number): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents/remove_accept/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAcceptUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAcceptUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAcceptUsingGET(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_12(id: number): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_12(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_12(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * update
     * @param document document
     * @param accept (optional) accept
     * @return OK
     */
    updateUsingPUT_11(document: Document, accept?: boolean | null | undefined): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents/{id}?";
        if (accept !== undefined)
            url_ += "accept=" + encodeURIComponent("" + accept) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_11(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_11(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * archived
     * @param id id
     * @param archived (optional) archived
     * @return OK
     */
    archivedUsingGET(id: number, archived?: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{id}/archive?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (archived !== undefined)
            url_ += "archived=" + encodeURIComponent("" + archived) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchivedUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchivedUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processArchivedUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param s (optional) s
     * @return OK
     */
    readAllUsingGET_13(s?: string | null | undefined): Observable<DrugDto[]> {
        let url_ = this.baseUrl + "/api/drugs?";
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_13(<any>response_);
                } catch (e) {
                    return <Observable<DrugDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_13(response: HttpResponseBase): Observable<DrugDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DrugDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugDto[]>(<any>null);
    }

    /**
     * readAllCodes
     * @param s (optional) s
     * @return OK
     */
    readAllCodesUsingGET(s?: string | null | undefined): Observable<Code[]> {
        let url_ = this.baseUrl + "/api/drugs/codes?";
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllCodesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllCodesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Code[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Code[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllCodesUsingGET(response: HttpResponseBase): Observable<Code[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Code.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Code[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_14(id: number): Observable<PharmacyReferenceItem> {
        let url_ = this.baseUrl + "/api/drugs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_14(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyReferenceItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyReferenceItem>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_14(response: HttpResponseBase): Observable<PharmacyReferenceItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyReferenceItem.fromJS(resultData200) : new PharmacyReferenceItem();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyReferenceItem>(<any>null);
    }

    /**
     * readAllAddressObject
     * @param diId (optional) diId
     * @param query (optional) query
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllAddressObjectUsingGET(diId?: number | null | undefined, query?: string | null | undefined, deleted?: boolean | null | undefined): Observable<AddressObject[]> {
        let url_ = this.baseUrl + "/api/fias/aos?";
        if (diId !== undefined)
            url_ += "diId=" + encodeURIComponent("" + diId) + "&"; 
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllAddressObjectUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllAddressObjectUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AddressObject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressObject[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllAddressObjectUsingGET(response: HttpResponseBase): Observable<AddressObject[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AddressObject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressObject[]>(<any>null);
    }

    /**
     * readAllDistrict
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllDistrictUsingGET_1(deleted?: boolean | null | undefined): Observable<District[]> {
        let url_ = this.baseUrl + "/api/fias/districts?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllDistrictUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllDistrictUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllDistrictUsingGET_1(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(District.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    /**
     * readOneDistrict
     * @param id id
     * @return OK
     */
    readOneDistrictUsingGET(id: number): Observable<District> {
        let url_ = this.baseUrl + "/api/fias/districts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneDistrictUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneDistrictUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<District>><any>_observableThrow(e);
                }
            } else
                return <Observable<District>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneDistrictUsingGET(response: HttpResponseBase): Observable<District> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? District.fromJS(resultData200) : new District();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District>(<any>null);
    }

    /**
     * findDistrict
     * @param aoId aoId
     * @return OK
     */
    findDistrictUsingGET(aoId: number): Observable<District[]> {
        let url_ = this.baseUrl + "/api/fias/find_district?";
        if (aoId === undefined || aoId === null)
            throw new Error("The parameter 'aoId' must be defined and cannot be null.");
        else
            url_ += "aoId=" + encodeURIComponent("" + aoId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindDistrictUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindDistrictUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindDistrictUsingGET(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(District.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    /**
     * cписок домов, принадлежащих address object
     * @param addressObjectId addressObjectId
     * @return OK
     */
    readHousesByAOidUsingGET(addressObjectId: number): Observable<CardAddressHouseDto[]> {
        let url_ = this.baseUrl + "/api/fias/{addressObjectId}/houses";
        if (addressObjectId === undefined || addressObjectId === null)
            throw new Error("The parameter 'addressObjectId' must be defined.");
        url_ = url_.replace("{addressObjectId}", encodeURIComponent("" + addressObjectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadHousesByAOidUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadHousesByAOidUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAddressHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAddressHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadHousesByAOidUsingGET(response: HttpResponseBase): Observable<CardAddressHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardAddressHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAddressHouseDto[]>(<any>null);
    }

    /**
     * cписок корпусов, принадлежащих address object
     * @param addressObjectId addressObjectId
     * @return OK
     */
    readStructuresByhouseIdUsingGET(addressObjectId: number): Observable<CardAddressHouseDto[]> {
        let url_ = this.baseUrl + "/api/fias/{addressObjectId}/houses/{houseNumber}";
        if (addressObjectId === undefined || addressObjectId === null)
            throw new Error("The parameter 'addressObjectId' must be defined.");
        url_ = url_.replace("{addressObjectId}", encodeURIComponent("" + addressObjectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadStructuresByhouseIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadStructuresByhouseIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAddressHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAddressHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadStructuresByhouseIdUsingGET(response: HttpResponseBase): Observable<CardAddressHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardAddressHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAddressHouseDto[]>(<any>null);
    }

    /**
     * completeAddress
     * @param dto dto
     * @return OK
     */
    completeAddressUsingPOST(dto: CallFiasAddressDto): Observable<CallFiasAddressDto> {
        let url_ = this.baseUrl + "/api/fias2/address/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteAddressUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteAddressUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallFiasAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallFiasAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteAddressUsingPOST(response: HttpResponseBase): Observable<CallFiasAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallFiasAddressDto.fromJS(resultData200) : new CallFiasAddressDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallFiasAddressDto>(<any>null);
    }

    /**
     * readAllCountries
     * @param q (optional) q
     * @return OK
     */
    readAllCountriesUsingGET(q?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/countries?";
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllCountriesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllCountriesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllCountriesUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllDistrict
     * @param region_code region_code
     * @param q (optional) q
     * @return OK
     */
    readAllDistrictUsingGET(region_code: string, q?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/districts?";
        if (region_code === undefined || region_code === null)
            throw new Error("The parameter 'region_code' must be defined and cannot be null.");
        else
            url_ += "region_code=" + encodeURIComponent("" + region_code) + "&"; 
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllDistrictUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllDistrictUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllDistrictUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllHouses
     * @param number (optional) number
     * @param building (optional) building
     * @param structure (optional) structure
     * @param settlement_code (optional) settlement_code
     * @param street_code (optional) street_code
     * @return OK
     */
    readAllHousesUsingGET(number?: string | null | undefined, building?: string | null | undefined, structure?: string | null | undefined, settlement_code?: string | null | undefined, street_code?: string | null | undefined): Observable<FiasAddressHouseDto[]> {
        let url_ = this.baseUrl + "/api/fias2/houses?";
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (building !== undefined)
            url_ += "building=" + encodeURIComponent("" + building) + "&"; 
        if (structure !== undefined)
            url_ += "structure=" + encodeURIComponent("" + structure) + "&"; 
        if (settlement_code !== undefined)
            url_ += "settlement_code=" + encodeURIComponent("" + settlement_code) + "&"; 
        if (street_code !== undefined)
            url_ += "street_code=" + encodeURIComponent("" + street_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllHousesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllHousesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllHousesUsingGET(response: HttpResponseBase): Observable<FiasAddressHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressHouseDto[]>(<any>null);
    }

    /**
     * readAllRegions
     * @param q (optional) q
     * @return OK
     */
    readAllRegionsUsingGET(q?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/regions?";
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllRegionsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllRegionsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllRegionsUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllSettlements
     * @param q q
     * @param region_code region_code
     * @param district_code (optional) district_code
     * @return OK
     */
    readAllSettlementsUsingGET(q: string, region_code: string, district_code?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/settlements?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (region_code === undefined || region_code === null)
            throw new Error("The parameter 'region_code' must be defined and cannot be null.");
        else
            url_ += "region_code=" + encodeURIComponent("" + region_code) + "&"; 
        if (district_code !== undefined)
            url_ += "district_code=" + encodeURIComponent("" + district_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllSettlementsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllSettlementsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllSettlementsUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllStreets
     * @param region_code region_code
     * @param district_code district_code
     * @param q (optional) q
     * @param settlement_code (optional) settlement_code
     * @return OK
     */
    readAllStreetsUsingGET(region_code: string, district_code: string, q?: string | null | undefined, settlement_code?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/streets?";
        if (region_code === undefined || region_code === null)
            throw new Error("The parameter 'region_code' must be defined and cannot be null.");
        else
            url_ += "region_code=" + encodeURIComponent("" + region_code) + "&"; 
        if (district_code === undefined || district_code === null)
            throw new Error("The parameter 'district_code' must be defined and cannot be null.");
        else
            url_ += "district_code=" + encodeURIComponent("" + district_code) + "&"; 
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (settlement_code !== undefined)
            url_ += "settlement_code=" + encodeURIComponent("" + settlement_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllStreetsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllStreetsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllStreetsUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * getManual
     * @return OK
     */
    getManualUsingGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/help/manual";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManualUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManualUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetManualUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param parId (optional) parId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_15(parId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<HospitalDto[]> {
        let url_ = this.baseUrl + "/api/hospitals?";
        if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_15(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_15(response: HttpResponseBase): Observable<HospitalDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HospitalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_11(dto: HospitalDto): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/hospitals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_11(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_11(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HospitalDto.fromJS(resultData200) : new HospitalDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_15(id: number): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/hospitals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_15(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_15(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_13(dto: HospitalDto): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/hospitals/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_13(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_13(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HospitalDto.fromJS(resultData200) : new HospitalDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(<any>null);
    }

    /**
     * create112
     * @return OK
     */
    create112UsingGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/imitation/create112";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate112UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate112UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate112UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * createNezabudka
     * @param phone phone
     * @return OK
     */
    createNezabudkaUsingGET(phone: string): Observable<CallGridDto[]> {
        let url_ = this.baseUrl + "/api/imitation/nezabudka/calls/find?";
        if (phone === undefined || phone === null)
            throw new Error("The parameter 'phone' must be defined and cannot be null.");
        else
            url_ += "phone=" + encodeURIComponent("" + phone) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNezabudkaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNezabudkaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNezabudkaUsingGET(response: HttpResponseBase): Observable<CallGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGridDto[]>(<any>null);
    }

    /**
     * routing
     * @param turn_on (optional) turn_on
     * @return OK
     */
    routingUsingGET(turn_on?: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/imitation/routing?";
        if (turn_on !== undefined)
            url_ += "turn_on=" + encodeURIComponent("" + turn_on) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoutingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoutingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRoutingUsingGET(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * опросник -> запись
     * @param dto dto
     * @return OK
     */
    updateObjectUsingPOST(dto: InquirerDto): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateObjectUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateObjectUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateObjectUsingPOST(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * опросник -> запись - > новая
     * @param parentId parentId
     * @return OK
     */
    getCreateUsingGET(parentId: number): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer/create/{parentId}";
        if (parentId === undefined || parentId === null)
            throw new Error("The parameter 'parentId' must be defined.");
        url_ = url_.replace("{parentId}", encodeURIComponent("" + parentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreateUsingGET(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * опросник в виде дерева
     * @param parentId (optional) parentId
     * @return OK
     */
    readTreeUsingGET(parentId?: number | null | undefined): Observable<InquirerTreeNode[]> {
        let url_ = this.baseUrl + "/api/inquirer/tree?";
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerTreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerTreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeUsingGET(response: HttpResponseBase): Observable<InquirerTreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InquirerTreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerTreeNode[]>(<any>null);
    }

    /**
     * опросник -> запись
     * @param id id
     * @return OK
     */
    readObjectUsingGET(id: number): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadObjectUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadObjectUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadObjectUsingGET(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * [UPDATE] опросник -> запись
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateObjectUsingPUT(id: number, dto: InquirerDto): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateObjectUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateObjectUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateObjectUsingPUT(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * [UPDATE] опросник -> запись
     * @param id id
     * @return OK
     */
    deleteObjectReasonUsingDELETE(id: number): Observable<Inquirer> {
        let url_ = this.baseUrl + "/api/inquirer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteObjectReasonUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteObjectReasonUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<Inquirer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inquirer>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteObjectReasonUsingDELETE(response: HttpResponseBase): Observable<Inquirer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inquirer.fromJS(resultData200) : new Inquirer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inquirer>(<any>null);
    }

    /**
     * readAll
     * @param place_id (optional) place_id
     * @param product_id (optional) product_id
     * @return OK
     */
    readAllUsingGET_16(place_id?: number | null | undefined, product_id?: number | null | undefined): Observable<Inventory[]> {
        let url_ = this.baseUrl + "/api/inventories?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (product_id !== undefined)
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_16(<any>response_);
                } catch (e) {
                    return <Observable<Inventory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_16(response: HttpResponseBase): Observable<Inventory[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Inventory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory[]>(<any>null);
    }

    /**
     * create
     * @param inventory inventory
     * @return OK
     */
    createUsingPOST_12(inventory: Inventory): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inventory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_12(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_12(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * readOneForProductAndPlace
     * @param place_id place_id
     * @param product_id product_id
     * @return OK
     */
    readOneForProductAndPlaceUsingGET(place_id: number, product_id: number): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories/for_product_and_place?";
        if (place_id === undefined || place_id === null)
            throw new Error("The parameter 'place_id' must be defined and cannot be null.");
        else
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (product_id === undefined || product_id === null)
            throw new Error("The parameter 'product_id' must be defined and cannot be null.");
        else
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneForProductAndPlaceUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneForProductAndPlaceUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneForProductAndPlaceUsingGET(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * getMovementOfInventory
     * @param inventory_id inventory_id
     * @return OK
     */
    getMovementOfInventoryUsingGET(inventory_id: number): Observable<ProductMove[]> {
        let url_ = this.baseUrl + "/api/inventories/movements?";
        if (inventory_id === undefined || inventory_id === null)
            throw new Error("The parameter 'inventory_id' must be defined and cannot be null.");
        else
            url_ += "inventory_id=" + encodeURIComponent("" + inventory_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMovementOfInventoryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMovementOfInventoryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ProductMove[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductMove[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMovementOfInventoryUsingGET(response: HttpResponseBase): Observable<ProductMove[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductMove.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductMove[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_16(id: number): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_16(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_16(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * update
     * @param inventory inventory
     * @return OK
     */
    updateUsingPUT_14(inventory: Inventory): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inventory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_14(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_14(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * readAll
     * @param inventory_id (optional) inventory_id
     * @param product_id (optional) product_id
     * @return OK
     */
    readAllUsingGET_17(inventory_id?: number | null | undefined, product_id?: number | null | undefined): Observable<InventoryNomenclature[]> {
        let url_ = this.baseUrl + "/api/inventory_nomenclatures?";
        if (inventory_id !== undefined)
            url_ += "inventory_id=" + encodeURIComponent("" + inventory_id) + "&"; 
        if (product_id !== undefined)
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_17(<any>response_);
                } catch (e) {
                    return <Observable<InventoryNomenclature[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryNomenclature[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_17(response: HttpResponseBase): Observable<InventoryNomenclature[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InventoryNomenclature.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryNomenclature[]>(<any>null);
    }

    /**
     * login
     * @return OK
     */
    loginUsingGET(): Observable<LoginInfo> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LoginInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginInfo>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingGET(response: HttpResponseBase): Observable<LoginInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginInfo.fromJS(resultData200) : new LoginInfo();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginInfo>(<any>null);
    }

    /**
     * login
     * @param login login
     * @return OK
     */
    loginUsingPOST(login: LoginPair): Observable<LoginInfo> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<LoginInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginInfo>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingPOST(response: HttpResponseBase): Observable<LoginInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginInfo.fromJS(resultData200) : new LoginInfo();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginInfo>(<any>null);
    }

    /**
     * logout
     * @return OK
     */
    logoutUsingGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogoutUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogoutUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogoutUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param itemId itemId
     * @param item_type (optional) item_type
     * @param type (optional) type
     * @param action_type (optional) action_type
     * @param date_from (optional) date_from
     * @param date_to (optional) date_to
     * @return OK
     */
    readAllUsingGET_18(itemId: number, item_type?: string | null | undefined, type?: string | null | undefined, action_type?: string | null | undefined, date_from?: string | null | undefined, date_to?: string | null | undefined): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/logs/{itemId}?";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId)); 
        if (item_type !== undefined)
            url_ += "item_type=" + encodeURIComponent("" + item_type) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (action_type !== undefined)
            url_ += "action_type=" + encodeURIComponent("" + action_type) + "&"; 
        if (date_from !== undefined)
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to !== undefined)
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_18(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_18(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> поиск бригад
     * @return OK
     */
    findBrigadesUsingGET_1(): Observable<BrigadeFindListDto[]> {
        let url_ = this.baseUrl + "/api/maps/brigade_schedules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindBrigadesUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindBrigadesUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeFindListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeFindListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindBrigadesUsingGET_1(response: HttpResponseBase): Observable<BrigadeFindListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeFindListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeFindListDto[]>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_27(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/materials?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_27(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_27(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_26(id: number): Observable<PharmacyReferenceItem> {
        let url_ = this.baseUrl + "/api/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_26(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyReferenceItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyReferenceItem>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_26(response: HttpResponseBase): Observable<PharmacyReferenceItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyReferenceItem.fromJS(resultData200) : new PharmacyReferenceItem();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyReferenceItem>(<any>null);
    }

    /**
     * readOne
     * @return OK
     */
    readOneUsingGET_17(): Observable<NotificationObject> {
        let url_ = this.baseUrl + "/api/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_17(<any>response_);
                } catch (e) {
                    return <Observable<NotificationObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationObject>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_17(response: HttpResponseBase): Observable<NotificationObject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NotificationObject.fromJS(resultData200) : new NotificationObject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationObject>(<any>null);
    }

    /**
     * readHelloWorld
     * @return OK
     */
    readHelloWorldUsingGET(): Observable<string> {
        let url_ = this.baseUrl + "/api/notifications/nosecurity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadHelloWorldUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadHelloWorldUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processReadHelloWorldUsingGET(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * карта -> tile [image.png]
     * @param z z
     * @param x x
     * @param y y
     * @return OK
     */
    getUsingGET(z: number, x: number, y: number): Observable<void> {
        let url_ = this.baseUrl + "/api/osm_tiles/{z}/{x}/{y}";
        if (z === undefined || z === null)
            throw new Error("The parameter 'z' must be defined.");
        url_ = url_.replace("{z}", encodeURIComponent("" + z)); 
        if (x === undefined || x === null)
            throw new Error("The parameter 'x' must be defined.");
        url_ = url_.replace("{x}", encodeURIComponent("" + x)); 
        if (y === undefined || y === null)
            throw new Error("The parameter 'y' must be defined.");
        url_ = url_.replace("{y}", encodeURIComponent("" + y)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param product_id product_id
     * @return OK
     */
    readAllUsingGET_19(product_id: number): Observable<Packaging[]> {
        let url_ = this.baseUrl + "/api/packagings?";
        if (product_id === undefined || product_id === null)
            throw new Error("The parameter 'product_id' must be defined and cannot be null.");
        else
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_19(<any>response_);
                } catch (e) {
                    return <Observable<Packaging[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_19(response: HttpResponseBase): Observable<Packaging[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Packaging.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging[]>(<any>null);
    }

    /**
     * create
     * @param packaging packaging
     * @return OK
     */
    createUsingPOST_13(packaging: Packaging): Observable<Packaging> {
        let url_ = this.baseUrl + "/api/packagings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(packaging);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_13(<any>response_);
                } catch (e) {
                    return <Observable<Packaging>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_13(response: HttpResponseBase): Observable<Packaging> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Packaging.fromJS(resultData200) : new Packaging();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_18(id: number): Observable<Packaging> {
        let url_ = this.baseUrl + "/api/packagings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_18(<any>response_);
                } catch (e) {
                    return <Observable<Packaging>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_18(response: HttpResponseBase): Observable<Packaging> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Packaging.fromJS(resultData200) : new Packaging();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging>(<any>null);
    }

    /**
     * update
     * @param packaging packaging
     * @return OK
     */
    updateUsingPUT_15(packaging: Packaging): Observable<Packaging> {
        let url_ = this.baseUrl + "/api/packagings/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(packaging);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_15(<any>response_);
                } catch (e) {
                    return <Observable<Packaging>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_15(response: HttpResponseBase): Observable<Packaging> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Packaging.fromJS(resultData200) : new Packaging();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging>(<any>null);
    }

    /**
     * readAll
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_21(deleted?: boolean | null | undefined): Observable<PerformerTypeDto[]> {
        let url_ = this.baseUrl + "/api/performer_types?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_21(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_21(response: HttpResponseBase): Observable<PerformerTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_15(dto: PerformerTypeDto): Observable<PerformerTypeDto> {
        let url_ = this.baseUrl + "/api/performer_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_15(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_15(response: HttpResponseBase): Observable<PerformerTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeDto.fromJS(resultData200) : new PerformerTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_20(id: number): Observable<PerformerTypeDto> {
        let url_ = this.baseUrl + "/api/performer_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_20(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_20(response: HttpResponseBase): Observable<PerformerTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeDto.fromJS(resultData200) : new PerformerTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_17(dto: PerformerTypeDto): Observable<PerformerTypeDto> {
        let url_ = this.baseUrl + "/api/performer_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_17(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_17(response: HttpResponseBase): Observable<PerformerTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeDto.fromJS(resultData200) : new PerformerTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto>(<any>null);
    }

    /**
     * readAll
     * @param subId (optional) subId
     * @param f110Id (optional) f110Id
     * @param deleted (optional) deleted
     * @param skills (optional) skills
     * @param query (optional) query
     * @param brigade_scheduleId (optional) brigade_scheduleId
     * @return OK
     */
    readAllUsingGET_20(subId?: number | null | undefined, f110Id?: number | null | undefined, deleted?: boolean | null | undefined, skills?: boolean | null | undefined, query?: string | null | undefined, brigade_scheduleId?: number | null | undefined): Observable<ListDtoOfPerformerDto> {
        let url_ = this.baseUrl + "/api/performers?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (f110Id !== undefined)
            url_ += "f110Id=" + encodeURIComponent("" + f110Id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (skills !== undefined)
            url_ += "skills=" + encodeURIComponent("" + skills) + "&"; 
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        if (brigade_scheduleId !== undefined)
            url_ += "brigade_scheduleId=" + encodeURIComponent("" + brigade_scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_20(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfPerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfPerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_20(response: HttpResponseBase): Observable<ListDtoOfPerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfPerformerDto.fromJS(resultData200) : new ListDtoOfPerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfPerformerDto>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_14(dto: PerformerDto): Observable<PerformerDto> {
        let url_ = this.baseUrl + "/api/performers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_14(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_14(response: HttpResponseBase): Observable<PerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerDto.fromJS(resultData200) : new PerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto>(<any>null);
    }

    /**
     * updatePassword
     * @param login login
     * @return OK
     */
    updatePasswordUsingGET(login: string): Observable<void> {
        let url_ = this.baseUrl + "/api/performers/password?";
        if (login === undefined || login === null)
            throw new Error("The parameter 'login' must be defined and cannot be null.");
        else
            url_ += "login=" + encodeURIComponent("" + login) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePasswordUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * updatePassword
     * @param dto dto
     * @param password password
     * @param password2 password2
     * @return OK
     */
    updatePasswordUsingPOST(dto: PerformerDto, password: string, password2: string): Observable<void> {
        let url_ = this.baseUrl + "/api/performers/password?";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (password2 === undefined || password2 === null)
            throw new Error("The parameter 'password2' must be defined and cannot be null.");
        else
            url_ += "password2=" + encodeURIComponent("" + password2) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePasswordUsingPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readRoles
     * @param id id
     * @return OK
     */
    readRolesUsingGET(id: number): Observable<ListDtoOfRole> {
        let url_ = this.baseUrl + "/api/performers/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadRolesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadRolesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfRole>><any>_observableThrow(response_);
        }));
    }

    protected processReadRolesUsingGET(response: HttpResponseBase): Observable<ListDtoOfRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfRole.fromJS(resultData200) : new ListDtoOfRole();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfRole>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @param skills (optional) skills
     * @return OK
     */
    readOneUsingGET_19(id: number, skills?: boolean | null | undefined): Observable<PerformerDto> {
        let url_ = this.baseUrl + "/api/performers/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (skills !== undefined)
            url_ += "skills=" + encodeURIComponent("" + skills) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_19(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_19(response: HttpResponseBase): Observable<PerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerDto.fromJS(resultData200) : new PerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_16(id: number, dto: PerformerDto): Observable<PerformerDto> {
        let url_ = this.baseUrl + "/api/performers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_16(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_16(response: HttpResponseBase): Observable<PerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerDto.fromJS(resultData200) : new PerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto>(<any>null);
    }

    /**
     * readAll
     * @param place_id (optional) place_id
     * @param drug_id (optional) drug_id
     * @param code (optional) code
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_22(place_id?: number | null | undefined, drug_id?: number | null | undefined, code?: string | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (drug_id !== undefined)
            url_ += "drug_id=" + encodeURIComponent("" + drug_id) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_22(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_22(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllDrugs
     * @param place_id (optional) place_id
     * @param drug_id (optional) drug_id
     * @param type (optional) type
     * @param group_id (optional) group_id
     * @param is_narcotic (optional) is_narcotic
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllDrugsUsingGET(place_id?: number | null | undefined, drug_id?: number | null | undefined, type?: number | null | undefined, group_id?: number | null | undefined, is_narcotic?: boolean | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/drugs?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (drug_id !== undefined)
            url_ += "drug_id=" + encodeURIComponent("" + drug_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (group_id !== undefined)
            url_ += "group_id=" + encodeURIComponent("" + group_id) + "&"; 
        if (is_narcotic !== undefined)
            url_ += "is_narcotic=" + encodeURIComponent("" + is_narcotic) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllDrugsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllDrugsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllDrugsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllTotalDrugs
     * @param place_id (optional) place_id
     * @param is_narcotic (optional) is_narcotic
     * @return OK
     */
    readAllTotalDrugsUsingGET(place_id?: number | null | undefined, is_narcotic?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/drugs/total?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (is_narcotic !== undefined)
            url_ += "is_narcotic=" + encodeURIComponent("" + is_narcotic) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllTotalDrugsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllTotalDrugsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllTotalDrugsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllMaterials
     * @param place_id (optional) place_id
     * @param drug_id (optional) drug_id
     * @param type (optional) type
     * @param group_id (optional) group_id
     * @param is_bandages (optional) is_bandages
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllMaterialsUsingGET(place_id?: number | null | undefined, drug_id?: number | null | undefined, type?: number | null | undefined, group_id?: number | null | undefined, is_bandages?: boolean | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/materials?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (drug_id !== undefined)
            url_ += "drug_id=" + encodeURIComponent("" + drug_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (group_id !== undefined)
            url_ += "group_id=" + encodeURIComponent("" + group_id) + "&"; 
        if (is_bandages !== undefined)
            url_ += "is_bandages=" + encodeURIComponent("" + is_bandages) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllMaterialsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllMaterialsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllMaterialsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllTotalMaterials
     * @param place_id (optional) place_id
     * @param is_bandages (optional) is_bandages
     * @return OK
     */
    readAllTotalMaterialsUsingGET(place_id?: number | null | undefined, is_bandages?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/materials/total?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (is_bandages !== undefined)
            url_ += "is_bandages=" + encodeURIComponent("" + is_bandages) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllTotalMaterialsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllTotalMaterialsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllTotalMaterialsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_21(id: number): Observable<PharmacyDto> {
        let url_ = this.baseUrl + "/api/pharmacy/references/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_21(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_21(response: HttpResponseBase): Observable<PharmacyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDto.fromJS(resultData200) : new PharmacyDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto>(<any>null);
    }

    /**
     * updateDrug
     * @param pharmacyItem pharmacyItem
     * @return OK
     */
    updateDrugUsingPUT(pharmacyItem: PharmacyItem): Observable<PharmacyItem> {
        let url_ = this.baseUrl + "/api/pharmacy/references/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pharmacyItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyItem>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugUsingPUT(response: HttpResponseBase): Observable<PharmacyItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyItem.fromJS(resultData200) : new PharmacyItem();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyItem>(<any>null);
    }

    /**
     * readAll
     * @param owner_id (optional) owner_id
     * @param bag_id (optional) bag_id
     * @return OK
     */
    readAllUsingGET_2(owner_id?: number | null | undefined, bag_id?: number | null | undefined): Observable<BagItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items?";
        if (owner_id !== undefined)
            url_ += "owner_id=" + encodeURIComponent("" + owner_id) + "&"; 
        if (bag_id !== undefined)
            url_ += "bag_id=" + encodeURIComponent("" + bag_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_2(response: HttpResponseBase): Observable<BagItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_2(dto: BagItemDto): Observable<BagItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_2(response: HttpResponseBase): Observable<BagItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagItemDto.fromJS(resultData200) : new BagItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto>(<any>null);
    }

    /**
     * readAllByTemplate
     * @param template_id (optional) template_id
     * @return OK
     */
    readAllByTemplateUsingGET(template_id?: number | null | undefined): Observable<BagItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items/templates/{id}?";
        if (template_id !== undefined)
            url_ += "template_id=" + encodeURIComponent("" + template_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllByTemplateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllByTemplateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllByTemplateUsingGET(response: HttpResponseBase): Observable<BagItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_2(id: number): Observable<BagItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_2(response: HttpResponseBase): Observable<BagItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagItemDto.fromJS(resultData200) : new BagItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_2(dto: BagItemDto): Observable<BagItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_2(response: HttpResponseBase): Observable<BagItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagItemDto.fromJS(resultData200) : new BagItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto>(<any>null);
    }

    /**
     * readAll
     * @param bag_id (optional) bag_id
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_3(bag_id?: number | null | undefined, matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<BagMatrixItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_matrix_items?";
        if (bag_id !== undefined)
            url_ += "bag_id=" + encodeURIComponent("" + bag_id) + "&"; 
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_3(<any>response_);
                } catch (e) {
                    return <Observable<BagMatrixItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagMatrixItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_3(response: HttpResponseBase): Observable<BagMatrixItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagMatrixItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagMatrixItemDto[]>(<any>null);
    }

    /**
     * readAll
     * @param owner_id (optional) owner_id
     * @return OK
     */
    readAllUsingGET_1(owner_id?: number | null | undefined): Observable<BagDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bags?";
        if (owner_id !== undefined)
            url_ += "owner_id=" + encodeURIComponent("" + owner_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_1(response: HttpResponseBase): Observable<BagDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_1(dto: BagDto): Observable<BagDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_1(response: HttpResponseBase): Observable<BagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagDto.fromJS(resultData200) : new BagDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto>(<any>null);
    }

    /**
     * sendBag
     * @param dto dto
     * @return OK
     */
    sendBagUsingPUT(dto: SendBagDto): Observable<void> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/sending";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendBagUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendBagUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendBagUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_1(id: number): Observable<BagDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_1(response: HttpResponseBase): Observable<BagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagDto.fromJS(resultData200) : new BagDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_1(id: number, dto: BagDto): Observable<BagDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_1(response: HttpResponseBase): Observable<BagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagDto.fromJS(resultData200) : new BagDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto>(<any>null);
    }

    /**
     * unpacking
     * @param id id
     * @param dto dto
     * @return OK
     */
    unpackingUsingPUT(id: number, dto: BagDto): Observable<void> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/{id}/unpacking";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpackingUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpackingUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnpackingUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_23(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyCounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_23(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyCounterpartyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyCounterpartyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_23(response: HttpResponseBase): Observable<PharmacyCounterpartyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyCounterpartyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyCounterpartyDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_16(dto: PharmacyCounterpartyDto): Observable<PharmacyCounterpartyDto> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_16(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_16(response: HttpResponseBase): Observable<PharmacyCounterpartyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyCounterpartyDto.fromJS(resultData200) : new PharmacyCounterpartyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyCounterpartyDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_22(id: number): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_22(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_22(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_18(dto: PharmacyCounterpartyDto): Observable<PharmacyCounterpartyDto> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_18(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_18(response: HttpResponseBase): Observable<PharmacyCounterpartyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyCounterpartyDto.fromJS(resultData200) : new PharmacyCounterpartyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyCounterpartyDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param type (optional) type
     * @param counterparty_id (optional) counterparty_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_24(sub_id?: number | null | undefined, type?: number | null | undefined, counterparty_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDocumentDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_documents?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (counterparty_id !== undefined)
            url_ += "counterparty_id=" + encodeURIComponent("" + counterparty_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_24(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_24(response: HttpResponseBase): Observable<PharmacyDocumentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDocumentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_17(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_17(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_17(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_19(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_19(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_19(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readAllNomenclatureItems
     * @param owner_id (optional) owner_id
     * @param type (optional) type
     * @return OK
     */
    readAllNomenclatureItemsUsingGET(owner_id?: number | null | undefined, type?: number | null | undefined): Observable<PharmacyNomenclatureDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/nomenclature_items?";
        if (owner_id !== undefined)
            url_ += "owner_id=" + encodeURIComponent("" + owner_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllNomenclatureItemsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllNomenclatureItemsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyNomenclatureDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyNomenclatureDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllNomenclatureItemsUsingGET(response: HttpResponseBase): Observable<PharmacyNomenclatureDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyNomenclatureDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyNomenclatureDto[]>(<any>null);
    }

    /**
     * createAndProcessing
     * @param dto dto
     * @return OK
     */
    createAndProcessingUsingPOST(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/processing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAndProcessingUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAndProcessingUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAndProcessingUsingPOST(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * updateAndProcessing
     * @param dto dto
     * @return OK
     */
    updateAndProcessingUsingPUT(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/processing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAndProcessingUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAndProcessingUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAndProcessingUsingPUT(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_23(id: number): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_23(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_23(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readAllItems
     * @param id id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllItemsUsingGET(id: number, deleted?: boolean | null | undefined): Observable<DocumentItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/{id}/items?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllItemsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllItemsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DocumentItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllItemsUsingGET(response: HttpResponseBase): Observable<DocumentItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentItemDto[]>(<any>null);
    }

    /**
     * processing
     * @param id id
     * @return OK
     */
    processingUsingGET(id: number): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/{id}/processing";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processProcessingUsingGET(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readAll
     * @param bag_id (optional) bag_id
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_14(bag_id?: number | null | undefined, matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<GroupBagItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_group_bag_items?";
        if (bag_id !== undefined)
            url_ += "bag_id=" + encodeURIComponent("" + bag_id) + "&"; 
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_14(<any>response_);
                } catch (e) {
                    return <Observable<GroupBagItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupBagItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_14(response: HttpResponseBase): Observable<GroupBagItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GroupBagItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupBagItemDto[]>(<any>null);
    }

    /**
     * readAll
     * @param group_id (optional) group_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_26(group_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyGroupReferenceDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references?";
        if (group_id !== undefined)
            url_ += "group_id=" + encodeURIComponent("" + group_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_26(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_26(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyGroupReferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_19(dto: PharmacyGroupReferenceDto): Observable<PharmacyGroupReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_19(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_19(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupReferenceDto.fromJS(resultData200) : new PharmacyGroupReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_25(id: number): Observable<PharmacyGroupReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_25(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_25(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupReferenceDto.fromJS(resultData200) : new PharmacyGroupReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_21(dto: PharmacyGroupReferenceDto): Observable<PharmacyGroupReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_21(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_21(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupReferenceDto.fromJS(resultData200) : new PharmacyGroupReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_25(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ReferenceDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_groups?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_25(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_25(response: HttpResponseBase): Observable<ReferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_18(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_18(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_18(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_24(id: number): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_24(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_24(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_20(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_groups/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_20(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_20(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_29(sub_id?: number | null | undefined, matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyMatrixGroupDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_29(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_29(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyMatrixGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_21(dto: PharmacyMatrixGroupDto): Observable<PharmacyMatrixGroupDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_21(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_21(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixGroupDto.fromJS(resultData200) : new PharmacyMatrixGroupDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_28(id: number): Observable<PharmacyMatrixGroupDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_28(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_28(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixGroupDto.fromJS(resultData200) : new PharmacyMatrixGroupDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_23(dto: PharmacyMatrixGroupDto): Observable<PharmacyMatrixGroupDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_23(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_23(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixGroupDto.fromJS(resultData200) : new PharmacyMatrixGroupDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto>(<any>null);
    }

    /**
     * readAll
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_30(matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyMatrixItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items?";
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_30(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_30(response: HttpResponseBase): Observable<PharmacyMatrixItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyMatrixItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_22(dto: PharmacyMatrixItemDto): Observable<PharmacyMatrixItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_22(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_22(response: HttpResponseBase): Observable<PharmacyMatrixItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixItemDto.fromJS(resultData200) : new PharmacyMatrixItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_29(id: number): Observable<PharmacyMatrixItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_29(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_29(response: HttpResponseBase): Observable<PharmacyMatrixItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixItemDto.fromJS(resultData200) : new PharmacyMatrixItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_24(dto: PharmacyMatrixItemDto): Observable<PharmacyMatrixItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_24(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_24(response: HttpResponseBase): Observable<PharmacyMatrixItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixItemDto.fromJS(resultData200) : new PharmacyMatrixItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_28(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ReferenceDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_28(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_28(response: HttpResponseBase): Observable<ReferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_20(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_20(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_20(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_27(id: number): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_27(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_27(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_22(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_22(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_22(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readAll
     * @param subdivision_id subdivision_id
     * @param without_owner (optional) without_owner
     * @param type (optional) type
     * @return OK
     */
    readAllUsingGET_31(subdivision_id: number, without_owner?: boolean | null | undefined, type?: Type | null | undefined): Observable<Place[]> {
        let url_ = this.baseUrl + "/api/places?";
        if (subdivision_id === undefined || subdivision_id === null)
            throw new Error("The parameter 'subdivision_id' must be defined and cannot be null.");
        else
            url_ += "subdivision_id=" + encodeURIComponent("" + subdivision_id) + "&"; 
        if (without_owner !== undefined)
            url_ += "without_owner=" + encodeURIComponent("" + without_owner) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_31(<any>response_);
                } catch (e) {
                    return <Observable<Place[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_31(response: HttpResponseBase): Observable<Place[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Place.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place[]>(<any>null);
    }

    /**
     * create
     * @param place place
     * @return OK
     */
    createUsingPOST_23(place: Place): Observable<Place> {
        let url_ = this.baseUrl + "/api/places";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(place);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_23(<any>response_);
                } catch (e) {
                    return <Observable<Place>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_23(response: HttpResponseBase): Observable<Place> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Place.fromJS(resultData200) : new Place();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_30(id: number): Observable<Place> {
        let url_ = this.baseUrl + "/api/places/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_30(<any>response_);
                } catch (e) {
                    return <Observable<Place>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_30(response: HttpResponseBase): Observable<Place> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Place.fromJS(resultData200) : new Place();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place>(<any>null);
    }

    /**
     * update
     * @param place place
     * @return OK
     */
    updateUsingPUT_25(place: Place): Observable<Place> {
        let url_ = this.baseUrl + "/api/places/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(place);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_25(<any>response_);
                } catch (e) {
                    return <Observable<Place>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_25(response: HttpResponseBase): Observable<Place> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Place.fromJS(resultData200) : new Place();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place>(<any>null);
    }

    /**
     * readAll
     * @return OK
     */
    readAllUsingGET_33(): Observable<ProductType[]> {
        let url_ = this.baseUrl + "/api/product_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_33(<any>response_);
                } catch (e) {
                    return <Observable<ProductType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_33(response: HttpResponseBase): Observable<ProductType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType[]>(<any>null);
    }

    /**
     * create
     * @param productType productType
     * @return OK
     */
    createUsingPOST_25(productType: ProductType): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/product_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_25(<any>response_);
                } catch (e) {
                    return <Observable<ProductType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_25(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductType.fromJS(resultData200) : new ProductType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_32(id: number): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/product_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_32(<any>response_);
                } catch (e) {
                    return <Observable<ProductType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_32(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductType.fromJS(resultData200) : new ProductType();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType>(<any>null);
    }

    /**
     * update
     * @param productType productType
     * @return OK
     */
    updateUsingPUT_27(productType: ProductType): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/product_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_27(<any>response_);
                } catch (e) {
                    return <Observable<ProductType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_27(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductType.fromJS(resultData200) : new ProductType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType>(<any>null);
    }

    /**
     * readAll
     * @param s (optional) s
     * @return OK
     */
    readAllUsingGET_32(s?: string | null | undefined): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/products?";
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_32(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_32(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * create
     * @param product product
     * @return OK
     */
    createUsingPOST_24(product: Product): Observable<Product> {
        let url_ = this.baseUrl + "/api/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_24(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_24(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_31(id: number): Observable<Product> {
        let url_ = this.baseUrl + "/api/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_31(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_31(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * update
     * @param product product
     * @return OK
     */
    updateUsingPUT_26(product: Product): Observable<Product> {
        let url_ = this.baseUrl + "/api/products/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_26(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_26(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * readAll
     * @param type type
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_34(type: string, deleted?: boolean | null | undefined): Observable<ReferenceTypeDto[]> {
        let url_ = this.baseUrl + "/api/reference_types?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_34(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_34(response: HttpResponseBase): Observable<ReferenceTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReferenceTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_26(dto: ReferenceTypeDto): Observable<ReferenceTypeDto> {
        let url_ = this.baseUrl + "/api/reference_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_26(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_26(response: HttpResponseBase): Observable<ReferenceTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeDto.fromJS(resultData200) : new ReferenceTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_33(id: number): Observable<ReferenceTypeDto> {
        let url_ = this.baseUrl + "/api/reference_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_33(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_33(response: HttpResponseBase): Observable<ReferenceTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeDto.fromJS(resultData200) : new ReferenceTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_28(id: number, dto: ReferenceTypeDto): Observable<ReferenceTypeDto> {
        let url_ = this.baseUrl + "/api/reference_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_28(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_28(response: HttpResponseBase): Observable<ReferenceTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeDto.fromJS(resultData200) : new ReferenceTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto>(<any>null);
    }

    /**
     * печать карт вызовов
     * @return OK
     */
    generateCardReportUsingGET_2(): Observable<ModelAndView> {
        let url_ = this.baseUrl + "/api/report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCardReportUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCardReportUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<ModelAndView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelAndView>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCardReportUsingGET_2(response: HttpResponseBase): Observable<ModelAndView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ModelAndView.fromJS(resultData200) : new ModelAndView();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelAndView>(<any>null);
    }

    /**
     * печать карты вызова
     * @param id id
     * @return OK
     */
    generateCardReportUsingGET_1(id: number): Observable<ModelAndView> {
        let url_ = this.baseUrl + "/api/report/cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCardReportUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCardReportUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ModelAndView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelAndView>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCardReportUsingGET_1(response: HttpResponseBase): Observable<ModelAndView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ModelAndView.fromJS(resultData200) : new ModelAndView();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelAndView>(<any>null);
    }

    /**
     * печать сопроводит. листа и талона к нему
     * @param id id
     * @return OK
     */
    generateCardReportUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/report/cards/{id}/ticket";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCardReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCardReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCardReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать графика нарядов бригад СМП
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @return OK
     */
    generateBrigadeCalendarUsingGET(id: number, date_from: string, date_to: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/calendars/brigades?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBrigadeCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBrigadeCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateBrigadeCalendarUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать графика работы сотрудников
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @param group_code group_code
     * @return OK
     */
    generatePerforemerCalendarUsingGET(id: number, date_from: string, date_to: string, group_code: Group_code): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/calendars/performers?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        if (group_code === undefined || group_code === null)
            throw new Error("The parameter 'group_code' must be defined and cannot be null.");
        else
            url_ += "group_code=" + encodeURIComponent("" + group_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePerforemerCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePerforemerCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePerforemerCalendarUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать дневника работы СМП
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @return OK
     */
    generateDiaryReportUsingGET(id: number, date_from: string, date_to: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/cards/diary?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDiaryReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDiaryReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDiaryReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать жарнала вызовов в подразделении
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @return OK
     */
    generateJournalReportUsingGET(id: number, date_from: string, date_to: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/cards/journal?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateJournalReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateJournalReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateJournalReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать ежедневного отчета
     * @param id id
     * @param date date
     * @return OK
     */
    generateDailyReportUsingGET(id: number, date: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/daily?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent("" + date) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDailyReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDailyReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDailyReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать сигнального талона
     * @param subId subId
     * @param cardId cardId
     * @return OK
     */
    generateAlarmTicketUsingGET(subId: number, cardId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{subId}/cards/{cardId}/alarm_ticket";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateAlarmTicketUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateAlarmTicketUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateAlarmTicketUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать протокола констатации смерти
     * @param subId subId
     * @param cardId cardId
     * @return OK
     */
    generateDeathProtocolUsingGET(subId: number, cardId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{subId}/cards/{cardId}/death_protocol";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDeathProtocolUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDeathProtocolUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDeathProtocolUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param node node
     * @return OK
     */
    readAllUsingGET_35(node: string): Observable<ReportGroup[]> {
        let url_ = this.baseUrl + "/api/report_groups/tree?";
        if (node === undefined || node === null)
            throw new Error("The parameter 'node' must be defined and cannot be null.");
        else
            url_ += "node=" + encodeURIComponent("" + node) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_35(<any>response_);
                } catch (e) {
                    return <Observable<ReportGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_35(response: HttpResponseBase): Observable<ReportGroup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportGroup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportGroup[]>(<any>null);
    }

    /**
     * readAllByGroupCodeAndSubdivisionId
     * @param group_code group_code
     * @return OK
     */
    readAllByGroupCodeAndSubdivisionIdUsingGET(group_code: string): Observable<Report[]> {
        let url_ = this.baseUrl + "/api/reports?";
        if (group_code === undefined || group_code === null)
            throw new Error("The parameter 'group_code' must be defined and cannot be null.");
        else
            url_ += "group_code=" + encodeURIComponent("" + group_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllByGroupCodeAndSubdivisionIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllByGroupCodeAndSubdivisionIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Report[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllByGroupCodeAndSubdivisionIdUsingGET(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Report.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report[]>(<any>null);
    }

    /**
     * create
     * @param form (optional) form
     * @return OK
     */
    createUsingPOST_27(form?: UploadFileForm | null | undefined): Observable<Report> {
        let url_ = this.baseUrl + "/api/reports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_27(<any>response_);
                } catch (e) {
                    return <Observable<Report>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_27(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Report.fromJS(resultData200) : new Report();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report>(<any>null);
    }

    /**
     * пустой метод, для автогенерации клиентского кода
     * @return OK
     */
    createEmptyUploadFormUsingGET(): Observable<UploadFileForm> {
        let url_ = this.baseUrl + "/api/reports/create-empty-upload-from";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmptyUploadFormUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmptyUploadFormUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UploadFileForm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadFileForm>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEmptyUploadFormUsingGET(response: HttpResponseBase): Observable<UploadFileForm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadFileForm.fromJS(resultData200) : new UploadFileForm();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadFileForm>(<any>null);
    }

    /**
     * download
     * @param id id
     * @return OK
     */
    downloadUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reports/download/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * print
     * @param map map
     * @return OK
     */
    printUsingPOST(map: string): Observable<string> {
        let url_ = this.baseUrl + "/api/reports/entities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(map);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrintUsingPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * getTables
     * @return OK
     */
    getTablesUsingGET(): Observable<Table[]> {
        let url_ = this.baseUrl + "/api/reports/entities/root";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTablesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTablesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Table[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Table[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTablesUsingGET(response: HttpResponseBase): Observable<Table[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Table.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Table[]>(<any>null);
    }

    /**
     * getFieldsByType
     * @param type type
     * @return OK
     */
    getFieldsByTypeUsingGET(type: number): Observable<Field[]> {
        let url_ = this.baseUrl + "/api/reports/entities/{type}/fields";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldsByTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldsByTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Field[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Field[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldsByTypeUsingGET(response: HttpResponseBase): Observable<Field[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Field.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Field[]>(<any>null);
    }

    /**
     * readReportList
     * @param code code
     * @param type type
     * @param format format
     * @return OK
     */
    readReportListUsingGET(code: string, type: number, format: number): Observable<Report[]> {
        let url_ = this.baseUrl + "/api/reports/list?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadReportListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadReportListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Report[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadReportListUsingGET(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Report.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report[]>(<any>null);
    }

    /**
     * prepareCommon
     * @param dto dto
     * @return OK
     */
    prepareCommonUsingPOST(dto: ReportRequestDto): Observable<string> {
        let url_ = this.baseUrl + "/api/reports/prepare_card";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCommonUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCommonUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCommonUsingPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * print
     * @param uid uid
     * @return OK
     */
    printUsingGET(uid: string): Observable<void> {
        let url_ = this.baseUrl + "/api/reports/print?";
        if (uid === undefined || uid === null)
            throw new Error("The parameter 'uid' must be defined and cannot be null.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrintUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_34(id: number): Observable<Report> {
        let url_ = this.baseUrl + "/api/reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_34(<any>response_);
                } catch (e) {
                    return <Observable<Report>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_34(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Report.fromJS(resultData200) : new Report();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE_2(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [DEPRECATED] возвращает список записей МКБ 10 по текстовому поиску в коде/названии
     * @param s s
     * @return OK
     */
    findMkbListUsingGET_1(s: string): Observable<MkbDto[]> {
        let url_ = this.baseUrl + "/api/results/mkb?";
        if (s === undefined || s === null)
            throw new Error("The parameter 's' must be defined and cannot be null.");
        else
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindMkbListUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindMkbListUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<MkbDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MkbDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindMkbListUsingGET_1(response: HttpResponseBase): Observable<MkbDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MkbDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MkbDto[]>(<any>null);
    }

    /**
     * [DEPRECATED] возвращает вложенные записи МКБ 10 по id parent-записи
     * @param id id
     * @return OK
     */
    readMkbListUsingGET_1(id: number): Observable<MkbDto[]> {
        let url_ = this.baseUrl + "/api/results/mkb/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadMkbListUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadMkbListUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<MkbDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MkbDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadMkbListUsingGET_1(response: HttpResponseBase): Observable<MkbDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MkbDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MkbDto[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_8(id: number): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/results/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_8(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_8(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_7(dto: CardResultDto): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/results/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_7(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_7(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * read
     * @param coords coords
     * @return OK
     */
    readUsingPOST(coords: number[][]): Observable<RoutingDto> {
        let url_ = this.baseUrl + "/api/routing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(coords);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<RoutingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutingDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadUsingPOST(response: HttpResponseBase): Observable<RoutingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoutingDto.fromJS(resultData200) : new RoutingDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutingDto>(<any>null);
    }

    /**
     * readAll
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_36(subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<SkillDto[]> {
        let url_ = this.baseUrl + "/api/skills?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_36(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_36(response: HttpResponseBase): Observable<SkillDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SkillDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_28(dto: SkillDto): Observable<SkillDto> {
        let url_ = this.baseUrl + "/api/skills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_28(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_28(response: HttpResponseBase): Observable<SkillDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillDto.fromJS(resultData200) : new SkillDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_35(id: number): Observable<SkillDto> {
        let url_ = this.baseUrl + "/api/skills/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_35(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_35(response: HttpResponseBase): Observable<SkillDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillDto.fromJS(resultData200) : new SkillDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_29(dto: SkillDto): Observable<SkillDto> {
        let url_ = this.baseUrl + "/api/skills/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_29(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_29(response: HttpResponseBase): Observable<SkillDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillDto.fromJS(resultData200) : new SkillDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto>(<any>null);
    }

    /**
     * readAll
     * @param parId (optional) parId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_39(parId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<SubdivisionTypeDto[]> {
        let url_ = this.baseUrl + "/api/subdivision_types?";
        if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_39(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_39(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_39(response: HttpResponseBase): Observable<SubdivisionTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_30(dto: SubdivisionDto): Observable<SubdivisionTypeDto> {
        let url_ = this.baseUrl + "/api/subdivision_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_30(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_30(response: HttpResponseBase): Observable<SubdivisionTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeDto.fromJS(resultData200) : new SubdivisionTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto>(<any>null);
    }

    /**
     * readTree
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeUsingGET_2(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivision_types/tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeUsingGET_2(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_37(id: number): Observable<SubdivisionTypeDto> {
        let url_ = this.baseUrl + "/api/subdivision_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_37(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_37(response: HttpResponseBase): Observable<SubdivisionTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeDto.fromJS(resultData200) : new SubdivisionTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_31(dto: SubdivisionDto): Observable<SubdivisionTypeDto> {
        let url_ = this.baseUrl + "/api/subdivision_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_31(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_31(response: HttpResponseBase): Observable<SubdivisionTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeDto.fromJS(resultData200) : new SubdivisionTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto>(<any>null);
    }

    /**
     * [READ] список подразделений -> все
     * @param query (optional) query
     * @param parId (optional) parId
     * @param with_par (optional) with_par
     * @param typeId (optional) typeId
     * @param type_code (optional) type_code
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_38(query?: string | null | undefined, parId?: number | null | undefined, with_par?: boolean | null | undefined, typeId?: number | null | undefined, type_code?: string | null | undefined, deleted?: boolean | null | undefined): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&"; 
        if (with_par !== undefined)
            url_ += "with_par=" + encodeURIComponent("" + with_par) + "&"; 
        if (typeId !== undefined)
            url_ += "typeId=" + encodeURIComponent("" + typeId) + "&"; 
        if (type_code !== undefined)
            url_ += "type_code=" + encodeURIComponent("" + type_code) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_38(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_38(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_38(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_29(dto: SubdivisionFlatDto): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/subdivisions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_29(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_29(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * [READ] список подразделений с родителями -> все
     * @return OK
     */
    readAllWithParentUsingGET(): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllWithParentUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllWithParentUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllWithParentUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * [READ] дерево подразделений с бригадами -> все
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeWithBrigadesUsingGET(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/brigade_tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeWithBrigadesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeWithBrigadesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeWithBrigadesUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * ????)
     * @return OK
     */
    readAllWithBrigadesUsingGET(): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/brigades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllWithBrigadesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllWithBrigadesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllWithBrigadesUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * ???? денис???)
     * @return OK
     */
    readBrigadeTreeUsingGET(): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/brigades/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadBrigadeTreeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadBrigadeTreeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadBrigadeTreeUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * [READ] список подразделений -> основные (ТЦМК/Отделения)
     * @param deleted (optional) deleted
     * @param cardId (optional) cardId
     * @param with_current (optional) with_current
     * @return OK
     */
    readAllPrimaryUsingGET_1(deleted?: boolean | null | undefined, cardId?: number | null | undefined, with_current?: boolean | null | undefined): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/primary?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (with_current !== undefined)
            url_ += "with_current=" + encodeURIComponent("" + with_current) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPrimaryUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPrimaryUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPrimaryUsingGET_1(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * [READ] дерево подразделений -> основные (ТЦМК/Отделения)
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllPrimaryTreeUsingGET(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/primary/tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPrimaryTreeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPrimaryTreeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPrimaryTreeUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * [READ] дерево подразделений -> все
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeUsingGET_1(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeUsingGET_1(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * readTreeFlat
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeFlatUsingGET(deleted?: boolean | null | undefined): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/tree/flat?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeFlatUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeFlatUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeFlatUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * [READ] подразделение
     * @param id id
     * @return OK
     */
    readOneUsingGET_36(id: number): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_36(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_36(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_30(dto: SubdivisionFlatDto): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_30(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_30(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * возвращает список бригад в подразделении
     * @param subId subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_37(subId: number, deleted?: boolean | null | undefined): Observable<BrigadeDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/brigades?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_37(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_37(response: HttpResponseBase): Observable<BrigadeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto[]>(<any>null);
    }

    /**
     * возвращает список актуальных смен бригад в подразделении
     * @param subId subId
     * @param mode (optional) mode
     * @return OK
     */
    readAllActualUsingGET(subId: number, mode?: Mode | null | undefined): Observable<BrigadeScheduleDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllActualUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllActualUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllActualUsingGET(response: HttpResponseBase): Observable<BrigadeScheduleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeScheduleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto[]>(<any>null);
    }

    /**
     * вывод бригады из смены
     * @param subId subId
     * @param brigadeScheduleId brigadeScheduleId
     * @param dto dto
     * @return OK
     */
    endBrigadeDutyUsingPUT(subId: number, brigadeScheduleId: number, dto: BrigadeDutyRequestDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules/{brigadeScheduleId}/end_duty";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndBrigadeDutyUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndBrigadeDutyUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processEndBrigadeDutyUsingPUT(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * возвращает хронологию изменений статусов бригады
     * @param subId subId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    getBrigadeScheduleCallTransferHistoryUsingGET(subId: number, brigadeScheduleId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules/{brigadeScheduleId}/protocol";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallTransferHistoryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallTransferHistoryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallTransferHistoryUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * вывод бригады в смену
     * @param subId subId
     * @param brigadeScheduleId brigadeScheduleId
     * @param dto dto
     * @return OK
     */
    startBrigadeDutyUsingPUT(subId: number, brigadeScheduleId: number, dto: BrigadeDutyRequestDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules/{brigadeScheduleId}/start_duty";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartBrigadeDutyUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartBrigadeDutyUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processStartBrigadeDutyUsingPUT(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * возвращает список рабочих периодов всех бригад в подразделении
     * @param subId subId
     * @param from (optional) from
     * @param to (optional) to
     * @return OK
     */
    readPerformersCalendarUsingGET(subId: number, from?: string | null | undefined, to?: string | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPerformersCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPerformersCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processReadPerformersCalendarUsingGET(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * возвращает список свободных сотрудников для назначения в бригаду
     * @param subId subId
     * @param from from
     * @param group_code group_code
     * @param to to
     * @param s (optional) s
     * @param chosen_list (optional) список id сотрудников, добавленных в бригаду
     * @return OK
     */
    readAllAvailablePerformersUsingGET(subId: number, from: string, group_code: Group_code2, to: string, s?: string | null | undefined, chosen_list?: number[] | null | undefined): Observable<PerformerBrigScheduleAvailableDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/performers/available?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (group_code === undefined || group_code === null)
            throw new Error("The parameter 'group_code' must be defined and cannot be null.");
        else
            url_ += "group_code=" + encodeURIComponent("" + group_code) + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        if (chosen_list !== undefined)
            chosen_list && chosen_list.forEach(item => { url_ += "chosen_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllAvailablePerformersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllAvailablePerformersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleAvailableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleAvailableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllAvailablePerformersUsingGET(response: HttpResponseBase): Observable<PerformerBrigScheduleAvailableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerBrigScheduleAvailableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleAvailableDto[]>(<any>null);
    }

    /**
     * возвращает список свободных транспортных средств для назначения в бригаду
     * @param subId subId
     * @param from from
     * @param to to
     * @param s (optional) s
     * @param excludeId_list (optional) список id авто, добавленных в бригаду
     * @return OK
     */
    readAllAvailableTranspotsUsingGET(subId: number, from: string, to: string, s?: string | null | undefined, excludeId_list?: number[] | null | undefined): Observable<TransportBrigScheduleAvailableDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/transport/available?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        if (excludeId_list !== undefined)
            excludeId_list && excludeId_list.forEach(item => { url_ += "excludeId_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllAvailableTranspotsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllAvailableTranspotsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportBrigScheduleAvailableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBrigScheduleAvailableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllAvailableTranspotsUsingGET(response: HttpResponseBase): Observable<TransportBrigScheduleAvailableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportBrigScheduleAvailableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBrigScheduleAvailableDto[]>(<any>null);
    }

    /**
     * создание рабочего периода (смены) для бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param dto dto
     * @return OK
     */
    createBrigadeScheduleUsingPOST(subId: number, brigadeId: number, dto: BrigadeScheduleCreateDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrigadeScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrigadeScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBrigadeScheduleUsingPOST(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * возвращает рабочий период бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @return OK
     */
    getBrigadeScheduleUsingGET_1(subId: number, brigadeId: number, scheduleId: number): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleUsingGET_1(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * редактирование рабочего периода для бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param dto dto
     * @return OK
     */
    updateBrigadeScheduleUsingPUT(subId: number, brigadeId: number, scheduleId: number, dto: BrigadeScheduleUpdateDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeScheduleUsingPUT(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * удаление рабочего периода бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @return OK
     */
    updateBrigadeScheduleUsingDELETE(subId: number, brigadeId: number, scheduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * возвращает список вызовов по наряду
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @return OK
     */
    getBrigadeScheduleCallsUsingGET(subId: number, brigadeId: number, scheduleId: number): Observable<BrigadeCallDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/calls";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeCallDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeCallDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallsUsingGET(response: HttpResponseBase): Observable<BrigadeCallDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeCallDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeCallDto[]>(<any>null);
    }

    /**
     * создание рабочего периода сотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param dto dto
     * @return OK
     */
    createPerformerBrigScheduleUsingPOST(subId: number, brigadeId: number, scheduleId: number, dto: PerformerBrigScheduleCreateDto): Observable<PerformerBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerformerBrigScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerformerBrigScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerformerBrigScheduleUsingPOST(response: HttpResponseBase): Observable<PerformerBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBrigScheduleDto.fromJS(resultData200) : new PerformerBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleDto>(<any>null);
    }

    /**
     * возвращает рабочий период cотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param performerScheduleId performerScheduleId
     * @return OK
     */
    getBrigadeScheduleUsingGET(subId: number, brigadeId: number, scheduleId: number, performerScheduleId: number): Observable<PerformerBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers/{performerScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (performerScheduleId === undefined || performerScheduleId === null)
            throw new Error("The parameter 'performerScheduleId' must be defined.");
        url_ = url_.replace("{performerScheduleId}", encodeURIComponent("" + performerScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleUsingGET(response: HttpResponseBase): Observable<PerformerBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBrigScheduleDto.fromJS(resultData200) : new PerformerBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleDto>(<any>null);
    }

    /**
     * редактирование рабочего периода сотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param performerScheduleId performerScheduleId
     * @param dto dto
     * @return OK
     */
    updatePerformerBrigScheduleUsingPUT(subId: number, brigadeId: number, scheduleId: number, performerScheduleId: number, dto: PerformerBrigScheduleUpdateDto): Observable<PerformerBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers/{performerScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (performerScheduleId === undefined || performerScheduleId === null)
            throw new Error("The parameter 'performerScheduleId' must be defined.");
        url_ = url_.replace("{performerScheduleId}", encodeURIComponent("" + performerScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerBrigScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerBrigScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerBrigScheduleUsingPUT(response: HttpResponseBase): Observable<PerformerBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBrigScheduleDto.fromJS(resultData200) : new PerformerBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleDto>(<any>null);
    }

    /**
     * удаление рабочего периода сотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param performerScheduleId performerScheduleId
     * @return OK
     */
    deletePerformerBrigadeScheduleUsingDELETE(subId: number, brigadeId: number, scheduleId: number, performerScheduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers/{performerScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (performerScheduleId === undefined || performerScheduleId === null)
            throw new Error("The parameter 'performerScheduleId' must be defined.");
        url_ = url_.replace("{performerScheduleId}", encodeURIComponent("" + performerScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * создание рабочего периода транспорта в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param dto dto
     * @return OK
     */
    createCarBrigScheduleUsingPOST(subId: number, brigadeId: number, scheduleId: number, dto: TransportBrigScheduleCreateDto): Observable<TransportBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/transport";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCarBrigScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCarBrigScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TransportBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCarBrigScheduleUsingPOST(response: HttpResponseBase): Observable<TransportBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBrigScheduleDto.fromJS(resultData200) : new TransportBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBrigScheduleDto>(<any>null);
    }

    /**
     * редактирование рабочего периода транспорта в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param transportScheduleId transportScheduleId
     * @param dto dto
     * @return OK
     */
    updateCarBrigScheduleUsingPUT(subId: number, brigadeId: number, scheduleId: number, transportScheduleId: number, dto: TransportBrigScheduleUpdateDto): Observable<TransportBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/transport/{transportScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (transportScheduleId === undefined || transportScheduleId === null)
            throw new Error("The parameter 'transportScheduleId' must be defined.");
        url_ = url_.replace("{transportScheduleId}", encodeURIComponent("" + transportScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCarBrigScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCarBrigScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<TransportBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCarBrigScheduleUsingPUT(response: HttpResponseBase): Observable<TransportBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBrigScheduleDto.fromJS(resultData200) : new TransportBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBrigScheduleDto>(<any>null);
    }

    /**
     * удаление рабочего периода транспорта в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param transportScheduleId transportScheduleId
     * @return OK
     */
    deleteCarBrigadeScheduleUsingDELETE(subId: number, brigadeId: number, scheduleId: number, transportScheduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/transport/{transportScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (transportScheduleId === undefined || transportScheduleId === null)
            throw new Error("The parameter 'transportScheduleId' must be defined.");
        url_ = url_.replace("{transportScheduleId}", encodeURIComponent("" + transportScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCarBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCarBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCarBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * возвращает список рабочих периодов всех сотрудников в подразделении
     * @param subId (optional) id текущего подразделения
     * @param from (optional) дата начала 'yyyy-MM-ddTHH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-ddTHH:mm:ss'
     * @param subdivisionId (optional) id подразделения для календаря
     * @return OK
     */
    readPerformersCalendarUsingGET_1(subId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined, subdivisionId?: number | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPerformersCalendarUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPerformersCalendarUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processReadPerformersCalendarUsingGET_1(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * возвращает шаблон для пролонгации календаря в подразделении
     * @param subId (optional) id текущего подразделения
     * @param from (optional) дата начала 'yyyy-MM-dd'T'HH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-dd'T'HH:mm:ss'
     * @return OK
     */
    generatePerformerScheduleCalendarUsingGET(subId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/generate?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePerformerScheduleCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePerformerScheduleCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePerformerScheduleCalendarUsingGET(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * формирует календрарь в подразделении по шаблону
     * @param map map
     * @param subId (optional) id текущего подразделения
     * @return OK
     */
    createPerformersCalendarUsingPOST(map: Container, subId?: number | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/generate";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(map);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerformersCalendarUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerformersCalendarUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerformersCalendarUsingPOST(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * протокол календаря в подразделении
     * @param subId (optional) id текущего подразделения
     * @param subdivisionId (optional) id подразделения для календаря
     * @param from (optional) дата начала 'yyyy-MM-ddTHH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-ddTHH:mm:ss'
     * @return OK
     */
    readProtocolForSubdivisionUsingGET(subId?: number | null | undefined, subdivisionId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/protocol?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolForSubdivisionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolForSubdivisionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolForSubdivisionUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * [READ] список типов смены в календаре
     * @param subId subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllScheduleTypeUsingGET(subId: number, deleted?: boolean | null | undefined): Observable<ScheduleType[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllScheduleTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllScheduleTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllScheduleTypeUsingGET(response: HttpResponseBase): Observable<ScheduleType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ScheduleType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType[]>(<any>null);
    }

    /**
     * [CREATE] создание нового типа смены в календаре
     * @param subId subId
     * @param scheduleType scheduleType
     * @return OK
     */
    createScheduleTypeUsingPOST(subId: number, scheduleType: ScheduleType): Observable<ScheduleType> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateScheduleTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateScheduleTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType>><any>_observableThrow(response_);
        }));
    }

    protected processCreateScheduleTypeUsingPOST(response: HttpResponseBase): Observable<ScheduleType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleType.fromJS(resultData200) : new ScheduleType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType>(<any>null);
    }

    /**
     * [READ] тип смены в календаре
     * @param subId subId
     * @param id id
     * @return OK
     */
    readScheduleTypeUsingGET(subId: number, id: number): Observable<ScheduleType> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadScheduleTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadScheduleTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType>><any>_observableThrow(response_);
        }));
    }

    protected processReadScheduleTypeUsingGET(response: HttpResponseBase): Observable<ScheduleType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleType.fromJS(resultData200) : new ScheduleType();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType>(<any>null);
    }

    /**
     * [UPDATE] изменение типа смены в календаре
     * @param subId subId
     * @param id id
     * @param scheduleType scheduleType
     * @return OK
     */
    updateScheduleTypeUsingPUT(subId: number, id: number, scheduleType: ScheduleType): Observable<ScheduleType> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheduleTypeUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheduleTypeUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheduleTypeUsingPUT(response: HttpResponseBase): Observable<ScheduleType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleType.fromJS(resultData200) : new ScheduleType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType>(<any>null);
    }

    /**
     * [READ] расчет периода смены в календаре
     * @param subId subId
     * @param id id
     * @param mode mode
     * @param from from
     * @param to (optional) to
     * @return OK
     */
    calculateScheduleUsingGET(subId: number, id: number, mode: Mode2, from: string, to?: string | null | undefined): Observable<Period> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types/{id}/calculate?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined and cannot be null.");
        else
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Period>><any>_observableThrow(e);
                }
            } else
                return <Observable<Period>><any>_observableThrow(response_);
        }));
    }

    protected processCalculateScheduleUsingGET(response: HttpResponseBase): Observable<Period> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Period.fromJS(resultData200) : new Period();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Period>(<any>null);
    }

    /**
     * протокол календаря для сотрудника
     * @param subId (optional) id текущего подразделения
     * @param performerId (optional) id сотрудника в календаре
     * @param from (optional) дата начала 'yyyy-MM-ddTHH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-ddTHH:mm:ss'
     * @return OK
     */
    readProtocolForPerformerUsingGET(subId?: number | null | undefined, performerId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/protocol?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (performerId !== null && performerId !== undefined)
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        else
            url_ = url_.replace("/{performerId}", "");
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolForPerformerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolForPerformerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolForPerformerUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * возвращает список рабочих периодов сотрудника по id
     * @param subId subId
     * @param performerId performerId
     * @param from (optional) from
     * @param to (optional) to
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllSchedulesUsingGET(subId: number, performerId: number, from?: string | null | undefined, to?: string | null | undefined, deleted?: boolean | null | undefined): Observable<PerformerScheduleDto2[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllSchedulesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllSchedulesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllSchedulesUsingGET(response: HttpResponseBase): Observable<PerformerScheduleDto2[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerScheduleDto2.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerScheduleDto2[]>(<any>null);
    }

    /**
     * создание рабочего периода для сотрудника
     * @param subId subId
     * @param performerId performerId
     * @param dto dto
     * @return OK
     */
    createPerformerScheduleUsingPOST(subId: number, performerId: number, dto: PerformerScheduleDto2): Observable<PerformerScheduleDto2[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerformerScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerformerScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerformerScheduleUsingPOST(response: HttpResponseBase): Observable<PerformerScheduleDto2[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerScheduleDto2.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerScheduleDto2[]>(<any>null);
    }

    /**
     * обновление сведений о конкретоном рабочем периоде сотрудника
     * @param subId subId
     * @param performerId performerId
     * @param dto dto
     * @return OK
     */
    updatePerformersScheduleUsingPUT(subId: number, performerId: number, dto: PerformerScheduleDto2): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformersScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformersScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformersScheduleUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * возвращает рабочий период сотрудника по id
     * @param subId subId
     * @param performerId performerId
     * @param id id
     * @return OK
     */
    readOnePerformerScheduleUsingGET(subId: number, performerId: number, id: number): Observable<PerformerScheduleDto2> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOnePerformerScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOnePerformerScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerScheduleDto2>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerScheduleDto2>><any>_observableThrow(response_);
        }));
    }

    protected processReadOnePerformerScheduleUsingGET(response: HttpResponseBase): Observable<PerformerScheduleDto2> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerScheduleDto2.fromJS(resultData200) : new PerformerScheduleDto2();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerScheduleDto2>(<any>null);
    }

    /**
     * удаление рабочего периода сотрудника
     * @param subId subId
     * @param performerId performerId
     * @param id id
     * @return OK
     */
    deletePerformersScheduleUsingDELETE(subId: number, performerId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformersScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformersScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformersScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы
     * @param subId subId
     * @param mode (optional) mode
     * @return OK
     */
    readAllUsingGET_6(subId: number, mode?: Mode3 | null | undefined): Observable<CallGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_6(<any>response_);
                } catch (e) {
                    return <Observable<CallGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_6(response: HttpResponseBase): Observable<CallGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGridDto[]>(<any>null);
    }

    /**
     * [CREATE ]создание нового вызова [возвращает callId]
     * @param subId subId
     * @param dto dto
     * @return OK
     */
    createUsingPOST_5(subId: number, dto: CallDtoFLAT): Observable<LongDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_5(<any>response_);
                } catch (e) {
                    return <Observable<LongDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LongDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_5(response: HttpResponseBase): Observable<LongDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LongDto.fromJS(resultData200) : new LongDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LongDto>(<any>null);
    }

    /**
     * [READ] получение данных для создания нового вызова
     * @param subId subId
     * @param phone (optional) phone
     * @param audio_file_name (optional) audio_file_name
     * @return OK
     */
    prepareCallUsingGET(subId: number, phone?: string | null | undefined, audio_file_name?: string | null | undefined): Observable<CallDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/create?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&"; 
        if (audio_file_name !== undefined)
            url_ += "audio_file_name=" + encodeURIComponent("" + audio_file_name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCallUsingGET(response: HttpResponseBase): Observable<CallDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDto.fromJS(resultData200) : new CallDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDto>(<any>null);
    }

    /**
     * [CREATE] поиск первичного вызова
     * @param subId subId
     * @param dto dto
     * @return OK
     */
    findSimilarCallsUsingPOST(subId: number, dto: CallSimilarRequestDto): Observable<CallShortDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/primary/find";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindSimilarCallsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindSimilarCallsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallShortDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallShortDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindSimilarCallsUsingPOST(response: HttpResponseBase): Observable<CallShortDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallShortDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallShortDto[]>(<any>null);
    }

    /**
     * [READ] возвращает список вызовов по заданным параметрам поиска
     * @param subdivisionId (optional) 
     * @param number (optional) 
     * @param declarantName (optional) 
     * @param declarantPhone (optional) 
     * @param patientName (optional) 
     * @param patientSex (optional) 
     * @param patientAgeYears (optional) 
     * @param patientAgeMonths (optional) 
     * @param patientAgeDays (optional) 
     * @param aoName (optional) 
     * @param districtId (optional) 
     * @param performer (optional) 
     * @param callTypeId (optional) 
     * @param declarantTypeId (optional) 
     * @param phone (optional) 
     * @param callPlaceTypeId (optional) 
     * @param reasonTypeId (optional) 
     * @return OK
     */
    readAllUsingPOST(subdivisionId?: number | null | undefined, number?: string | null | undefined, declarantName?: string | null | undefined, declarantPhone?: string | null | undefined, patientName?: string | null | undefined, patientSex?: number | null | undefined, patientAgeYears?: number | null | undefined, patientAgeMonths?: number | null | undefined, patientAgeDays?: number | null | undefined, aoName?: string | null | undefined, districtId?: number | null | undefined, performer?: string | null | undefined, callTypeId?: number | null | undefined, declarantTypeId?: number | null | undefined, phone?: string | null | undefined, callPlaceTypeId?: number | null | undefined, reasonTypeId?: number | null | undefined): Observable<CallGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/request?";
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (declarantName !== undefined)
            url_ += "declarantName=" + encodeURIComponent("" + declarantName) + "&"; 
        if (declarantPhone !== undefined)
            url_ += "declarantPhone=" + encodeURIComponent("" + declarantPhone) + "&"; 
        if (patientName !== undefined)
            url_ += "patientName=" + encodeURIComponent("" + patientName) + "&"; 
        if (patientSex !== undefined)
            url_ += "patientSex=" + encodeURIComponent("" + patientSex) + "&"; 
        if (patientAgeYears !== undefined)
            url_ += "patientAgeYears=" + encodeURIComponent("" + patientAgeYears) + "&"; 
        if (patientAgeMonths !== undefined)
            url_ += "patientAgeMonths=" + encodeURIComponent("" + patientAgeMonths) + "&"; 
        if (patientAgeDays !== undefined)
            url_ += "patientAgeDays=" + encodeURIComponent("" + patientAgeDays) + "&"; 
        if (aoName !== undefined)
            url_ += "aoName=" + encodeURIComponent("" + aoName) + "&"; 
        if (districtId !== undefined)
            url_ += "districtId=" + encodeURIComponent("" + districtId) + "&"; 
        if (performer !== undefined)
            url_ += "performer=" + encodeURIComponent("" + performer) + "&"; 
        if (callTypeId !== undefined)
            url_ += "callTypeId=" + encodeURIComponent("" + callTypeId) + "&"; 
        if (declarantTypeId !== undefined)
            url_ += "declarantTypeId=" + encodeURIComponent("" + declarantTypeId) + "&"; 
        if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&"; 
        if (callPlaceTypeId !== undefined)
            url_ += "callPlaceTypeId=" + encodeURIComponent("" + callPlaceTypeId) + "&"; 
        if (reasonTypeId !== undefined)
            url_ += "reasonTypeId=" + encodeURIComponent("" + reasonTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingPOST(response: HttpResponseBase): Observable<CallGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGridDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы -> входящие
     * @param subId subId
     * @return OK
     */
    getReceivedListUsingGET(subId: number): Observable<CallTransferDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/transfer";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallTransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallTransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceivedListUsingGET(response: HttpResponseBase): Observable<CallTransferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallTransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallTransferDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readOneUsingGET_5(subId: number, callId: number): Observable<CallDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_5(<any>response_);
                } catch (e) {
                    return <Observable<CallDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_5(response: HttpResponseBase): Observable<CallDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDto.fromJS(resultData200) : new CallDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> адрес
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readSideOneAddressPartUsingGET(subId: number, callId: number): Observable<FiasAddressDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/address";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneAddressPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneAddressPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneAddressPartUsingGET(response: HttpResponseBase): Observable<FiasAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiasAddressDto.fromJS(resultData200) : new FiasAddressDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> адрес
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateAddressPartUsingPUT(subId: number, callId: number, dto: CallFiasAddressDto): Observable<FiasAddressDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/address";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAddressPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAddressPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAddressPartUsingPUT(response: HttpResponseBase): Observable<FiasAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiasAddressDto.fromJS(resultData200) : new FiasAddressDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> адрес -> локация
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateLocationPartUsingPUT(subId: number, callId: number, dto: CallLocationPartDto): Observable<CallLocationPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/address/location";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLocationPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLocationPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CallLocationPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallLocationPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLocationPartUsingPUT(response: HttpResponseBase): Observable<CallLocationPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallLocationPartDto.fromJS(resultData200) : new CallLocationPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallLocationPartDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> все назначенные смены бригад
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    getBrigadesFromCallUsingGET(subId: number, callId: number): Observable<CallBrigadePartDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadesFromCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadesFromCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallBrigadePartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallBrigadePartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadesFromCallUsingGET(response: HttpResponseBase): Observable<CallBrigadePartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallBrigadePartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBrigadePartDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> назначение бригады
     * @param subId subId
     * @param callId callId
     * @param dtoList dtoList
     * @return OK
     */
    setBrigadeUsingPOST(subId: number, callId: number, dtoList: BrigadeAppointRequestDto[]): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dtoList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetBrigadeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetBrigadeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetBrigadeUsingPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> конкретная назначенная смена бригады
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    getBrigadeScheduleCallTransferUsingGET(subId: number, callId: number, brigadeScheduleId: number): Observable<CallBrigadePartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallTransferUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallTransferUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallBrigadePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallBrigadePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallTransferUsingGET(response: HttpResponseBase): Observable<CallBrigadePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBrigadePartDto.fromJS(resultData200) : new CallBrigadePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBrigadePartDto>(<any>null);
    }

    /**
     * возвращает список карт вызова в бригаде
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @param deleted (optional) deleted
     * @return OK
     */
    readCardsByCallAndBrigadeUsingGET(subId: number, callId: number, brigadeScheduleId: number, deleted?: boolean | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/cards?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardsByCallAndBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardsByCallAndBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardsByCallAndBrigadeUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> бригада -> Форма 110/у
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    createCardUsingPOST(subId: number, callId: number, brigadeScheduleId: number): Observable<CardDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/cards";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCardUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCardUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCardUsingPOST(response: HttpResponseBase): Observable<CardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardDto.fromJS(resultData200) : new CardDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> смена бригады -> история сообщений
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    getBrigadeScheduleCallTransferHistoryUsingGET_1(subId: number, callId: number, brigadeScheduleId: number): Observable<MessageEventDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/history";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallTransferHistoryUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallTransferHistoryUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<MessageEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallTransferHistoryUsingGET_1(response: HttpResponseBase): Observable<MessageEventDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageEventDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> смена бригады -> доступные сообщения
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    readAvailableEventsUsingGET(subId: number, callId: number, brigadeScheduleId: number): Observable<MessageEventDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/messages";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAvailableEventsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAvailableEventsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<MessageEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAvailableEventsUsingGET(response: HttpResponseBase): Observable<MessageEventDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageEventDto[]>(<any>null);
    }

    /**
     * [CREATE] создание нового сообщения бригады
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @param dtoList dtoList
     * @return OK
     */
    createNewMessageUsingPOST(subId: number, callId: number, brigadeScheduleId: number, dtoList: MessageEventDto[]): Observable<MessageEventDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/messages";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dtoList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNewMessageUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNewMessageUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<MessageEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNewMessageUsingPOST(response: HttpResponseBase): Observable<MessageEventDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageEventDto[]>(<any>null);
    }

    /**
     * возвращает список карт вызова в вызове
     * @param subId subId
     * @param callId callId
     * @param deleted (optional) deleted
     * @return OK
     */
    readCardsByCallAndSubdivisionUsingGET(subId: number, callId: number, deleted?: boolean | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/cards?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardsByCallAndSubdivisionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardsByCallAndSubdivisionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardsByCallAndSubdivisionUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> заявитель
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readSideOneDeclarantPartUsingGET(subId: number, callId: number): Observable<CallDeclarantPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/declarant";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneDeclarantPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneDeclarantPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallDeclarantPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDeclarantPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneDeclarantPartUsingGET(response: HttpResponseBase): Observable<CallDeclarantPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDeclarantPartDto.fromJS(resultData200) : new CallDeclarantPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDeclarantPartDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> декларант
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateDeclarantPartUsingPUT(subId: number, callId: number, dto: CallDeclarantPartDto): Observable<CallDeclarantPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/declarant";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeclarantPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeclarantPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CallDeclarantPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDeclarantPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeclarantPartUsingPUT(response: HttpResponseBase): Observable<CallDeclarantPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDeclarantPartDto.fromJS(resultData200) : new CallDeclarantPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDeclarantPartDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> поиск бригад
     * @param subId subId
     * @param callId callId
     * @param radius (optional) radius
     * @param routing (optional) routing
     * @return OK
     */
    findBrigadesUsingGET(subId: number, callId: number, radius?: number | null | undefined, routing?: boolean | null | undefined): Observable<BrigadeFindListDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/find?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (radius !== undefined)
            url_ += "radius=" + encodeURIComponent("" + radius) + "&"; 
        if (routing !== undefined)
            url_ += "routing=" + encodeURIComponent("" + routing) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindBrigadesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindBrigadesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeFindListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeFindListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindBrigadesUsingGET(response: HttpResponseBase): Observable<BrigadeFindListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeFindListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeFindListDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> основные сведения
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readSideOneGeneralPartUsingGET(subId: number, callId: number): Observable<CallGeneralPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/general";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneGeneralPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneGeneralPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallGeneralPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGeneralPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneGeneralPartUsingGET(response: HttpResponseBase): Observable<CallGeneralPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallGeneralPartDto.fromJS(resultData200) : new CallGeneralPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGeneralPartDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> основные сведения
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateGeneralPartUsingPUT(subId: number, callId: number, dto: CallGeneralPartDto): Observable<CallGeneralPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/general";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CallGeneralPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGeneralPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGeneralPartUsingPUT(response: HttpResponseBase): Observable<CallGeneralPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallGeneralPartDto.fromJS(resultData200) : new CallGeneralPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGeneralPartDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> все пациенты
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readAllPatientsUsingGET(subId: number, callId: number): Observable<CallPatientPartDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPatientsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPatientsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPatientsUsingGET(response: HttpResponseBase): Observable<CallPatientPartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallPatientPartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> больные
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updatePatientsUsingPOST(subId: number, callId: number, dto: CallPatientPartDto[]): Observable<CallPatientPartDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatientsUsingPOST(response: HttpResponseBase): Observable<CallPatientPartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallPatientPartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы -> поиск карт по данным пациента
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    getAllChronicCardsUsingGET(subId: number, callId: number): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/chronic/cards";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChronicCardsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChronicCardsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChronicCardsUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> пациент
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @return OK
     */
    readOnePatientUsingGET(subId: number, callId: number, patientId: number): Observable<CallPatientPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOnePatientUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOnePatientUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOnePatientUsingGET(response: HttpResponseBase): Observable<CallPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallPatientPartDto.fromJS(resultData200) : new CallPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> пациент
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_5(subId: number, callId: number, patientId: number, dto: CallPatientPartDto): Observable<CallPatientPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_5(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_5(response: HttpResponseBase): Observable<CallPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallPatientPartDto.fromJS(resultData200) : new CallPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto>(<any>null);
    }

    /**
     * [DELETE] подразделение -> вызов -> пациент
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @return OK
     */
    deletePatientUsingDELETE(subId: number, callId: number, patientId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePatientUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePatientUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePatientUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы -> пациент -> поиск карт по данным пациента
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @return OK
     */
    getChronicCardUsingGET(subId: number, callId: number, patientId: number): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}/chronic/cards";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChronicCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChronicCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChronicCardUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * вызов -> протокол
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readProtocolUsingGET(subId: number, callId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/protocol";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * [READ] подразделение ->  вызов -> передача -> список подразделений-получателей
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    getSendListUsingGET(subId: number, callId: number): Observable<CallTransferDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/transfer";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSendListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSendListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallTransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallTransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSendListUsingGET(response: HttpResponseBase): Observable<CallTransferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallTransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallTransferDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> передача
     * @param subId subId
     * @param callId callId
     * @param request request
     * @return OK
     */
    getSubdivisionsForCallTransferUsingPOST(subId: number, callId: number, request: TransferAddresseeDto[]): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/transfer";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionsForCallTransferUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionsForCallTransferUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionsForCallTransferUsingPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение ->  вызов -> передача -> список доступных подразделений
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readAllPrimaryUsingGET(subId: number, callId: number): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/transfer/available";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPrimaryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPrimaryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPrimaryUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * readAll
     * @param result_id (optional) result_id
     * @param is_local (optional) is_local
     * @return OK
     */
    readAllUsingGET_40(result_id?: number | null | undefined, is_local?: boolean | null | undefined): Observable<TherapyDto[]> {
        let url_ = this.baseUrl + "/api/therapies?";
        if (result_id !== undefined)
            url_ += "result_id=" + encodeURIComponent("" + result_id) + "&"; 
        if (is_local !== undefined)
            url_ += "is_local=" + encodeURIComponent("" + is_local) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_40(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_40(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_40(response: HttpResponseBase): Observable<TherapyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TherapyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_31(dto: TherapyDto): Observable<TherapyDto> {
        let url_ = this.baseUrl + "/api/therapies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_31(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_31(response: HttpResponseBase): Observable<TherapyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyDto.fromJS(resultData200) : new TherapyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_38(id: number): Observable<TherapyDto> {
        let url_ = this.baseUrl + "/api/therapies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_38(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_38(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_38(response: HttpResponseBase): Observable<TherapyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyDto.fromJS(resultData200) : new TherapyDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_32(dto: TherapyDto): Observable<TherapyDto> {
        let url_ = this.baseUrl + "/api/therapies/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_32(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_32(response: HttpResponseBase): Observable<TherapyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyDto.fromJS(resultData200) : new TherapyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto>(<any>null);
    }

    /**
     * delete
     * @param dto dto
     * @return OK
     */
    deleteUsingDELETE_3(dto: TherapyDto): Observable<void> {
        let url_ = this.baseUrl + "/api/therapies/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param template_id (optional) template_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_42(template_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<TherapyTemplateItemDto[]> {
        let url_ = this.baseUrl + "/api/therapy_template_items?";
        if (template_id !== undefined)
            url_ += "template_id=" + encodeURIComponent("" + template_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_42(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_42(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_42(response: HttpResponseBase): Observable<TherapyTemplateItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TherapyTemplateItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_33(dto: TherapyTemplateItemDto): Observable<TherapyTemplateItemDto> {
        let url_ = this.baseUrl + "/api/therapy_template_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_33(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_33(response: HttpResponseBase): Observable<TherapyTemplateItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemDto.fromJS(resultData200) : new TherapyTemplateItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_40(id: number): Observable<TherapyTemplateItemDto> {
        let url_ = this.baseUrl + "/api/therapy_template_items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_40(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_40(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_40(response: HttpResponseBase): Observable<TherapyTemplateItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemDto.fromJS(resultData200) : new TherapyTemplateItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_34(dto: TherapyTemplateItemDto): Observable<TherapyTemplateItemDto> {
        let url_ = this.baseUrl + "/api/therapy_template_items/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_34(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_34(response: HttpResponseBase): Observable<TherapyTemplateItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemDto.fromJS(resultData200) : new TherapyTemplateItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_41(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<TherapyTemplateDto[]> {
        let url_ = this.baseUrl + "/api/therapy_templates?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_41(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_41(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_41(response: HttpResponseBase): Observable<TherapyTemplateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TherapyTemplateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_32(dto: TherapyTemplateDto): Observable<TherapyTemplateDto> {
        let url_ = this.baseUrl + "/api/therapy_templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_32(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_32(response: HttpResponseBase): Observable<TherapyTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateDto.fromJS(resultData200) : new TherapyTemplateDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_39(id: number): Observable<TherapyTemplateDto> {
        let url_ = this.baseUrl + "/api/therapy_templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_39(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_39(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_39(response: HttpResponseBase): Observable<TherapyTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateDto.fromJS(resultData200) : new TherapyTemplateDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_33(dto: TherapyTemplateDto): Observable<TherapyTemplateDto> {
        let url_ = this.baseUrl + "/api/therapy_templates/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_33(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_33(response: HttpResponseBase): Observable<TherapyTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateDto.fromJS(resultData200) : new TherapyTemplateDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto>(<any>null);
    }

    /**
     * возвращает список всех транспортных средств в подразделении
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_44(subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<TransportDto[]> {
        let url_ = this.baseUrl + "/api/transport?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_44(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_44(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_44(response: HttpResponseBase): Observable<TransportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto[]>(<any>null);
    }

    /**
     * создание нового транспортного средства
     * @param dto dto
     * @return OK
     */
    createUsingPOST_35(dto: TransportDto): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/transport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_35(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_35(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportDto.fromJS(resultData200) : new TransportDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(<any>null);
    }

    /**
     * возвращает список всех транспортных средств c мониторинга
     * @param params params
     * @return OK
     */
    readPathUsingPOST(params: CarPathParams): Observable<MonPoint[]> {
        let url_ = this.baseUrl + "/api/transport/path";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(params);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPathUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPathUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<MonPoint[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MonPoint[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadPathUsingPOST(response: HttpResponseBase): Observable<MonPoint[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MonPoint.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MonPoint[]>(<any>null);
    }

    /**
     * readAllStateMarks
     * @return OK
     */
    readAllStateMarksUsingGET(): Observable<TransportDto[]> {
        let url_ = this.baseUrl + "/api/transport/state_marks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllStateMarksUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllStateMarksUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllStateMarksUsingGET(response: HttpResponseBase): Observable<TransportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto[]>(<any>null);
    }

    /**
     * возвращает конкретное транспортное средство по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_42(id: number): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/transport/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_42(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_42(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_42(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportDto.fromJS(resultData200) : new TransportDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(<any>null);
    }

    /**
     * обновление сведений об транспортном средстве
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_36(dto: TransportDto): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/transport/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_36(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_36(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportDto.fromJS(resultData200) : new TransportDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(<any>null);
    }

    /**
     * возвращает список классов транспортных средств
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_43(deleted?: boolean | null | undefined): Observable<TransportClassDto[]> {
        let url_ = this.baseUrl + "/api/transport_classes?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_43(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_43(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_43(response: HttpResponseBase): Observable<TransportClassDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportClassDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto[]>(<any>null);
    }

    /**
     * создание нового класса транспортных средств
     * @param dto dto
     * @return OK
     */
    createUsingPOST_34(dto: TransportClassDto): Observable<TransportClassDto> {
        let url_ = this.baseUrl + "/api/transport_classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_34(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_34(response: HttpResponseBase): Observable<TransportClassDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportClassDto.fromJS(resultData200) : new TransportClassDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto>(<any>null);
    }

    /**
     * возвращает класс транспортных средств по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_41(id: number): Observable<TransportClassDto> {
        let url_ = this.baseUrl + "/api/transport_classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_41(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_41(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_41(response: HttpResponseBase): Observable<TransportClassDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportClassDto.fromJS(resultData200) : new TransportClassDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto>(<any>null);
    }

    /**
     * обновление сведений о классе транспортных средств
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_35(dto: TransportClassDto): Observable<TransportClassDto> {
        let url_ = this.baseUrl + "/api/transport_classes/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_35(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_35(response: HttpResponseBase): Observable<TransportClassDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportClassDto.fromJS(resultData200) : new TransportClassDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto>(<any>null);
    }

    /**
     * возвращает список типов транспортных средств
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_45(deleted?: boolean | null | undefined): Observable<TransportTypeDto[]> {
        let url_ = this.baseUrl + "/api/transport_types?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_45(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_45(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_45(response: HttpResponseBase): Observable<TransportTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto[]>(<any>null);
    }

    /**
     * создание нового типа транспортных средств
     * @param dto dto
     * @return OK
     */
    createUsingPOST_36(dto: TransportTypeDto): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/transport_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_36(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_36(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportTypeDto.fromJS(resultData200) : new TransportTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(<any>null);
    }

    /**
     * возвращает тип транспортных средств по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_43(id: number): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/transport_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_43(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_43(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_43(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportTypeDto.fromJS(resultData200) : new TransportTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(<any>null);
    }

    /**
     * обновление сведений о типе транспортных средств
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_37(dto: TransportTypeDto): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/transport_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_37(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_37(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportTypeDto.fromJS(resultData200) : new TransportTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(<any>null);
    }

    /**
     * readAll
     * @return OK
     */
    readAllUsingGET_46(): Observable<Unit[]> {
        let url_ = this.baseUrl + "/api/units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_46(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_46(<any>response_);
                } catch (e) {
                    return <Observable<Unit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_46(response: HttpResponseBase): Observable<Unit[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Unit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit[]>(<any>null);
    }

    /**
     * create
     * @param unit unit
     * @return OK
     */
    createUsingPOST_37(unit: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/api/units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unit);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_37(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_37(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200) : new Unit();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * readOne
     * @param code code
     * @return OK
     */
    readOneUsingGET_44(code: string): Observable<Unit> {
        let url_ = this.baseUrl + "/api/units/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_44(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_44(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_44(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200) : new Unit();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * update
     * @param unit unit
     * @return OK
     */
    updateUsingPUT_38(unit: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/api/units/{code}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unit);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_38(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_38(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_38(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200) : new Unit();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * delete
     * @param code code
     * @return OK
     */
    deleteUsingDELETE_4(code: string): Observable<void> {
        let url_ = this.baseUrl + "/api/units/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_4(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_4(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * login
     * @param error (optional) error
     * @param logout (optional) logout
     * @return OK
     */
    loginUsingGET_1(error?: string | null | undefined, logout?: string | null | undefined): Observable<ModelAndView> {
        let url_ = this.baseUrl + "/login?";
        if (error !== undefined)
            url_ += "error=" + encodeURIComponent("" + error) + "&"; 
        if (logout !== undefined)
            url_ += "logout=" + encodeURIComponent("" + logout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ModelAndView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelAndView>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingGET_1(response: HttpResponseBase): Observable<ModelAndView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ModelAndView.fromJS(resultData200) : new ModelAndView();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelAndView>(<any>null);
    }

    /**
     * readAllBrigadeMedicine
     * @param brigade (optional) brigade
     * @return OK
     */
    readAllBrigadeMedicineUsingGET(brigade?: string | null | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/bag?";
        if (brigade !== undefined)
            url_ += "brigade=" + encodeURIComponent("" + brigade) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllBrigadeMedicineUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllBrigadeMedicineUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllBrigadeMedicineUsingGET(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * writeAllMedicineConsumption
     * @param items items
     * @return OK
     */
    writeAllMedicineConsumptionUsingPOST(items: Medicine[]): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/bag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWriteAllMedicineConsumptionUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWriteAllMedicineConsumptionUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processWriteAllMedicineConsumptionUsingPOST(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * readAllCalls
     * @return OK
     */
    readAllCallsUsingGET(): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/calls";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllCallsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllCallsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllCallsUsingGET(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * confirmAllCalls
     * @param guid guid
     * @return OK
     */
    confirmAllCallsUsingGET(guid: string): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/calls/confirm?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmAllCallsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmAllCallsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmAllCallsUsingGET(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * создание карточек вызовов
     * @param request request
     * @return OK
     */
    createCardsUsingPOST(request: MobileCardRequest): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/cards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCardsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCardsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCardsUsingPOST(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * receiveMobileMessage
     * @param mobileMessage mobileMessage
     * @return OK
     */
    receiveMobileMessageUsingPOST(mobileMessage: MobileMessage): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mobileMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReceiveMobileMessageUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReceiveMobileMessageUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processReceiveMobileMessageUsingPOST(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }
}

export class CardResultIllegalActionsDto implements ICardResultIllegalActionsDto {
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;

    constructor(data?: ICardResultIllegalActionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.illegal_actions = data["illegal_actions"] !== undefined ? data["illegal_actions"] : <any>null;
            this.illegal_actions_text = data["illegal_actions_text"] !== undefined ? data["illegal_actions_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultIllegalActionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultIllegalActionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["illegal_actions"] = this.illegal_actions !== undefined ? this.illegal_actions : <any>null;
        data["illegal_actions_text"] = this.illegal_actions_text !== undefined ? this.illegal_actions_text : <any>null;
        return data; 
    }
}

export interface ICardResultIllegalActionsDto {
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;
}

export class CallPatientPartDto implements ICallPatientPartDto {
    deleted?: boolean | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;

    constructor(data?: ICallPatientPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.patient_age_days = data["patient_age_days"] !== undefined ? data["patient_age_days"] : <any>null;
            this.patient_age_months = data["patient_age_months"] !== undefined ? data["patient_age_months"] : <any>null;
            this.patient_age_years = data["patient_age_years"] !== undefined ? data["patient_age_years"] : <any>null;
            this.patient_firstname = data["patient_firstname"] !== undefined ? data["patient_firstname"] : <any>null;
            this.patient_id = data["patient_id"] !== undefined ? data["patient_id"] : <any>null;
            this.patient_patronymic = data["patient_patronymic"] !== undefined ? data["patient_patronymic"] : <any>null;
            this.patient_secondname = data["patient_secondname"] !== undefined ? data["patient_secondname"] : <any>null;
            this.patient_sex = data["patient_sex"] !== undefined ? data["patient_sex"] : <any>null;
            this.patient_sex_name = data["patient_sex_name"] !== undefined ? data["patient_sex_name"] : <any>null;
            this.patient_type_id = data["patient_type_id"] !== undefined ? data["patient_type_id"] : <any>null;
            this.patient_type_name = data["patient_type_name"] !== undefined ? data["patient_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallPatientPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallPatientPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["patient_age_days"] = this.patient_age_days !== undefined ? this.patient_age_days : <any>null;
        data["patient_age_months"] = this.patient_age_months !== undefined ? this.patient_age_months : <any>null;
        data["patient_age_years"] = this.patient_age_years !== undefined ? this.patient_age_years : <any>null;
        data["patient_firstname"] = this.patient_firstname !== undefined ? this.patient_firstname : <any>null;
        data["patient_id"] = this.patient_id !== undefined ? this.patient_id : <any>null;
        data["patient_patronymic"] = this.patient_patronymic !== undefined ? this.patient_patronymic : <any>null;
        data["patient_secondname"] = this.patient_secondname !== undefined ? this.patient_secondname : <any>null;
        data["patient_sex"] = this.patient_sex !== undefined ? this.patient_sex : <any>null;
        data["patient_sex_name"] = this.patient_sex_name !== undefined ? this.patient_sex_name : <any>null;
        data["patient_type_id"] = this.patient_type_id !== undefined ? this.patient_type_id : <any>null;
        data["patient_type_name"] = this.patient_type_name !== undefined ? this.patient_type_name : <any>null;
        return data; 
    }
}

export interface ICallPatientPartDto {
    deleted?: boolean | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;
}

export class CardResultDiagnosisDto implements ICardResultDiagnosisDto {
    complication_id?: number | null;
    complication_name?: string | null;
    concomitant_diagnosis?: MkbDto | null;
    main_diagnosis?: MkbDto | null;

    constructor(data?: ICardResultDiagnosisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.complication_id = data["complication_id"] !== undefined ? data["complication_id"] : <any>null;
            this.complication_name = data["complication_name"] !== undefined ? data["complication_name"] : <any>null;
            this.concomitant_diagnosis = data["concomitant_diagnosis"] ? MkbDto.fromJS(data["concomitant_diagnosis"]) : <any>null;
            this.main_diagnosis = data["main_diagnosis"] ? MkbDto.fromJS(data["main_diagnosis"]) : <any>null;
        }
    }

    static fromJS(data: any): CardResultDiagnosisDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDiagnosisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complication_id"] = this.complication_id !== undefined ? this.complication_id : <any>null;
        data["complication_name"] = this.complication_name !== undefined ? this.complication_name : <any>null;
        data["concomitant_diagnosis"] = this.concomitant_diagnosis ? this.concomitant_diagnosis.toJSON() : <any>null;
        data["main_diagnosis"] = this.main_diagnosis ? this.main_diagnosis.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardResultDiagnosisDto {
    complication_id?: number | null;
    complication_name?: string | null;
    concomitant_diagnosis?: MkbDto | null;
    main_diagnosis?: MkbDto | null;
}

export class CallGeneralPartDto implements ICallGeneralPartDto {
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_status?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: LocalDateTime | null;
    is_unfounded?: boolean | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_accept_id?: number | null;
    subdivision_accept_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;

    constructor(data?: ICallGeneralPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_priority = data["call_priority"] !== undefined ? data["call_priority"] : <any>null;
            this.call_priority_name = data["call_priority_name"] !== undefined ? data["call_priority_name"] : <any>null;
            this.call_status = data["call_status"] !== undefined ? data["call_status"] : <any>null;
            this.call_type_id = data["call_type_id"] !== undefined ? data["call_type_id"] : <any>null;
            this.call_type_name = data["call_type_name"] !== undefined ? data["call_type_name"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            this.performer_accept_id = data["performer_accept_id"] !== undefined ? data["performer_accept_id"] : <any>null;
            this.performer_accept_name = data["performer_accept_name"] !== undefined ? data["performer_accept_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.performer_send_id = data["performer_send_id"] !== undefined ? data["performer_send_id"] : <any>null;
            this.performer_send_name = data["performer_send_name"] !== undefined ? data["performer_send_name"] : <any>null;
            this.primary_call_id = data["primary_call_id"] !== undefined ? data["primary_call_id"] : <any>null;
            this.primary_call_number = data["primary_call_number"] !== undefined ? data["primary_call_number"] : <any>null;
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.subdivision_accept_id = data["subdivision_accept_id"] !== undefined ? data["subdivision_accept_id"] : <any>null;
            this.subdivision_accept_name = data["subdivision_accept_name"] !== undefined ? data["subdivision_accept_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.subdivision_send_id = data["subdivision_send_id"] !== undefined ? data["subdivision_send_id"] : <any>null;
            this.subdivision_send_name = data["subdivision_send_name"] !== undefined ? data["subdivision_send_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallGeneralPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallGeneralPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_priority"] = this.call_priority !== undefined ? this.call_priority : <any>null;
        data["call_priority_name"] = this.call_priority_name !== undefined ? this.call_priority_name : <any>null;
        data["call_status"] = this.call_status !== undefined ? this.call_status : <any>null;
        data["call_type_id"] = this.call_type_id !== undefined ? this.call_type_id : <any>null;
        data["call_type_name"] = this.call_type_name !== undefined ? this.call_type_name : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        data["performer_accept_id"] = this.performer_accept_id !== undefined ? this.performer_accept_id : <any>null;
        data["performer_accept_name"] = this.performer_accept_name !== undefined ? this.performer_accept_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["performer_send_id"] = this.performer_send_id !== undefined ? this.performer_send_id : <any>null;
        data["performer_send_name"] = this.performer_send_name !== undefined ? this.performer_send_name : <any>null;
        data["primary_call_id"] = this.primary_call_id !== undefined ? this.primary_call_id : <any>null;
        data["primary_call_number"] = this.primary_call_number !== undefined ? this.primary_call_number : <any>null;
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["subdivision_accept_id"] = this.subdivision_accept_id !== undefined ? this.subdivision_accept_id : <any>null;
        data["subdivision_accept_name"] = this.subdivision_accept_name !== undefined ? this.subdivision_accept_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["subdivision_send_id"] = this.subdivision_send_id !== undefined ? this.subdivision_send_id : <any>null;
        data["subdivision_send_name"] = this.subdivision_send_name !== undefined ? this.subdivision_send_name : <any>null;
        return data; 
    }
}

export interface ICallGeneralPartDto {
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_status?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: LocalDateTime | null;
    is_unfounded?: boolean | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_accept_id?: number | null;
    subdivision_accept_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;
}

export class Product implements IProduct {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    productType?: ProductType | null;
    unit_code?: string | null;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.productType = data["productType"] ? ProductType.fromJS(data["productType"]) : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["productType"] = this.productType ? this.productType.toJSON() : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IProduct {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    productType?: ProductType | null;
    unit_code?: string | null;
}

export class CardAnamnesisHeaderDto implements ICardAnamnesisHeaderDto {
    is_created?: boolean | null;

    constructor(data?: ICardAnamnesisHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisHeaderDto {
    is_created?: boolean | null;
}

export class BrigadeScheduleUpdateDto implements IBrigadeScheduleUpdateDto {
    period_details?: PeriodDetails | null;

    constructor(data?: IBrigadeScheduleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeScheduleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeScheduleUpdateDto {
    period_details?: PeriodDetails | null;
}

export class Document implements IDocument {
    accepted?: boolean | null;
    archived?: boolean | null;
    date_doc?: LocalDateTime | null;
    id?: number | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    organization?: string | null;
    performer?: Performer | null;
    placeFrom?: Place | null;
    placeTo?: Place | null;
    type?: number | null;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accepted = data["accepted"] !== undefined ? data["accepted"] : <any>null;
            this.archived = data["archived"] !== undefined ? data["archived"] : <any>null;
            this.date_doc = data["date_doc"] ? LocalDateTime.fromJS(data["date_doc"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["nomenclatures"] && data["nomenclatures"].constructor === Array) {
                this.nomenclatures = [];
                for (let item of data["nomenclatures"])
                    this.nomenclatures.push(DocumentNomenclature.fromJS(item));
            }
            this.number_doc = data["number_doc"] !== undefined ? data["number_doc"] : <any>null;
            this.organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            this.performer = data["performer"] ? Performer.fromJS(data["performer"]) : <any>null;
            this.placeFrom = data["placeFrom"] ? Place.fromJS(data["placeFrom"]) : <any>null;
            this.placeTo = data["placeTo"] ? Place.fromJS(data["placeTo"]) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accepted"] = this.accepted !== undefined ? this.accepted : <any>null;
        data["archived"] = this.archived !== undefined ? this.archived : <any>null;
        data["date_doc"] = this.date_doc ? this.date_doc.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.nomenclatures && this.nomenclatures.constructor === Array) {
            data["nomenclatures"] = [];
            for (let item of this.nomenclatures)
                data["nomenclatures"].push(item.toJSON());
        }
        data["number_doc"] = this.number_doc !== undefined ? this.number_doc : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>null;
        data["placeFrom"] = this.placeFrom ? this.placeFrom.toJSON() : <any>null;
        data["placeTo"] = this.placeTo ? this.placeTo.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IDocument {
    accepted?: boolean | null;
    archived?: boolean | null;
    date_doc?: LocalDateTime | null;
    id?: number | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    organization?: string | null;
    performer?: Performer | null;
    placeFrom?: Place | null;
    placeTo?: Place | null;
    type?: number | null;
}

export class LocalDate implements ILocalDate {
    chronology?: IsoChronology | null;
    dayOfMonth?: number | null;
    dayOfWeek?: LocalDateDayOfWeek | null;
    dayOfYear?: number | null;
    era?: Era | null;
    leapYear?: boolean | null;
    month?: LocalDateMonth | null;
    monthValue?: number | null;
    year?: number | null;

    constructor(data?: ILocalDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.chronology = data["chronology"] ? IsoChronology.fromJS(data["chronology"]) : <any>null;
            this.dayOfMonth = data["dayOfMonth"] !== undefined ? data["dayOfMonth"] : <any>null;
            this.dayOfWeek = data["dayOfWeek"] !== undefined ? data["dayOfWeek"] : <any>null;
            this.dayOfYear = data["dayOfYear"] !== undefined ? data["dayOfYear"] : <any>null;
            this.era = data["era"] ? Era.fromJS(data["era"]) : <any>null;
            this.leapYear = data["leapYear"] !== undefined ? data["leapYear"] : <any>null;
            this.month = data["month"] !== undefined ? data["month"] : <any>null;
            this.monthValue = data["monthValue"] !== undefined ? data["monthValue"] : <any>null;
            this.year = data["year"] !== undefined ? data["year"] : <any>null;
        }
    }

    static fromJS(data: any): LocalDate {
        data = typeof data === 'object' ? data : {};
        let result = new LocalDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chronology"] = this.chronology ? this.chronology.toJSON() : <any>null;
        data["dayOfMonth"] = this.dayOfMonth !== undefined ? this.dayOfMonth : <any>null;
        data["dayOfWeek"] = this.dayOfWeek !== undefined ? this.dayOfWeek : <any>null;
        data["dayOfYear"] = this.dayOfYear !== undefined ? this.dayOfYear : <any>null;
        data["era"] = this.era ? this.era.toJSON() : <any>null;
        data["leapYear"] = this.leapYear !== undefined ? this.leapYear : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["monthValue"] = this.monthValue !== undefined ? this.monthValue : <any>null;
        data["year"] = this.year !== undefined ? this.year : <any>null;
        return data; 
    }
}

export interface ILocalDate {
    chronology?: IsoChronology | null;
    dayOfMonth?: number | null;
    dayOfWeek?: LocalDateDayOfWeek | null;
    dayOfYear?: number | null;
    era?: Era | null;
    leapYear?: boolean | null;
    month?: LocalDateMonth | null;
    monthValue?: number | null;
    year?: number | null;
}

export class BrigadeCallDto implements IBrigadeCallDto {
    call_id?: number | null;
    call_number?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    reason_extra?: boolean | null;
    reason_name?: string | null;
    state?: string | null;
    state_date?: LocalDateTime | null;

    constructor(data?: IBrigadeCallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.reason_extra = data["reason_extra"] !== undefined ? data["reason_extra"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.state = data["state"] !== undefined ? data["state"] : <any>null;
            this.state_date = data["state_date"] ? LocalDateTime.fromJS(data["state_date"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeCallDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeCallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["reason_extra"] = this.reason_extra !== undefined ? this.reason_extra : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["state_date"] = this.state_date ? this.state_date.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeCallDto {
    call_id?: number | null;
    call_number?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    reason_extra?: boolean | null;
    reason_name?: string | null;
    state?: string | null;
    state_date?: LocalDateTime | null;
}

export class PerformerScheduller implements IPerformerScheduller {
    basic?: boolean | null;
    dateFrom?: LocalDate | null;
    dateTo?: LocalDate | null;
    id?: number | null;

    constructor(data?: IPerformerScheduller) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.basic = data["basic"] !== undefined ? data["basic"] : <any>null;
            this.dateFrom = data["dateFrom"] ? LocalDate.fromJS(data["dateFrom"]) : <any>null;
            this.dateTo = data["dateTo"] ? LocalDate.fromJS(data["dateTo"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerScheduller {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerScheduller();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basic"] = this.basic !== undefined ? this.basic : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toJSON() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IPerformerScheduller {
    basic?: boolean | null;
    dateFrom?: LocalDate | null;
    dateTo?: LocalDate | null;
    id?: number | null;
}

export class PerformerBrigScheduleCreateDto implements IPerformerBrigScheduleCreateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;

    constructor(data?: IPerformerBrigScheduleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleCreateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
}

export class MobileCardDrug implements IMobileCardDrug {
    count?: number | null;
    in_car?: boolean | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;

    constructor(data?: IMobileCardDrug) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.in_car = data["in_car"] !== undefined ? data["in_car"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.uid = data["uid"] !== undefined ? data["uid"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardDrug {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardDrug();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["in_car"] = this.in_car !== undefined ? this.in_car : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["uid"] = this.uid !== undefined ? this.uid : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IMobileCardDrug {
    count?: number | null;
    in_car?: boolean | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;
}

export class PharmacyItem implements IPharmacyItem {
    amount?: number | null;
    id?: number | null;
    innerAmount?: number | null;
    nomenclatureItem?: NomenclatureItem | null;
    owner?: PharmacyOwner | null;

    constructor(data?: IPharmacyItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.innerAmount = data["innerAmount"] !== undefined ? data["innerAmount"] : <any>null;
            this.nomenclatureItem = data["nomenclatureItem"] ? NomenclatureItem.fromJS(data["nomenclatureItem"]) : <any>null;
            this.owner = data["owner"] ? PharmacyOwner.fromJS(data["owner"]) : <any>null;
        }
    }

    static fromJS(data: any): PharmacyItem {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["innerAmount"] = this.innerAmount !== undefined ? this.innerAmount : <any>null;
        data["nomenclatureItem"] = this.nomenclatureItem ? this.nomenclatureItem.toJSON() : <any>null;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>null;
        return data; 
    }
}

export interface IPharmacyItem {
    amount?: number | null;
    id?: number | null;
    innerAmount?: number | null;
    nomenclatureItem?: NomenclatureItem | null;
    owner?: PharmacyOwner | null;
}

export class Permission implements IPermission {
    checked?: boolean | null;
    code?: string | null;
    items?: Permission[] | null;
    leaf?: boolean | null;
    name?: string | null;
    type?: PermissionType | null;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checked = data["checked"] !== undefined ? data["checked"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Permission.fromJS(item));
            }
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checked"] = this.checked !== undefined ? this.checked : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPermission {
    checked?: boolean | null;
    code?: string | null;
    items?: Permission[] | null;
    leaf?: boolean | null;
    name?: string | null;
    type?: PermissionType | null;
}

export class MobileCall implements IMobileCall {
    build?: string | null;
    caller_name?: string | null;
    caller_phone?: string | null;
    cards?: MobileCard[] | null;
    city?: string | null;
    date?: string | null;
    flat?: string | null;
    guid?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    patients?: MobilePatient[] | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    street?: string | null;
    time?: string | null;

    constructor(data?: IMobileCall) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.build = data["build"] !== undefined ? data["build"] : <any>null;
            this.caller_name = data["caller_name"] !== undefined ? data["caller_name"] : <any>null;
            this.caller_phone = data["caller_phone"] !== undefined ? data["caller_phone"] : <any>null;
            if (data["cards"] && data["cards"].constructor === Array) {
                this.cards = [];
                for (let item of data["cards"])
                    this.cards.push(MobileCard.fromJS(item));
            }
            this.city = data["city"] !== undefined ? data["city"] : <any>null;
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["patients"] && data["patients"].constructor === Array) {
                this.patients = [];
                for (let item of data["patients"])
                    this.patients.push(MobilePatient.fromJS(item));
            }
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_extra = data["reason_extra"] !== undefined ? data["reason_extra"] : <any>null;
            this.street = data["street"] !== undefined ? data["street"] : <any>null;
            this.time = data["time"] !== undefined ? data["time"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCall {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCall();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["build"] = this.build !== undefined ? this.build : <any>null;
        data["caller_name"] = this.caller_name !== undefined ? this.caller_name : <any>null;
        data["caller_phone"] = this.caller_phone !== undefined ? this.caller_phone : <any>null;
        if (this.cards && this.cards.constructor === Array) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.patients && this.patients.constructor === Array) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_extra"] = this.reason_extra !== undefined ? this.reason_extra : <any>null;
        data["street"] = this.street !== undefined ? this.street : <any>null;
        data["time"] = this.time !== undefined ? this.time : <any>null;
        return data; 
    }
}

export interface IMobileCall {
    build?: string | null;
    caller_name?: string | null;
    caller_phone?: string | null;
    cards?: MobileCard[] | null;
    city?: string | null;
    date?: string | null;
    flat?: string | null;
    guid?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    patients?: MobilePatient[] | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    street?: string | null;
    time?: string | null;
}

export class DocumentNomenclature implements IDocumentNomenclature {
    accepted?: boolean | null;
    adminConfig?: string | null;
    archived?: boolean | null;
    code?: string | null;
    date_doc?: LocalDateTime | null;
    deleted?: boolean | null;
    description?: string | null;
    document?: Document | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    name?: string | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    online?: boolean | null;
    organization?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    packaging?: Packaging | null;
    packaging_count?: number | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    product?: Product | null;
    product_count?: number | null;
    product_id?: number | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    typeId?: number | null;
    typeName?: string | null;
    type_name?: string | null;
    unit_code?: string | null;
    unit_count?: number | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;

    constructor(data?: IDocumentNomenclature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accepted = data["accepted"] !== undefined ? data["accepted"] : <any>null;
            this.adminConfig = data["adminConfig"] !== undefined ? data["adminConfig"] : <any>null;
            this.archived = data["archived"] !== undefined ? data["archived"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.date_doc = data["date_doc"] ? LocalDateTime.fromJS(data["date_doc"]) : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.document = data["document"] ? Document.fromJS(data["document"]) : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["nomenclatures"] && data["nomenclatures"].constructor === Array) {
                this.nomenclatures = [];
                for (let item of data["nomenclatures"])
                    this.nomenclatures.push(DocumentNomenclature.fromJS(item));
            }
            this.number_doc = data["number_doc"] !== undefined ? data["number_doc"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.packaging = data["packaging"] ? Packaging.fromJS(data["packaging"]) : <any>null;
            this.packaging_count = data["packaging_count"] !== undefined ? data["packaging_count"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>null;
            this.product_count = data["product_count"] !== undefined ? data["product_count"] : <any>null;
            this.product_id = data["product_id"] !== undefined ? data["product_id"] : <any>null;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(Role.fromJS(item));
            }
            this.secondName = data["secondName"] !== undefined ? data["secondName"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            if (data["skills"] && data["skills"].constructor === Array) {
                this.skills = [];
                for (let item of data["skills"])
                    this.skills.push(Skill.fromJS(item));
            }
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.subdivisionName = data["subdivisionName"] !== undefined ? data["subdivisionName"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeId = data["typeId"] !== undefined ? data["typeId"] : <any>null;
            this.typeName = data["typeName"] !== undefined ? data["typeName"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
            this.unit_count = data["unit_count"] !== undefined ? data["unit_count"] : <any>null;
            this.userConfig = data["userConfig"] !== undefined ? data["userConfig"] : <any>null;
            this.workplaceSubdivisionId = data["workplaceSubdivisionId"] !== undefined ? data["workplaceSubdivisionId"] : <any>null;
            this.workplaceSubdivisionName = data["workplaceSubdivisionName"] !== undefined ? data["workplaceSubdivisionName"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentNomenclature {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentNomenclature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accepted"] = this.accepted !== undefined ? this.accepted : <any>null;
        data["adminConfig"] = this.adminConfig !== undefined ? this.adminConfig : <any>null;
        data["archived"] = this.archived !== undefined ? this.archived : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["date_doc"] = this.date_doc ? this.date_doc.toJSON() : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["document"] = this.document ? this.document.toJSON() : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.nomenclatures && this.nomenclatures.constructor === Array) {
            data["nomenclatures"] = [];
            for (let item of this.nomenclatures)
                data["nomenclatures"].push(item.toJSON());
        }
        data["number_doc"] = this.number_doc !== undefined ? this.number_doc : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["packaging"] = this.packaging ? this.packaging.toJSON() : <any>null;
        data["packaging_count"] = this.packaging_count !== undefined ? this.packaging_count : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["product_count"] = this.product_count !== undefined ? this.product_count : <any>null;
        data["product_id"] = this.product_id !== undefined ? this.product_id : <any>null;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["secondName"] = this.secondName !== undefined ? this.secondName : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        if (this.skills && this.skills.constructor === Array) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["subdivisionName"] = this.subdivisionName !== undefined ? this.subdivisionName : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeId"] = this.typeId !== undefined ? this.typeId : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        data["unit_count"] = this.unit_count !== undefined ? this.unit_count : <any>null;
        data["userConfig"] = this.userConfig !== undefined ? this.userConfig : <any>null;
        data["workplaceSubdivisionId"] = this.workplaceSubdivisionId !== undefined ? this.workplaceSubdivisionId : <any>null;
        data["workplaceSubdivisionName"] = this.workplaceSubdivisionName !== undefined ? this.workplaceSubdivisionName : <any>null;
        return data; 
    }
}

export interface IDocumentNomenclature {
    accepted?: boolean | null;
    adminConfig?: string | null;
    archived?: boolean | null;
    code?: string | null;
    date_doc?: LocalDateTime | null;
    deleted?: boolean | null;
    description?: string | null;
    document?: Document | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    name?: string | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    online?: boolean | null;
    organization?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    packaging?: Packaging | null;
    packaging_count?: number | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    product?: Product | null;
    product_count?: number | null;
    product_id?: number | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    typeId?: number | null;
    typeName?: string | null;
    type_name?: string | null;
    unit_code?: string | null;
    unit_count?: number | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;
}

export class ProductType implements IProductType {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IProductType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ProductType {
        data = typeof data === 'object' ? data : {};
        let result = new ProductType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IProductType {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CarPathParams implements ICarPathParams {
    date_from?: LocalDateTime | null;
    date_to?: LocalDateTime | null;
    maxRow?: number | null;
    polygon?: MonPoint[] | null;
    statemark?: string | null;

    constructor(data?: ICarPathParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_from = data["date_from"] ? LocalDateTime.fromJS(data["date_from"]) : <any>null;
            this.date_to = data["date_to"] ? LocalDateTime.fromJS(data["date_to"]) : <any>null;
            this.maxRow = data["maxRow"] !== undefined ? data["maxRow"] : <any>null;
            if (data["polygon"] && data["polygon"].constructor === Array) {
                this.polygon = [];
                for (let item of data["polygon"])
                    this.polygon.push(MonPoint.fromJS(item));
            }
            this.statemark = data["statemark"] !== undefined ? data["statemark"] : <any>null;
        }
    }

    static fromJS(data: any): CarPathParams {
        data = typeof data === 'object' ? data : {};
        let result = new CarPathParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_from"] = this.date_from ? this.date_from.toJSON() : <any>null;
        data["date_to"] = this.date_to ? this.date_to.toJSON() : <any>null;
        data["maxRow"] = this.maxRow !== undefined ? this.maxRow : <any>null;
        if (this.polygon && this.polygon.constructor === Array) {
            data["polygon"] = [];
            for (let item of this.polygon)
                data["polygon"].push(item.toJSON());
        }
        data["statemark"] = this.statemark !== undefined ? this.statemark : <any>null;
        return data; 
    }
}

export interface ICarPathParams {
    date_from?: LocalDateTime | null;
    date_to?: LocalDateTime | null;
    maxRow?: number | null;
    polygon?: MonPoint[] | null;
    statemark?: string | null;
}

export class Code implements ICode {
    value?: string | null;

    constructor(data?: ICode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Code {
        data = typeof data === 'object' ? data : {};
        let result = new Code();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface ICode {
    value?: string | null;
}

export class CardObjectivePercPartDto implements ICardObjectivePercPartDto {
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;

    constructor(data?: ICardObjectivePercPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.perc_lungs_sound_id = data["perc_lungs_sound_id"] !== undefined ? data["perc_lungs_sound_id"] : <any>null;
            this.perc_lungs_sound_name = data["perc_lungs_sound_name"] !== undefined ? data["perc_lungs_sound_name"] : <any>null;
            this.perc_lungs_sound_text = data["perc_lungs_sound_text"] !== undefined ? data["perc_lungs_sound_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePercPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePercPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["perc_lungs_sound_id"] = this.perc_lungs_sound_id !== undefined ? this.perc_lungs_sound_id : <any>null;
        data["perc_lungs_sound_name"] = this.perc_lungs_sound_name !== undefined ? this.perc_lungs_sound_name : <any>null;
        data["perc_lungs_sound_text"] = this.perc_lungs_sound_text !== undefined ? this.perc_lungs_sound_text : <any>null;
        return data; 
    }
}

export interface ICardObjectivePercPartDto {
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;
}

export class CardObjectiveStomachPartDto implements ICardObjectiveStomachPartDto {
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;

    constructor(data?: ICardObjectiveStomachPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stomach_ascites = data["stomach_ascites"] !== undefined ? data["stomach_ascites"] : <any>null;
            this.stomach_breathing_involved = data["stomach_breathing_involved"] !== undefined ? data["stomach_breathing_involved"] : <any>null;
            this.stomach_breathing_involved_name = data["stomach_breathing_involved_name"] !== undefined ? data["stomach_breathing_involved_name"] : <any>null;
            this.stomach_disklike = data["stomach_disklike"] !== undefined ? data["stomach_disklike"] : <any>null;
            this.stomach_hard = data["stomach_hard"] !== undefined ? data["stomach_hard"] : <any>null;
            this.stomach_infliat = data["stomach_infliat"] !== undefined ? data["stomach_infliat"] : <any>null;
            this.stomach_normal = data["stomach_normal"] !== undefined ? data["stomach_normal"] : <any>null;
            this.stomach_painful = data["stomach_painful"] !== undefined ? data["stomach_painful"] : <any>null;
            this.stomach_peritonit = data["stomach_peritonit"] !== undefined ? data["stomach_peritonit"] : <any>null;
            this.stomach_peritonit_name = data["stomach_peritonit_name"] !== undefined ? data["stomach_peritonit_name"] : <any>null;
            this.stomach_soft = data["stomach_soft"] !== undefined ? data["stomach_soft"] : <any>null;
            this.stomach_text = data["stomach_text"] !== undefined ? data["stomach_text"] : <any>null;
            this.stomach_unpainful = data["stomach_unpainful"] !== undefined ? data["stomach_unpainful"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveStomachPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveStomachPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stomach_ascites"] = this.stomach_ascites !== undefined ? this.stomach_ascites : <any>null;
        data["stomach_breathing_involved"] = this.stomach_breathing_involved !== undefined ? this.stomach_breathing_involved : <any>null;
        data["stomach_breathing_involved_name"] = this.stomach_breathing_involved_name !== undefined ? this.stomach_breathing_involved_name : <any>null;
        data["stomach_disklike"] = this.stomach_disklike !== undefined ? this.stomach_disklike : <any>null;
        data["stomach_hard"] = this.stomach_hard !== undefined ? this.stomach_hard : <any>null;
        data["stomach_infliat"] = this.stomach_infliat !== undefined ? this.stomach_infliat : <any>null;
        data["stomach_normal"] = this.stomach_normal !== undefined ? this.stomach_normal : <any>null;
        data["stomach_painful"] = this.stomach_painful !== undefined ? this.stomach_painful : <any>null;
        data["stomach_peritonit"] = this.stomach_peritonit !== undefined ? this.stomach_peritonit : <any>null;
        data["stomach_peritonit_name"] = this.stomach_peritonit_name !== undefined ? this.stomach_peritonit_name : <any>null;
        data["stomach_soft"] = this.stomach_soft !== undefined ? this.stomach_soft : <any>null;
        data["stomach_text"] = this.stomach_text !== undefined ? this.stomach_text : <any>null;
        data["stomach_unpainful"] = this.stomach_unpainful !== undefined ? this.stomach_unpainful : <any>null;
        return data; 
    }
}

export interface ICardObjectiveStomachPartDto {
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;
}

export class TransportDto implements ITransportDto {
    brand?: string | null;
    can_use?: boolean | null;
    class_id?: number | null;
    class_name?: string | null;
    color?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    picture?: string | null;
    state_mark?: string | null;
    status_description?: string | null;
    status_id?: number | null;
    status_name?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ITransportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brand = data["brand"] !== undefined ? data["brand"] : <any>null;
            this.can_use = data["can_use"] !== undefined ? data["can_use"] : <any>null;
            this.class_id = data["class_id"] !== undefined ? data["class_id"] : <any>null;
            this.class_name = data["class_name"] !== undefined ? data["class_name"] : <any>null;
            this.color = data["color"] !== undefined ? data["color"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.state_mark = data["state_mark"] !== undefined ? data["state_mark"] : <any>null;
            this.status_description = data["status_description"] !== undefined ? data["status_description"] : <any>null;
            this.status_id = data["status_id"] !== undefined ? data["status_id"] : <any>null;
            this.status_name = data["status_name"] !== undefined ? data["status_name"] : <any>null;
            this.sub_code = data["sub_code"] !== undefined ? data["sub_code"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): TransportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand !== undefined ? this.brand : <any>null;
        data["can_use"] = this.can_use !== undefined ? this.can_use : <any>null;
        data["class_id"] = this.class_id !== undefined ? this.class_id : <any>null;
        data["class_name"] = this.class_name !== undefined ? this.class_name : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["state_mark"] = this.state_mark !== undefined ? this.state_mark : <any>null;
        data["status_description"] = this.status_description !== undefined ? this.status_description : <any>null;
        data["status_id"] = this.status_id !== undefined ? this.status_id : <any>null;
        data["status_name"] = this.status_name !== undefined ? this.status_name : <any>null;
        data["sub_code"] = this.sub_code !== undefined ? this.sub_code : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ITransportDto {
    brand?: string | null;
    can_use?: boolean | null;
    class_id?: number | null;
    class_name?: string | null;
    color?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    picture?: string | null;
    state_mark?: string | null;
    status_description?: string | null;
    status_id?: number | null;
    status_name?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class CardAnamnesisPartDto implements ICardAnamnesisPartDto {
    allergic?: CardAnamnesisAllergicPartDto | null;
    complaints?: CardAnamnesisComplaintsPartDto | null;
    epidemic?: CardAnamnesisEpidemicPartDto | null;
    gynecologic?: CardAnamnesisGynecologicPartDto | null;
    header?: CardAnamnesisHeaderDto | null;
    illnes?: CardAnamnesisIllnesPartDto | null;

    constructor(data?: ICardAnamnesisPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic = data["allergic"] ? CardAnamnesisAllergicPartDto.fromJS(data["allergic"]) : <any>null;
            this.complaints = data["complaints"] ? CardAnamnesisComplaintsPartDto.fromJS(data["complaints"]) : <any>null;
            this.epidemic = data["epidemic"] ? CardAnamnesisEpidemicPartDto.fromJS(data["epidemic"]) : <any>null;
            this.gynecologic = data["gynecologic"] ? CardAnamnesisGynecologicPartDto.fromJS(data["gynecologic"]) : <any>null;
            this.header = data["header"] ? CardAnamnesisHeaderDto.fromJS(data["header"]) : <any>null;
            this.illnes = data["illnes"] ? CardAnamnesisIllnesPartDto.fromJS(data["illnes"]) : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic"] = this.allergic ? this.allergic.toJSON() : <any>null;
        data["complaints"] = this.complaints ? this.complaints.toJSON() : <any>null;
        data["epidemic"] = this.epidemic ? this.epidemic.toJSON() : <any>null;
        data["gynecologic"] = this.gynecologic ? this.gynecologic.toJSON() : <any>null;
        data["header"] = this.header ? this.header.toJSON() : <any>null;
        data["illnes"] = this.illnes ? this.illnes.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisPartDto {
    allergic?: CardAnamnesisAllergicPartDto | null;
    complaints?: CardAnamnesisComplaintsPartDto | null;
    epidemic?: CardAnamnesisEpidemicPartDto | null;
    gynecologic?: CardAnamnesisGynecologicPartDto | null;
    header?: CardAnamnesisHeaderDto | null;
    illnes?: CardAnamnesisIllnesPartDto | null;
}

export class MobileCardAddress implements IMobileCardAddress {
    building?: string | null;
    city?: string | null;
    country?: string | null;
    district?: string | null;
    flat?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    region?: string | null;
    street?: string | null;

    constructor(data?: IMobileCardAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.city = data["city"] !== undefined ? data["city"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.region = data["region"] !== undefined ? data["region"] : <any>null;
            this.street = data["street"] !== undefined ? data["street"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardAddress {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["region"] = this.region !== undefined ? this.region : <any>null;
        data["street"] = this.street !== undefined ? this.street : <any>null;
        return data; 
    }
}

export interface IMobileCardAddress {
    building?: string | null;
    city?: string | null;
    country?: string | null;
    district?: string | null;
    flat?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    region?: string | null;
    street?: string | null;
}

export class Inventory implements IInventory {
    code?: string | null;
    count?: number | null;
    count_current?: number | null;
    count_min?: number | null;
    date_inventory?: LocalDateTime | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    nomenclatures?: InventoryNomenclature[] | null;
    owner_id?: number | null;
    owner_name?: string | null;
    place?: Place | null;
    product?: Product | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    type_name?: string | null;
    unit_code?: string | null;

    constructor(data?: IInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.count_current = data["count_current"] !== undefined ? data["count_current"] : <any>null;
            this.count_min = data["count_min"] !== undefined ? data["count_min"] : <any>null;
            this.date_inventory = data["date_inventory"] ? LocalDateTime.fromJS(data["date_inventory"]) : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["nomenclatures"] && data["nomenclatures"].constructor === Array) {
                this.nomenclatures = [];
                for (let item of data["nomenclatures"])
                    this.nomenclatures.push(InventoryNomenclature.fromJS(item));
            }
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.place = data["place"] ? Place.fromJS(data["place"]) : <any>null;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): Inventory {
        data = typeof data === 'object' ? data : {};
        let result = new Inventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["count_current"] = this.count_current !== undefined ? this.count_current : <any>null;
        data["count_min"] = this.count_min !== undefined ? this.count_min : <any>null;
        data["date_inventory"] = this.date_inventory ? this.date_inventory.toJSON() : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.nomenclatures && this.nomenclatures.constructor === Array) {
            data["nomenclatures"] = [];
            for (let item of this.nomenclatures)
                data["nomenclatures"].push(item.toJSON());
        }
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["place"] = this.place ? this.place.toJSON() : <any>null;
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IInventory {
    code?: string | null;
    count?: number | null;
    count_current?: number | null;
    count_min?: number | null;
    date_inventory?: LocalDateTime | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    nomenclatures?: InventoryNomenclature[] | null;
    owner_id?: number | null;
    owner_name?: string | null;
    place?: Place | null;
    product?: Product | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    type_name?: string | null;
    unit_code?: string | null;
}

export class MobilePatient implements IMobilePatient {
    age?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    citizenship?: string | null;
    city?: string | null;
    country?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    previous_cards?: MobileCardChronic[] | null;
    sex_id?: number | null;
    social_property_id?: number | null;
    surname?: string | null;
    type?: string | null;

    constructor(data?: IMobilePatient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.age = data["age"] !== undefined ? data["age"] : <any>null;
            this.age_days = data["age_days"] !== undefined ? data["age_days"] : <any>null;
            this.age_months = data["age_months"] !== undefined ? data["age_months"] : <any>null;
            this.age_years = data["age_years"] !== undefined ? data["age_years"] : <any>null;
            this.birth_date = data["birth_date"] !== undefined ? data["birth_date"] : <any>null;
            this.citizenship = data["citizenship"] !== undefined ? data["citizenship"] : <any>null;
            this.city = data["city"] !== undefined ? data["city"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.firstname = data["firstname"] !== undefined ? data["firstname"] : <any>null;
            this.job = data["job"] !== undefined ? data["job"] : <any>null;
            this.job_position = data["job_position"] !== undefined ? data["job_position"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            if (data["previous_cards"] && data["previous_cards"].constructor === Array) {
                this.previous_cards = [];
                for (let item of data["previous_cards"])
                    this.previous_cards.push(MobileCardChronic.fromJS(item));
            }
            this.sex_id = data["sex_id"] !== undefined ? data["sex_id"] : <any>null;
            this.social_property_id = data["social_property_id"] !== undefined ? data["social_property_id"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): MobilePatient {
        data = typeof data === 'object' ? data : {};
        let result = new MobilePatient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["age"] = this.age !== undefined ? this.age : <any>null;
        data["age_days"] = this.age_days !== undefined ? this.age_days : <any>null;
        data["age_months"] = this.age_months !== undefined ? this.age_months : <any>null;
        data["age_years"] = this.age_years !== undefined ? this.age_years : <any>null;
        data["birth_date"] = this.birth_date !== undefined ? this.birth_date : <any>null;
        data["citizenship"] = this.citizenship !== undefined ? this.citizenship : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["firstname"] = this.firstname !== undefined ? this.firstname : <any>null;
        data["job"] = this.job !== undefined ? this.job : <any>null;
        data["job_position"] = this.job_position !== undefined ? this.job_position : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        if (this.previous_cards && this.previous_cards.constructor === Array) {
            data["previous_cards"] = [];
            for (let item of this.previous_cards)
                data["previous_cards"].push(item.toJSON());
        }
        data["sex_id"] = this.sex_id !== undefined ? this.sex_id : <any>null;
        data["social_property_id"] = this.social_property_id !== undefined ? this.social_property_id : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IMobilePatient {
    age?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    citizenship?: string | null;
    city?: string | null;
    country?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    previous_cards?: MobileCardChronic[] | null;
    sex_id?: number | null;
    social_property_id?: number | null;
    surname?: string | null;
    type?: string | null;
}

export class TherapyItemDto implements ITherapyItemDto {
    count?: number | null;
    id?: number | null;
    product_name?: string | null;
    therapy_id?: number | null;

    constructor(data?: ITherapyItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.product_name = data["product_name"] !== undefined ? data["product_name"] : <any>null;
            this.therapy_id = data["therapy_id"] !== undefined ? data["therapy_id"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["product_name"] = this.product_name !== undefined ? this.product_name : <any>null;
        data["therapy_id"] = this.therapy_id !== undefined ? this.therapy_id : <any>null;
        return data; 
    }
}

export interface ITherapyItemDto {
    count?: number | null;
    id?: number | null;
    product_name?: string | null;
    therapy_id?: number | null;
}

export class MobileCardDocument implements IMobileCardDocument {
    date?: string | null;
    name?: string | null;
    number?: string | null;
    organisation?: string | null;
    serie?: string | null;
    type_id?: number | null;

    constructor(data?: IMobileCardDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.organisation = data["organisation"] !== undefined ? data["organisation"] : <any>null;
            this.serie = data["serie"] !== undefined ? data["serie"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardDocument {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["organisation"] = this.organisation !== undefined ? this.organisation : <any>null;
        data["serie"] = this.serie !== undefined ? this.serie : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        return data; 
    }
}

export interface IMobileCardDocument {
    date?: string | null;
    name?: string | null;
    number?: string | null;
    organisation?: string | null;
    serie?: string | null;
    type_id?: number | null;
}

export class BrigadeScheduleDto implements IBrigadeScheduleDto {
    active_calls?: number | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    is_edited?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    performers?: PerformerBrigScheduleDto[] | null;
    period_details?: PeriodDetails | null;
    pharmacy_package_id?: number | null;
    pharmacy_package_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    transports?: TransportBrigScheduleDto[] | null;

    constructor(data?: IBrigadeScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active_calls = data["active_calls"] !== undefined ? data["active_calls"] : <any>null;
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
            this.brigade_name = data["brigade_name"] !== undefined ? data["brigade_name"] : <any>null;
            this.brigade_status_id = data["brigade_status_id"] !== undefined ? data["brigade_status_id"] : <any>null;
            this.brigade_status_name = data["brigade_status_name"] !== undefined ? data["brigade_status_name"] : <any>null;
            this.brigade_type_code = data["brigade_type_code"] !== undefined ? data["brigade_type_code"] : <any>null;
            this.brigade_type_id = data["brigade_type_id"] !== undefined ? data["brigade_type_id"] : <any>null;
            this.brigade_type_name = data["brigade_type_name"] !== undefined ? data["brigade_type_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_edited = data["is_edited"] !== undefined ? data["is_edited"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerBrigScheduleDto.fromJS(item));
            }
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.pharmacy_package_id = data["pharmacy_package_id"] !== undefined ? data["pharmacy_package_id"] : <any>null;
            this.pharmacy_package_name = data["pharmacy_package_name"] !== undefined ? data["pharmacy_package_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            if (data["transports"] && data["transports"].constructor === Array) {
                this.transports = [];
                for (let item of data["transports"])
                    this.transports.push(TransportBrigScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrigadeScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active_calls"] = this.active_calls !== undefined ? this.active_calls : <any>null;
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        data["brigade_name"] = this.brigade_name !== undefined ? this.brigade_name : <any>null;
        data["brigade_status_id"] = this.brigade_status_id !== undefined ? this.brigade_status_id : <any>null;
        data["brigade_status_name"] = this.brigade_status_name !== undefined ? this.brigade_status_name : <any>null;
        data["brigade_type_code"] = this.brigade_type_code !== undefined ? this.brigade_type_code : <any>null;
        data["brigade_type_id"] = this.brigade_type_id !== undefined ? this.brigade_type_id : <any>null;
        data["brigade_type_name"] = this.brigade_type_name !== undefined ? this.brigade_type_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_edited"] = this.is_edited !== undefined ? this.is_edited : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["pharmacy_package_id"] = this.pharmacy_package_id !== undefined ? this.pharmacy_package_id : <any>null;
        data["pharmacy_package_name"] = this.pharmacy_package_name !== undefined ? this.pharmacy_package_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        if (this.transports && this.transports.constructor === Array) {
            data["transports"] = [];
            for (let item of this.transports)
                data["transports"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrigadeScheduleDto {
    active_calls?: number | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    is_edited?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    performers?: PerformerBrigScheduleDto[] | null;
    period_details?: PeriodDetails | null;
    pharmacy_package_id?: number | null;
    pharmacy_package_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    transports?: TransportBrigScheduleDto[] | null;
}

export class CardObjectiveOtherPartDto implements ICardObjectiveOtherPartDto {
    ad?: string | null;
    admax?: string | null;
    adn?: string | null;
    bodytemp?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;

    constructor(data?: ICardObjectiveOtherPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ad = data["ad"] !== undefined ? data["ad"] : <any>null;
            this.admax = data["admax"] !== undefined ? data["admax"] : <any>null;
            this.adn = data["adn"] !== undefined ? data["adn"] : <any>null;
            this.bodytemp = data["bodytemp"] !== undefined ? data["bodytemp"] : <any>null;
            this.chd = data["chd"] !== undefined ? data["chd"] : <any>null;
            this.chss = data["chss"] !== undefined ? data["chss"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.ps = data["ps"] !== undefined ? data["ps"] : <any>null;
            this.pulse_oximetry = data["pulse_oximetry"] !== undefined ? data["pulse_oximetry"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveOtherPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveOtherPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ad"] = this.ad !== undefined ? this.ad : <any>null;
        data["admax"] = this.admax !== undefined ? this.admax : <any>null;
        data["adn"] = this.adn !== undefined ? this.adn : <any>null;
        data["bodytemp"] = this.bodytemp !== undefined ? this.bodytemp : <any>null;
        data["chd"] = this.chd !== undefined ? this.chd : <any>null;
        data["chss"] = this.chss !== undefined ? this.chss : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["ps"] = this.ps !== undefined ? this.ps : <any>null;
        data["pulse_oximetry"] = this.pulse_oximetry !== undefined ? this.pulse_oximetry : <any>null;
        return data; 
    }
}

export interface ICardObjectiveOtherPartDto {
    ad?: string | null;
    admax?: string | null;
    adn?: string | null;
    bodytemp?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;
}

export class CardObjectivePartDto implements ICardObjectivePartDto {
    addition?: CardObjectiveAdditionPartDto | null;
    alcohol?: CardObjectiveAlcoPartDto | null;
    breath?: CardObjectiveBreathPartDto | null;
    diuresis?: CardObjectiveDiuresisPartDto | null;
    dyspeptic?: CardObjectiveDyspepticPartDto | null;
    edema?: CardObjectiveEdemaPartDto | null;
    excreta?: CardObjectiveExcretaUrinePartDto | null;
    general_state?: CardObjectiveGeneralStatePartDto | null;
    glasgow?: CardObjectiveGlasgowPartDto | null;
    header?: CardObjectiveHeaderDto | null;
    heart?: CardObjectiveHeartPartDto | null;
    hemodynamics?: CardAnamnesisHemodynamicsPartDto | null;
    liver?: CardObjectiveLiverPartDto | null;
    lymph?: CardObjectiveLymphPartDto | null;
    other?: CardObjectiveOtherPartDto | null;
    perc?: CardObjectivePercPartDto | null;
    pupils?: CardObjectivePupilsDto | null;
    reflexes?: CardObjectiveReflexesDto | null;
    skin?: CardObjectiveSkinPartDto | null;
    stomach?: CardObjectiveStomachPartDto | null;
    throat?: CardObjectiveThroatPartDto | null;
    tongue?: CardObjectiveTonguePart | null;
    tonsils?: CardObjectiveTonsilsPartDto | null;
    wheezing?: CardObjectiveWheezingPartDto | null;

    constructor(data?: ICardObjectivePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addition = data["addition"] ? CardObjectiveAdditionPartDto.fromJS(data["addition"]) : <any>null;
            this.alcohol = data["alcohol"] ? CardObjectiveAlcoPartDto.fromJS(data["alcohol"]) : <any>null;
            this.breath = data["breath"] ? CardObjectiveBreathPartDto.fromJS(data["breath"]) : <any>null;
            this.diuresis = data["diuresis"] ? CardObjectiveDiuresisPartDto.fromJS(data["diuresis"]) : <any>null;
            this.dyspeptic = data["dyspeptic"] ? CardObjectiveDyspepticPartDto.fromJS(data["dyspeptic"]) : <any>null;
            this.edema = data["edema"] ? CardObjectiveEdemaPartDto.fromJS(data["edema"]) : <any>null;
            this.excreta = data["excreta"] ? CardObjectiveExcretaUrinePartDto.fromJS(data["excreta"]) : <any>null;
            this.general_state = data["general_state"] ? CardObjectiveGeneralStatePartDto.fromJS(data["general_state"]) : <any>null;
            this.glasgow = data["glasgow"] ? CardObjectiveGlasgowPartDto.fromJS(data["glasgow"]) : <any>null;
            this.header = data["header"] ? CardObjectiveHeaderDto.fromJS(data["header"]) : <any>null;
            this.heart = data["heart"] ? CardObjectiveHeartPartDto.fromJS(data["heart"]) : <any>null;
            this.hemodynamics = data["hemodynamics"] ? CardAnamnesisHemodynamicsPartDto.fromJS(data["hemodynamics"]) : <any>null;
            this.liver = data["liver"] ? CardObjectiveLiverPartDto.fromJS(data["liver"]) : <any>null;
            this.lymph = data["lymph"] ? CardObjectiveLymphPartDto.fromJS(data["lymph"]) : <any>null;
            this.other = data["other"] ? CardObjectiveOtherPartDto.fromJS(data["other"]) : <any>null;
            this.perc = data["perc"] ? CardObjectivePercPartDto.fromJS(data["perc"]) : <any>null;
            this.pupils = data["pupils"] ? CardObjectivePupilsDto.fromJS(data["pupils"]) : <any>null;
            this.reflexes = data["reflexes"] ? CardObjectiveReflexesDto.fromJS(data["reflexes"]) : <any>null;
            this.skin = data["skin"] ? CardObjectiveSkinPartDto.fromJS(data["skin"]) : <any>null;
            this.stomach = data["stomach"] ? CardObjectiveStomachPartDto.fromJS(data["stomach"]) : <any>null;
            this.throat = data["throat"] ? CardObjectiveThroatPartDto.fromJS(data["throat"]) : <any>null;
            this.tongue = data["tongue"] ? CardObjectiveTonguePart.fromJS(data["tongue"]) : <any>null;
            this.tonsils = data["tonsils"] ? CardObjectiveTonsilsPartDto.fromJS(data["tonsils"]) : <any>null;
            this.wheezing = data["wheezing"] ? CardObjectiveWheezingPartDto.fromJS(data["wheezing"]) : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addition"] = this.addition ? this.addition.toJSON() : <any>null;
        data["alcohol"] = this.alcohol ? this.alcohol.toJSON() : <any>null;
        data["breath"] = this.breath ? this.breath.toJSON() : <any>null;
        data["diuresis"] = this.diuresis ? this.diuresis.toJSON() : <any>null;
        data["dyspeptic"] = this.dyspeptic ? this.dyspeptic.toJSON() : <any>null;
        data["edema"] = this.edema ? this.edema.toJSON() : <any>null;
        data["excreta"] = this.excreta ? this.excreta.toJSON() : <any>null;
        data["general_state"] = this.general_state ? this.general_state.toJSON() : <any>null;
        data["glasgow"] = this.glasgow ? this.glasgow.toJSON() : <any>null;
        data["header"] = this.header ? this.header.toJSON() : <any>null;
        data["heart"] = this.heart ? this.heart.toJSON() : <any>null;
        data["hemodynamics"] = this.hemodynamics ? this.hemodynamics.toJSON() : <any>null;
        data["liver"] = this.liver ? this.liver.toJSON() : <any>null;
        data["lymph"] = this.lymph ? this.lymph.toJSON() : <any>null;
        data["other"] = this.other ? this.other.toJSON() : <any>null;
        data["perc"] = this.perc ? this.perc.toJSON() : <any>null;
        data["pupils"] = this.pupils ? this.pupils.toJSON() : <any>null;
        data["reflexes"] = this.reflexes ? this.reflexes.toJSON() : <any>null;
        data["skin"] = this.skin ? this.skin.toJSON() : <any>null;
        data["stomach"] = this.stomach ? this.stomach.toJSON() : <any>null;
        data["throat"] = this.throat ? this.throat.toJSON() : <any>null;
        data["tongue"] = this.tongue ? this.tongue.toJSON() : <any>null;
        data["tonsils"] = this.tonsils ? this.tonsils.toJSON() : <any>null;
        data["wheezing"] = this.wheezing ? this.wheezing.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardObjectivePartDto {
    addition?: CardObjectiveAdditionPartDto | null;
    alcohol?: CardObjectiveAlcoPartDto | null;
    breath?: CardObjectiveBreathPartDto | null;
    diuresis?: CardObjectiveDiuresisPartDto | null;
    dyspeptic?: CardObjectiveDyspepticPartDto | null;
    edema?: CardObjectiveEdemaPartDto | null;
    excreta?: CardObjectiveExcretaUrinePartDto | null;
    general_state?: CardObjectiveGeneralStatePartDto | null;
    glasgow?: CardObjectiveGlasgowPartDto | null;
    header?: CardObjectiveHeaderDto | null;
    heart?: CardObjectiveHeartPartDto | null;
    hemodynamics?: CardAnamnesisHemodynamicsPartDto | null;
    liver?: CardObjectiveLiverPartDto | null;
    lymph?: CardObjectiveLymphPartDto | null;
    other?: CardObjectiveOtherPartDto | null;
    perc?: CardObjectivePercPartDto | null;
    pupils?: CardObjectivePupilsDto | null;
    reflexes?: CardObjectiveReflexesDto | null;
    skin?: CardObjectiveSkinPartDto | null;
    stomach?: CardObjectiveStomachPartDto | null;
    throat?: CardObjectiveThroatPartDto | null;
    tongue?: CardObjectiveTonguePart | null;
    tonsils?: CardObjectiveTonsilsPartDto | null;
    wheezing?: CardObjectiveWheezingPartDto | null;
}

export class MobileCardResult implements IMobileCardResult {
    additional_diagnosis_id?: number | null;
    basic_diagnosis_id?: number | null;
    body_temperature?: string | null;
    comment?: string | null;
    diagnosis_complications_id?: number | null;
    diagnosis_need_visitor_id?: number | null;
    ekg_after?: string | null;
    ekg_before?: string | null;
    glucometry?: string | null;
    medical_events?: string | null;
    medical_events_in_car?: string | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    result_id?: number | null;
    transportation_data?: string | null;
    transportation_method_id?: number | null;
    transportation_place_id?: number | null;
    transportation_problems?: string | null;
    transportation_time?: string | null;
    type_id?: number | null;
    unlaw_actions?: string | null;

    constructor(data?: IMobileCardResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additional_diagnosis_id = data["additional_diagnosis_id"] !== undefined ? data["additional_diagnosis_id"] : <any>null;
            this.basic_diagnosis_id = data["basic_diagnosis_id"] !== undefined ? data["basic_diagnosis_id"] : <any>null;
            this.body_temperature = data["body_temperature"] !== undefined ? data["body_temperature"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.diagnosis_complications_id = data["diagnosis_complications_id"] !== undefined ? data["diagnosis_complications_id"] : <any>null;
            this.diagnosis_need_visitor_id = data["diagnosis_need_visitor_id"] !== undefined ? data["diagnosis_need_visitor_id"] : <any>null;
            this.ekg_after = data["ekg_after"] !== undefined ? data["ekg_after"] : <any>null;
            this.ekg_before = data["ekg_before"] !== undefined ? data["ekg_before"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.medical_events = data["medical_events"] !== undefined ? data["medical_events"] : <any>null;
            this.medical_events_in_car = data["medical_events_in_car"] !== undefined ? data["medical_events_in_car"] : <any>null;
            this.palpitation = data["palpitation"] !== undefined ? data["palpitation"] : <any>null;
            this.palpitation_ad = data["palpitation_ad"] !== undefined ? data["palpitation_ad"] : <any>null;
            this.palpitation_adn = data["palpitation_adn"] !== undefined ? data["palpitation_adn"] : <any>null;
            this.palpitation_cd = data["palpitation_cd"] !== undefined ? data["palpitation_cd"] : <any>null;
            this.palpitation_ps = data["palpitation_ps"] !== undefined ? data["palpitation_ps"] : <any>null;
            this.palpitation_sat_02 = data["palpitation_sat_02"] !== undefined ? data["palpitation_sat_02"] : <any>null;
            this.result_id = data["result_id"] !== undefined ? data["result_id"] : <any>null;
            this.transportation_data = data["transportation_data"] !== undefined ? data["transportation_data"] : <any>null;
            this.transportation_method_id = data["transportation_method_id"] !== undefined ? data["transportation_method_id"] : <any>null;
            this.transportation_place_id = data["transportation_place_id"] !== undefined ? data["transportation_place_id"] : <any>null;
            this.transportation_problems = data["transportation_problems"] !== undefined ? data["transportation_problems"] : <any>null;
            this.transportation_time = data["transportation_time"] !== undefined ? data["transportation_time"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.unlaw_actions = data["unlaw_actions"] !== undefined ? data["unlaw_actions"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardResult {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additional_diagnosis_id"] = this.additional_diagnosis_id !== undefined ? this.additional_diagnosis_id : <any>null;
        data["basic_diagnosis_id"] = this.basic_diagnosis_id !== undefined ? this.basic_diagnosis_id : <any>null;
        data["body_temperature"] = this.body_temperature !== undefined ? this.body_temperature : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["diagnosis_complications_id"] = this.diagnosis_complications_id !== undefined ? this.diagnosis_complications_id : <any>null;
        data["diagnosis_need_visitor_id"] = this.diagnosis_need_visitor_id !== undefined ? this.diagnosis_need_visitor_id : <any>null;
        data["ekg_after"] = this.ekg_after !== undefined ? this.ekg_after : <any>null;
        data["ekg_before"] = this.ekg_before !== undefined ? this.ekg_before : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["medical_events"] = this.medical_events !== undefined ? this.medical_events : <any>null;
        data["medical_events_in_car"] = this.medical_events_in_car !== undefined ? this.medical_events_in_car : <any>null;
        data["palpitation"] = this.palpitation !== undefined ? this.palpitation : <any>null;
        data["palpitation_ad"] = this.palpitation_ad !== undefined ? this.palpitation_ad : <any>null;
        data["palpitation_adn"] = this.palpitation_adn !== undefined ? this.palpitation_adn : <any>null;
        data["palpitation_cd"] = this.palpitation_cd !== undefined ? this.palpitation_cd : <any>null;
        data["palpitation_ps"] = this.palpitation_ps !== undefined ? this.palpitation_ps : <any>null;
        data["palpitation_sat_02"] = this.palpitation_sat_02 !== undefined ? this.palpitation_sat_02 : <any>null;
        data["result_id"] = this.result_id !== undefined ? this.result_id : <any>null;
        data["transportation_data"] = this.transportation_data !== undefined ? this.transportation_data : <any>null;
        data["transportation_method_id"] = this.transportation_method_id !== undefined ? this.transportation_method_id : <any>null;
        data["transportation_place_id"] = this.transportation_place_id !== undefined ? this.transportation_place_id : <any>null;
        data["transportation_problems"] = this.transportation_problems !== undefined ? this.transportation_problems : <any>null;
        data["transportation_time"] = this.transportation_time !== undefined ? this.transportation_time : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["unlaw_actions"] = this.unlaw_actions !== undefined ? this.unlaw_actions : <any>null;
        return data; 
    }
}

export interface IMobileCardResult {
    additional_diagnosis_id?: number | null;
    basic_diagnosis_id?: number | null;
    body_temperature?: string | null;
    comment?: string | null;
    diagnosis_complications_id?: number | null;
    diagnosis_need_visitor_id?: number | null;
    ekg_after?: string | null;
    ekg_before?: string | null;
    glucometry?: string | null;
    medical_events?: string | null;
    medical_events_in_car?: string | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    result_id?: number | null;
    transportation_data?: string | null;
    transportation_method_id?: number | null;
    transportation_place_id?: number | null;
    transportation_problems?: string | null;
    transportation_time?: string | null;
    type_id?: number | null;
    unlaw_actions?: string | null;
}

export class CardObjectiveHeartPartDto implements ICardObjectiveHeartPartDto {
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;

    constructor(data?: ICardObjectiveHeartPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.heart_noise_id = data["heart_noise_id"] !== undefined ? data["heart_noise_id"] : <any>null;
            this.heart_noise_name = data["heart_noise_name"] !== undefined ? data["heart_noise_name"] : <any>null;
            this.heart_rate_id = data["heart_rate_id"] !== undefined ? data["heart_rate_id"] : <any>null;
            this.heart_rate_name = data["heart_rate_name"] !== undefined ? data["heart_rate_name"] : <any>null;
            this.heart_tone_id = data["heart_tone_id"] !== undefined ? data["heart_tone_id"] : <any>null;
            this.heart_tone_name = data["heart_tone_name"] !== undefined ? data["heart_tone_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveHeartPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveHeartPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heart_noise_id"] = this.heart_noise_id !== undefined ? this.heart_noise_id : <any>null;
        data["heart_noise_name"] = this.heart_noise_name !== undefined ? this.heart_noise_name : <any>null;
        data["heart_rate_id"] = this.heart_rate_id !== undefined ? this.heart_rate_id : <any>null;
        data["heart_rate_name"] = this.heart_rate_name !== undefined ? this.heart_rate_name : <any>null;
        data["heart_tone_id"] = this.heart_tone_id !== undefined ? this.heart_tone_id : <any>null;
        data["heart_tone_name"] = this.heart_tone_name !== undefined ? this.heart_tone_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveHeartPartDto {
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;
}

export class DistrictDto implements IDistrictDto {
    code?: string | null;
    fias_id?: number | null;
    id?: number | null;
    name?: string | null;
    zone?: string | null;

    constructor(data?: IDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.fias_id = data["fias_id"] !== undefined ? data["fias_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.zone = data["zone"] !== undefined ? data["zone"] : <any>null;
        }
    }

    static fromJS(data: any): DistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["fias_id"] = this.fias_id !== undefined ? this.fias_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["zone"] = this.zone !== undefined ? this.zone : <any>null;
        return data; 
    }
}

export interface IDistrictDto {
    code?: string | null;
    fias_id?: number | null;
    id?: number | null;
    name?: string | null;
    zone?: string | null;
}

export class MobileCardObjective implements IMobileCardObjective {
    adenoid_incrustation?: boolean | null;
    adenoid_size_id?: number | null;
    alcohol_air?: boolean | null;
    body_temperature?: string | null;
    breath_absent?: boolean | null;
    breath_bronchial?: boolean | null;
    breath_hard?: boolean | null;
    breath_puerile?: boolean | null;
    breath_smooth?: boolean | null;
    breath_vesicular?: boolean | null;
    breath_weak?: boolean | null;
    conscious_state_id?: number | null;
    ds_pupil_ratio_id?: number | null;
    ds_reflex_id?: number | null;
    emotional_lability?: boolean | null;
    epidermis_acrocyanosis?: boolean | null;
    epidermis_cyanotic?: boolean | null;
    epidermis_dry?: boolean | null;
    epidermis_earthy?: boolean | null;
    epidermis_hyperemic?: boolean | null;
    epidermis_icteric?: boolean | null;
    epidermis_normal?: boolean | null;
    epidermis_pale?: boolean | null;
    epidermis_profuse_sweat?: boolean | null;
    epidermis_rashes?: boolean | null;
    glucometry?: string | null;
    health_state_id?: number | null;
    inadequate_assessment?: boolean | null;
    instability_romberg?: boolean | null;
    lymph_nodes_localisation?: string | null;
    meningeal?: boolean | null;
    mucous_throat_id?: number | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_ad_max?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_noises?: boolean | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    palpitation_tone_id?: number | null;
    palpitation_type_id?: number | null;
    pathological?: boolean | null;
    pupil_ratio_id?: number | null;
    reaction_to_light?: boolean | null;
    reflex_id?: number | null;
    sensitivity_of_lymph_nodes_id?: number | null;
    shaky_walk?: boolean | null;
    size_of_lymph_nodes_id?: number | null;
    speech_drunk_man?: boolean | null;
    swelling?: boolean | null;
    swelling_localisation?: string | null;

    constructor(data?: IMobileCardObjective) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adenoid_incrustation = data["adenoid_incrustation"] !== undefined ? data["adenoid_incrustation"] : <any>null;
            this.adenoid_size_id = data["adenoid_size_id"] !== undefined ? data["adenoid_size_id"] : <any>null;
            this.alcohol_air = data["alcohol_air"] !== undefined ? data["alcohol_air"] : <any>null;
            this.body_temperature = data["body_temperature"] !== undefined ? data["body_temperature"] : <any>null;
            this.breath_absent = data["breath_absent"] !== undefined ? data["breath_absent"] : <any>null;
            this.breath_bronchial = data["breath_bronchial"] !== undefined ? data["breath_bronchial"] : <any>null;
            this.breath_hard = data["breath_hard"] !== undefined ? data["breath_hard"] : <any>null;
            this.breath_puerile = data["breath_puerile"] !== undefined ? data["breath_puerile"] : <any>null;
            this.breath_smooth = data["breath_smooth"] !== undefined ? data["breath_smooth"] : <any>null;
            this.breath_vesicular = data["breath_vesicular"] !== undefined ? data["breath_vesicular"] : <any>null;
            this.breath_weak = data["breath_weak"] !== undefined ? data["breath_weak"] : <any>null;
            this.conscious_state_id = data["conscious_state_id"] !== undefined ? data["conscious_state_id"] : <any>null;
            this.ds_pupil_ratio_id = data["ds_pupil_ratio_id"] !== undefined ? data["ds_pupil_ratio_id"] : <any>null;
            this.ds_reflex_id = data["ds_reflex_id"] !== undefined ? data["ds_reflex_id"] : <any>null;
            this.emotional_lability = data["emotional_lability"] !== undefined ? data["emotional_lability"] : <any>null;
            this.epidermis_acrocyanosis = data["epidermis_acrocyanosis"] !== undefined ? data["epidermis_acrocyanosis"] : <any>null;
            this.epidermis_cyanotic = data["epidermis_cyanotic"] !== undefined ? data["epidermis_cyanotic"] : <any>null;
            this.epidermis_dry = data["epidermis_dry"] !== undefined ? data["epidermis_dry"] : <any>null;
            this.epidermis_earthy = data["epidermis_earthy"] !== undefined ? data["epidermis_earthy"] : <any>null;
            this.epidermis_hyperemic = data["epidermis_hyperemic"] !== undefined ? data["epidermis_hyperemic"] : <any>null;
            this.epidermis_icteric = data["epidermis_icteric"] !== undefined ? data["epidermis_icteric"] : <any>null;
            this.epidermis_normal = data["epidermis_normal"] !== undefined ? data["epidermis_normal"] : <any>null;
            this.epidermis_pale = data["epidermis_pale"] !== undefined ? data["epidermis_pale"] : <any>null;
            this.epidermis_profuse_sweat = data["epidermis_profuse_sweat"] !== undefined ? data["epidermis_profuse_sweat"] : <any>null;
            this.epidermis_rashes = data["epidermis_rashes"] !== undefined ? data["epidermis_rashes"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.health_state_id = data["health_state_id"] !== undefined ? data["health_state_id"] : <any>null;
            this.inadequate_assessment = data["inadequate_assessment"] !== undefined ? data["inadequate_assessment"] : <any>null;
            this.instability_romberg = data["instability_romberg"] !== undefined ? data["instability_romberg"] : <any>null;
            this.lymph_nodes_localisation = data["lymph_nodes_localisation"] !== undefined ? data["lymph_nodes_localisation"] : <any>null;
            this.meningeal = data["meningeal"] !== undefined ? data["meningeal"] : <any>null;
            this.mucous_throat_id = data["mucous_throat_id"] !== undefined ? data["mucous_throat_id"] : <any>null;
            this.palpitation = data["palpitation"] !== undefined ? data["palpitation"] : <any>null;
            this.palpitation_ad = data["palpitation_ad"] !== undefined ? data["palpitation_ad"] : <any>null;
            this.palpitation_ad_max = data["palpitation_ad_max"] !== undefined ? data["palpitation_ad_max"] : <any>null;
            this.palpitation_adn = data["palpitation_adn"] !== undefined ? data["palpitation_adn"] : <any>null;
            this.palpitation_cd = data["palpitation_cd"] !== undefined ? data["palpitation_cd"] : <any>null;
            this.palpitation_noises = data["palpitation_noises"] !== undefined ? data["palpitation_noises"] : <any>null;
            this.palpitation_ps = data["palpitation_ps"] !== undefined ? data["palpitation_ps"] : <any>null;
            this.palpitation_sat_02 = data["palpitation_sat_02"] !== undefined ? data["palpitation_sat_02"] : <any>null;
            this.palpitation_tone_id = data["palpitation_tone_id"] !== undefined ? data["palpitation_tone_id"] : <any>null;
            this.palpitation_type_id = data["palpitation_type_id"] !== undefined ? data["palpitation_type_id"] : <any>null;
            this.pathological = data["pathological"] !== undefined ? data["pathological"] : <any>null;
            this.pupil_ratio_id = data["pupil_ratio_id"] !== undefined ? data["pupil_ratio_id"] : <any>null;
            this.reaction_to_light = data["reaction_to_light"] !== undefined ? data["reaction_to_light"] : <any>null;
            this.reflex_id = data["reflex_id"] !== undefined ? data["reflex_id"] : <any>null;
            this.sensitivity_of_lymph_nodes_id = data["sensitivity_of_lymph_nodes_id"] !== undefined ? data["sensitivity_of_lymph_nodes_id"] : <any>null;
            this.shaky_walk = data["shaky_walk"] !== undefined ? data["shaky_walk"] : <any>null;
            this.size_of_lymph_nodes_id = data["size_of_lymph_nodes_id"] !== undefined ? data["size_of_lymph_nodes_id"] : <any>null;
            this.speech_drunk_man = data["speech_drunk_man"] !== undefined ? data["speech_drunk_man"] : <any>null;
            this.swelling = data["swelling"] !== undefined ? data["swelling"] : <any>null;
            this.swelling_localisation = data["swelling_localisation"] !== undefined ? data["swelling_localisation"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardObjective {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardObjective();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adenoid_incrustation"] = this.adenoid_incrustation !== undefined ? this.adenoid_incrustation : <any>null;
        data["adenoid_size_id"] = this.adenoid_size_id !== undefined ? this.adenoid_size_id : <any>null;
        data["alcohol_air"] = this.alcohol_air !== undefined ? this.alcohol_air : <any>null;
        data["body_temperature"] = this.body_temperature !== undefined ? this.body_temperature : <any>null;
        data["breath_absent"] = this.breath_absent !== undefined ? this.breath_absent : <any>null;
        data["breath_bronchial"] = this.breath_bronchial !== undefined ? this.breath_bronchial : <any>null;
        data["breath_hard"] = this.breath_hard !== undefined ? this.breath_hard : <any>null;
        data["breath_puerile"] = this.breath_puerile !== undefined ? this.breath_puerile : <any>null;
        data["breath_smooth"] = this.breath_smooth !== undefined ? this.breath_smooth : <any>null;
        data["breath_vesicular"] = this.breath_vesicular !== undefined ? this.breath_vesicular : <any>null;
        data["breath_weak"] = this.breath_weak !== undefined ? this.breath_weak : <any>null;
        data["conscious_state_id"] = this.conscious_state_id !== undefined ? this.conscious_state_id : <any>null;
        data["ds_pupil_ratio_id"] = this.ds_pupil_ratio_id !== undefined ? this.ds_pupil_ratio_id : <any>null;
        data["ds_reflex_id"] = this.ds_reflex_id !== undefined ? this.ds_reflex_id : <any>null;
        data["emotional_lability"] = this.emotional_lability !== undefined ? this.emotional_lability : <any>null;
        data["epidermis_acrocyanosis"] = this.epidermis_acrocyanosis !== undefined ? this.epidermis_acrocyanosis : <any>null;
        data["epidermis_cyanotic"] = this.epidermis_cyanotic !== undefined ? this.epidermis_cyanotic : <any>null;
        data["epidermis_dry"] = this.epidermis_dry !== undefined ? this.epidermis_dry : <any>null;
        data["epidermis_earthy"] = this.epidermis_earthy !== undefined ? this.epidermis_earthy : <any>null;
        data["epidermis_hyperemic"] = this.epidermis_hyperemic !== undefined ? this.epidermis_hyperemic : <any>null;
        data["epidermis_icteric"] = this.epidermis_icteric !== undefined ? this.epidermis_icteric : <any>null;
        data["epidermis_normal"] = this.epidermis_normal !== undefined ? this.epidermis_normal : <any>null;
        data["epidermis_pale"] = this.epidermis_pale !== undefined ? this.epidermis_pale : <any>null;
        data["epidermis_profuse_sweat"] = this.epidermis_profuse_sweat !== undefined ? this.epidermis_profuse_sweat : <any>null;
        data["epidermis_rashes"] = this.epidermis_rashes !== undefined ? this.epidermis_rashes : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["health_state_id"] = this.health_state_id !== undefined ? this.health_state_id : <any>null;
        data["inadequate_assessment"] = this.inadequate_assessment !== undefined ? this.inadequate_assessment : <any>null;
        data["instability_romberg"] = this.instability_romberg !== undefined ? this.instability_romberg : <any>null;
        data["lymph_nodes_localisation"] = this.lymph_nodes_localisation !== undefined ? this.lymph_nodes_localisation : <any>null;
        data["meningeal"] = this.meningeal !== undefined ? this.meningeal : <any>null;
        data["mucous_throat_id"] = this.mucous_throat_id !== undefined ? this.mucous_throat_id : <any>null;
        data["palpitation"] = this.palpitation !== undefined ? this.palpitation : <any>null;
        data["palpitation_ad"] = this.palpitation_ad !== undefined ? this.palpitation_ad : <any>null;
        data["palpitation_ad_max"] = this.palpitation_ad_max !== undefined ? this.palpitation_ad_max : <any>null;
        data["palpitation_adn"] = this.palpitation_adn !== undefined ? this.palpitation_adn : <any>null;
        data["palpitation_cd"] = this.palpitation_cd !== undefined ? this.palpitation_cd : <any>null;
        data["palpitation_noises"] = this.palpitation_noises !== undefined ? this.palpitation_noises : <any>null;
        data["palpitation_ps"] = this.palpitation_ps !== undefined ? this.palpitation_ps : <any>null;
        data["palpitation_sat_02"] = this.palpitation_sat_02 !== undefined ? this.palpitation_sat_02 : <any>null;
        data["palpitation_tone_id"] = this.palpitation_tone_id !== undefined ? this.palpitation_tone_id : <any>null;
        data["palpitation_type_id"] = this.palpitation_type_id !== undefined ? this.palpitation_type_id : <any>null;
        data["pathological"] = this.pathological !== undefined ? this.pathological : <any>null;
        data["pupil_ratio_id"] = this.pupil_ratio_id !== undefined ? this.pupil_ratio_id : <any>null;
        data["reaction_to_light"] = this.reaction_to_light !== undefined ? this.reaction_to_light : <any>null;
        data["reflex_id"] = this.reflex_id !== undefined ? this.reflex_id : <any>null;
        data["sensitivity_of_lymph_nodes_id"] = this.sensitivity_of_lymph_nodes_id !== undefined ? this.sensitivity_of_lymph_nodes_id : <any>null;
        data["shaky_walk"] = this.shaky_walk !== undefined ? this.shaky_walk : <any>null;
        data["size_of_lymph_nodes_id"] = this.size_of_lymph_nodes_id !== undefined ? this.size_of_lymph_nodes_id : <any>null;
        data["speech_drunk_man"] = this.speech_drunk_man !== undefined ? this.speech_drunk_man : <any>null;
        data["swelling"] = this.swelling !== undefined ? this.swelling : <any>null;
        data["swelling_localisation"] = this.swelling_localisation !== undefined ? this.swelling_localisation : <any>null;
        return data; 
    }
}

export interface IMobileCardObjective {
    adenoid_incrustation?: boolean | null;
    adenoid_size_id?: number | null;
    alcohol_air?: boolean | null;
    body_temperature?: string | null;
    breath_absent?: boolean | null;
    breath_bronchial?: boolean | null;
    breath_hard?: boolean | null;
    breath_puerile?: boolean | null;
    breath_smooth?: boolean | null;
    breath_vesicular?: boolean | null;
    breath_weak?: boolean | null;
    conscious_state_id?: number | null;
    ds_pupil_ratio_id?: number | null;
    ds_reflex_id?: number | null;
    emotional_lability?: boolean | null;
    epidermis_acrocyanosis?: boolean | null;
    epidermis_cyanotic?: boolean | null;
    epidermis_dry?: boolean | null;
    epidermis_earthy?: boolean | null;
    epidermis_hyperemic?: boolean | null;
    epidermis_icteric?: boolean | null;
    epidermis_normal?: boolean | null;
    epidermis_pale?: boolean | null;
    epidermis_profuse_sweat?: boolean | null;
    epidermis_rashes?: boolean | null;
    glucometry?: string | null;
    health_state_id?: number | null;
    inadequate_assessment?: boolean | null;
    instability_romberg?: boolean | null;
    lymph_nodes_localisation?: string | null;
    meningeal?: boolean | null;
    mucous_throat_id?: number | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_ad_max?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_noises?: boolean | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    palpitation_tone_id?: number | null;
    palpitation_type_id?: number | null;
    pathological?: boolean | null;
    pupil_ratio_id?: number | null;
    reaction_to_light?: boolean | null;
    reflex_id?: number | null;
    sensitivity_of_lymph_nodes_id?: number | null;
    shaky_walk?: boolean | null;
    size_of_lymph_nodes_id?: number | null;
    speech_drunk_man?: boolean | null;
    swelling?: boolean | null;
    swelling_localisation?: string | null;
}

export class MobileCardAnamnesis implements IMobileCardAnamnesis {
    allergic_anamnesis_id?: number | null;
    born_diseases?: string | null;
    disease_anamnesis?: string | null;
    dont_like?: string | null;
    gynecological?: string | null;
    infect_patient_contact?: string | null;
    problems?: string | null;
    quarantine?: string | null;
    shit_frequency?: string | null;
    shit_id?: number | null;
    urine?: string | null;
    vaccination?: string | null;

    constructor(data?: IMobileCardAnamnesis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic_anamnesis_id = data["allergic_anamnesis_id"] !== undefined ? data["allergic_anamnesis_id"] : <any>null;
            this.born_diseases = data["born_diseases"] !== undefined ? data["born_diseases"] : <any>null;
            this.disease_anamnesis = data["disease_anamnesis"] !== undefined ? data["disease_anamnesis"] : <any>null;
            this.dont_like = data["dont_like"] !== undefined ? data["dont_like"] : <any>null;
            this.gynecological = data["gynecological"] !== undefined ? data["gynecological"] : <any>null;
            this.infect_patient_contact = data["infect_patient_contact"] !== undefined ? data["infect_patient_contact"] : <any>null;
            this.problems = data["problems"] !== undefined ? data["problems"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.shit_frequency = data["shit_frequency"] !== undefined ? data["shit_frequency"] : <any>null;
            this.shit_id = data["shit_id"] !== undefined ? data["shit_id"] : <any>null;
            this.urine = data["urine"] !== undefined ? data["urine"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardAnamnesis {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardAnamnesis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic_anamnesis_id"] = this.allergic_anamnesis_id !== undefined ? this.allergic_anamnesis_id : <any>null;
        data["born_diseases"] = this.born_diseases !== undefined ? this.born_diseases : <any>null;
        data["disease_anamnesis"] = this.disease_anamnesis !== undefined ? this.disease_anamnesis : <any>null;
        data["dont_like"] = this.dont_like !== undefined ? this.dont_like : <any>null;
        data["gynecological"] = this.gynecological !== undefined ? this.gynecological : <any>null;
        data["infect_patient_contact"] = this.infect_patient_contact !== undefined ? this.infect_patient_contact : <any>null;
        data["problems"] = this.problems !== undefined ? this.problems : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["shit_frequency"] = this.shit_frequency !== undefined ? this.shit_frequency : <any>null;
        data["shit_id"] = this.shit_id !== undefined ? this.shit_id : <any>null;
        data["urine"] = this.urine !== undefined ? this.urine : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        return data; 
    }
}

export interface IMobileCardAnamnesis {
    allergic_anamnesis_id?: number | null;
    born_diseases?: string | null;
    disease_anamnesis?: string | null;
    dont_like?: string | null;
    gynecological?: string | null;
    infect_patient_contact?: string | null;
    problems?: string | null;
    quarantine?: string | null;
    shit_frequency?: string | null;
    shit_id?: number | null;
    urine?: string | null;
    vaccination?: string | null;
}

export class PerformerTypeDto implements IPerformerTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IPerformerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IPerformerTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CardResultTransferPatientDto implements ICardResultTransferPatientDto {
    brigade_number?: string | null;
    time?: LocalDateTime | null;

    constructor(data?: ICardResultTransferPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_number = data["brigade_number"] !== undefined ? data["brigade_number"] : <any>null;
            this.time = data["time"] ? LocalDateTime.fromJS(data["time"]) : <any>null;
        }
    }

    static fromJS(data: any): CardResultTransferPatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTransferPatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_number"] = this.brigade_number !== undefined ? this.brigade_number : <any>null;
        data["time"] = this.time ? this.time.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardResultTransferPatientDto {
    brigade_number?: string | null;
    time?: LocalDateTime | null;
}

export class CardObjectiveDyspepticPartDto implements ICardObjectiveDyspepticPartDto {
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;

    constructor(data?: ICardObjectiveDyspepticPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dyspeptic_diarrhea = data["dyspeptic_diarrhea"] !== undefined ? data["dyspeptic_diarrhea"] : <any>null;
            this.dyspeptic_nausea = data["dyspeptic_nausea"] !== undefined ? data["dyspeptic_nausea"] : <any>null;
            this.dyspeptic_retch = data["dyspeptic_retch"] !== undefined ? data["dyspeptic_retch"] : <any>null;
            this.dyspeptics_no = data["dyspeptics_no"] !== undefined ? data["dyspeptics_no"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveDyspepticPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveDyspepticPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dyspeptic_diarrhea"] = this.dyspeptic_diarrhea !== undefined ? this.dyspeptic_diarrhea : <any>null;
        data["dyspeptic_nausea"] = this.dyspeptic_nausea !== undefined ? this.dyspeptic_nausea : <any>null;
        data["dyspeptic_retch"] = this.dyspeptic_retch !== undefined ? this.dyspeptic_retch : <any>null;
        data["dyspeptics_no"] = this.dyspeptics_no !== undefined ? this.dyspeptics_no : <any>null;
        return data; 
    }
}

export interface ICardObjectiveDyspepticPartDto {
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;
}

export class InquirerTreeNode implements IInquirerTreeNode {
    answer_title?: string | null;
    expanded?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    leaf?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_id?: number | null;
    reason_title?: string | null;

    constructor(data?: IInquirerTreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer_title = data["answer_title"] !== undefined ? data["answer_title"] : <any>null;
            this.expanded = data["expanded"] !== undefined ? data["expanded"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.is_editable = data["is_editable"] !== undefined ? data["is_editable"] : <any>null;
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
            this.query_title = data["query_title"] !== undefined ? data["query_title"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_title = data["reason_title"] !== undefined ? data["reason_title"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerTreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerTreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer_title"] = this.answer_title !== undefined ? this.answer_title : <any>null;
        data["expanded"] = this.expanded !== undefined ? this.expanded : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["is_editable"] = this.is_editable !== undefined ? this.is_editable : <any>null;
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        data["query_title"] = this.query_title !== undefined ? this.query_title : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_title"] = this.reason_title !== undefined ? this.reason_title : <any>null;
        return data; 
    }
}

export interface IInquirerTreeNode {
    answer_title?: string | null;
    expanded?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    leaf?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_id?: number | null;
    reason_title?: string | null;
}

export class BrigadeAppointRequestDto implements IBrigadeAppointRequestDto {
    brigade_schedule_id?: number | null;
    receiving_type_id?: number | null;

    constructor(data?: IBrigadeAppointRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_schedule_id = data["brigade_schedule_id"] !== undefined ? data["brigade_schedule_id"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeAppointRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeAppointRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_schedule_id"] = this.brigade_schedule_id !== undefined ? this.brigade_schedule_id : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        return data; 
    }
}

export interface IBrigadeAppointRequestDto {
    brigade_schedule_id?: number | null;
    receiving_type_id?: number | null;
}

export class SkillDto implements ISkillDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ISkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ISkillDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CallLocationPartDto implements ICallLocationPartDto {
    call_id?: number | null;
    latitude?: number | null;
    longitude?: number | null;

    constructor(data?: ICallLocationPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
        }
    }

    static fromJS(data: any): CallLocationPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallLocationPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        return data; 
    }
}

export interface ICallLocationPartDto {
    call_id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
}

export class Mkb implements IMkb {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    info?: string | null;
    isFinal?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parent?: Mkb | null;
    parentCode?: string | null;

    constructor(data?: IMkb) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.info = data["info"] !== undefined ? data["info"] : <any>null;
            this.isFinal = data["isFinal"] !== undefined ? data["isFinal"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nodeCount = data["nodeCount"] !== undefined ? data["nodeCount"] : <any>null;
            this.parent = data["parent"] ? Mkb.fromJS(data["parent"]) : <any>null;
            this.parentCode = data["parentCode"] !== undefined ? data["parentCode"] : <any>null;
        }
    }

    static fromJS(data: any): Mkb {
        data = typeof data === 'object' ? data : {};
        let result = new Mkb();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["info"] = this.info !== undefined ? this.info : <any>null;
        data["isFinal"] = this.isFinal !== undefined ? this.isFinal : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nodeCount"] = this.nodeCount !== undefined ? this.nodeCount : <any>null;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>null;
        data["parentCode"] = this.parentCode !== undefined ? this.parentCode : <any>null;
        return data; 
    }
}

export interface IMkb {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    info?: string | null;
    isFinal?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parent?: Mkb | null;
    parentCode?: string | null;
}

export class CardObjectiveAdditionPartDto implements ICardObjectiveAdditionPartDto {
    addition_objective?: string | null;

    constructor(data?: ICardObjectiveAdditionPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addition_objective = data["addition_objective"] !== undefined ? data["addition_objective"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveAdditionPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveAdditionPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addition_objective"] = this.addition_objective !== undefined ? this.addition_objective : <any>null;
        return data; 
    }
}

export interface ICardObjectiveAdditionPartDto {
    addition_objective?: string | null;
}

export class MobileCardPatient implements IMobileCardPatient {
    dms?: string | null;
    oms?: string | null;
    omsOrganisation?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    sex_id?: number | null;
    social_status_id?: number | null;
    surname?: string | null;
    type_id?: number | null;

    constructor(data?: IMobileCardPatient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dms = data["Dms"] !== undefined ? data["Dms"] : <any>null;
            this.oms = data["Oms"] !== undefined ? data["Oms"] : <any>null;
            this.omsOrganisation = data["OmsOrganisation"] !== undefined ? data["OmsOrganisation"] : <any>null;
            this.age_days = data["age_days"] !== undefined ? data["age_days"] : <any>null;
            this.age_months = data["age_months"] !== undefined ? data["age_months"] : <any>null;
            this.age_years = data["age_years"] !== undefined ? data["age_years"] : <any>null;
            this.birth_date = data["birth_date"] !== undefined ? data["birth_date"] : <any>null;
            this.firstname = data["firstname"] !== undefined ? data["firstname"] : <any>null;
            this.job = data["job"] !== undefined ? data["job"] : <any>null;
            this.job_position = data["job_position"] !== undefined ? data["job_position"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.sex_id = data["sex_id"] !== undefined ? data["sex_id"] : <any>null;
            this.social_status_id = data["social_status_id"] !== undefined ? data["social_status_id"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardPatient {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardPatient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Dms"] = this.dms !== undefined ? this.dms : <any>null;
        data["Oms"] = this.oms !== undefined ? this.oms : <any>null;
        data["OmsOrganisation"] = this.omsOrganisation !== undefined ? this.omsOrganisation : <any>null;
        data["age_days"] = this.age_days !== undefined ? this.age_days : <any>null;
        data["age_months"] = this.age_months !== undefined ? this.age_months : <any>null;
        data["age_years"] = this.age_years !== undefined ? this.age_years : <any>null;
        data["birth_date"] = this.birth_date !== undefined ? this.birth_date : <any>null;
        data["firstname"] = this.firstname !== undefined ? this.firstname : <any>null;
        data["job"] = this.job !== undefined ? this.job : <any>null;
        data["job_position"] = this.job_position !== undefined ? this.job_position : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["sex_id"] = this.sex_id !== undefined ? this.sex_id : <any>null;
        data["social_status_id"] = this.social_status_id !== undefined ? this.social_status_id : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        return data; 
    }
}

export interface IMobileCardPatient {
    dms?: string | null;
    oms?: string | null;
    omsOrganisation?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    sex_id?: number | null;
    social_status_id?: number | null;
    surname?: string | null;
    type_id?: number | null;
}

export class ListDtoOfString implements IListDtoOfString {
    list?: string[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(item);
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item);
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfString {
    list?: string[] | null;
    size?: number | null;
    total?: number | null;
}

export class InquirerInCallDto implements IInquirerInCallDto {
    basic_reason_id?: number | null;
    brigade_types?: BrigadeTypeDto[] | null;
    extra?: boolean | null;
    id?: number | null;
    items?: InquirerInCallDto[] | null;
    title?: string | null;
    type?: string | null;

    constructor(data?: IInquirerInCallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.basic_reason_id = data["basic_reason_id"] !== undefined ? data["basic_reason_id"] : <any>null;
            if (data["brigade_types"] && data["brigade_types"].constructor === Array) {
                this.brigade_types = [];
                for (let item of data["brigade_types"])
                    this.brigade_types.push(BrigadeTypeDto.fromJS(item));
            }
            this.extra = data["extra"] !== undefined ? data["extra"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(InquirerInCallDto.fromJS(item));
            }
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerInCallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerInCallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basic_reason_id"] = this.basic_reason_id !== undefined ? this.basic_reason_id : <any>null;
        if (this.brigade_types && this.brigade_types.constructor === Array) {
            data["brigade_types"] = [];
            for (let item of this.brigade_types)
                data["brigade_types"].push(item.toJSON());
        }
        data["extra"] = this.extra !== undefined ? this.extra : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IInquirerInCallDto {
    basic_reason_id?: number | null;
    brigade_types?: BrigadeTypeDto[] | null;
    extra?: boolean | null;
    id?: number | null;
    items?: InquirerInCallDto[] | null;
    title?: string | null;
    type?: string | null;
}

export class HospitalDto implements IHospitalDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;

    constructor(data?: IHospitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? FiasAddressDto.fromJS(data["address"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.district_code = data["district_code"] !== undefined ? data["district_code"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
        }
    }

    static fromJS(data: any): HospitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["district_code"] = this.district_code !== undefined ? this.district_code : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        return data; 
    }
}

export interface IHospitalDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
}

export class Medicine implements IMedicine {
    count?: number | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;

    constructor(data?: IMedicine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.uid = data["uid"] !== undefined ? data["uid"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): Medicine {
        data = typeof data === 'object' ? data : {};
        let result = new Medicine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["uid"] = this.uid !== undefined ? this.uid : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IMedicine {
    count?: number | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;
}

export class PerformerShortDto implements IPerformerShortDto {
    first_name?: string | null;
    id?: number | null;
    patronymic?: string | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: IPerformerShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.second_name = data["second_name"] !== undefined ? data["second_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["second_name"] = this.second_name !== undefined ? this.second_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface IPerformerShortDto {
    first_name?: string | null;
    id?: number | null;
    patronymic?: string | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class MessageDto implements IMessageDto {
    message?: string | null;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"] !== undefined ? data["message"] : <any>null;
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data; 
    }
}

export interface IMessageDto {
    message?: string | null;
}

export class CardObjectiveDiuresisPartDto implements ICardObjectiveDiuresisPartDto {
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;

    constructor(data?: ICardObjectiveDiuresisPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diuresis_disuria = data["diuresis_disuria"] !== undefined ? data["diuresis_disuria"] : <any>null;
            this.diuresis_hematuria = data["diuresis_hematuria"] !== undefined ? data["diuresis_hematuria"] : <any>null;
            this.diuresis_n = data["diuresis_n"] !== undefined ? data["diuresis_n"] : <any>null;
            this.diuresis_oliguria = data["diuresis_oliguria"] !== undefined ? data["diuresis_oliguria"] : <any>null;
            this.lion_tapping_left = data["lion_tapping_left"] !== undefined ? data["lion_tapping_left"] : <any>null;
            this.lion_tapping_right = data["lion_tapping_right"] !== undefined ? data["lion_tapping_right"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveDiuresisPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveDiuresisPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diuresis_disuria"] = this.diuresis_disuria !== undefined ? this.diuresis_disuria : <any>null;
        data["diuresis_hematuria"] = this.diuresis_hematuria !== undefined ? this.diuresis_hematuria : <any>null;
        data["diuresis_n"] = this.diuresis_n !== undefined ? this.diuresis_n : <any>null;
        data["diuresis_oliguria"] = this.diuresis_oliguria !== undefined ? this.diuresis_oliguria : <any>null;
        data["lion_tapping_left"] = this.lion_tapping_left !== undefined ? this.lion_tapping_left : <any>null;
        data["lion_tapping_right"] = this.lion_tapping_right !== undefined ? this.lion_tapping_right : <any>null;
        return data; 
    }
}

export interface ICardObjectiveDiuresisPartDto {
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;
}

export class BrigadeDto implements IBrigadeDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_receiving_type_id?: number | null;
    brigade_receiving_type_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    can_use?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    full_name?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    on_duty?: boolean | null;
    on_duty_comment?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    status_time?: LocalDateTime | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_state_mark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;

    constructor(data?: IBrigadeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.br_type_code = data["br_type_code"] !== undefined ? data["br_type_code"] : <any>null;
            this.br_type_id = data["br_type_id"] !== undefined ? data["br_type_id"] : <any>null;
            this.br_type_name = data["br_type_name"] !== undefined ? data["br_type_name"] : <any>null;
            this.brigade_receiving_type_id = data["brigade_receiving_type_id"] !== undefined ? data["brigade_receiving_type_id"] : <any>null;
            this.brigade_receiving_type_name = data["brigade_receiving_type_name"] !== undefined ? data["brigade_receiving_type_name"] : <any>null;
            this.brigade_status_id = data["brigade_status_id"] !== undefined ? data["brigade_status_id"] : <any>null;
            this.brigade_status_name = data["brigade_status_name"] !== undefined ? data["brigade_status_name"] : <any>null;
            this.can_use = data["can_use"] !== undefined ? data["can_use"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.on_duty = data["on_duty"] !== undefined ? data["on_duty"] : <any>null;
            this.on_duty_comment = data["on_duty_comment"] !== undefined ? data["on_duty_comment"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerDto.fromJS(item));
            }
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.status_time = data["status_time"] ? LocalDateTime.fromJS(data["status_time"]) : <any>null;
            this.sub_code = data["sub_code"] !== undefined ? data["sub_code"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
            this.transport_state_mark = data["transport_state_mark"] !== undefined ? data["transport_state_mark"] : <any>null;
            this.workplace_id = data["workplace_id"] !== undefined ? data["workplace_id"] : <any>null;
            this.workplace_name = data["workplace_name"] !== undefined ? data["workplace_name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_type_code"] = this.br_type_code !== undefined ? this.br_type_code : <any>null;
        data["br_type_id"] = this.br_type_id !== undefined ? this.br_type_id : <any>null;
        data["br_type_name"] = this.br_type_name !== undefined ? this.br_type_name : <any>null;
        data["brigade_receiving_type_id"] = this.brigade_receiving_type_id !== undefined ? this.brigade_receiving_type_id : <any>null;
        data["brigade_receiving_type_name"] = this.brigade_receiving_type_name !== undefined ? this.brigade_receiving_type_name : <any>null;
        data["brigade_status_id"] = this.brigade_status_id !== undefined ? this.brigade_status_id : <any>null;
        data["brigade_status_name"] = this.brigade_status_name !== undefined ? this.brigade_status_name : <any>null;
        data["can_use"] = this.can_use !== undefined ? this.can_use : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["on_duty"] = this.on_duty !== undefined ? this.on_duty : <any>null;
        data["on_duty_comment"] = this.on_duty_comment !== undefined ? this.on_duty_comment : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["status_time"] = this.status_time ? this.status_time.toJSON() : <any>null;
        data["sub_code"] = this.sub_code !== undefined ? this.sub_code : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        data["transport_state_mark"] = this.transport_state_mark !== undefined ? this.transport_state_mark : <any>null;
        data["workplace_id"] = this.workplace_id !== undefined ? this.workplace_id : <any>null;
        data["workplace_name"] = this.workplace_name !== undefined ? this.workplace_name : <any>null;
        return data; 
    }
}

export interface IBrigadeDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_receiving_type_id?: number | null;
    brigade_receiving_type_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    can_use?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    full_name?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    on_duty?: boolean | null;
    on_duty_comment?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    status_time?: LocalDateTime | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_state_mark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;
}

export class CardObjectiveEdemaPartDto implements ICardObjectiveEdemaPartDto {
    titles?: boolean | null;
    titles_text?: string | null;

    constructor(data?: ICardObjectiveEdemaPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.titles = data["titles"] !== undefined ? data["titles"] : <any>null;
            this.titles_text = data["titles_text"] !== undefined ? data["titles_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveEdemaPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveEdemaPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titles"] = this.titles !== undefined ? this.titles : <any>null;
        data["titles_text"] = this.titles_text !== undefined ? this.titles_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveEdemaPartDto {
    titles?: boolean | null;
    titles_text?: string | null;
}

export class CardObjectiveGeneralStatePartDto implements ICardObjectiveGeneralStatePartDto {
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    general_state_id?: number | null;
    general_state_name?: string | null;

    constructor(data?: ICardObjectiveGeneralStatePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.behaviour_id = data["behaviour_id"] !== undefined ? data["behaviour_id"] : <any>null;
            this.behaviour_name = data["behaviour_name"] !== undefined ? data["behaviour_name"] : <any>null;
            this.conscious_id = data["conscious_id"] !== undefined ? data["conscious_id"] : <any>null;
            this.conscious_name = data["conscious_name"] !== undefined ? data["conscious_name"] : <any>null;
            this.general_state_id = data["general_state_id"] !== undefined ? data["general_state_id"] : <any>null;
            this.general_state_name = data["general_state_name"] !== undefined ? data["general_state_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveGeneralStatePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveGeneralStatePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["behaviour_id"] = this.behaviour_id !== undefined ? this.behaviour_id : <any>null;
        data["behaviour_name"] = this.behaviour_name !== undefined ? this.behaviour_name : <any>null;
        data["conscious_id"] = this.conscious_id !== undefined ? this.conscious_id : <any>null;
        data["conscious_name"] = this.conscious_name !== undefined ? this.conscious_name : <any>null;
        data["general_state_id"] = this.general_state_id !== undefined ? this.general_state_id : <any>null;
        data["general_state_name"] = this.general_state_name !== undefined ? this.general_state_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveGeneralStatePartDto {
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    general_state_id?: number | null;
    general_state_name?: string | null;
}

export class Place implements IPlace {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: PlaceType | null;
    type_name?: string | null;

    constructor(data?: IPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): Place {
        data = typeof data === 'object' ? data : {};
        let result = new Place();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface IPlace {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: PlaceType | null;
    type_name?: string | null;
}

export class CardResultEfficiencyAssistance implements ICardResultEfficiencyAssistance {
    ad?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    id?: number | null;
    pulse?: string | null;
    pulse_oximetry?: string | null;
    temperature?: string | null;
    work_ad?: string | null;

    constructor(data?: ICardResultEfficiencyAssistance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ad = data["ad"] !== undefined ? data["ad"] : <any>null;
            this.chd = data["chd"] !== undefined ? data["chd"] : <any>null;
            this.chss = data["chss"] !== undefined ? data["chss"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.pulse = data["pulse"] !== undefined ? data["pulse"] : <any>null;
            this.pulse_oximetry = data["pulse_oximetry"] !== undefined ? data["pulse_oximetry"] : <any>null;
            this.temperature = data["temperature"] !== undefined ? data["temperature"] : <any>null;
            this.work_ad = data["work_ad"] !== undefined ? data["work_ad"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultEfficiencyAssistance {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultEfficiencyAssistance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ad"] = this.ad !== undefined ? this.ad : <any>null;
        data["chd"] = this.chd !== undefined ? this.chd : <any>null;
        data["chss"] = this.chss !== undefined ? this.chss : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["pulse"] = this.pulse !== undefined ? this.pulse : <any>null;
        data["pulse_oximetry"] = this.pulse_oximetry !== undefined ? this.pulse_oximetry : <any>null;
        data["temperature"] = this.temperature !== undefined ? this.temperature : <any>null;
        data["work_ad"] = this.work_ad !== undefined ? this.work_ad : <any>null;
        return data; 
    }
}

export interface ICardResultEfficiencyAssistance {
    ad?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    id?: number | null;
    pulse?: string | null;
    pulse_oximetry?: string | null;
    temperature?: string | null;
    work_ad?: string | null;
}

export class TransportTypeDto implements ITransportTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ITransportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TransportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ITransportTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class TransportBrigScheduleUpdateDto implements ITransportBrigScheduleUpdateDto {
    id?: number | null;
    period_details?: PeriodDetails | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleUpdateDto {
    id?: number | null;
    period_details?: PeriodDetails | null;
    transport_id?: number | null;
}

export class CardAnamnesisAllergicPartDto implements ICardAnamnesisAllergicPartDto {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_name?: string | null;
    allergic_anamnesis_text?: string | null;

    constructor(data?: ICardAnamnesisAllergicPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic_anamnesis = data["allergic_anamnesis"] !== undefined ? data["allergic_anamnesis"] : <any>null;
            this.allergic_anamnesis_name = data["allergic_anamnesis_name"] !== undefined ? data["allergic_anamnesis_name"] : <any>null;
            this.allergic_anamnesis_text = data["allergic_anamnesis_text"] !== undefined ? data["allergic_anamnesis_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisAllergicPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisAllergicPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic_anamnesis"] = this.allergic_anamnesis !== undefined ? this.allergic_anamnesis : <any>null;
        data["allergic_anamnesis_name"] = this.allergic_anamnesis_name !== undefined ? this.allergic_anamnesis_name : <any>null;
        data["allergic_anamnesis_text"] = this.allergic_anamnesis_text !== undefined ? this.allergic_anamnesis_text : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisAllergicPartDto {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_name?: string | null;
    allergic_anamnesis_text?: string | null;
}

export class InventoryNomenclature implements IInventoryNomenclature {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    inventory_id?: number | null;
    name?: string | null;
    packaging_count?: number | null;
    packaging_count_current?: number | null;
    product_count?: number | null;
    product_count_current?: number | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;

    constructor(data?: IInventoryNomenclature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.inventory_id = data["inventory_id"] !== undefined ? data["inventory_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.packaging_count = data["packaging_count"] !== undefined ? data["packaging_count"] : <any>null;
            this.packaging_count_current = data["packaging_count_current"] !== undefined ? data["packaging_count_current"] : <any>null;
            this.product_count = data["product_count"] !== undefined ? data["product_count"] : <any>null;
            this.product_count_current = data["product_count_current"] !== undefined ? data["product_count_current"] : <any>null;
            this.product_id = data["product_id"] !== undefined ? data["product_id"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
            this.unit_count = data["unit_count"] !== undefined ? data["unit_count"] : <any>null;
        }
    }

    static fromJS(data: any): InventoryNomenclature {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryNomenclature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["inventory_id"] = this.inventory_id !== undefined ? this.inventory_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["packaging_count"] = this.packaging_count !== undefined ? this.packaging_count : <any>null;
        data["packaging_count_current"] = this.packaging_count_current !== undefined ? this.packaging_count_current : <any>null;
        data["product_count"] = this.product_count !== undefined ? this.product_count : <any>null;
        data["product_count_current"] = this.product_count_current !== undefined ? this.product_count_current : <any>null;
        data["product_id"] = this.product_id !== undefined ? this.product_id : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        data["unit_count"] = this.unit_count !== undefined ? this.unit_count : <any>null;
        return data; 
    }
}

export interface IInventoryNomenclature {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    inventory_id?: number | null;
    name?: string | null;
    packaging_count?: number | null;
    packaging_count_current?: number | null;
    product_count?: number | null;
    product_count_current?: number | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;
}

export class Container implements IContainer {
    columns?: string[] | null;
    list?: any[] | null;

    constructor(data?: IContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["columns"] && data["columns"].constructor === Array) {
                this.columns = [];
                for (let item of data["columns"])
                    this.columns.push(item);
            }
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(item);
            }
        }
    }

    static fromJS(data: any): Container {
        data = typeof data === 'object' ? data : {};
        let result = new Container();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.columns && this.columns.constructor === Array) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item);
        }
        return data; 
    }
}

export interface IContainer {
    columns?: string[] | null;
    list?: any[] | null;
}

export class PeriodDetails implements IPeriodDetails {
    date_from?: LocalDateTime | null;
    date_to?: LocalDateTime | null;
    duty_comment?: string | null;
    duty_end_date?: LocalDateTime | null;
    duty_start_date?: LocalDateTime | null;

    constructor(data?: IPeriodDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_from = data["date_from"] ? LocalDateTime.fromJS(data["date_from"]) : <any>null;
            this.date_to = data["date_to"] ? LocalDateTime.fromJS(data["date_to"]) : <any>null;
            this.duty_comment = data["duty_comment"] !== undefined ? data["duty_comment"] : <any>null;
            this.duty_end_date = data["duty_end_date"] ? LocalDateTime.fromJS(data["duty_end_date"]) : <any>null;
            this.duty_start_date = data["duty_start_date"] ? LocalDateTime.fromJS(data["duty_start_date"]) : <any>null;
        }
    }

    static fromJS(data: any): PeriodDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_from"] = this.date_from ? this.date_from.toJSON() : <any>null;
        data["date_to"] = this.date_to ? this.date_to.toJSON() : <any>null;
        data["duty_comment"] = this.duty_comment !== undefined ? this.duty_comment : <any>null;
        data["duty_end_date"] = this.duty_end_date ? this.duty_end_date.toJSON() : <any>null;
        data["duty_start_date"] = this.duty_start_date ? this.duty_start_date.toJSON() : <any>null;
        return data; 
    }
}

export interface IPeriodDetails {
    date_from?: LocalDateTime | null;
    date_to?: LocalDateTime | null;
    duty_comment?: string | null;
    duty_end_date?: LocalDateTime | null;
    duty_start_date?: LocalDateTime | null;
}

export class CardObjectiveWheezingPartDto implements ICardObjectiveWheezingPartDto {
    lungs_wheezing_id?: number | null;
    lungs_wheezing_name?: string | null;
    lungs_wheezing_text?: string | null;

    constructor(data?: ICardObjectiveWheezingPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lungs_wheezing_id = data["lungs_wheezing_id"] !== undefined ? data["lungs_wheezing_id"] : <any>null;
            this.lungs_wheezing_name = data["lungs_wheezing_name"] !== undefined ? data["lungs_wheezing_name"] : <any>null;
            this.lungs_wheezing_text = data["lungs_wheezing_text"] !== undefined ? data["lungs_wheezing_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveWheezingPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveWheezingPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lungs_wheezing_id"] = this.lungs_wheezing_id !== undefined ? this.lungs_wheezing_id : <any>null;
        data["lungs_wheezing_name"] = this.lungs_wheezing_name !== undefined ? this.lungs_wheezing_name : <any>null;
        data["lungs_wheezing_text"] = this.lungs_wheezing_text !== undefined ? this.lungs_wheezing_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveWheezingPartDto {
    lungs_wheezing_id?: number | null;
    lungs_wheezing_name?: string | null;
    lungs_wheezing_text?: string | null;
}

export class TreeNode implements ITreeNode {
    count_active?: number | null;
    count_all?: number | null;
    expanded?: boolean | null;
    id?: number | null;
    items?: TreeNode[] | null;
    leaf?: boolean | null;
    loaded?: boolean | null;
    text?: string | null;
    typeId?: number | null;

    constructor(data?: ITreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count_active = data["count_active"] !== undefined ? data["count_active"] : <any>null;
            this.count_all = data["count_all"] !== undefined ? data["count_all"] : <any>null;
            this.expanded = data["expanded"] !== undefined ? data["expanded"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TreeNode.fromJS(item));
            }
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.loaded = data["loaded"] !== undefined ? data["loaded"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.typeId = data["typeId"] !== undefined ? data["typeId"] : <any>null;
        }
    }

    static fromJS(data: any): TreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count_active"] = this.count_active !== undefined ? this.count_active : <any>null;
        data["count_all"] = this.count_all !== undefined ? this.count_all : <any>null;
        data["expanded"] = this.expanded !== undefined ? this.expanded : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["loaded"] = this.loaded !== undefined ? this.loaded : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["typeId"] = this.typeId !== undefined ? this.typeId : <any>null;
        return data; 
    }
}

export interface ITreeNode {
    count_active?: number | null;
    count_all?: number | null;
    expanded?: boolean | null;
    id?: number | null;
    items?: TreeNode[] | null;
    leaf?: boolean | null;
    loaded?: boolean | null;
    text?: string | null;
    typeId?: number | null;
}

export class TransportBrigScheduleAvailableDto implements ITransportBrigScheduleAvailableDto {
    brand?: string | null;
    periods?: Period[] | null;
    statemark?: string | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleAvailableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brand = data["brand"] !== undefined ? data["brand"] : <any>null;
            if (data["periods"] && data["periods"].constructor === Array) {
                this.periods = [];
                for (let item of data["periods"])
                    this.periods.push(Period.fromJS(item));
            }
            this.statemark = data["statemark"] !== undefined ? data["statemark"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleAvailableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleAvailableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand !== undefined ? this.brand : <any>null;
        if (this.periods && this.periods.constructor === Array) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item.toJSON());
        }
        data["statemark"] = this.statemark !== undefined ? this.statemark : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleAvailableDto {
    brand?: string | null;
    periods?: Period[] | null;
    statemark?: string | null;
    transport_id?: number | null;
}

export class CardSideTwoDto implements ICardSideTwoDto {
    anamnesis?: CardAnamnesisPartDto | null;
    objective?: CardObjectivePartDto | null;

    constructor(data?: ICardSideTwoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.anamnesis = data["anamnesis"] ? CardAnamnesisPartDto.fromJS(data["anamnesis"]) : <any>null;
            this.objective = data["objective"] ? CardObjectivePartDto.fromJS(data["objective"]) : <any>null;
        }
    }

    static fromJS(data: any): CardSideTwoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardSideTwoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anamnesis"] = this.anamnesis ? this.anamnesis.toJSON() : <any>null;
        data["objective"] = this.objective ? this.objective.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardSideTwoDto {
    anamnesis?: CardAnamnesisPartDto | null;
    objective?: CardObjectivePartDto | null;
}

export class TransportBrigScheduleDto implements ITransportBrigScheduleDto {
    brand?: string | null;
    id?: number | null;
    period_details?: PeriodDetails | null;
    statemark?: string | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brand = data["brand"] !== undefined ? data["brand"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.statemark = data["statemark"] !== undefined ? data["statemark"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand !== undefined ? this.brand : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["statemark"] = this.statemark !== undefined ? this.statemark : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleDto {
    brand?: string | null;
    id?: number | null;
    period_details?: PeriodDetails | null;
    statemark?: string | null;
    transport_id?: number | null;
}

export class CardObjectiveHeaderDto implements ICardObjectiveHeaderDto {
    is_created?: boolean | null;

    constructor(data?: ICardObjectiveHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        return data; 
    }
}

export interface ICardObjectiveHeaderDto {
    is_created?: boolean | null;
}

export class PGgeometry implements IPGgeometry {
    geoType?: number | null;
    geometry?: Geometry | null;
    type?: string | null;
    value?: string | null;

    constructor(data?: IPGgeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.geoType = data["geoType"] !== undefined ? data["geoType"] : <any>null;
            this.geometry = data["geometry"] ? Geometry.fromJS(data["geometry"]) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PGgeometry {
        data = typeof data === 'object' ? data : {};
        let result = new PGgeometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geoType"] = this.geoType !== undefined ? this.geoType : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IPGgeometry {
    geoType?: number | null;
    geometry?: Geometry | null;
    type?: string | null;
    value?: string | null;
}

export class ReportRequestDto implements IReportRequestDto {
    am?: string | null;
    apu?: string | null;
    code?: string | null;
    dateFromAsLocalDateTime?: LocalDateTime | null;
    dateToAsLocalDateTime?: LocalDateTime | null;
    date_from?: string | null;
    date_to?: string | null;
    equip_id?: number | null;
    format?: number | null;
    image?: string[] | null;
    interval?: number | null;
    sub_id?: number | null;
    type?: number | null;

    constructor(data?: IReportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.am = data["am"] !== undefined ? data["am"] : <any>null;
            this.apu = data["apu"] !== undefined ? data["apu"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.dateFromAsLocalDateTime = data["dateFromAsLocalDateTime"] ? LocalDateTime.fromJS(data["dateFromAsLocalDateTime"]) : <any>null;
            this.dateToAsLocalDateTime = data["dateToAsLocalDateTime"] ? LocalDateTime.fromJS(data["dateToAsLocalDateTime"]) : <any>null;
            this.date_from = data["date_from"] !== undefined ? data["date_from"] : <any>null;
            this.date_to = data["date_to"] !== undefined ? data["date_to"] : <any>null;
            this.equip_id = data["equip_id"] !== undefined ? data["equip_id"] : <any>null;
            this.format = data["format"] !== undefined ? data["format"] : <any>null;
            if (data["image"] && data["image"].constructor === Array) {
                this.image = [];
                for (let item of data["image"])
                    this.image.push(item);
            }
            this.interval = data["interval"] !== undefined ? data["interval"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): ReportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["am"] = this.am !== undefined ? this.am : <any>null;
        data["apu"] = this.apu !== undefined ? this.apu : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["dateFromAsLocalDateTime"] = this.dateFromAsLocalDateTime ? this.dateFromAsLocalDateTime.toJSON() : <any>null;
        data["dateToAsLocalDateTime"] = this.dateToAsLocalDateTime ? this.dateToAsLocalDateTime.toJSON() : <any>null;
        data["date_from"] = this.date_from !== undefined ? this.date_from : <any>null;
        data["date_to"] = this.date_to !== undefined ? this.date_to : <any>null;
        data["equip_id"] = this.equip_id !== undefined ? this.equip_id : <any>null;
        data["format"] = this.format !== undefined ? this.format : <any>null;
        if (this.image && this.image.constructor === Array) {
            data["image"] = [];
            for (let item of this.image)
                data["image"].push(item);
        }
        data["interval"] = this.interval !== undefined ? this.interval : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReportRequestDto {
    am?: string | null;
    apu?: string | null;
    code?: string | null;
    dateFromAsLocalDateTime?: LocalDateTime | null;
    dateToAsLocalDateTime?: LocalDateTime | null;
    date_from?: string | null;
    date_to?: string | null;
    equip_id?: number | null;
    format?: number | null;
    image?: string[] | null;
    interval?: number | null;
    sub_id?: number | null;
    type?: number | null;
}

export class ChatMessage implements IChatMessage {
    blob?: string[] | null;
    chat_id?: number | null;
    date?: LocalDateTime | null;
    id?: number | null;
    sender_id?: number | null;
    sender_name?: string | null;
    sender_position?: string | null;
    sender_subdivision_name?: string | null;
    text?: string | null;
    type?: ChatMessageType | null;
    was_read?: boolean | null;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["blob"] && data["blob"].constructor === Array) {
                this.blob = [];
                for (let item of data["blob"])
                    this.blob.push(item);
            }
            this.chat_id = data["chat_id"] !== undefined ? data["chat_id"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.sender_id = data["sender_id"] !== undefined ? data["sender_id"] : <any>null;
            this.sender_name = data["sender_name"] !== undefined ? data["sender_name"] : <any>null;
            this.sender_position = data["sender_position"] !== undefined ? data["sender_position"] : <any>null;
            this.sender_subdivision_name = data["sender_subdivision_name"] !== undefined ? data["sender_subdivision_name"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.was_read = data["was_read"] !== undefined ? data["was_read"] : <any>null;
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.blob && this.blob.constructor === Array) {
            data["blob"] = [];
            for (let item of this.blob)
                data["blob"].push(item);
        }
        data["chat_id"] = this.chat_id !== undefined ? this.chat_id : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["sender_id"] = this.sender_id !== undefined ? this.sender_id : <any>null;
        data["sender_name"] = this.sender_name !== undefined ? this.sender_name : <any>null;
        data["sender_position"] = this.sender_position !== undefined ? this.sender_position : <any>null;
        data["sender_subdivision_name"] = this.sender_subdivision_name !== undefined ? this.sender_subdivision_name : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["was_read"] = this.was_read !== undefined ? this.was_read : <any>null;
        return data; 
    }
}

export interface IChatMessage {
    blob?: string[] | null;
    chat_id?: number | null;
    date?: LocalDateTime | null;
    id?: number | null;
    sender_id?: number | null;
    sender_name?: string | null;
    sender_position?: string | null;
    sender_subdivision_name?: string | null;
    text?: string | null;
    type?: ChatMessageType | null;
    was_read?: boolean | null;
}

export class TherapyTemplateItemDto implements ITherapyTemplateItemDto {
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    template_id?: number | null;

    constructor(data?: ITherapyTemplateItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.template_id = data["template_id"] !== undefined ? data["template_id"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["template_id"] = this.template_id !== undefined ? this.template_id : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateItemDto {
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    template_id?: number | null;
}

export class Inquirer implements IInquirer {
    answer?: string | null;
    brigadeTypes?: BrigadeType[] | null;
    childs?: Inquirer[] | null;
    codes?: string[] | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    final?: boolean | null;
    id?: number | null;
    isFinal?: boolean | null;
    parent?: Inquirer | null;
    query?: string | null;
    reasonBasic?: boolean | null;
    reasonComment?: string | null;
    reasonExtra?: boolean | null;
    reasonName?: string | null;
    type?: string | null;

    constructor(data?: IInquirer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer = data["answer"] !== undefined ? data["answer"] : <any>null;
            if (data["brigadeTypes"] && data["brigadeTypes"].constructor === Array) {
                this.brigadeTypes = [];
                for (let item of data["brigadeTypes"])
                    this.brigadeTypes.push(BrigadeType.fromJS(item));
            }
            if (data["childs"] && data["childs"].constructor === Array) {
                this.childs = [];
                for (let item of data["childs"])
                    this.childs.push(Inquirer.fromJS(item));
            }
            if (data["codes"] && data["codes"].constructor === Array) {
                this.codes = [];
                for (let item of data["codes"])
                    this.codes.push(item);
            }
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.final = data["final"] !== undefined ? data["final"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isFinal = data["isFinal"] !== undefined ? data["isFinal"] : <any>null;
            this.parent = data["parent"] ? Inquirer.fromJS(data["parent"]) : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.reasonBasic = data["reasonBasic"] !== undefined ? data["reasonBasic"] : <any>null;
            this.reasonComment = data["reasonComment"] !== undefined ? data["reasonComment"] : <any>null;
            this.reasonExtra = data["reasonExtra"] !== undefined ? data["reasonExtra"] : <any>null;
            this.reasonName = data["reasonName"] !== undefined ? data["reasonName"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Inquirer {
        data = typeof data === 'object' ? data : {};
        let result = new Inquirer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer !== undefined ? this.answer : <any>null;
        if (this.brigadeTypes && this.brigadeTypes.constructor === Array) {
            data["brigadeTypes"] = [];
            for (let item of this.brigadeTypes)
                data["brigadeTypes"].push(item.toJSON());
        }
        if (this.childs && this.childs.constructor === Array) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        if (this.codes && this.codes.constructor === Array) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["final"] = this.final !== undefined ? this.final : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isFinal"] = this.isFinal !== undefined ? this.isFinal : <any>null;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["reasonBasic"] = this.reasonBasic !== undefined ? this.reasonBasic : <any>null;
        data["reasonComment"] = this.reasonComment !== undefined ? this.reasonComment : <any>null;
        data["reasonExtra"] = this.reasonExtra !== undefined ? this.reasonExtra : <any>null;
        data["reasonName"] = this.reasonName !== undefined ? this.reasonName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IInquirer {
    answer?: string | null;
    brigadeTypes?: BrigadeType[] | null;
    childs?: Inquirer[] | null;
    codes?: string[] | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    final?: boolean | null;
    id?: number | null;
    isFinal?: boolean | null;
    parent?: Inquirer | null;
    query?: string | null;
    reasonBasic?: boolean | null;
    reasonComment?: string | null;
    reasonExtra?: boolean | null;
    reasonName?: string | null;
    type?: string | null;
}

export class CardResultActiveVisitDto implements ICardResultActiveVisitDto {
    active_visit_date?: LocalDateTime | null;
    active_visit_hours?: number | null;
    active_visit_type_code?: string | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;

    constructor(data?: ICardResultActiveVisitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active_visit_date = data["active_visit_date"] ? LocalDateTime.fromJS(data["active_visit_date"]) : <any>null;
            this.active_visit_hours = data["active_visit_hours"] !== undefined ? data["active_visit_hours"] : <any>null;
            this.active_visit_type_code = data["active_visit_type_code"] !== undefined ? data["active_visit_type_code"] : <any>null;
            this.active_visit_type_id = data["active_visit_type_id"] !== undefined ? data["active_visit_type_id"] : <any>null;
            this.active_visit_type_name = data["active_visit_type_name"] !== undefined ? data["active_visit_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultActiveVisitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultActiveVisitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active_visit_date"] = this.active_visit_date ? this.active_visit_date.toJSON() : <any>null;
        data["active_visit_hours"] = this.active_visit_hours !== undefined ? this.active_visit_hours : <any>null;
        data["active_visit_type_code"] = this.active_visit_type_code !== undefined ? this.active_visit_type_code : <any>null;
        data["active_visit_type_id"] = this.active_visit_type_id !== undefined ? this.active_visit_type_id : <any>null;
        data["active_visit_type_name"] = this.active_visit_type_name !== undefined ? this.active_visit_type_name : <any>null;
        return data; 
    }
}

export interface ICardResultActiveVisitDto {
    active_visit_date?: LocalDateTime | null;
    active_visit_hours?: number | null;
    active_visit_type_code?: string | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;
}

export class CardObjectiveLiverPartDto implements ICardObjectiveLiverPartDto {
    liver_normal_large?: number | null;
    liver_normal_large_name?: string | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;

    constructor(data?: ICardObjectiveLiverPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.liver_normal_large = data["liver_normal_large"] !== undefined ? data["liver_normal_large"] : <any>null;
            this.liver_normal_large_name = data["liver_normal_large_name"] !== undefined ? data["liver_normal_large_name"] : <any>null;
            this.liver_ortner = data["liver_ortner"] !== undefined ? data["liver_ortner"] : <any>null;
            this.liver_size_text = data["liver_size_text"] !== undefined ? data["liver_size_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveLiverPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveLiverPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["liver_normal_large"] = this.liver_normal_large !== undefined ? this.liver_normal_large : <any>null;
        data["liver_normal_large_name"] = this.liver_normal_large_name !== undefined ? this.liver_normal_large_name : <any>null;
        data["liver_ortner"] = this.liver_ortner !== undefined ? this.liver_ortner : <any>null;
        data["liver_size_text"] = this.liver_size_text !== undefined ? this.liver_size_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveLiverPartDto {
    liver_normal_large?: number | null;
    liver_normal_large_name?: string | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;
}

export class MobileCard implements IMobileCard {
    address?: MobileCardAddress | null;
    anamnesis?: MobileCardAnamnesis | null;
    document?: MobileCardDocument | null;
    drugs?: MobileCardDrug[] | null;
    objective_data?: MobileCardObjective | null;
    patient?: MobileCardPatient | null;
    result?: MobileCardResult | null;

    constructor(data?: IMobileCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? MobileCardAddress.fromJS(data["address"]) : <any>null;
            this.anamnesis = data["anamnesis"] ? MobileCardAnamnesis.fromJS(data["anamnesis"]) : <any>null;
            this.document = data["document"] ? MobileCardDocument.fromJS(data["document"]) : <any>null;
            if (data["drugs"] && data["drugs"].constructor === Array) {
                this.drugs = [];
                for (let item of data["drugs"])
                    this.drugs.push(MobileCardDrug.fromJS(item));
            }
            this.objective_data = data["objective_data"] ? MobileCardObjective.fromJS(data["objective_data"]) : <any>null;
            this.patient = data["patient"] ? MobileCardPatient.fromJS(data["patient"]) : <any>null;
            this.result = data["result"] ? MobileCardResult.fromJS(data["result"]) : <any>null;
        }
    }

    static fromJS(data: any): MobileCard {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["anamnesis"] = this.anamnesis ? this.anamnesis.toJSON() : <any>null;
        data["document"] = this.document ? this.document.toJSON() : <any>null;
        if (this.drugs && this.drugs.constructor === Array) {
            data["drugs"] = [];
            for (let item of this.drugs)
                data["drugs"].push(item.toJSON());
        }
        data["objective_data"] = this.objective_data ? this.objective_data.toJSON() : <any>null;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>null;
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        return data; 
    }
}

export interface IMobileCard {
    address?: MobileCardAddress | null;
    anamnesis?: MobileCardAnamnesis | null;
    document?: MobileCardDocument | null;
    drugs?: MobileCardDrug[] | null;
    objective_data?: MobileCardObjective | null;
    patient?: MobileCardPatient | null;
    result?: MobileCardResult | null;
}

export class CardResultReasonDto implements ICardResultReasonDto {
    accident_type_code?: string | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: LocalDateTime | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    reason_type_code?: string | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;

    constructor(data?: ICardResultReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accident_type_code = data["accident_type_code"] !== undefined ? data["accident_type_code"] : <any>null;
            this.accident_type_id = data["accident_type_id"] !== undefined ? data["accident_type_id"] : <any>null;
            this.accident_type_name = data["accident_type_name"] !== undefined ? data["accident_type_name"] : <any>null;
            this.death_condition_id = data["death_condition_id"] !== undefined ? data["death_condition_id"] : <any>null;
            this.death_condition_name = data["death_condition_name"] !== undefined ? data["death_condition_name"] : <any>null;
            this.death_time = data["death_time"] ? LocalDateTime.fromJS(data["death_time"]) : <any>null;
            this.intoxication_type_id = data["intoxication_type_id"] !== undefined ? data["intoxication_type_id"] : <any>null;
            this.intoxication_type_name = data["intoxication_type_name"] !== undefined ? data["intoxication_type_name"] : <any>null;
            this.reason_type_code = data["reason_type_code"] !== undefined ? data["reason_type_code"] : <any>null;
            this.reason_type_id = data["reason_type_id"] !== undefined ? data["reason_type_id"] : <any>null;
            this.reason_type_name = data["reason_type_name"] !== undefined ? data["reason_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accident_type_code"] = this.accident_type_code !== undefined ? this.accident_type_code : <any>null;
        data["accident_type_id"] = this.accident_type_id !== undefined ? this.accident_type_id : <any>null;
        data["accident_type_name"] = this.accident_type_name !== undefined ? this.accident_type_name : <any>null;
        data["death_condition_id"] = this.death_condition_id !== undefined ? this.death_condition_id : <any>null;
        data["death_condition_name"] = this.death_condition_name !== undefined ? this.death_condition_name : <any>null;
        data["death_time"] = this.death_time ? this.death_time.toJSON() : <any>null;
        data["intoxication_type_id"] = this.intoxication_type_id !== undefined ? this.intoxication_type_id : <any>null;
        data["intoxication_type_name"] = this.intoxication_type_name !== undefined ? this.intoxication_type_name : <any>null;
        data["reason_type_code"] = this.reason_type_code !== undefined ? this.reason_type_code : <any>null;
        data["reason_type_id"] = this.reason_type_id !== undefined ? this.reason_type_id : <any>null;
        data["reason_type_name"] = this.reason_type_name !== undefined ? this.reason_type_name : <any>null;
        return data; 
    }
}

export interface ICardResultReasonDto {
    accident_type_code?: string | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: LocalDateTime | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    reason_type_code?: string | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;
}

export class RoutingPointDto implements IRoutingPointDto {
    x1?: number | null;
    x2?: number | null;
    y1?: number | null;
    y2?: number | null;

    constructor(data?: IRoutingPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x1 = data["x1"] !== undefined ? data["x1"] : <any>null;
            this.x2 = data["x2"] !== undefined ? data["x2"] : <any>null;
            this.y1 = data["y1"] !== undefined ? data["y1"] : <any>null;
            this.y2 = data["y2"] !== undefined ? data["y2"] : <any>null;
        }
    }

    static fromJS(data: any): RoutingPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoutingPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x1"] = this.x1 !== undefined ? this.x1 : <any>null;
        data["x2"] = this.x2 !== undefined ? this.x2 : <any>null;
        data["y1"] = this.y1 !== undefined ? this.y1 : <any>null;
        data["y2"] = this.y2 !== undefined ? this.y2 : <any>null;
        return data; 
    }
}

export interface IRoutingPointDto {
    x1?: number | null;
    x2?: number | null;
    y1?: number | null;
    y2?: number | null;
}

export class Role implements IRole {
    active?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IRole {
    active?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CardDto implements ICardDto {
    result?: CardResultDto | null;
    side_one?: CardSideOneDto | null;
    side_two?: CardSideTwoDto | null;
    similars?: string[] | null;

    constructor(data?: ICardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"] ? CardResultDto.fromJS(data["result"]) : <any>null;
            this.side_one = data["side_one"] ? CardSideOneDto.fromJS(data["side_one"]) : <any>null;
            this.side_two = data["side_two"] ? CardSideTwoDto.fromJS(data["side_two"]) : <any>null;
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
        }
    }

    static fromJS(data: any): CardDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        data["side_one"] = this.side_one ? this.side_one.toJSON() : <any>null;
        data["side_two"] = this.side_two ? this.side_two.toJSON() : <any>null;
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        return data; 
    }
}

export interface ICardDto {
    result?: CardResultDto | null;
    side_one?: CardSideOneDto | null;
    side_two?: CardSideTwoDto | null;
    similars?: string[] | null;
}

export class TransferAddresseeDto implements ITransferAddresseeDto {
    reconended_brigade_id?: number | null;
    subdivision_id?: number | null;

    constructor(data?: ITransferAddresseeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reconended_brigade_id = data["reconended_brigade_id"] !== undefined ? data["reconended_brigade_id"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransferAddresseeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferAddresseeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reconended_brigade_id"] = this.reconended_brigade_id !== undefined ? this.reconended_brigade_id : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        return data; 
    }
}

export interface ITransferAddresseeDto {
    reconended_brigade_id?: number | null;
    subdivision_id?: number | null;
}

export class PharmacyDto implements IPharmacyDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    items?: GroupBagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IPharmacyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.document_id = data["document_id"] !== undefined ? data["document_id"] : <any>null;
            this.document_name = data["document_name"] !== undefined ? data["document_name"] : <any>null;
            this.drug_id = data["drug_id"] !== undefined ? data["drug_id"] : <any>null;
            this.expiry_date = data["expiry_date"] ? LocalDateTime.fromJS(data["expiry_date"]) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.inner_amount = data["inner_amount"] !== undefined ? data["inner_amount"] : <any>null;
            this.is_reusable = data["is_reusable"] !== undefined ? data["is_reusable"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GroupBagItemDto.fromJS(item));
            }
            this.matrix_code = data["matrix_code"] !== undefined ? data["matrix_code"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.matrix_name = data["matrix_name"] !== undefined ? data["matrix_name"] : <any>null;
            this.minimum = data["minimum"] !== undefined ? data["minimum"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["document_id"] = this.document_id !== undefined ? this.document_id : <any>null;
        data["document_name"] = this.document_name !== undefined ? this.document_name : <any>null;
        data["drug_id"] = this.drug_id !== undefined ? this.drug_id : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toJSON() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["inner_amount"] = this.inner_amount !== undefined ? this.inner_amount : <any>null;
        data["is_reusable"] = this.is_reusable !== undefined ? this.is_reusable : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["matrix_code"] = this.matrix_code !== undefined ? this.matrix_code : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["matrix_name"] = this.matrix_name !== undefined ? this.matrix_name : <any>null;
        data["minimum"] = this.minimum !== undefined ? this.minimum : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    items?: GroupBagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    series_number?: number | null;
    type?: number | null;
}

export class CallSimilarRequestDto implements ICallSimilarRequestDto {
    ao_full_name?: string | null;
    declarant_phone?: string | null;
    district_guid?: string | null;
    house?: string | null;
    patient?: CallPatientPartDto[] | null;

    constructor(data?: ICallSimilarRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ao_full_name = data["ao_full_name"] !== undefined ? data["ao_full_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.district_guid = data["district_guid"] !== undefined ? data["district_guid"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            if (data["patient"] && data["patient"].constructor === Array) {
                this.patient = [];
                for (let item of data["patient"])
                    this.patient.push(CallPatientPartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CallSimilarRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallSimilarRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ao_full_name"] = this.ao_full_name !== undefined ? this.ao_full_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["district_guid"] = this.district_guid !== undefined ? this.district_guid : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        if (this.patient && this.patient.constructor === Array) {
            data["patient"] = [];
            for (let item of this.patient)
                data["patient"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICallSimilarRequestDto {
    ao_full_name?: string | null;
    declarant_phone?: string | null;
    district_guid?: string | null;
    house?: string | null;
    patient?: CallPatientPartDto[] | null;
}

export class District implements IDistrict {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    fiasId?: number | null;
    geometry?: PGgeometry | null;
    id?: number | null;
    name?: string | null;
    osmGid?: number | null;
    osmId?: number | null;
    zone?: string | null;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.fiasId = data["fiasId"] !== undefined ? data["fiasId"] : <any>null;
            this.geometry = data["geometry"] ? PGgeometry.fromJS(data["geometry"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.osmGid = data["osmGid"] !== undefined ? data["osmGid"] : <any>null;
            this.osmId = data["osmId"] !== undefined ? data["osmId"] : <any>null;
            this.zone = data["zone"] !== undefined ? data["zone"] : <any>null;
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["fiasId"] = this.fiasId !== undefined ? this.fiasId : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["osmGid"] = this.osmGid !== undefined ? this.osmGid : <any>null;
        data["osmId"] = this.osmId !== undefined ? this.osmId : <any>null;
        data["zone"] = this.zone !== undefined ? this.zone : <any>null;
        return data; 
    }
}

export interface IDistrict {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    fiasId?: number | null;
    geometry?: PGgeometry | null;
    id?: number | null;
    name?: string | null;
    osmGid?: number | null;
    osmId?: number | null;
    zone?: string | null;
}

export class LocalDateTime implements ILocalDateTime {
    chronology?: Chronology | null;
    dayOfMonth?: number | null;
    dayOfWeek?: LocalDateTimeDayOfWeek | null;
    dayOfYear?: number | null;
    hour?: number | null;
    minute?: number | null;
    month?: LocalDateTimeMonth | null;
    monthValue?: number | null;
    nano?: number | null;
    second?: number | null;
    year?: number | null;

    constructor(data?: ILocalDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.chronology = data["chronology"] ? Chronology.fromJS(data["chronology"]) : <any>null;
            this.dayOfMonth = data["dayOfMonth"] !== undefined ? data["dayOfMonth"] : <any>null;
            this.dayOfWeek = data["dayOfWeek"] !== undefined ? data["dayOfWeek"] : <any>null;
            this.dayOfYear = data["dayOfYear"] !== undefined ? data["dayOfYear"] : <any>null;
            this.hour = data["hour"] !== undefined ? data["hour"] : <any>null;
            this.minute = data["minute"] !== undefined ? data["minute"] : <any>null;
            this.month = data["month"] !== undefined ? data["month"] : <any>null;
            this.monthValue = data["monthValue"] !== undefined ? data["monthValue"] : <any>null;
            this.nano = data["nano"] !== undefined ? data["nano"] : <any>null;
            this.second = data["second"] !== undefined ? data["second"] : <any>null;
            this.year = data["year"] !== undefined ? data["year"] : <any>null;
        }
    }

    static fromJS(data: any): LocalDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new LocalDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chronology"] = this.chronology ? this.chronology.toJSON() : <any>null;
        data["dayOfMonth"] = this.dayOfMonth !== undefined ? this.dayOfMonth : <any>null;
        data["dayOfWeek"] = this.dayOfWeek !== undefined ? this.dayOfWeek : <any>null;
        data["dayOfYear"] = this.dayOfYear !== undefined ? this.dayOfYear : <any>null;
        data["hour"] = this.hour !== undefined ? this.hour : <any>null;
        data["minute"] = this.minute !== undefined ? this.minute : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["monthValue"] = this.monthValue !== undefined ? this.monthValue : <any>null;
        data["nano"] = this.nano !== undefined ? this.nano : <any>null;
        data["second"] = this.second !== undefined ? this.second : <any>null;
        data["year"] = this.year !== undefined ? this.year : <any>null;
        return data; 
    }
}

export interface ILocalDateTime {
    chronology?: Chronology | null;
    dayOfMonth?: number | null;
    dayOfWeek?: LocalDateTimeDayOfWeek | null;
    dayOfYear?: number | null;
    hour?: number | null;
    minute?: number | null;
    month?: LocalDateTimeMonth | null;
    monthValue?: number | null;
    nano?: number | null;
    second?: number | null;
    year?: number | null;
}

export class BagMatrixItemDto implements IBagMatrixItemDto {
    amount?: number | null;
    bag_id?: number | null;
    code?: string | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    nomenclature_id?: number | null;

    constructor(data?: IBagMatrixItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BagItemDto.fromJS(item));
            }
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
        }
    }

    static fromJS(data: any): BagMatrixItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BagMatrixItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        return data; 
    }
}

export interface IBagMatrixItemDto {
    amount?: number | null;
    bag_id?: number | null;
    code?: string | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    nomenclature_id?: number | null;
}

export class PerformerBrigScheduleDto implements IPerformerBrigScheduleDto {
    id?: number | null;
    is_major?: boolean | null;
    performer_first_name?: string | null;
    performer_id?: number | null;
    performer_patronymic?: string | null;
    performer_second_name?: string | null;
    performer_type_id?: number | null;
    performer_type_name?: string | null;
    period_details?: PeriodDetails | null;
    short_name?: string | null;

    constructor(data?: IPerformerBrigScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_major = data["is_major"] !== undefined ? data["is_major"] : <any>null;
            this.performer_first_name = data["performer_first_name"] !== undefined ? data["performer_first_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_patronymic = data["performer_patronymic"] !== undefined ? data["performer_patronymic"] : <any>null;
            this.performer_second_name = data["performer_second_name"] !== undefined ? data["performer_second_name"] : <any>null;
            this.performer_type_id = data["performer_type_id"] !== undefined ? data["performer_type_id"] : <any>null;
            this.performer_type_name = data["performer_type_name"] !== undefined ? data["performer_type_name"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_major"] = this.is_major !== undefined ? this.is_major : <any>null;
        data["performer_first_name"] = this.performer_first_name !== undefined ? this.performer_first_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_patronymic"] = this.performer_patronymic !== undefined ? this.performer_patronymic : <any>null;
        data["performer_second_name"] = this.performer_second_name !== undefined ? this.performer_second_name : <any>null;
        data["performer_type_id"] = this.performer_type_id !== undefined ? this.performer_type_id : <any>null;
        data["performer_type_name"] = this.performer_type_name !== undefined ? this.performer_type_name : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleDto {
    id?: number | null;
    is_major?: boolean | null;
    performer_first_name?: string | null;
    performer_id?: number | null;
    performer_patronymic?: string | null;
    performer_second_name?: string | null;
    performer_type_id?: number | null;
    performer_type_name?: string | null;
    period_details?: PeriodDetails | null;
    short_name?: string | null;
}

export class Field implements IField {
    text?: string | null;
    type?: number | null;
    value?: string | null;

    constructor(data?: IField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Field {
        data = typeof data === 'object' ? data : {};
        let result = new Field();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IField {
    text?: string | null;
    type?: number | null;
    value?: string | null;
}

export class CardObjectiveThroatPartDto implements ICardObjectiveThroatPartDto {
    multiple_zeva_clean_hyper?: number | null;
    multiple_zeva_clean_hyper_name?: string | null;

    constructor(data?: ICardObjectiveThroatPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.multiple_zeva_clean_hyper = data["multiple_zeva_clean_hyper"] !== undefined ? data["multiple_zeva_clean_hyper"] : <any>null;
            this.multiple_zeva_clean_hyper_name = data["multiple_zeva_clean_hyper_name"] !== undefined ? data["multiple_zeva_clean_hyper_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveThroatPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveThroatPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiple_zeva_clean_hyper"] = this.multiple_zeva_clean_hyper !== undefined ? this.multiple_zeva_clean_hyper : <any>null;
        data["multiple_zeva_clean_hyper_name"] = this.multiple_zeva_clean_hyper_name !== undefined ? this.multiple_zeva_clean_hyper_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveThroatPartDto {
    multiple_zeva_clean_hyper?: number | null;
    multiple_zeva_clean_hyper_name?: string | null;
}

export class SubdivisionFlatDto implements ISubdivisionFlatDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    email?: string | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;
    zone_exist?: boolean | null;

    constructor(data?: ISubdivisionFlatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? FiasAddressDto.fromJS(data["address"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
            if (data["zone"] && data["zone"].constructor === Array) {
                this.zone = [];
                for (let item of data["zone"])
                    this.zone.push(item);
            }
            this.zone_exist = data["zone_exist"] !== undefined ? data["zone_exist"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionFlatDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionFlatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        if (this.zone && this.zone.constructor === Array) {
            data["zone"] = [];
            for (let item of this.zone)
                data["zone"].push(item);
        }
        data["zone_exist"] = this.zone_exist !== undefined ? this.zone_exist : <any>null;
        return data; 
    }
}

export interface ISubdivisionFlatDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    email?: string | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;
    zone_exist?: boolean | null;
}

export class MonPoint implements IMonPoint {
    date?: string | null;
    externalId?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    row?: number | null;
    stateMark?: string | null;

    constructor(data?: IMonPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.externalId = data["externalId"] !== undefined ? data["externalId"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.row = data["row"] !== undefined ? data["row"] : <any>null;
            this.stateMark = data["stateMark"] !== undefined ? data["stateMark"] : <any>null;
        }
    }

    static fromJS(data: any): MonPoint {
        data = typeof data === 'object' ? data : {};
        let result = new MonPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["row"] = this.row !== undefined ? this.row : <any>null;
        data["stateMark"] = this.stateMark !== undefined ? this.stateMark : <any>null;
        return data; 
    }
}

export interface IMonPoint {
    date?: string | null;
    externalId?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    row?: number | null;
    stateMark?: string | null;
}

export class NotificationObject implements INotificationObject {
    current_time?: LocalDateTime | null;
    incomings?: number | null;

    constructor(data?: INotificationObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.current_time = data["current_time"] ? LocalDateTime.fromJS(data["current_time"]) : <any>null;
            this.incomings = data["incomings"] !== undefined ? data["incomings"] : <any>null;
        }
    }

    static fromJS(data: any): NotificationObject {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current_time"] = this.current_time ? this.current_time.toJSON() : <any>null;
        data["incomings"] = this.incomings !== undefined ? this.incomings : <any>null;
        return data; 
    }
}

export interface INotificationObject {
    current_time?: LocalDateTime | null;
    incomings?: number | null;
}

export class CardAnamnesisPartDtoFLAT implements ICardAnamnesisPartDtoFLAT {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_text?: string | null;
    complaints_anamnesis?: string | null;
    gynecologic_anamnesis?: string | null;
    illnes_anamnesis?: string | null;
    infect_contacts?: string | null;
    is_created?: boolean | null;
    past_illneses?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;

    constructor(data?: ICardAnamnesisPartDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic_anamnesis = data["allergic_anamnesis"] !== undefined ? data["allergic_anamnesis"] : <any>null;
            this.allergic_anamnesis_text = data["allergic_anamnesis_text"] !== undefined ? data["allergic_anamnesis_text"] : <any>null;
            this.complaints_anamnesis = data["complaints_anamnesis"] !== undefined ? data["complaints_anamnesis"] : <any>null;
            this.gynecologic_anamnesis = data["gynecologic_anamnesis"] !== undefined ? data["gynecologic_anamnesis"] : <any>null;
            this.illnes_anamnesis = data["illnes_anamnesis"] !== undefined ? data["illnes_anamnesis"] : <any>null;
            this.infect_contacts = data["infect_contacts"] !== undefined ? data["infect_contacts"] : <any>null;
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
            this.past_illneses = data["past_illneses"] !== undefined ? data["past_illneses"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisPartDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisPartDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic_anamnesis"] = this.allergic_anamnesis !== undefined ? this.allergic_anamnesis : <any>null;
        data["allergic_anamnesis_text"] = this.allergic_anamnesis_text !== undefined ? this.allergic_anamnesis_text : <any>null;
        data["complaints_anamnesis"] = this.complaints_anamnesis !== undefined ? this.complaints_anamnesis : <any>null;
        data["gynecologic_anamnesis"] = this.gynecologic_anamnesis !== undefined ? this.gynecologic_anamnesis : <any>null;
        data["illnes_anamnesis"] = this.illnes_anamnesis !== undefined ? this.illnes_anamnesis : <any>null;
        data["infect_contacts"] = this.infect_contacts !== undefined ? this.infect_contacts : <any>null;
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        data["past_illneses"] = this.past_illneses !== undefined ? this.past_illneses : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisPartDtoFLAT {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_text?: string | null;
    complaints_anamnesis?: string | null;
    gynecologic_anamnesis?: string | null;
    illnes_anamnesis?: string | null;
    infect_contacts?: string | null;
    is_created?: boolean | null;
    past_illneses?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;
}

export class ChatUser implements IChatUser {
    active?: boolean | null;
    author?: boolean | null;
    chatMessages?: ChatMessage[] | null;
    id?: number | null;
    performer?: Performer | null;
    unreadCount?: number | null;

    constructor(data?: IChatUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.author = data["author"] !== undefined ? data["author"] : <any>null;
            if (data["chatMessages"] && data["chatMessages"].constructor === Array) {
                this.chatMessages = [];
                for (let item of data["chatMessages"])
                    this.chatMessages.push(ChatMessage.fromJS(item));
            }
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.performer = data["performer"] ? Performer.fromJS(data["performer"]) : <any>null;
            this.unreadCount = data["unreadCount"] !== undefined ? data["unreadCount"] : <any>null;
        }
    }

    static fromJS(data: any): ChatUser {
        data = typeof data === 'object' ? data : {};
        let result = new ChatUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        if (this.chatMessages && this.chatMessages.constructor === Array) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>null;
        data["unreadCount"] = this.unreadCount !== undefined ? this.unreadCount : <any>null;
        return data; 
    }
}

export interface IChatUser {
    active?: boolean | null;
    author?: boolean | null;
    chatMessages?: ChatMessage[] | null;
    id?: number | null;
    performer?: Performer | null;
    unreadCount?: number | null;
}

export class SubdivisionTypeDto implements ISubdivisionTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ISubdivisionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ISubdivisionTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class Report implements IReport {
    code?: string | null;
    deleted?: boolean | null;
    file_name?: string | null;
    format?: ReportFormat | null;
    group_code?: string | null;
    group_name?: string | null;
    id?: number | null;
    lastUpdate?: LocalDateTime | null;
    name?: string | null;
    nn?: number | null;
    performer?: string | null;
    script?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    template?: string[] | null;
    type?: ReportType | null;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.file_name = data["file_name"] !== undefined ? data["file_name"] : <any>null;
            this.format = data["format"] !== undefined ? data["format"] : <any>null;
            this.group_code = data["group_code"] !== undefined ? data["group_code"] : <any>null;
            this.group_name = data["group_name"] !== undefined ? data["group_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.lastUpdate = data["lastUpdate"] ? LocalDateTime.fromJS(data["lastUpdate"]) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nn = data["nn"] !== undefined ? data["nn"] : <any>null;
            this.performer = data["performer"] !== undefined ? data["performer"] : <any>null;
            this.script = data["script"] !== undefined ? data["script"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
            if (data["template"] && data["template"].constructor === Array) {
                this.template = [];
                for (let item of data["template"])
                    this.template.push(item);
            }
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["file_name"] = this.file_name !== undefined ? this.file_name : <any>null;
        data["format"] = this.format !== undefined ? this.format : <any>null;
        data["group_code"] = this.group_code !== undefined ? this.group_code : <any>null;
        data["group_name"] = this.group_name !== undefined ? this.group_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nn"] = this.nn !== undefined ? this.nn : <any>null;
        data["performer"] = this.performer !== undefined ? this.performer : <any>null;
        data["script"] = this.script !== undefined ? this.script : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        if (this.template && this.template.constructor === Array) {
            data["template"] = [];
            for (let item of this.template)
                data["template"].push(item);
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReport {
    code?: string | null;
    deleted?: boolean | null;
    file_name?: string | null;
    format?: ReportFormat | null;
    group_code?: string | null;
    group_name?: string | null;
    id?: number | null;
    lastUpdate?: LocalDateTime | null;
    name?: string | null;
    nn?: number | null;
    performer?: string | null;
    script?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    template?: string[] | null;
    type?: ReportType | null;
}

export class PharmacyNomenclatureDto implements IPharmacyNomenclatureDto {
    amount?: number | null;
    company?: string | null;
    drug_id?: number | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IPharmacyNomenclatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.drug_id = data["drug_id"] !== undefined ? data["drug_id"] : <any>null;
            this.expiry_date = data["expiry_date"] ? LocalDateTime.fromJS(data["expiry_date"]) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyNomenclatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyNomenclatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["drug_id"] = this.drug_id !== undefined ? this.drug_id : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toJSON() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyNomenclatureDto {
    amount?: number | null;
    company?: string | null;
    drug_id?: number | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    series_number?: number | null;
    type?: number | null;
}

export class ListDtoOfPermission implements IListDtoOfPermission {
    list?: Permission[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(Permission.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfPermission {
    list?: Permission[] | null;
    size?: number | null;
    total?: number | null;
}

export class CardSubdivisionHeadDoctorPartDto implements ICardSubdivisionHeadDoctorPartDto {
    subdivision_head_doctor_checked?: boolean | null;
    subdivision_head_doctor_comment?: string | null;
    subdivision_head_doctor_date?: LocalDateTime | null;
    subdivision_head_doctor_id?: number | null;
    subdivision_head_doctor_name?: string | null;

    constructor(data?: ICardSubdivisionHeadDoctorPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subdivision_head_doctor_checked = data["subdivision_head_doctor_checked"] !== undefined ? data["subdivision_head_doctor_checked"] : <any>null;
            this.subdivision_head_doctor_comment = data["subdivision_head_doctor_comment"] !== undefined ? data["subdivision_head_doctor_comment"] : <any>null;
            this.subdivision_head_doctor_date = data["subdivision_head_doctor_date"] ? LocalDateTime.fromJS(data["subdivision_head_doctor_date"]) : <any>null;
            this.subdivision_head_doctor_id = data["subdivision_head_doctor_id"] !== undefined ? data["subdivision_head_doctor_id"] : <any>null;
            this.subdivision_head_doctor_name = data["subdivision_head_doctor_name"] !== undefined ? data["subdivision_head_doctor_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardSubdivisionHeadDoctorPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardSubdivisionHeadDoctorPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subdivision_head_doctor_checked"] = this.subdivision_head_doctor_checked !== undefined ? this.subdivision_head_doctor_checked : <any>null;
        data["subdivision_head_doctor_comment"] = this.subdivision_head_doctor_comment !== undefined ? this.subdivision_head_doctor_comment : <any>null;
        data["subdivision_head_doctor_date"] = this.subdivision_head_doctor_date ? this.subdivision_head_doctor_date.toJSON() : <any>null;
        data["subdivision_head_doctor_id"] = this.subdivision_head_doctor_id !== undefined ? this.subdivision_head_doctor_id : <any>null;
        data["subdivision_head_doctor_name"] = this.subdivision_head_doctor_name !== undefined ? this.subdivision_head_doctor_name : <any>null;
        return data; 
    }
}

export interface ICardSubdivisionHeadDoctorPartDto {
    subdivision_head_doctor_checked?: boolean | null;
    subdivision_head_doctor_comment?: string | null;
    subdivision_head_doctor_date?: LocalDateTime | null;
    subdivision_head_doctor_id?: number | null;
    subdivision_head_doctor_name?: string | null;
}

export class View implements IView {
    contentType?: string | null;

    constructor(data?: IView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["contentType"] !== undefined ? data["contentType"] : <any>null;
        }
    }

    static fromJS(data: any): View {
        data = typeof data === 'object' ? data : {};
        let result = new View();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        return data; 
    }
}

export interface IView {
    contentType?: string | null;
}

export class ReportGroup implements IReportGroup {
    children?: ReportGroup[] | null;
    code?: string | null;
    id?: string | null;
    leaf?: boolean | null;
    name?: string | null;

    constructor(data?: IReportGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(ReportGroup.fromJS(item));
            }
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ReportGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ReportGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IReportGroup {
    children?: ReportGroup[] | null;
    code?: string | null;
    id?: string | null;
    leaf?: boolean | null;
    name?: string | null;
}

export class BagDto implements IBagDto {
    date?: LocalDateTime | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    owner_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IBagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BagItemDto.fromJS(item));
            }
            this.matrix_code = data["matrix_code"] !== undefined ? data["matrix_code"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.matrix_name = data["matrix_name"] !== undefined ? data["matrix_name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): BagDto {
        data = typeof data === 'object' ? data : {};
        let result = new BagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["matrix_code"] = this.matrix_code !== undefined ? this.matrix_code : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["matrix_name"] = this.matrix_name !== undefined ? this.matrix_name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IBagDto {
    date?: LocalDateTime | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    owner_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    series_number?: number | null;
    type?: number | null;
}

export class Skill implements ISkill {
    code?: string | null;
    commonName?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.commonName = data["commonName"] !== undefined ? data["commonName"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["commonName"] = this.commonName !== undefined ? this.commonName : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ISkill {
    code?: string | null;
    commonName?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CardResultHeaderDto implements ICardResultHeaderDto {
    is_created?: boolean | null;

    constructor(data?: ICardResultHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        return data; 
    }
}

export interface ICardResultHeaderDto {
    is_created?: boolean | null;
}

export class CardObjectiveSkinPartDto implements ICardObjectiveSkinPartDto {
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;

    constructor(data?: ICardObjectiveSkinPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skin_integ_acrosian = data["skin_integ_acrosian"] !== undefined ? data["skin_integ_acrosian"] : <any>null;
            this.skin_integ_cyanotic = data["skin_integ_cyanotic"] !== undefined ? data["skin_integ_cyanotic"] : <any>null;
            this.skin_integ_dry = data["skin_integ_dry"] !== undefined ? data["skin_integ_dry"] : <any>null;
            this.skin_integ_earthy = data["skin_integ_earthy"] !== undefined ? data["skin_integ_earthy"] : <any>null;
            this.skin_integ_hyperemetic = data["skin_integ_hyperemetic"] !== undefined ? data["skin_integ_hyperemetic"] : <any>null;
            this.skin_integ_icteric = data["skin_integ_icteric"] !== undefined ? data["skin_integ_icteric"] : <any>null;
            this.skin_integ_marbleness = data["skin_integ_marbleness"] !== undefined ? data["skin_integ_marbleness"] : <any>null;
            this.skin_integ_normal = data["skin_integ_normal"] !== undefined ? data["skin_integ_normal"] : <any>null;
            this.skin_integ_pale = data["skin_integ_pale"] !== undefined ? data["skin_integ_pale"] : <any>null;
            this.skin_integ_profuse = data["skin_integ_profuse"] !== undefined ? data["skin_integ_profuse"] : <any>null;
            this.skin_integ_rashes = data["skin_integ_rashes"] !== undefined ? data["skin_integ_rashes"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveSkinPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveSkinPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skin_integ_acrosian"] = this.skin_integ_acrosian !== undefined ? this.skin_integ_acrosian : <any>null;
        data["skin_integ_cyanotic"] = this.skin_integ_cyanotic !== undefined ? this.skin_integ_cyanotic : <any>null;
        data["skin_integ_dry"] = this.skin_integ_dry !== undefined ? this.skin_integ_dry : <any>null;
        data["skin_integ_earthy"] = this.skin_integ_earthy !== undefined ? this.skin_integ_earthy : <any>null;
        data["skin_integ_hyperemetic"] = this.skin_integ_hyperemetic !== undefined ? this.skin_integ_hyperemetic : <any>null;
        data["skin_integ_icteric"] = this.skin_integ_icteric !== undefined ? this.skin_integ_icteric : <any>null;
        data["skin_integ_marbleness"] = this.skin_integ_marbleness !== undefined ? this.skin_integ_marbleness : <any>null;
        data["skin_integ_normal"] = this.skin_integ_normal !== undefined ? this.skin_integ_normal : <any>null;
        data["skin_integ_pale"] = this.skin_integ_pale !== undefined ? this.skin_integ_pale : <any>null;
        data["skin_integ_profuse"] = this.skin_integ_profuse !== undefined ? this.skin_integ_profuse : <any>null;
        data["skin_integ_rashes"] = this.skin_integ_rashes !== undefined ? this.skin_integ_rashes : <any>null;
        return data; 
    }
}

export interface ICardObjectiveSkinPartDto {
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;
}

export class TherapyDto implements ITherapyDto {
    date?: LocalDateTime | null;
    id?: number | null;
    is_local?: boolean | null;
    items?: TherapyItemDto[] | null;
    result_id?: number | null;
    template_id?: number | null;
    text?: string | null;

    constructor(data?: ITherapyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_local = data["is_local"] !== undefined ? data["is_local"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TherapyItemDto.fromJS(item));
            }
            this.result_id = data["result_id"] !== undefined ? data["result_id"] : <any>null;
            this.template_id = data["template_id"] !== undefined ? data["template_id"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_local"] = this.is_local !== undefined ? this.is_local : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["result_id"] = this.result_id !== undefined ? this.result_id : <any>null;
        data["template_id"] = this.template_id !== undefined ? this.template_id : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyDto {
    date?: LocalDateTime | null;
    id?: number | null;
    is_local?: boolean | null;
    items?: TherapyItemDto[] | null;
    result_id?: number | null;
    template_id?: number | null;
    text?: string | null;
}

export class CardResultDtoFLAT implements ICardResultDtoFLAT {
    accident_type?: number | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    active_visit_date?: LocalDateTime | null;
    active_visit_hours?: number | null;
    active_visit_type?: number | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;
    assistance_result_id?: number | null;
    bandages?: number | null;
    catheters?: number | null;
    comments?: string | null;
    complication_id?: number | null;
    concomitant_diagnosis?: MkbDto | null;
    death_condition?: number | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: LocalDateTime | null;
    ekg_ch_s_s?: number | null;
    ekg_ch_s_s_after?: number | null;
    ekg_comments?: string | null;
    ekg_comments_after?: string | null;
    ekg_rhythm?: string | null;
    ekg_rhythm_after?: string | null;
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_reason?: number | null;
    hosp_reason_name?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation?: number | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;
    intoxication_type?: number | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    is_created?: boolean | null;
    local_CHD?: string | null;
    local_CHSS?: string | null;
    local_ad?: string | null;
    local_glucometry?: string | null;
    local_pulse?: string | null;
    local_pulse_oximetry?: string | null;
    local_temperature?: string | null;
    local_therapies?: TherapyDto[] | null;
    local_therapy?: string | null;
    local_work_ad?: string | null;
    main_diagnosis?: MkbDto | null;
    other_materials?: string | null;
    reason_type?: number | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;
    syringes?: number | null;
    transfer_patient_brigade?: string | null;
    transfer_patient_time?: LocalDateTime | null;
    transfusion_systems?: number | null;
    transport_CHD?: string | null;
    transport_CHSS?: string | null;
    transport_ad?: string | null;
    transport_glucometry?: string | null;
    transport_pulse?: string | null;
    transport_pulse_oximetry?: string | null;
    transport_temperature?: string | null;
    transport_therapies?: TherapyDto[] | null;
    transport_therapy?: string | null;
    transport_work_ad?: string | null;
    transporting_date?: LocalDateTime | null;
    transporting_type?: number | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;
    type?: number | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ICardResultDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accident_type = data["accident_type"] !== undefined ? data["accident_type"] : <any>null;
            this.accident_type_id = data["accident_type_id"] !== undefined ? data["accident_type_id"] : <any>null;
            this.accident_type_name = data["accident_type_name"] !== undefined ? data["accident_type_name"] : <any>null;
            this.active_visit_date = data["active_visit_date"] ? LocalDateTime.fromJS(data["active_visit_date"]) : <any>null;
            this.active_visit_hours = data["active_visit_hours"] !== undefined ? data["active_visit_hours"] : <any>null;
            this.active_visit_type = data["active_visit_type"] !== undefined ? data["active_visit_type"] : <any>null;
            this.active_visit_type_id = data["active_visit_type_id"] !== undefined ? data["active_visit_type_id"] : <any>null;
            this.active_visit_type_name = data["active_visit_type_name"] !== undefined ? data["active_visit_type_name"] : <any>null;
            this.assistance_result_id = data["assistance_result_id"] !== undefined ? data["assistance_result_id"] : <any>null;
            this.bandages = data["bandages"] !== undefined ? data["bandages"] : <any>null;
            this.catheters = data["catheters"] !== undefined ? data["catheters"] : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.complication_id = data["complication_id"] !== undefined ? data["complication_id"] : <any>null;
            this.concomitant_diagnosis = data["concomitant_diagnosis"] ? MkbDto.fromJS(data["concomitant_diagnosis"]) : <any>null;
            this.death_condition = data["death_condition"] !== undefined ? data["death_condition"] : <any>null;
            this.death_condition_id = data["death_condition_id"] !== undefined ? data["death_condition_id"] : <any>null;
            this.death_condition_name = data["death_condition_name"] !== undefined ? data["death_condition_name"] : <any>null;
            this.death_time = data["death_time"] ? LocalDateTime.fromJS(data["death_time"]) : <any>null;
            this.ekg_ch_s_s = data["ekg_ch_s_s"] !== undefined ? data["ekg_ch_s_s"] : <any>null;
            this.ekg_ch_s_s_after = data["ekg_ch_s_s_after"] !== undefined ? data["ekg_ch_s_s_after"] : <any>null;
            this.ekg_comments = data["ekg_comments"] !== undefined ? data["ekg_comments"] : <any>null;
            this.ekg_comments_after = data["ekg_comments_after"] !== undefined ? data["ekg_comments_after"] : <any>null;
            this.ekg_rhythm = data["ekg_rhythm"] !== undefined ? data["ekg_rhythm"] : <any>null;
            this.ekg_rhythm_after = data["ekg_rhythm_after"] !== undefined ? data["ekg_rhythm_after"] : <any>null;
            this.hosp_complications = data["hosp_complications"] !== undefined ? data["hosp_complications"] : <any>null;
            this.hosp_complications_text = data["hosp_complications_text"] !== undefined ? data["hosp_complications_text"] : <any>null;
            this.hosp_reason = data["hosp_reason"] !== undefined ? data["hosp_reason"] : <any>null;
            this.hosp_reason_name = data["hosp_reason_name"] !== undefined ? data["hosp_reason_name"] : <any>null;
            this.hosp_to_id = data["hosp_to_id"] !== undefined ? data["hosp_to_id"] : <any>null;
            this.hosp_to_name = data["hosp_to_name"] !== undefined ? data["hosp_to_name"] : <any>null;
            this.hosp_transportation = data["hosp_transportation"] !== undefined ? data["hosp_transportation"] : <any>null;
            this.hosp_transportation_id = data["hosp_transportation_id"] !== undefined ? data["hosp_transportation_id"] : <any>null;
            this.hosp_transportation_name = data["hosp_transportation_name"] !== undefined ? data["hosp_transportation_name"] : <any>null;
            this.illegal_actions = data["illegal_actions"] !== undefined ? data["illegal_actions"] : <any>null;
            this.illegal_actions_text = data["illegal_actions_text"] !== undefined ? data["illegal_actions_text"] : <any>null;
            this.intoxication_type = data["intoxication_type"] !== undefined ? data["intoxication_type"] : <any>null;
            this.intoxication_type_id = data["intoxication_type_id"] !== undefined ? data["intoxication_type_id"] : <any>null;
            this.intoxication_type_name = data["intoxication_type_name"] !== undefined ? data["intoxication_type_name"] : <any>null;
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
            this.local_CHD = data["local_CHD"] !== undefined ? data["local_CHD"] : <any>null;
            this.local_CHSS = data["local_CHSS"] !== undefined ? data["local_CHSS"] : <any>null;
            this.local_ad = data["local_ad"] !== undefined ? data["local_ad"] : <any>null;
            this.local_glucometry = data["local_glucometry"] !== undefined ? data["local_glucometry"] : <any>null;
            this.local_pulse = data["local_pulse"] !== undefined ? data["local_pulse"] : <any>null;
            this.local_pulse_oximetry = data["local_pulse_oximetry"] !== undefined ? data["local_pulse_oximetry"] : <any>null;
            this.local_temperature = data["local_temperature"] !== undefined ? data["local_temperature"] : <any>null;
            if (data["local_therapies"] && data["local_therapies"].constructor === Array) {
                this.local_therapies = [];
                for (let item of data["local_therapies"])
                    this.local_therapies.push(TherapyDto.fromJS(item));
            }
            this.local_therapy = data["local_therapy"] !== undefined ? data["local_therapy"] : <any>null;
            this.local_work_ad = data["local_work_ad"] !== undefined ? data["local_work_ad"] : <any>null;
            this.main_diagnosis = data["main_diagnosis"] ? MkbDto.fromJS(data["main_diagnosis"]) : <any>null;
            this.other_materials = data["other_materials"] !== undefined ? data["other_materials"] : <any>null;
            this.reason_type = data["reason_type"] !== undefined ? data["reason_type"] : <any>null;
            this.reason_type_id = data["reason_type_id"] !== undefined ? data["reason_type_id"] : <any>null;
            this.reason_type_name = data["reason_type_name"] !== undefined ? data["reason_type_name"] : <any>null;
            this.syringes = data["syringes"] !== undefined ? data["syringes"] : <any>null;
            this.transfer_patient_brigade = data["transfer_patient_brigade"] !== undefined ? data["transfer_patient_brigade"] : <any>null;
            this.transfer_patient_time = data["transfer_patient_time"] ? LocalDateTime.fromJS(data["transfer_patient_time"]) : <any>null;
            this.transfusion_systems = data["transfusion_systems"] !== undefined ? data["transfusion_systems"] : <any>null;
            this.transport_CHD = data["transport_CHD"] !== undefined ? data["transport_CHD"] : <any>null;
            this.transport_CHSS = data["transport_CHSS"] !== undefined ? data["transport_CHSS"] : <any>null;
            this.transport_ad = data["transport_ad"] !== undefined ? data["transport_ad"] : <any>null;
            this.transport_glucometry = data["transport_glucometry"] !== undefined ? data["transport_glucometry"] : <any>null;
            this.transport_pulse = data["transport_pulse"] !== undefined ? data["transport_pulse"] : <any>null;
            this.transport_pulse_oximetry = data["transport_pulse_oximetry"] !== undefined ? data["transport_pulse_oximetry"] : <any>null;
            this.transport_temperature = data["transport_temperature"] !== undefined ? data["transport_temperature"] : <any>null;
            if (data["transport_therapies"] && data["transport_therapies"].constructor === Array) {
                this.transport_therapies = [];
                for (let item of data["transport_therapies"])
                    this.transport_therapies.push(TherapyDto.fromJS(item));
            }
            this.transport_therapy = data["transport_therapy"] !== undefined ? data["transport_therapy"] : <any>null;
            this.transport_work_ad = data["transport_work_ad"] !== undefined ? data["transport_work_ad"] : <any>null;
            this.transporting_date = data["transporting_date"] ? LocalDateTime.fromJS(data["transporting_date"]) : <any>null;
            this.transporting_type = data["transporting_type"] !== undefined ? data["transporting_type"] : <any>null;
            this.transporting_type_id = data["transporting_type_id"] !== undefined ? data["transporting_type_id"] : <any>null;
            this.transporting_type_name = data["transporting_type_name"] !== undefined ? data["transporting_type_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_comment = data["type_comment"] !== undefined ? data["type_comment"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accident_type"] = this.accident_type !== undefined ? this.accident_type : <any>null;
        data["accident_type_id"] = this.accident_type_id !== undefined ? this.accident_type_id : <any>null;
        data["accident_type_name"] = this.accident_type_name !== undefined ? this.accident_type_name : <any>null;
        data["active_visit_date"] = this.active_visit_date ? this.active_visit_date.toJSON() : <any>null;
        data["active_visit_hours"] = this.active_visit_hours !== undefined ? this.active_visit_hours : <any>null;
        data["active_visit_type"] = this.active_visit_type !== undefined ? this.active_visit_type : <any>null;
        data["active_visit_type_id"] = this.active_visit_type_id !== undefined ? this.active_visit_type_id : <any>null;
        data["active_visit_type_name"] = this.active_visit_type_name !== undefined ? this.active_visit_type_name : <any>null;
        data["assistance_result_id"] = this.assistance_result_id !== undefined ? this.assistance_result_id : <any>null;
        data["bandages"] = this.bandages !== undefined ? this.bandages : <any>null;
        data["catheters"] = this.catheters !== undefined ? this.catheters : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["complication_id"] = this.complication_id !== undefined ? this.complication_id : <any>null;
        data["concomitant_diagnosis"] = this.concomitant_diagnosis ? this.concomitant_diagnosis.toJSON() : <any>null;
        data["death_condition"] = this.death_condition !== undefined ? this.death_condition : <any>null;
        data["death_condition_id"] = this.death_condition_id !== undefined ? this.death_condition_id : <any>null;
        data["death_condition_name"] = this.death_condition_name !== undefined ? this.death_condition_name : <any>null;
        data["death_time"] = this.death_time ? this.death_time.toJSON() : <any>null;
        data["ekg_ch_s_s"] = this.ekg_ch_s_s !== undefined ? this.ekg_ch_s_s : <any>null;
        data["ekg_ch_s_s_after"] = this.ekg_ch_s_s_after !== undefined ? this.ekg_ch_s_s_after : <any>null;
        data["ekg_comments"] = this.ekg_comments !== undefined ? this.ekg_comments : <any>null;
        data["ekg_comments_after"] = this.ekg_comments_after !== undefined ? this.ekg_comments_after : <any>null;
        data["ekg_rhythm"] = this.ekg_rhythm !== undefined ? this.ekg_rhythm : <any>null;
        data["ekg_rhythm_after"] = this.ekg_rhythm_after !== undefined ? this.ekg_rhythm_after : <any>null;
        data["hosp_complications"] = this.hosp_complications !== undefined ? this.hosp_complications : <any>null;
        data["hosp_complications_text"] = this.hosp_complications_text !== undefined ? this.hosp_complications_text : <any>null;
        data["hosp_reason"] = this.hosp_reason !== undefined ? this.hosp_reason : <any>null;
        data["hosp_reason_name"] = this.hosp_reason_name !== undefined ? this.hosp_reason_name : <any>null;
        data["hosp_to_id"] = this.hosp_to_id !== undefined ? this.hosp_to_id : <any>null;
        data["hosp_to_name"] = this.hosp_to_name !== undefined ? this.hosp_to_name : <any>null;
        data["hosp_transportation"] = this.hosp_transportation !== undefined ? this.hosp_transportation : <any>null;
        data["hosp_transportation_id"] = this.hosp_transportation_id !== undefined ? this.hosp_transportation_id : <any>null;
        data["hosp_transportation_name"] = this.hosp_transportation_name !== undefined ? this.hosp_transportation_name : <any>null;
        data["illegal_actions"] = this.illegal_actions !== undefined ? this.illegal_actions : <any>null;
        data["illegal_actions_text"] = this.illegal_actions_text !== undefined ? this.illegal_actions_text : <any>null;
        data["intoxication_type"] = this.intoxication_type !== undefined ? this.intoxication_type : <any>null;
        data["intoxication_type_id"] = this.intoxication_type_id !== undefined ? this.intoxication_type_id : <any>null;
        data["intoxication_type_name"] = this.intoxication_type_name !== undefined ? this.intoxication_type_name : <any>null;
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        data["local_CHD"] = this.local_CHD !== undefined ? this.local_CHD : <any>null;
        data["local_CHSS"] = this.local_CHSS !== undefined ? this.local_CHSS : <any>null;
        data["local_ad"] = this.local_ad !== undefined ? this.local_ad : <any>null;
        data["local_glucometry"] = this.local_glucometry !== undefined ? this.local_glucometry : <any>null;
        data["local_pulse"] = this.local_pulse !== undefined ? this.local_pulse : <any>null;
        data["local_pulse_oximetry"] = this.local_pulse_oximetry !== undefined ? this.local_pulse_oximetry : <any>null;
        data["local_temperature"] = this.local_temperature !== undefined ? this.local_temperature : <any>null;
        if (this.local_therapies && this.local_therapies.constructor === Array) {
            data["local_therapies"] = [];
            for (let item of this.local_therapies)
                data["local_therapies"].push(item.toJSON());
        }
        data["local_therapy"] = this.local_therapy !== undefined ? this.local_therapy : <any>null;
        data["local_work_ad"] = this.local_work_ad !== undefined ? this.local_work_ad : <any>null;
        data["main_diagnosis"] = this.main_diagnosis ? this.main_diagnosis.toJSON() : <any>null;
        data["other_materials"] = this.other_materials !== undefined ? this.other_materials : <any>null;
        data["reason_type"] = this.reason_type !== undefined ? this.reason_type : <any>null;
        data["reason_type_id"] = this.reason_type_id !== undefined ? this.reason_type_id : <any>null;
        data["reason_type_name"] = this.reason_type_name !== undefined ? this.reason_type_name : <any>null;
        data["syringes"] = this.syringes !== undefined ? this.syringes : <any>null;
        data["transfer_patient_brigade"] = this.transfer_patient_brigade !== undefined ? this.transfer_patient_brigade : <any>null;
        data["transfer_patient_time"] = this.transfer_patient_time ? this.transfer_patient_time.toJSON() : <any>null;
        data["transfusion_systems"] = this.transfusion_systems !== undefined ? this.transfusion_systems : <any>null;
        data["transport_CHD"] = this.transport_CHD !== undefined ? this.transport_CHD : <any>null;
        data["transport_CHSS"] = this.transport_CHSS !== undefined ? this.transport_CHSS : <any>null;
        data["transport_ad"] = this.transport_ad !== undefined ? this.transport_ad : <any>null;
        data["transport_glucometry"] = this.transport_glucometry !== undefined ? this.transport_glucometry : <any>null;
        data["transport_pulse"] = this.transport_pulse !== undefined ? this.transport_pulse : <any>null;
        data["transport_pulse_oximetry"] = this.transport_pulse_oximetry !== undefined ? this.transport_pulse_oximetry : <any>null;
        data["transport_temperature"] = this.transport_temperature !== undefined ? this.transport_temperature : <any>null;
        if (this.transport_therapies && this.transport_therapies.constructor === Array) {
            data["transport_therapies"] = [];
            for (let item of this.transport_therapies)
                data["transport_therapies"].push(item.toJSON());
        }
        data["transport_therapy"] = this.transport_therapy !== undefined ? this.transport_therapy : <any>null;
        data["transport_work_ad"] = this.transport_work_ad !== undefined ? this.transport_work_ad : <any>null;
        data["transporting_date"] = this.transporting_date ? this.transporting_date.toJSON() : <any>null;
        data["transporting_type"] = this.transporting_type !== undefined ? this.transporting_type : <any>null;
        data["transporting_type_id"] = this.transporting_type_id !== undefined ? this.transporting_type_id : <any>null;
        data["transporting_type_name"] = this.transporting_type_name !== undefined ? this.transporting_type_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_comment"] = this.type_comment !== undefined ? this.type_comment : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ICardResultDtoFLAT {
    accident_type?: number | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    active_visit_date?: LocalDateTime | null;
    active_visit_hours?: number | null;
    active_visit_type?: number | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;
    assistance_result_id?: number | null;
    bandages?: number | null;
    catheters?: number | null;
    comments?: string | null;
    complication_id?: number | null;
    concomitant_diagnosis?: MkbDto | null;
    death_condition?: number | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: LocalDateTime | null;
    ekg_ch_s_s?: number | null;
    ekg_ch_s_s_after?: number | null;
    ekg_comments?: string | null;
    ekg_comments_after?: string | null;
    ekg_rhythm?: string | null;
    ekg_rhythm_after?: string | null;
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_reason?: number | null;
    hosp_reason_name?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation?: number | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;
    intoxication_type?: number | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    is_created?: boolean | null;
    local_CHD?: string | null;
    local_CHSS?: string | null;
    local_ad?: string | null;
    local_glucometry?: string | null;
    local_pulse?: string | null;
    local_pulse_oximetry?: string | null;
    local_temperature?: string | null;
    local_therapies?: TherapyDto[] | null;
    local_therapy?: string | null;
    local_work_ad?: string | null;
    main_diagnosis?: MkbDto | null;
    other_materials?: string | null;
    reason_type?: number | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;
    syringes?: number | null;
    transfer_patient_brigade?: string | null;
    transfer_patient_time?: LocalDateTime | null;
    transfusion_systems?: number | null;
    transport_CHD?: string | null;
    transport_CHSS?: string | null;
    transport_ad?: string | null;
    transport_glucometry?: string | null;
    transport_pulse?: string | null;
    transport_pulse_oximetry?: string | null;
    transport_temperature?: string | null;
    transport_therapies?: TherapyDto[] | null;
    transport_therapy?: string | null;
    transport_work_ad?: string | null;
    transporting_date?: LocalDateTime | null;
    transporting_type?: number | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;
    type?: number | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class CardAnamnesisIllnesPartDto implements ICardAnamnesisIllnesPartDto {
    illnes_anamnesis?: string | null;
    past_illneses?: string | null;

    constructor(data?: ICardAnamnesisIllnesPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.illnes_anamnesis = data["illnes_anamnesis"] !== undefined ? data["illnes_anamnesis"] : <any>null;
            this.past_illneses = data["past_illneses"] !== undefined ? data["past_illneses"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisIllnesPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisIllnesPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["illnes_anamnesis"] = this.illnes_anamnesis !== undefined ? this.illnes_anamnesis : <any>null;
        data["past_illneses"] = this.past_illneses !== undefined ? this.past_illneses : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisIllnesPartDto {
    illnes_anamnesis?: string | null;
    past_illneses?: string | null;
}

export class CardDeclarantPartDto implements ICardDeclarantPartDto {
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;

    constructor(data?: ICardDeclarantPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.declarant_type_id = data["declarant_type_id"] !== undefined ? data["declarant_type_id"] : <any>null;
            this.declarant_type_name = data["declarant_type_name"] !== undefined ? data["declarant_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardDeclarantPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardDeclarantPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["declarant_type_id"] = this.declarant_type_id !== undefined ? this.declarant_type_id : <any>null;
        data["declarant_type_name"] = this.declarant_type_name !== undefined ? this.declarant_type_name : <any>null;
        return data; 
    }
}

export interface ICardDeclarantPartDto {
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
}

export class CardAddressHouseDto implements ICardAddressHouseDto {
    building?: string | null;
    fias_id?: number | null;
    full_name?: string | null;
    house?: string | null;
    structure?: string | null;

    constructor(data?: ICardAddressHouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.fias_id = data["fias_id"] !== undefined ? data["fias_id"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.structure = data["structure"] !== undefined ? data["structure"] : <any>null;
        }
    }

    static fromJS(data: any): CardAddressHouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAddressHouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["fias_id"] = this.fias_id !== undefined ? this.fias_id : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["structure"] = this.structure !== undefined ? this.structure : <any>null;
        return data; 
    }
}

export interface ICardAddressHouseDto {
    building?: string | null;
    fias_id?: number | null;
    full_name?: string | null;
    house?: string | null;
    structure?: string | null;
}

export class PerformerBrigScheduleUpdateDto implements IPerformerBrigScheduleUpdateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;

    constructor(data?: IPerformerBrigScheduleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleUpdateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
}

export class ListDtoOfPerformer implements IListDtoOfPerformer {
    list?: Performer[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfPerformer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(Performer.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfPerformer {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfPerformer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfPerformer {
    list?: Performer[] | null;
    size?: number | null;
    total?: number | null;
}

export class CardBasicDatesPartDto implements ICardBasicDatesPartDto {
    arrive_time_exceed?: boolean | null;
    brigade_arrive_date?: LocalDateTime | null;
    brigade_complete_date?: LocalDateTime | null;
    brigade_departure_date?: LocalDateTime | null;
    brigade_receiving_date?: LocalDateTime | null;
    brigade_return_date?: LocalDateTime | null;
    brigade_transport_begin_date?: LocalDateTime | null;
    brigade_transport_end_date?: LocalDateTime | null;
    call_create_date?: LocalDateTime | null;
    call_date?: LocalDateTime | null;
    card_date?: LocalDateTime | null;
    full_time_interval?: string | null;
    receiving_time_exceed?: boolean | null;

    constructor(data?: ICardBasicDatesPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.arrive_time_exceed = data["arrive_time_exceed"] !== undefined ? data["arrive_time_exceed"] : <any>null;
            this.brigade_arrive_date = data["brigade_arrive_date"] ? LocalDateTime.fromJS(data["brigade_arrive_date"]) : <any>null;
            this.brigade_complete_date = data["brigade_complete_date"] ? LocalDateTime.fromJS(data["brigade_complete_date"]) : <any>null;
            this.brigade_departure_date = data["brigade_departure_date"] ? LocalDateTime.fromJS(data["brigade_departure_date"]) : <any>null;
            this.brigade_receiving_date = data["brigade_receiving_date"] ? LocalDateTime.fromJS(data["brigade_receiving_date"]) : <any>null;
            this.brigade_return_date = data["brigade_return_date"] ? LocalDateTime.fromJS(data["brigade_return_date"]) : <any>null;
            this.brigade_transport_begin_date = data["brigade_transport_begin_date"] ? LocalDateTime.fromJS(data["brigade_transport_begin_date"]) : <any>null;
            this.brigade_transport_end_date = data["brigade_transport_end_date"] ? LocalDateTime.fromJS(data["brigade_transport_end_date"]) : <any>null;
            this.call_create_date = data["call_create_date"] ? LocalDateTime.fromJS(data["call_create_date"]) : <any>null;
            this.call_date = data["call_date"] ? LocalDateTime.fromJS(data["call_date"]) : <any>null;
            this.card_date = data["card_date"] ? LocalDateTime.fromJS(data["card_date"]) : <any>null;
            this.full_time_interval = data["full_time_interval"] !== undefined ? data["full_time_interval"] : <any>null;
            this.receiving_time_exceed = data["receiving_time_exceed"] !== undefined ? data["receiving_time_exceed"] : <any>null;
        }
    }

    static fromJS(data: any): CardBasicDatesPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardBasicDatesPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrive_time_exceed"] = this.arrive_time_exceed !== undefined ? this.arrive_time_exceed : <any>null;
        data["brigade_arrive_date"] = this.brigade_arrive_date ? this.brigade_arrive_date.toJSON() : <any>null;
        data["brigade_complete_date"] = this.brigade_complete_date ? this.brigade_complete_date.toJSON() : <any>null;
        data["brigade_departure_date"] = this.brigade_departure_date ? this.brigade_departure_date.toJSON() : <any>null;
        data["brigade_receiving_date"] = this.brigade_receiving_date ? this.brigade_receiving_date.toJSON() : <any>null;
        data["brigade_return_date"] = this.brigade_return_date ? this.brigade_return_date.toJSON() : <any>null;
        data["brigade_transport_begin_date"] = this.brigade_transport_begin_date ? this.brigade_transport_begin_date.toJSON() : <any>null;
        data["brigade_transport_end_date"] = this.brigade_transport_end_date ? this.brigade_transport_end_date.toJSON() : <any>null;
        data["call_create_date"] = this.call_create_date ? this.call_create_date.toJSON() : <any>null;
        data["call_date"] = this.call_date ? this.call_date.toJSON() : <any>null;
        data["card_date"] = this.card_date ? this.card_date.toJSON() : <any>null;
        data["full_time_interval"] = this.full_time_interval !== undefined ? this.full_time_interval : <any>null;
        data["receiving_time_exceed"] = this.receiving_time_exceed !== undefined ? this.receiving_time_exceed : <any>null;
        return data; 
    }
}

export interface ICardBasicDatesPartDto {
    arrive_time_exceed?: boolean | null;
    brigade_arrive_date?: LocalDateTime | null;
    brigade_complete_date?: LocalDateTime | null;
    brigade_departure_date?: LocalDateTime | null;
    brigade_receiving_date?: LocalDateTime | null;
    brigade_return_date?: LocalDateTime | null;
    brigade_transport_begin_date?: LocalDateTime | null;
    brigade_transport_end_date?: LocalDateTime | null;
    call_create_date?: LocalDateTime | null;
    call_date?: LocalDateTime | null;
    card_date?: LocalDateTime | null;
    full_time_interval?: string | null;
    receiving_time_exceed?: boolean | null;
}

export class CallShortDto implements ICallShortDto {
    address?: string | null;
    call_id?: number | null;
    call_reason?: string | null;
    date?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    is_unfounded?: boolean | null;
    number?: string | null;
    patient_age?: string | null;
    patient_firstname?: string | null;
    patient_patronymic?: string | null;
    patient_second_name?: string | null;
    patients?: string[] | null;
    similars?: string[] | null;
    status?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICallShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_reason = data["call_reason"] !== undefined ? data["call_reason"] : <any>null;
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patient_age = data["patient_age"] !== undefined ? data["patient_age"] : <any>null;
            this.patient_firstname = data["patient_firstname"] !== undefined ? data["patient_firstname"] : <any>null;
            this.patient_patronymic = data["patient_patronymic"] !== undefined ? data["patient_patronymic"] : <any>null;
            this.patient_second_name = data["patient_second_name"] !== undefined ? data["patient_second_name"] : <any>null;
            if (data["patients"] && data["patients"].constructor === Array) {
                this.patients = [];
                for (let item of data["patients"])
                    this.patients.push(item);
            }
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_reason"] = this.call_reason !== undefined ? this.call_reason : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patient_age"] = this.patient_age !== undefined ? this.patient_age : <any>null;
        data["patient_firstname"] = this.patient_firstname !== undefined ? this.patient_firstname : <any>null;
        data["patient_patronymic"] = this.patient_patronymic !== undefined ? this.patient_patronymic : <any>null;
        data["patient_second_name"] = this.patient_second_name !== undefined ? this.patient_second_name : <any>null;
        if (this.patients && this.patients.constructor === Array) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item);
        }
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICallShortDto {
    address?: string | null;
    call_id?: number | null;
    call_reason?: string | null;
    date?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    is_unfounded?: boolean | null;
    number?: string | null;
    patient_age?: string | null;
    patient_firstname?: string | null;
    patient_patronymic?: string | null;
    patient_second_name?: string | null;
    patients?: string[] | null;
    similars?: string[] | null;
    status?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class CardObjectiveComplicationsPartDto implements ICardObjectiveComplicationsPartDto {
    complications_id?: number | null;
    complications_name?: string | null;
    complications_text?: string | null;

    constructor(data?: ICardObjectiveComplicationsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.complications_id = data["complications_id"] !== undefined ? data["complications_id"] : <any>null;
            this.complications_name = data["complications_name"] !== undefined ? data["complications_name"] : <any>null;
            this.complications_text = data["complications_text"] !== undefined ? data["complications_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveComplicationsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveComplicationsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complications_id"] = this.complications_id !== undefined ? this.complications_id : <any>null;
        data["complications_name"] = this.complications_name !== undefined ? this.complications_name : <any>null;
        data["complications_text"] = this.complications_text !== undefined ? this.complications_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveComplicationsPartDto {
    complications_id?: number | null;
    complications_name?: string | null;
    complications_text?: string | null;
}

export class MobileMessage implements IMobileMessage {
    code?: string | null;
    date?: LocalDateTime | null;
    guid?: string | null;
    on_off?: boolean | null;

    constructor(data?: IMobileMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
            this.on_off = data["on_off"] !== undefined ? data["on_off"] : <any>null;
        }
    }

    static fromJS(data: any): MobileMessage {
        data = typeof data === 'object' ? data : {};
        let result = new MobileMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        data["on_off"] = this.on_off !== undefined ? this.on_off : <any>null;
        return data; 
    }
}

export interface IMobileMessage {
    code?: string | null;
    date?: LocalDateTime | null;
    guid?: string | null;
    on_off?: boolean | null;
}

export class BagItemDto implements IBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    bag_nomenclature_id?: number | null;
    bag_series_number?: number | null;
    company?: string | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IBagItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.bag_nomenclature_id = data["bag_nomenclature_id"] !== undefined ? data["bag_nomenclature_id"] : <any>null;
            this.bag_series_number = data["bag_series_number"] !== undefined ? data["bag_series_number"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.expiry_date = data["expiry_date"] ? LocalDateTime.fromJS(data["expiry_date"]) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_reusable = data["is_reusable"] !== undefined ? data["is_reusable"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): BagItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BagItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["bag_nomenclature_id"] = this.bag_nomenclature_id !== undefined ? this.bag_nomenclature_id : <any>null;
        data["bag_series_number"] = this.bag_series_number !== undefined ? this.bag_series_number : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toJSON() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_reusable"] = this.is_reusable !== undefined ? this.is_reusable : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    bag_nomenclature_id?: number | null;
    bag_series_number?: number | null;
    company?: string | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    series_number?: number | null;
    type?: number | null;
}

export class CardObjectiveAlcoPartDto implements ICardObjectiveAlcoPartDto {
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;

    constructor(data?: ICardObjectiveAlcoPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.alco_breath = data["alco_breath"] !== undefined ? data["alco_breath"] : <any>null;
            this.alco_emotion_lability = data["alco_emotion_lability"] !== undefined ? data["alco_emotion_lability"] : <any>null;
            this.alco_inadequate = data["alco_inadequate"] !== undefined ? data["alco_inadequate"] : <any>null;
            this.alco_romberg_pose = data["alco_romberg_pose"] !== undefined ? data["alco_romberg_pose"] : <any>null;
            this.alco_shaky_walk = data["alco_shaky_walk"] !== undefined ? data["alco_shaky_walk"] : <any>null;
            this.alco_speach_behavior = data["alco_speach_behavior"] !== undefined ? data["alco_speach_behavior"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveAlcoPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveAlcoPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alco_breath"] = this.alco_breath !== undefined ? this.alco_breath : <any>null;
        data["alco_emotion_lability"] = this.alco_emotion_lability !== undefined ? this.alco_emotion_lability : <any>null;
        data["alco_inadequate"] = this.alco_inadequate !== undefined ? this.alco_inadequate : <any>null;
        data["alco_romberg_pose"] = this.alco_romberg_pose !== undefined ? this.alco_romberg_pose : <any>null;
        data["alco_shaky_walk"] = this.alco_shaky_walk !== undefined ? this.alco_shaky_walk : <any>null;
        data["alco_speach_behavior"] = this.alco_speach_behavior !== undefined ? this.alco_speach_behavior : <any>null;
        return data; 
    }
}

export interface ICardObjectiveAlcoPartDto {
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;
}

export class ListDtoOfLogDto implements IListDtoOfLogDto {
    list?: LogDto[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(LogDto.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfLogDto {
    list?: LogDto[] | null;
    size?: number | null;
    total?: number | null;
}

export class GroupBagItemDto implements IGroupBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    group_id?: number | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    name?: string | null;
    nomenclature_id?: number | null;

    constructor(data?: IGroupBagItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BagItemDto.fromJS(item));
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
        }
    }

    static fromJS(data: any): GroupBagItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupBagItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        return data; 
    }
}

export interface IGroupBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    group_id?: number | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    name?: string | null;
    nomenclature_id?: number | null;
}

export class CardGridDto implements ICardGridDto {
    address?: string | null;
    brigade_arrive_date?: LocalDateTime | null;
    brigade_departure_date?: LocalDateTime | null;
    brigade_help_date?: LocalDateTime | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_receiving_date?: LocalDateTime | null;
    brigade_return_date?: LocalDateTime | null;
    call_id?: number | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    date?: LocalDateTime | null;
    declarant_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: LocalDateTime | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    district?: string | null;
    district_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    main_diagnosis_id?: number | null;
    main_diagnosis_name?: string | null;
    number?: string | null;
    patient?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    result_id?: number | null;
    result_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICardGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.brigade_arrive_date = data["brigade_arrive_date"] ? LocalDateTime.fromJS(data["brigade_arrive_date"]) : <any>null;
            this.brigade_departure_date = data["brigade_departure_date"] ? LocalDateTime.fromJS(data["brigade_departure_date"]) : <any>null;
            this.brigade_help_date = data["brigade_help_date"] ? LocalDateTime.fromJS(data["brigade_help_date"]) : <any>null;
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
            this.brigade_name = data["brigade_name"] !== undefined ? data["brigade_name"] : <any>null;
            this.brigade_receiving_date = data["brigade_receiving_date"] ? LocalDateTime.fromJS(data["brigade_receiving_date"]) : <any>null;
            this.brigade_return_date = data["brigade_return_date"] ? LocalDateTime.fromJS(data["brigade_return_date"]) : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.card_id = data["card_id"] !== undefined ? data["card_id"] : <any>null;
            this.card_status = data["card_status"] !== undefined ? data["card_status"] : <any>null;
            this.card_status_name = data["card_status_name"] !== undefined ? data["card_status_name"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.deleted_date = data["deleted_date"] ? LocalDateTime.fromJS(data["deleted_date"]) : <any>null;
            this.deleted_message = data["deleted_message"] !== undefined ? data["deleted_message"] : <any>null;
            this.deleted_performer_id = data["deleted_performer_id"] !== undefined ? data["deleted_performer_id"] : <any>null;
            this.deleted_performer_name = data["deleted_performer_name"] !== undefined ? data["deleted_performer_name"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.district_name = data["district_name"] !== undefined ? data["district_name"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.main_diagnosis_id = data["main_diagnosis_id"] !== undefined ? data["main_diagnosis_id"] : <any>null;
            this.main_diagnosis_name = data["main_diagnosis_name"] !== undefined ? data["main_diagnosis_name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patient = data["patient"] !== undefined ? data["patient"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.result_id = data["result_id"] !== undefined ? data["result_id"] : <any>null;
            this.result_name = data["result_name"] !== undefined ? data["result_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["brigade_arrive_date"] = this.brigade_arrive_date ? this.brigade_arrive_date.toJSON() : <any>null;
        data["brigade_departure_date"] = this.brigade_departure_date ? this.brigade_departure_date.toJSON() : <any>null;
        data["brigade_help_date"] = this.brigade_help_date ? this.brigade_help_date.toJSON() : <any>null;
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        data["brigade_name"] = this.brigade_name !== undefined ? this.brigade_name : <any>null;
        data["brigade_receiving_date"] = this.brigade_receiving_date ? this.brigade_receiving_date.toJSON() : <any>null;
        data["brigade_return_date"] = this.brigade_return_date ? this.brigade_return_date.toJSON() : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["card_id"] = this.card_id !== undefined ? this.card_id : <any>null;
        data["card_status"] = this.card_status !== undefined ? this.card_status : <any>null;
        data["card_status_name"] = this.card_status_name !== undefined ? this.card_status_name : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["deleted_date"] = this.deleted_date ? this.deleted_date.toJSON() : <any>null;
        data["deleted_message"] = this.deleted_message !== undefined ? this.deleted_message : <any>null;
        data["deleted_performer_id"] = this.deleted_performer_id !== undefined ? this.deleted_performer_id : <any>null;
        data["deleted_performer_name"] = this.deleted_performer_name !== undefined ? this.deleted_performer_name : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["district_name"] = this.district_name !== undefined ? this.district_name : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["main_diagnosis_id"] = this.main_diagnosis_id !== undefined ? this.main_diagnosis_id : <any>null;
        data["main_diagnosis_name"] = this.main_diagnosis_name !== undefined ? this.main_diagnosis_name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patient"] = this.patient !== undefined ? this.patient : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["result_id"] = this.result_id !== undefined ? this.result_id : <any>null;
        data["result_name"] = this.result_name !== undefined ? this.result_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICardGridDto {
    address?: string | null;
    brigade_arrive_date?: LocalDateTime | null;
    brigade_departure_date?: LocalDateTime | null;
    brigade_help_date?: LocalDateTime | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_receiving_date?: LocalDateTime | null;
    brigade_return_date?: LocalDateTime | null;
    call_id?: number | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    date?: LocalDateTime | null;
    declarant_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: LocalDateTime | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    district?: string | null;
    district_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    main_diagnosis_id?: number | null;
    main_diagnosis_name?: string | null;
    number?: string | null;
    patient?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    result_id?: number | null;
    result_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class CardObjectiveLymphPartDto implements ICardObjectiveLymphPartDto {
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_normal_large_name?: string | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_painful_unpainful_name?: string | null;
    lymph_nodes_text?: string | null;

    constructor(data?: ICardObjectiveLymphPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lymph_nodes_normal_large = data["lymph_nodes_normal_large"] !== undefined ? data["lymph_nodes_normal_large"] : <any>null;
            this.lymph_nodes_normal_large_name = data["lymph_nodes_normal_large_name"] !== undefined ? data["lymph_nodes_normal_large_name"] : <any>null;
            this.lymph_nodes_painful_unpainful = data["lymph_nodes_painful_unpainful"] !== undefined ? data["lymph_nodes_painful_unpainful"] : <any>null;
            this.lymph_nodes_painful_unpainful_name = data["lymph_nodes_painful_unpainful_name"] !== undefined ? data["lymph_nodes_painful_unpainful_name"] : <any>null;
            this.lymph_nodes_text = data["lymph_nodes_text"] !== undefined ? data["lymph_nodes_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveLymphPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveLymphPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lymph_nodes_normal_large"] = this.lymph_nodes_normal_large !== undefined ? this.lymph_nodes_normal_large : <any>null;
        data["lymph_nodes_normal_large_name"] = this.lymph_nodes_normal_large_name !== undefined ? this.lymph_nodes_normal_large_name : <any>null;
        data["lymph_nodes_painful_unpainful"] = this.lymph_nodes_painful_unpainful !== undefined ? this.lymph_nodes_painful_unpainful : <any>null;
        data["lymph_nodes_painful_unpainful_name"] = this.lymph_nodes_painful_unpainful_name !== undefined ? this.lymph_nodes_painful_unpainful_name : <any>null;
        data["lymph_nodes_text"] = this.lymph_nodes_text !== undefined ? this.lymph_nodes_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveLymphPartDto {
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_normal_large_name?: string | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_painful_unpainful_name?: string | null;
    lymph_nodes_text?: string | null;
}

export class CardAnamnesisComplaintsPartDto implements ICardAnamnesisComplaintsPartDto {
    complaints_anamnesis?: string | null;

    constructor(data?: ICardAnamnesisComplaintsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.complaints_anamnesis = data["complaints_anamnesis"] !== undefined ? data["complaints_anamnesis"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisComplaintsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisComplaintsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complaints_anamnesis"] = this.complaints_anamnesis !== undefined ? this.complaints_anamnesis : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisComplaintsPartDto {
    complaints_anamnesis?: string | null;
}

export class MessageEventDto implements IMessageEventDto {
    code?: string | null;
    date?: LocalDateTime | null;
    date_filled?: LocalDateTime | null;
    id?: number | null;
    message_id?: number | null;
    name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    transmitted?: boolean | null;

    constructor(data?: IMessageEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.date_filled = data["date_filled"] ? LocalDateTime.fromJS(data["date_filled"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.message_id = data["message_id"] !== undefined ? data["message_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.transmitted = data["transmitted"] !== undefined ? data["transmitted"] : <any>null;
        }
    }

    static fromJS(data: any): MessageEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["date_filled"] = this.date_filled ? this.date_filled.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["message_id"] = this.message_id !== undefined ? this.message_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["transmitted"] = this.transmitted !== undefined ? this.transmitted : <any>null;
        return data; 
    }
}

export interface IMessageEventDto {
    code?: string | null;
    date?: LocalDateTime | null;
    date_filled?: LocalDateTime | null;
    id?: number | null;
    message_id?: number | null;
    name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    transmitted?: boolean | null;
}

export class CardResultCommentsDto implements ICardResultCommentsDto {
    comments?: string | null;

    constructor(data?: ICardResultCommentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultCommentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultCommentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        return data; 
    }
}

export interface ICardResultCommentsDto {
    comments?: string | null;
}

export class BrigadeScheduleCreateDto implements IBrigadeScheduleCreateDto {
    cars?: TransportBrigScheduleCreateDto[] | null;
    performers?: PerformerBrigScheduleCreateDto[] | null;
    period_details?: PeriodDetails | null;

    constructor(data?: IBrigadeScheduleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cars"] && data["cars"].constructor === Array) {
                this.cars = [];
                for (let item of data["cars"])
                    this.cars.push(TransportBrigScheduleCreateDto.fromJS(item));
            }
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerBrigScheduleCreateDto.fromJS(item));
            }
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeScheduleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cars && this.cars.constructor === Array) {
            data["cars"] = [];
            for (let item of this.cars)
                data["cars"].push(item.toJSON());
        }
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeScheduleCreateDto {
    cars?: TransportBrigScheduleCreateDto[] | null;
    performers?: PerformerBrigScheduleCreateDto[] | null;
    period_details?: PeriodDetails | null;
}

export class CardObjectiveExcretaUrinePartDto implements ICardObjectiveExcretaUrinePartDto {
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    urine_text?: string | null;

    constructor(data?: ICardObjectiveExcretaUrinePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.excreta = data["excreta"] !== undefined ? data["excreta"] : <any>null;
            this.excreta_name = data["excreta_name"] !== undefined ? data["excreta_name"] : <any>null;
            this.excreta_text = data["excreta_text"] !== undefined ? data["excreta_text"] : <any>null;
            this.urine_text = data["urine_text"] !== undefined ? data["urine_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveExcretaUrinePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveExcretaUrinePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["excreta"] = this.excreta !== undefined ? this.excreta : <any>null;
        data["excreta_name"] = this.excreta_name !== undefined ? this.excreta_name : <any>null;
        data["excreta_text"] = this.excreta_text !== undefined ? this.excreta_text : <any>null;
        data["urine_text"] = this.urine_text !== undefined ? this.urine_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveExcretaUrinePartDto {
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    urine_text?: string | null;
}

export class CardResultDto implements ICardResultDto {
    active_visit?: CardResultActiveVisitDto | null;
    assistance_result?: CardResultAssistanceResultDto | null;
    comments?: string | null;
    death?: CardResultDeathDto | null;
    diagnosis?: CardResultDiagnosisDto | null;
    ekg?: CardResultEkg | null;
    ekg_after?: CardResultEkg | null;
    header?: CardResultHeaderDto | null;
    illegal_actions?: CardResultIllegalActionsDto | null;
    local_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    local_therapies?: TherapyDto[] | null;
    materials?: CardResultMaterialsDto | null;
    transfer_patient?: CardResultTransferPatientDto | null;
    transport_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    transport_therapies?: TherapyDto[] | null;
    transporting?: CardResultTransportingDto | null;
    type?: CardResultTypeDto | null;

    constructor(data?: ICardResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active_visit = data["active_visit"] ? CardResultActiveVisitDto.fromJS(data["active_visit"]) : <any>null;
            this.assistance_result = data["assistance_result"] ? CardResultAssistanceResultDto.fromJS(data["assistance_result"]) : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.death = data["death"] ? CardResultDeathDto.fromJS(data["death"]) : <any>null;
            this.diagnosis = data["diagnosis"] ? CardResultDiagnosisDto.fromJS(data["diagnosis"]) : <any>null;
            this.ekg = data["ekg"] ? CardResultEkg.fromJS(data["ekg"]) : <any>null;
            this.ekg_after = data["ekg_after"] ? CardResultEkg.fromJS(data["ekg_after"]) : <any>null;
            this.header = data["header"] ? CardResultHeaderDto.fromJS(data["header"]) : <any>null;
            this.illegal_actions = data["illegal_actions"] ? CardResultIllegalActionsDto.fromJS(data["illegal_actions"]) : <any>null;
            this.local_efficiency_assistance = data["local_efficiency_assistance"] ? CardResultEfficiencyAssistance.fromJS(data["local_efficiency_assistance"]) : <any>null;
            if (data["local_therapies"] && data["local_therapies"].constructor === Array) {
                this.local_therapies = [];
                for (let item of data["local_therapies"])
                    this.local_therapies.push(TherapyDto.fromJS(item));
            }
            this.materials = data["materials"] ? CardResultMaterialsDto.fromJS(data["materials"]) : <any>null;
            this.transfer_patient = data["transfer_patient"] ? CardResultTransferPatientDto.fromJS(data["transfer_patient"]) : <any>null;
            this.transport_efficiency_assistance = data["transport_efficiency_assistance"] ? CardResultEfficiencyAssistance.fromJS(data["transport_efficiency_assistance"]) : <any>null;
            if (data["transport_therapies"] && data["transport_therapies"].constructor === Array) {
                this.transport_therapies = [];
                for (let item of data["transport_therapies"])
                    this.transport_therapies.push(TherapyDto.fromJS(item));
            }
            this.transporting = data["transporting"] ? CardResultTransportingDto.fromJS(data["transporting"]) : <any>null;
            this.type = data["type"] ? CardResultTypeDto.fromJS(data["type"]) : <any>null;
        }
    }

    static fromJS(data: any): CardResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active_visit"] = this.active_visit ? this.active_visit.toJSON() : <any>null;
        data["assistance_result"] = this.assistance_result ? this.assistance_result.toJSON() : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["death"] = this.death ? this.death.toJSON() : <any>null;
        data["diagnosis"] = this.diagnosis ? this.diagnosis.toJSON() : <any>null;
        data["ekg"] = this.ekg ? this.ekg.toJSON() : <any>null;
        data["ekg_after"] = this.ekg_after ? this.ekg_after.toJSON() : <any>null;
        data["header"] = this.header ? this.header.toJSON() : <any>null;
        data["illegal_actions"] = this.illegal_actions ? this.illegal_actions.toJSON() : <any>null;
        data["local_efficiency_assistance"] = this.local_efficiency_assistance ? this.local_efficiency_assistance.toJSON() : <any>null;
        if (this.local_therapies && this.local_therapies.constructor === Array) {
            data["local_therapies"] = [];
            for (let item of this.local_therapies)
                data["local_therapies"].push(item.toJSON());
        }
        data["materials"] = this.materials ? this.materials.toJSON() : <any>null;
        data["transfer_patient"] = this.transfer_patient ? this.transfer_patient.toJSON() : <any>null;
        data["transport_efficiency_assistance"] = this.transport_efficiency_assistance ? this.transport_efficiency_assistance.toJSON() : <any>null;
        if (this.transport_therapies && this.transport_therapies.constructor === Array) {
            data["transport_therapies"] = [];
            for (let item of this.transport_therapies)
                data["transport_therapies"].push(item.toJSON());
        }
        data["transporting"] = this.transporting ? this.transporting.toJSON() : <any>null;
        data["type"] = this.type ? this.type.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardResultDto {
    active_visit?: CardResultActiveVisitDto | null;
    assistance_result?: CardResultAssistanceResultDto | null;
    comments?: string | null;
    death?: CardResultDeathDto | null;
    diagnosis?: CardResultDiagnosisDto | null;
    ekg?: CardResultEkg | null;
    ekg_after?: CardResultEkg | null;
    header?: CardResultHeaderDto | null;
    illegal_actions?: CardResultIllegalActionsDto | null;
    local_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    local_therapies?: TherapyDto[] | null;
    materials?: CardResultMaterialsDto | null;
    transfer_patient?: CardResultTransferPatientDto | null;
    transport_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    transport_therapies?: TherapyDto[] | null;
    transporting?: CardResultTransportingDto | null;
    type?: CardResultTypeDto | null;
}

export class Era implements IEra {
    value?: number | null;

    constructor(data?: IEra) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Era {
        data = typeof data === 'object' ? data : {};
        let result = new Era();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IEra {
    value?: number | null;
}

export class LoginPair implements ILoginPair {
    name?: string | null;
    password?: string | null;

    constructor(data?: ILoginPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginPair {
        data = typeof data === 'object' ? data : {};
        let result = new LoginPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface ILoginPair {
    name?: string | null;
    password?: string | null;
}

export class PharmacyGroupReferenceDto implements IPharmacyGroupReferenceDto {
    code?: string | null;
    company?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    reference_id?: number | null;

    constructor(data?: IPharmacyGroupReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.reference_id = data["reference_id"] !== undefined ? data["reference_id"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyGroupReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyGroupReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["reference_id"] = this.reference_id !== undefined ? this.reference_id : <any>null;
        return data; 
    }
}

export interface IPharmacyGroupReferenceDto {
    code?: string | null;
    company?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    reference_id?: number | null;
}

export class CardShiftSeniorDoctorPartDto implements ICardShiftSeniorDoctorPartDto {
    shift_senior_doctor_checked?: boolean | null;
    shift_senior_doctor_comment?: string | null;
    shift_senior_doctor_date?: LocalDateTime | null;
    shift_senior_doctor_id?: number | null;
    shift_senior_doctor_name?: string | null;

    constructor(data?: ICardShiftSeniorDoctorPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shift_senior_doctor_checked = data["shift_senior_doctor_checked"] !== undefined ? data["shift_senior_doctor_checked"] : <any>null;
            this.shift_senior_doctor_comment = data["shift_senior_doctor_comment"] !== undefined ? data["shift_senior_doctor_comment"] : <any>null;
            this.shift_senior_doctor_date = data["shift_senior_doctor_date"] ? LocalDateTime.fromJS(data["shift_senior_doctor_date"]) : <any>null;
            this.shift_senior_doctor_id = data["shift_senior_doctor_id"] !== undefined ? data["shift_senior_doctor_id"] : <any>null;
            this.shift_senior_doctor_name = data["shift_senior_doctor_name"] !== undefined ? data["shift_senior_doctor_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardShiftSeniorDoctorPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardShiftSeniorDoctorPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shift_senior_doctor_checked"] = this.shift_senior_doctor_checked !== undefined ? this.shift_senior_doctor_checked : <any>null;
        data["shift_senior_doctor_comment"] = this.shift_senior_doctor_comment !== undefined ? this.shift_senior_doctor_comment : <any>null;
        data["shift_senior_doctor_date"] = this.shift_senior_doctor_date ? this.shift_senior_doctor_date.toJSON() : <any>null;
        data["shift_senior_doctor_id"] = this.shift_senior_doctor_id !== undefined ? this.shift_senior_doctor_id : <any>null;
        data["shift_senior_doctor_name"] = this.shift_senior_doctor_name !== undefined ? this.shift_senior_doctor_name : <any>null;
        return data; 
    }
}

export interface ICardShiftSeniorDoctorPartDto {
    shift_senior_doctor_checked?: boolean | null;
    shift_senior_doctor_comment?: string | null;
    shift_senior_doctor_date?: LocalDateTime | null;
    shift_senior_doctor_id?: number | null;
    shift_senior_doctor_name?: string | null;
}

export class CardObjectiveGlasgowPartDto implements ICardObjectiveGlasgowPartDto {
    eye?: number | null;
    motor?: number | null;
    verbal?: number | null;

    constructor(data?: ICardObjectiveGlasgowPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eye = data["eye"] !== undefined ? data["eye"] : <any>null;
            this.motor = data["motor"] !== undefined ? data["motor"] : <any>null;
            this.verbal = data["verbal"] !== undefined ? data["verbal"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveGlasgowPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveGlasgowPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eye"] = this.eye !== undefined ? this.eye : <any>null;
        data["motor"] = this.motor !== undefined ? this.motor : <any>null;
        data["verbal"] = this.verbal !== undefined ? this.verbal : <any>null;
        return data; 
    }
}

export interface ICardObjectiveGlasgowPartDto {
    eye?: number | null;
    motor?: number | null;
    verbal?: number | null;
}

export class ProductMove implements IProductMove {
    count?: number | null;
    count_consumption?: number | null;
    count_receiving?: number | null;
    date?: LocalDateTime | null;
    description?: string | null;
    document_id?: number | null;

    constructor(data?: IProductMove) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.count_consumption = data["count_consumption"] !== undefined ? data["count_consumption"] : <any>null;
            this.count_receiving = data["count_receiving"] !== undefined ? data["count_receiving"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.document_id = data["document_id"] !== undefined ? data["document_id"] : <any>null;
        }
    }

    static fromJS(data: any): ProductMove {
        data = typeof data === 'object' ? data : {};
        let result = new ProductMove();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["count_consumption"] = this.count_consumption !== undefined ? this.count_consumption : <any>null;
        data["count_receiving"] = this.count_receiving !== undefined ? this.count_receiving : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["document_id"] = this.document_id !== undefined ? this.document_id : <any>null;
        return data; 
    }
}

export interface IProductMove {
    count?: number | null;
    count_consumption?: number | null;
    count_receiving?: number | null;
    date?: LocalDateTime | null;
    description?: string | null;
    document_id?: number | null;
}

export class CardBrigadeDoctorPartDto implements ICardBrigadeDoctorPartDto {
    brigade_doctor_date?: LocalDateTime | null;
    brigade_doctor_id?: number | null;
    brigade_doctor_name?: string | null;
    brigade_doctor_signed?: boolean | null;

    constructor(data?: ICardBrigadeDoctorPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_doctor_date = data["brigade_doctor_date"] ? LocalDateTime.fromJS(data["brigade_doctor_date"]) : <any>null;
            this.brigade_doctor_id = data["brigade_doctor_id"] !== undefined ? data["brigade_doctor_id"] : <any>null;
            this.brigade_doctor_name = data["brigade_doctor_name"] !== undefined ? data["brigade_doctor_name"] : <any>null;
            this.brigade_doctor_signed = data["brigade_doctor_signed"] !== undefined ? data["brigade_doctor_signed"] : <any>null;
        }
    }

    static fromJS(data: any): CardBrigadeDoctorPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardBrigadeDoctorPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_doctor_date"] = this.brigade_doctor_date ? this.brigade_doctor_date.toJSON() : <any>null;
        data["brigade_doctor_id"] = this.brigade_doctor_id !== undefined ? this.brigade_doctor_id : <any>null;
        data["brigade_doctor_name"] = this.brigade_doctor_name !== undefined ? this.brigade_doctor_name : <any>null;
        data["brigade_doctor_signed"] = this.brigade_doctor_signed !== undefined ? this.brigade_doctor_signed : <any>null;
        return data; 
    }
}

export interface ICardBrigadeDoctorPartDto {
    brigade_doctor_date?: LocalDateTime | null;
    brigade_doctor_id?: number | null;
    brigade_doctor_name?: string | null;
    brigade_doctor_signed?: boolean | null;
}

export class CardObjectivePartDtoFLAT implements ICardObjectivePartDtoFLAT {
    ad?: string | null;
    addition_objective?: string | null;
    admax?: string | null;
    adn?: string | null;
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;
    almonds_normal_large?: number | null;
    almonds_plaque?: boolean | null;
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    bodytemp?: string | null;
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    card_delivery_id?: number | null;
    chd?: string | null;
    chss?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    eye?: number | null;
    general_state_id?: number | null;
    general_state_name?: string | null;
    glucometry?: string | null;
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_pulse_id?: number | null;
    heart_pulse_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;
    heart_tone_noise?: boolean | null;
    is_created?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;
    liver_normal_large?: number | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;
    lungs_wheezing_id?: number | null;
    lungs_wheezing_text?: string | null;
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_text?: string | null;
    meningeal_reflexes?: boolean | null;
    motor?: number | null;
    multiple_zeva_clean_hyper?: number | null;
    pathological_reflexes?: boolean | null;
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;
    post_therapy_hemodynamics?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;
    titles?: boolean | null;
    titles_text?: string | null;
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;
    urine_text?: string | null;
    verbal?: number | null;

    constructor(data?: ICardObjectivePartDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ad = data["ad"] !== undefined ? data["ad"] : <any>null;
            this.addition_objective = data["addition_objective"] !== undefined ? data["addition_objective"] : <any>null;
            this.admax = data["admax"] !== undefined ? data["admax"] : <any>null;
            this.adn = data["adn"] !== undefined ? data["adn"] : <any>null;
            this.alco_breath = data["alco_breath"] !== undefined ? data["alco_breath"] : <any>null;
            this.alco_emotion_lability = data["alco_emotion_lability"] !== undefined ? data["alco_emotion_lability"] : <any>null;
            this.alco_inadequate = data["alco_inadequate"] !== undefined ? data["alco_inadequate"] : <any>null;
            this.alco_romberg_pose = data["alco_romberg_pose"] !== undefined ? data["alco_romberg_pose"] : <any>null;
            this.alco_shaky_walk = data["alco_shaky_walk"] !== undefined ? data["alco_shaky_walk"] : <any>null;
            this.alco_speach_behavior = data["alco_speach_behavior"] !== undefined ? data["alco_speach_behavior"] : <any>null;
            this.almonds_normal_large = data["almonds_normal_large"] !== undefined ? data["almonds_normal_large"] : <any>null;
            this.almonds_plaque = data["almonds_plaque"] !== undefined ? data["almonds_plaque"] : <any>null;
            this.behaviour_id = data["behaviour_id"] !== undefined ? data["behaviour_id"] : <any>null;
            this.behaviour_name = data["behaviour_name"] !== undefined ? data["behaviour_name"] : <any>null;
            this.bodytemp = data["bodytemp"] !== undefined ? data["bodytemp"] : <any>null;
            this.breath_absent = data["breath_absent"] !== undefined ? data["breath_absent"] : <any>null;
            this.breath_bronch = data["breath_bronch"] !== undefined ? data["breath_bronch"] : <any>null;
            this.breath_evenly = data["breath_evenly"] !== undefined ? data["breath_evenly"] : <any>null;
            this.breath_hard = data["breath_hard"] !== undefined ? data["breath_hard"] : <any>null;
            this.breath_puer = data["breath_puer"] !== undefined ? data["breath_puer"] : <any>null;
            this.breath_text = data["breath_text"] !== undefined ? data["breath_text"] : <any>null;
            this.breath_vesicul = data["breath_vesicul"] !== undefined ? data["breath_vesicul"] : <any>null;
            this.breath_weak = data["breath_weak"] !== undefined ? data["breath_weak"] : <any>null;
            this.card_delivery_id = data["card_delivery_id"] !== undefined ? data["card_delivery_id"] : <any>null;
            this.chd = data["chd"] !== undefined ? data["chd"] : <any>null;
            this.chss = data["chss"] !== undefined ? data["chss"] : <any>null;
            this.conscious_id = data["conscious_id"] !== undefined ? data["conscious_id"] : <any>null;
            this.conscious_name = data["conscious_name"] !== undefined ? data["conscious_name"] : <any>null;
            this.diuresis_disuria = data["diuresis_disuria"] !== undefined ? data["diuresis_disuria"] : <any>null;
            this.diuresis_hematuria = data["diuresis_hematuria"] !== undefined ? data["diuresis_hematuria"] : <any>null;
            this.diuresis_n = data["diuresis_n"] !== undefined ? data["diuresis_n"] : <any>null;
            this.diuresis_oliguria = data["diuresis_oliguria"] !== undefined ? data["diuresis_oliguria"] : <any>null;
            this.dyspeptic_diarrhea = data["dyspeptic_diarrhea"] !== undefined ? data["dyspeptic_diarrhea"] : <any>null;
            this.dyspeptic_nausea = data["dyspeptic_nausea"] !== undefined ? data["dyspeptic_nausea"] : <any>null;
            this.dyspeptic_retch = data["dyspeptic_retch"] !== undefined ? data["dyspeptic_retch"] : <any>null;
            this.dyspeptics_no = data["dyspeptics_no"] !== undefined ? data["dyspeptics_no"] : <any>null;
            this.dyspnea_id = data["dyspnea_id"] !== undefined ? data["dyspnea_id"] : <any>null;
            this.dyspnea_name = data["dyspnea_name"] !== undefined ? data["dyspnea_name"] : <any>null;
            this.excreta = data["excreta"] !== undefined ? data["excreta"] : <any>null;
            this.excreta_name = data["excreta_name"] !== undefined ? data["excreta_name"] : <any>null;
            this.excreta_text = data["excreta_text"] !== undefined ? data["excreta_text"] : <any>null;
            this.eye = data["eye"] !== undefined ? data["eye"] : <any>null;
            this.general_state_id = data["general_state_id"] !== undefined ? data["general_state_id"] : <any>null;
            this.general_state_name = data["general_state_name"] !== undefined ? data["general_state_name"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.heart_noise_id = data["heart_noise_id"] !== undefined ? data["heart_noise_id"] : <any>null;
            this.heart_noise_name = data["heart_noise_name"] !== undefined ? data["heart_noise_name"] : <any>null;
            this.heart_pulse_id = data["heart_pulse_id"] !== undefined ? data["heart_pulse_id"] : <any>null;
            this.heart_pulse_name = data["heart_pulse_name"] !== undefined ? data["heart_pulse_name"] : <any>null;
            this.heart_rate_id = data["heart_rate_id"] !== undefined ? data["heart_rate_id"] : <any>null;
            this.heart_rate_name = data["heart_rate_name"] !== undefined ? data["heart_rate_name"] : <any>null;
            this.heart_tone_id = data["heart_tone_id"] !== undefined ? data["heart_tone_id"] : <any>null;
            this.heart_tone_name = data["heart_tone_name"] !== undefined ? data["heart_tone_name"] : <any>null;
            this.heart_tone_noise = data["heart_tone_noise"] !== undefined ? data["heart_tone_noise"] : <any>null;
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
            this.lion_tapping_left = data["lion_tapping_left"] !== undefined ? data["lion_tapping_left"] : <any>null;
            this.lion_tapping_right = data["lion_tapping_right"] !== undefined ? data["lion_tapping_right"] : <any>null;
            this.liver_normal_large = data["liver_normal_large"] !== undefined ? data["liver_normal_large"] : <any>null;
            this.liver_ortner = data["liver_ortner"] !== undefined ? data["liver_ortner"] : <any>null;
            this.liver_size_text = data["liver_size_text"] !== undefined ? data["liver_size_text"] : <any>null;
            this.lungs_wheezing_id = data["lungs_wheezing_id"] !== undefined ? data["lungs_wheezing_id"] : <any>null;
            this.lungs_wheezing_text = data["lungs_wheezing_text"] !== undefined ? data["lungs_wheezing_text"] : <any>null;
            this.lymph_nodes_normal_large = data["lymph_nodes_normal_large"] !== undefined ? data["lymph_nodes_normal_large"] : <any>null;
            this.lymph_nodes_painful_unpainful = data["lymph_nodes_painful_unpainful"] !== undefined ? data["lymph_nodes_painful_unpainful"] : <any>null;
            this.lymph_nodes_text = data["lymph_nodes_text"] !== undefined ? data["lymph_nodes_text"] : <any>null;
            this.meningeal_reflexes = data["meningeal_reflexes"] !== undefined ? data["meningeal_reflexes"] : <any>null;
            this.motor = data["motor"] !== undefined ? data["motor"] : <any>null;
            this.multiple_zeva_clean_hyper = data["multiple_zeva_clean_hyper"] !== undefined ? data["multiple_zeva_clean_hyper"] : <any>null;
            this.pathological_reflexes = data["pathological_reflexes"] !== undefined ? data["pathological_reflexes"] : <any>null;
            this.penalties_anisocoria = data["penalties_anisocoria"] !== undefined ? data["penalties_anisocoria"] : <any>null;
            this.penalties_anisocoria_name = data["penalties_anisocoria_name"] !== undefined ? data["penalties_anisocoria_name"] : <any>null;
            this.penalties_d_s_id = data["penalties_d_s_id"] !== undefined ? data["penalties_d_s_id"] : <any>null;
            this.penalties_d_s_name = data["penalties_d_s_name"] !== undefined ? data["penalties_d_s_name"] : <any>null;
            this.penalties_id = data["penalties_id"] !== undefined ? data["penalties_id"] : <any>null;
            this.penalties_light = data["penalties_light"] !== undefined ? data["penalties_light"] : <any>null;
            this.penalties_light_name = data["penalties_light_name"] !== undefined ? data["penalties_light_name"] : <any>null;
            this.penalties_name = data["penalties_name"] !== undefined ? data["penalties_name"] : <any>null;
            this.penalties_nystagmus = data["penalties_nystagmus"] !== undefined ? data["penalties_nystagmus"] : <any>null;
            this.penalties_nystagmus_name = data["penalties_nystagmus_name"] !== undefined ? data["penalties_nystagmus_name"] : <any>null;
            this.perc_lungs_sound_id = data["perc_lungs_sound_id"] !== undefined ? data["perc_lungs_sound_id"] : <any>null;
            this.perc_lungs_sound_name = data["perc_lungs_sound_name"] !== undefined ? data["perc_lungs_sound_name"] : <any>null;
            this.perc_lungs_sound_text = data["perc_lungs_sound_text"] !== undefined ? data["perc_lungs_sound_text"] : <any>null;
            this.post_therapy_hemodynamics = data["post_therapy_hemodynamics"] !== undefined ? data["post_therapy_hemodynamics"] : <any>null;
            this.ps = data["ps"] !== undefined ? data["ps"] : <any>null;
            this.pulse_oximetry = data["pulse_oximetry"] !== undefined ? data["pulse_oximetry"] : <any>null;
            this.reflexes_d_s_id = data["reflexes_d_s_id"] !== undefined ? data["reflexes_d_s_id"] : <any>null;
            this.reflexes_d_s_name = data["reflexes_d_s_name"] !== undefined ? data["reflexes_d_s_name"] : <any>null;
            this.reflexes_name = data["reflexes_name"] !== undefined ? data["reflexes_name"] : <any>null;
            this.skin_integ_acrosian = data["skin_integ_acrosian"] !== undefined ? data["skin_integ_acrosian"] : <any>null;
            this.skin_integ_cyanotic = data["skin_integ_cyanotic"] !== undefined ? data["skin_integ_cyanotic"] : <any>null;
            this.skin_integ_dry = data["skin_integ_dry"] !== undefined ? data["skin_integ_dry"] : <any>null;
            this.skin_integ_earthy = data["skin_integ_earthy"] !== undefined ? data["skin_integ_earthy"] : <any>null;
            this.skin_integ_hyperemetic = data["skin_integ_hyperemetic"] !== undefined ? data["skin_integ_hyperemetic"] : <any>null;
            this.skin_integ_icteric = data["skin_integ_icteric"] !== undefined ? data["skin_integ_icteric"] : <any>null;
            this.skin_integ_marbleness = data["skin_integ_marbleness"] !== undefined ? data["skin_integ_marbleness"] : <any>null;
            this.skin_integ_normal = data["skin_integ_normal"] !== undefined ? data["skin_integ_normal"] : <any>null;
            this.skin_integ_pale = data["skin_integ_pale"] !== undefined ? data["skin_integ_pale"] : <any>null;
            this.skin_integ_profuse = data["skin_integ_profuse"] !== undefined ? data["skin_integ_profuse"] : <any>null;
            this.skin_integ_rashes = data["skin_integ_rashes"] !== undefined ? data["skin_integ_rashes"] : <any>null;
            this.stomach_ascites = data["stomach_ascites"] !== undefined ? data["stomach_ascites"] : <any>null;
            this.stomach_breathing_involved = data["stomach_breathing_involved"] !== undefined ? data["stomach_breathing_involved"] : <any>null;
            this.stomach_breathing_involved_name = data["stomach_breathing_involved_name"] !== undefined ? data["stomach_breathing_involved_name"] : <any>null;
            this.stomach_disklike = data["stomach_disklike"] !== undefined ? data["stomach_disklike"] : <any>null;
            this.stomach_hard = data["stomach_hard"] !== undefined ? data["stomach_hard"] : <any>null;
            this.stomach_infliat = data["stomach_infliat"] !== undefined ? data["stomach_infliat"] : <any>null;
            this.stomach_normal = data["stomach_normal"] !== undefined ? data["stomach_normal"] : <any>null;
            this.stomach_painful = data["stomach_painful"] !== undefined ? data["stomach_painful"] : <any>null;
            this.stomach_peritonit = data["stomach_peritonit"] !== undefined ? data["stomach_peritonit"] : <any>null;
            this.stomach_peritonit_name = data["stomach_peritonit_name"] !== undefined ? data["stomach_peritonit_name"] : <any>null;
            this.stomach_soft = data["stomach_soft"] !== undefined ? data["stomach_soft"] : <any>null;
            this.stomach_text = data["stomach_text"] !== undefined ? data["stomach_text"] : <any>null;
            this.stomach_unpainful = data["stomach_unpainful"] !== undefined ? data["stomach_unpainful"] : <any>null;
            this.tendon_reflexes_id = data["tendon_reflexes_id"] !== undefined ? data["tendon_reflexes_id"] : <any>null;
            this.tendon_reflexes_name = data["tendon_reflexes_name"] !== undefined ? data["tendon_reflexes_name"] : <any>null;
            this.titles = data["titles"] !== undefined ? data["titles"] : <any>null;
            this.titles_text = data["titles_text"] !== undefined ? data["titles_text"] : <any>null;
            this.tongue_clean_furred = data["tongue_clean_furred"] !== undefined ? data["tongue_clean_furred"] : <any>null;
            this.tongue_clean_furred_name = data["tongue_clean_furred_name"] !== undefined ? data["tongue_clean_furred_name"] : <any>null;
            this.tongue_weat_dry = data["tongue_weat_dry"] !== undefined ? data["tongue_weat_dry"] : <any>null;
            this.tongue_weat_dry_name = data["tongue_weat_dry_name"] !== undefined ? data["tongue_weat_dry_name"] : <any>null;
            this.urine_text = data["urine_text"] !== undefined ? data["urine_text"] : <any>null;
            this.verbal = data["verbal"] !== undefined ? data["verbal"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePartDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePartDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ad"] = this.ad !== undefined ? this.ad : <any>null;
        data["addition_objective"] = this.addition_objective !== undefined ? this.addition_objective : <any>null;
        data["admax"] = this.admax !== undefined ? this.admax : <any>null;
        data["adn"] = this.adn !== undefined ? this.adn : <any>null;
        data["alco_breath"] = this.alco_breath !== undefined ? this.alco_breath : <any>null;
        data["alco_emotion_lability"] = this.alco_emotion_lability !== undefined ? this.alco_emotion_lability : <any>null;
        data["alco_inadequate"] = this.alco_inadequate !== undefined ? this.alco_inadequate : <any>null;
        data["alco_romberg_pose"] = this.alco_romberg_pose !== undefined ? this.alco_romberg_pose : <any>null;
        data["alco_shaky_walk"] = this.alco_shaky_walk !== undefined ? this.alco_shaky_walk : <any>null;
        data["alco_speach_behavior"] = this.alco_speach_behavior !== undefined ? this.alco_speach_behavior : <any>null;
        data["almonds_normal_large"] = this.almonds_normal_large !== undefined ? this.almonds_normal_large : <any>null;
        data["almonds_plaque"] = this.almonds_plaque !== undefined ? this.almonds_plaque : <any>null;
        data["behaviour_id"] = this.behaviour_id !== undefined ? this.behaviour_id : <any>null;
        data["behaviour_name"] = this.behaviour_name !== undefined ? this.behaviour_name : <any>null;
        data["bodytemp"] = this.bodytemp !== undefined ? this.bodytemp : <any>null;
        data["breath_absent"] = this.breath_absent !== undefined ? this.breath_absent : <any>null;
        data["breath_bronch"] = this.breath_bronch !== undefined ? this.breath_bronch : <any>null;
        data["breath_evenly"] = this.breath_evenly !== undefined ? this.breath_evenly : <any>null;
        data["breath_hard"] = this.breath_hard !== undefined ? this.breath_hard : <any>null;
        data["breath_puer"] = this.breath_puer !== undefined ? this.breath_puer : <any>null;
        data["breath_text"] = this.breath_text !== undefined ? this.breath_text : <any>null;
        data["breath_vesicul"] = this.breath_vesicul !== undefined ? this.breath_vesicul : <any>null;
        data["breath_weak"] = this.breath_weak !== undefined ? this.breath_weak : <any>null;
        data["card_delivery_id"] = this.card_delivery_id !== undefined ? this.card_delivery_id : <any>null;
        data["chd"] = this.chd !== undefined ? this.chd : <any>null;
        data["chss"] = this.chss !== undefined ? this.chss : <any>null;
        data["conscious_id"] = this.conscious_id !== undefined ? this.conscious_id : <any>null;
        data["conscious_name"] = this.conscious_name !== undefined ? this.conscious_name : <any>null;
        data["diuresis_disuria"] = this.diuresis_disuria !== undefined ? this.diuresis_disuria : <any>null;
        data["diuresis_hematuria"] = this.diuresis_hematuria !== undefined ? this.diuresis_hematuria : <any>null;
        data["diuresis_n"] = this.diuresis_n !== undefined ? this.diuresis_n : <any>null;
        data["diuresis_oliguria"] = this.diuresis_oliguria !== undefined ? this.diuresis_oliguria : <any>null;
        data["dyspeptic_diarrhea"] = this.dyspeptic_diarrhea !== undefined ? this.dyspeptic_diarrhea : <any>null;
        data["dyspeptic_nausea"] = this.dyspeptic_nausea !== undefined ? this.dyspeptic_nausea : <any>null;
        data["dyspeptic_retch"] = this.dyspeptic_retch !== undefined ? this.dyspeptic_retch : <any>null;
        data["dyspeptics_no"] = this.dyspeptics_no !== undefined ? this.dyspeptics_no : <any>null;
        data["dyspnea_id"] = this.dyspnea_id !== undefined ? this.dyspnea_id : <any>null;
        data["dyspnea_name"] = this.dyspnea_name !== undefined ? this.dyspnea_name : <any>null;
        data["excreta"] = this.excreta !== undefined ? this.excreta : <any>null;
        data["excreta_name"] = this.excreta_name !== undefined ? this.excreta_name : <any>null;
        data["excreta_text"] = this.excreta_text !== undefined ? this.excreta_text : <any>null;
        data["eye"] = this.eye !== undefined ? this.eye : <any>null;
        data["general_state_id"] = this.general_state_id !== undefined ? this.general_state_id : <any>null;
        data["general_state_name"] = this.general_state_name !== undefined ? this.general_state_name : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["heart_noise_id"] = this.heart_noise_id !== undefined ? this.heart_noise_id : <any>null;
        data["heart_noise_name"] = this.heart_noise_name !== undefined ? this.heart_noise_name : <any>null;
        data["heart_pulse_id"] = this.heart_pulse_id !== undefined ? this.heart_pulse_id : <any>null;
        data["heart_pulse_name"] = this.heart_pulse_name !== undefined ? this.heart_pulse_name : <any>null;
        data["heart_rate_id"] = this.heart_rate_id !== undefined ? this.heart_rate_id : <any>null;
        data["heart_rate_name"] = this.heart_rate_name !== undefined ? this.heart_rate_name : <any>null;
        data["heart_tone_id"] = this.heart_tone_id !== undefined ? this.heart_tone_id : <any>null;
        data["heart_tone_name"] = this.heart_tone_name !== undefined ? this.heart_tone_name : <any>null;
        data["heart_tone_noise"] = this.heart_tone_noise !== undefined ? this.heart_tone_noise : <any>null;
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        data["lion_tapping_left"] = this.lion_tapping_left !== undefined ? this.lion_tapping_left : <any>null;
        data["lion_tapping_right"] = this.lion_tapping_right !== undefined ? this.lion_tapping_right : <any>null;
        data["liver_normal_large"] = this.liver_normal_large !== undefined ? this.liver_normal_large : <any>null;
        data["liver_ortner"] = this.liver_ortner !== undefined ? this.liver_ortner : <any>null;
        data["liver_size_text"] = this.liver_size_text !== undefined ? this.liver_size_text : <any>null;
        data["lungs_wheezing_id"] = this.lungs_wheezing_id !== undefined ? this.lungs_wheezing_id : <any>null;
        data["lungs_wheezing_text"] = this.lungs_wheezing_text !== undefined ? this.lungs_wheezing_text : <any>null;
        data["lymph_nodes_normal_large"] = this.lymph_nodes_normal_large !== undefined ? this.lymph_nodes_normal_large : <any>null;
        data["lymph_nodes_painful_unpainful"] = this.lymph_nodes_painful_unpainful !== undefined ? this.lymph_nodes_painful_unpainful : <any>null;
        data["lymph_nodes_text"] = this.lymph_nodes_text !== undefined ? this.lymph_nodes_text : <any>null;
        data["meningeal_reflexes"] = this.meningeal_reflexes !== undefined ? this.meningeal_reflexes : <any>null;
        data["motor"] = this.motor !== undefined ? this.motor : <any>null;
        data["multiple_zeva_clean_hyper"] = this.multiple_zeva_clean_hyper !== undefined ? this.multiple_zeva_clean_hyper : <any>null;
        data["pathological_reflexes"] = this.pathological_reflexes !== undefined ? this.pathological_reflexes : <any>null;
        data["penalties_anisocoria"] = this.penalties_anisocoria !== undefined ? this.penalties_anisocoria : <any>null;
        data["penalties_anisocoria_name"] = this.penalties_anisocoria_name !== undefined ? this.penalties_anisocoria_name : <any>null;
        data["penalties_d_s_id"] = this.penalties_d_s_id !== undefined ? this.penalties_d_s_id : <any>null;
        data["penalties_d_s_name"] = this.penalties_d_s_name !== undefined ? this.penalties_d_s_name : <any>null;
        data["penalties_id"] = this.penalties_id !== undefined ? this.penalties_id : <any>null;
        data["penalties_light"] = this.penalties_light !== undefined ? this.penalties_light : <any>null;
        data["penalties_light_name"] = this.penalties_light_name !== undefined ? this.penalties_light_name : <any>null;
        data["penalties_name"] = this.penalties_name !== undefined ? this.penalties_name : <any>null;
        data["penalties_nystagmus"] = this.penalties_nystagmus !== undefined ? this.penalties_nystagmus : <any>null;
        data["penalties_nystagmus_name"] = this.penalties_nystagmus_name !== undefined ? this.penalties_nystagmus_name : <any>null;
        data["perc_lungs_sound_id"] = this.perc_lungs_sound_id !== undefined ? this.perc_lungs_sound_id : <any>null;
        data["perc_lungs_sound_name"] = this.perc_lungs_sound_name !== undefined ? this.perc_lungs_sound_name : <any>null;
        data["perc_lungs_sound_text"] = this.perc_lungs_sound_text !== undefined ? this.perc_lungs_sound_text : <any>null;
        data["post_therapy_hemodynamics"] = this.post_therapy_hemodynamics !== undefined ? this.post_therapy_hemodynamics : <any>null;
        data["ps"] = this.ps !== undefined ? this.ps : <any>null;
        data["pulse_oximetry"] = this.pulse_oximetry !== undefined ? this.pulse_oximetry : <any>null;
        data["reflexes_d_s_id"] = this.reflexes_d_s_id !== undefined ? this.reflexes_d_s_id : <any>null;
        data["reflexes_d_s_name"] = this.reflexes_d_s_name !== undefined ? this.reflexes_d_s_name : <any>null;
        data["reflexes_name"] = this.reflexes_name !== undefined ? this.reflexes_name : <any>null;
        data["skin_integ_acrosian"] = this.skin_integ_acrosian !== undefined ? this.skin_integ_acrosian : <any>null;
        data["skin_integ_cyanotic"] = this.skin_integ_cyanotic !== undefined ? this.skin_integ_cyanotic : <any>null;
        data["skin_integ_dry"] = this.skin_integ_dry !== undefined ? this.skin_integ_dry : <any>null;
        data["skin_integ_earthy"] = this.skin_integ_earthy !== undefined ? this.skin_integ_earthy : <any>null;
        data["skin_integ_hyperemetic"] = this.skin_integ_hyperemetic !== undefined ? this.skin_integ_hyperemetic : <any>null;
        data["skin_integ_icteric"] = this.skin_integ_icteric !== undefined ? this.skin_integ_icteric : <any>null;
        data["skin_integ_marbleness"] = this.skin_integ_marbleness !== undefined ? this.skin_integ_marbleness : <any>null;
        data["skin_integ_normal"] = this.skin_integ_normal !== undefined ? this.skin_integ_normal : <any>null;
        data["skin_integ_pale"] = this.skin_integ_pale !== undefined ? this.skin_integ_pale : <any>null;
        data["skin_integ_profuse"] = this.skin_integ_profuse !== undefined ? this.skin_integ_profuse : <any>null;
        data["skin_integ_rashes"] = this.skin_integ_rashes !== undefined ? this.skin_integ_rashes : <any>null;
        data["stomach_ascites"] = this.stomach_ascites !== undefined ? this.stomach_ascites : <any>null;
        data["stomach_breathing_involved"] = this.stomach_breathing_involved !== undefined ? this.stomach_breathing_involved : <any>null;
        data["stomach_breathing_involved_name"] = this.stomach_breathing_involved_name !== undefined ? this.stomach_breathing_involved_name : <any>null;
        data["stomach_disklike"] = this.stomach_disklike !== undefined ? this.stomach_disklike : <any>null;
        data["stomach_hard"] = this.stomach_hard !== undefined ? this.stomach_hard : <any>null;
        data["stomach_infliat"] = this.stomach_infliat !== undefined ? this.stomach_infliat : <any>null;
        data["stomach_normal"] = this.stomach_normal !== undefined ? this.stomach_normal : <any>null;
        data["stomach_painful"] = this.stomach_painful !== undefined ? this.stomach_painful : <any>null;
        data["stomach_peritonit"] = this.stomach_peritonit !== undefined ? this.stomach_peritonit : <any>null;
        data["stomach_peritonit_name"] = this.stomach_peritonit_name !== undefined ? this.stomach_peritonit_name : <any>null;
        data["stomach_soft"] = this.stomach_soft !== undefined ? this.stomach_soft : <any>null;
        data["stomach_text"] = this.stomach_text !== undefined ? this.stomach_text : <any>null;
        data["stomach_unpainful"] = this.stomach_unpainful !== undefined ? this.stomach_unpainful : <any>null;
        data["tendon_reflexes_id"] = this.tendon_reflexes_id !== undefined ? this.tendon_reflexes_id : <any>null;
        data["tendon_reflexes_name"] = this.tendon_reflexes_name !== undefined ? this.tendon_reflexes_name : <any>null;
        data["titles"] = this.titles !== undefined ? this.titles : <any>null;
        data["titles_text"] = this.titles_text !== undefined ? this.titles_text : <any>null;
        data["tongue_clean_furred"] = this.tongue_clean_furred !== undefined ? this.tongue_clean_furred : <any>null;
        data["tongue_clean_furred_name"] = this.tongue_clean_furred_name !== undefined ? this.tongue_clean_furred_name : <any>null;
        data["tongue_weat_dry"] = this.tongue_weat_dry !== undefined ? this.tongue_weat_dry : <any>null;
        data["tongue_weat_dry_name"] = this.tongue_weat_dry_name !== undefined ? this.tongue_weat_dry_name : <any>null;
        data["urine_text"] = this.urine_text !== undefined ? this.urine_text : <any>null;
        data["verbal"] = this.verbal !== undefined ? this.verbal : <any>null;
        return data; 
    }
}

export interface ICardObjectivePartDtoFLAT {
    ad?: string | null;
    addition_objective?: string | null;
    admax?: string | null;
    adn?: string | null;
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;
    almonds_normal_large?: number | null;
    almonds_plaque?: boolean | null;
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    bodytemp?: string | null;
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    card_delivery_id?: number | null;
    chd?: string | null;
    chss?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    eye?: number | null;
    general_state_id?: number | null;
    general_state_name?: string | null;
    glucometry?: string | null;
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_pulse_id?: number | null;
    heart_pulse_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;
    heart_tone_noise?: boolean | null;
    is_created?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;
    liver_normal_large?: number | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;
    lungs_wheezing_id?: number | null;
    lungs_wheezing_text?: string | null;
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_text?: string | null;
    meningeal_reflexes?: boolean | null;
    motor?: number | null;
    multiple_zeva_clean_hyper?: number | null;
    pathological_reflexes?: boolean | null;
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;
    post_therapy_hemodynamics?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;
    titles?: boolean | null;
    titles_text?: string | null;
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;
    urine_text?: string | null;
    verbal?: number | null;
}

export class UploadFileForm implements IUploadFileForm {
    code?: string | null;
    file?: any | null;
    format?: number | null;
    group_code?: string | null;
    id?: number | null;
    name?: string | null;
    nn?: number | null;
    script?: string | null;
    sub_id?: number | null;
    type?: number | null;

    constructor(data?: IUploadFileForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.format = data["format"] !== undefined ? data["format"] : <any>null;
            this.group_code = data["group_code"] !== undefined ? data["group_code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nn = data["nn"] !== undefined ? data["nn"] : <any>null;
            this.script = data["script"] !== undefined ? data["script"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): UploadFileForm {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["format"] = this.format !== undefined ? this.format : <any>null;
        data["group_code"] = this.group_code !== undefined ? this.group_code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nn"] = this.nn !== undefined ? this.nn : <any>null;
        data["script"] = this.script !== undefined ? this.script : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IUploadFileForm {
    code?: string | null;
    file?: any | null;
    format?: number | null;
    group_code?: string | null;
    id?: number | null;
    name?: string | null;
    nn?: number | null;
    script?: string | null;
    sub_id?: number | null;
    type?: number | null;
}

export class CardObjectiveReflexesDto implements ICardObjectiveReflexesDto {
    meningeal_reflexes?: boolean | null;
    pathological_reflexes?: boolean | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;

    constructor(data?: ICardObjectiveReflexesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.meningeal_reflexes = data["meningeal_reflexes"] !== undefined ? data["meningeal_reflexes"] : <any>null;
            this.pathological_reflexes = data["pathological_reflexes"] !== undefined ? data["pathological_reflexes"] : <any>null;
            this.reflexes_d_s_id = data["reflexes_d_s_id"] !== undefined ? data["reflexes_d_s_id"] : <any>null;
            this.reflexes_d_s_name = data["reflexes_d_s_name"] !== undefined ? data["reflexes_d_s_name"] : <any>null;
            this.reflexes_name = data["reflexes_name"] !== undefined ? data["reflexes_name"] : <any>null;
            this.tendon_reflexes_id = data["tendon_reflexes_id"] !== undefined ? data["tendon_reflexes_id"] : <any>null;
            this.tendon_reflexes_name = data["tendon_reflexes_name"] !== undefined ? data["tendon_reflexes_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveReflexesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveReflexesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meningeal_reflexes"] = this.meningeal_reflexes !== undefined ? this.meningeal_reflexes : <any>null;
        data["pathological_reflexes"] = this.pathological_reflexes !== undefined ? this.pathological_reflexes : <any>null;
        data["reflexes_d_s_id"] = this.reflexes_d_s_id !== undefined ? this.reflexes_d_s_id : <any>null;
        data["reflexes_d_s_name"] = this.reflexes_d_s_name !== undefined ? this.reflexes_d_s_name : <any>null;
        data["reflexes_name"] = this.reflexes_name !== undefined ? this.reflexes_name : <any>null;
        data["tendon_reflexes_id"] = this.tendon_reflexes_id !== undefined ? this.tendon_reflexes_id : <any>null;
        data["tendon_reflexes_name"] = this.tendon_reflexes_name !== undefined ? this.tendon_reflexes_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveReflexesDto {
    meningeal_reflexes?: boolean | null;
    pathological_reflexes?: boolean | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;
}

export class BrigadeType implements IBrigadeType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IBrigadeType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeType {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class URI implements IURI {
    absolute?: boolean | null;
    authority?: string | null;
    fragment?: string | null;
    host?: string | null;
    opaque?: boolean | null;
    path?: string | null;
    port?: number | null;
    query?: string | null;
    rawAuthority?: string | null;
    rawFragment?: string | null;
    rawPath?: string | null;
    rawQuery?: string | null;
    rawSchemeSpecificPart?: string | null;
    rawUserInfo?: string | null;
    scheme?: string | null;
    schemeSpecificPart?: string | null;
    userInfo?: string | null;

    constructor(data?: IURI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.absolute = data["absolute"] !== undefined ? data["absolute"] : <any>null;
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
            this.fragment = data["fragment"] !== undefined ? data["fragment"] : <any>null;
            this.host = data["host"] !== undefined ? data["host"] : <any>null;
            this.opaque = data["opaque"] !== undefined ? data["opaque"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.port = data["port"] !== undefined ? data["port"] : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.rawAuthority = data["rawAuthority"] !== undefined ? data["rawAuthority"] : <any>null;
            this.rawFragment = data["rawFragment"] !== undefined ? data["rawFragment"] : <any>null;
            this.rawPath = data["rawPath"] !== undefined ? data["rawPath"] : <any>null;
            this.rawQuery = data["rawQuery"] !== undefined ? data["rawQuery"] : <any>null;
            this.rawSchemeSpecificPart = data["rawSchemeSpecificPart"] !== undefined ? data["rawSchemeSpecificPart"] : <any>null;
            this.rawUserInfo = data["rawUserInfo"] !== undefined ? data["rawUserInfo"] : <any>null;
            this.scheme = data["scheme"] !== undefined ? data["scheme"] : <any>null;
            this.schemeSpecificPart = data["schemeSpecificPart"] !== undefined ? data["schemeSpecificPart"] : <any>null;
            this.userInfo = data["userInfo"] !== undefined ? data["userInfo"] : <any>null;
        }
    }

    static fromJS(data: any): URI {
        data = typeof data === 'object' ? data : {};
        let result = new URI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absolute"] = this.absolute !== undefined ? this.absolute : <any>null;
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        data["fragment"] = this.fragment !== undefined ? this.fragment : <any>null;
        data["host"] = this.host !== undefined ? this.host : <any>null;
        data["opaque"] = this.opaque !== undefined ? this.opaque : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["port"] = this.port !== undefined ? this.port : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["rawAuthority"] = this.rawAuthority !== undefined ? this.rawAuthority : <any>null;
        data["rawFragment"] = this.rawFragment !== undefined ? this.rawFragment : <any>null;
        data["rawPath"] = this.rawPath !== undefined ? this.rawPath : <any>null;
        data["rawQuery"] = this.rawQuery !== undefined ? this.rawQuery : <any>null;
        data["rawSchemeSpecificPart"] = this.rawSchemeSpecificPart !== undefined ? this.rawSchemeSpecificPart : <any>null;
        data["rawUserInfo"] = this.rawUserInfo !== undefined ? this.rawUserInfo : <any>null;
        data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
        data["schemeSpecificPart"] = this.schemeSpecificPart !== undefined ? this.schemeSpecificPart : <any>null;
        data["userInfo"] = this.userInfo !== undefined ? this.userInfo : <any>null;
        return data; 
    }
}

export interface IURI {
    absolute?: boolean | null;
    authority?: string | null;
    fragment?: string | null;
    host?: string | null;
    opaque?: boolean | null;
    path?: string | null;
    port?: number | null;
    query?: string | null;
    rawAuthority?: string | null;
    rawFragment?: string | null;
    rawPath?: string | null;
    rawQuery?: string | null;
    rawSchemeSpecificPart?: string | null;
    rawUserInfo?: string | null;
    scheme?: string | null;
    schemeSpecificPart?: string | null;
    userInfo?: string | null;
}

export class URL implements IURL {
    authority?: string | null;
    content?: any | null;
    defaultPort?: number | null;
    file?: string | null;
    host?: string | null;
    path?: string | null;
    port?: number | null;
    protocol?: string | null;
    query?: string | null;
    ref?: string | null;
    userInfo?: string | null;

    constructor(data?: IURL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
            this.content = data["content"] !== undefined ? data["content"] : <any>null;
            this.defaultPort = data["defaultPort"] !== undefined ? data["defaultPort"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.host = data["host"] !== undefined ? data["host"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.port = data["port"] !== undefined ? data["port"] : <any>null;
            this.protocol = data["protocol"] !== undefined ? data["protocol"] : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.ref = data["ref"] !== undefined ? data["ref"] : <any>null;
            this.userInfo = data["userInfo"] !== undefined ? data["userInfo"] : <any>null;
        }
    }

    static fromJS(data: any): URL {
        data = typeof data === 'object' ? data : {};
        let result = new URL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        data["content"] = this.content !== undefined ? this.content : <any>null;
        data["defaultPort"] = this.defaultPort !== undefined ? this.defaultPort : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["host"] = this.host !== undefined ? this.host : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["port"] = this.port !== undefined ? this.port : <any>null;
        data["protocol"] = this.protocol !== undefined ? this.protocol : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["ref"] = this.ref !== undefined ? this.ref : <any>null;
        data["userInfo"] = this.userInfo !== undefined ? this.userInfo : <any>null;
        return data; 
    }
}

export interface IURL {
    authority?: string | null;
    content?: any | null;
    defaultPort?: number | null;
    file?: string | null;
    host?: string | null;
    path?: string | null;
    port?: number | null;
    protocol?: string | null;
    query?: string | null;
    ref?: string | null;
    userInfo?: string | null;
}

export class Chat implements IChat {
    archive?: boolean | null;
    chatMessage?: ChatMessage | null;
    creator?: ChatUser | null;
    date?: LocalDateTime | null;
    id?: number | null;
    name?: string | null;
    online?: boolean | null;
    position?: string | null;
    subdivision_name?: string | null;
    type?: ChatType | null;
    unread_count?: number | null;
    users?: ChatUser[] | null;

    constructor(data?: IChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archive = data["archive"] !== undefined ? data["archive"] : <any>null;
            this.chatMessage = data["chatMessage"] ? ChatMessage.fromJS(data["chatMessage"]) : <any>null;
            this.creator = data["creator"] ? ChatUser.fromJS(data["creator"]) : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.position = data["position"] !== undefined ? data["position"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.unread_count = data["unread_count"] !== undefined ? data["unread_count"] : <any>null;
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(ChatUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Chat {
        data = typeof data === 'object' ? data : {};
        let result = new Chat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archive"] = this.archive !== undefined ? this.archive : <any>null;
        data["chatMessage"] = this.chatMessage ? this.chatMessage.toJSON() : <any>null;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["position"] = this.position !== undefined ? this.position : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["unread_count"] = this.unread_count !== undefined ? this.unread_count : <any>null;
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChat {
    archive?: boolean | null;
    chatMessage?: ChatMessage | null;
    creator?: ChatUser | null;
    date?: LocalDateTime | null;
    id?: number | null;
    name?: string | null;
    online?: boolean | null;
    position?: string | null;
    subdivision_name?: string | null;
    type?: ChatType | null;
    unread_count?: number | null;
    users?: ChatUser[] | null;
}

export class CardResultDeathDto implements ICardResultDeathDto {
    time?: LocalDateTime | null;

    constructor(data?: ICardResultDeathDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? LocalDateTime.fromJS(data["time"]) : <any>null;
        }
    }

    static fromJS(data: any): CardResultDeathDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDeathDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardResultDeathDto {
    time?: LocalDateTime | null;
}

export class ReferenceDto implements IReferenceDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IReferenceDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class DocumentItemDto implements IDocumentItemDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    performer_id?: number | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IDocumentItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.document_id = data["document_id"] !== undefined ? data["document_id"] : <any>null;
            this.document_name = data["document_name"] !== undefined ? data["document_name"] : <any>null;
            this.drug_id = data["drug_id"] !== undefined ? data["drug_id"] : <any>null;
            this.expiry_date = data["expiry_date"] ? LocalDateTime.fromJS(data["expiry_date"]) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.inner_amount = data["inner_amount"] !== undefined ? data["inner_amount"] : <any>null;
            this.is_reusable = data["is_reusable"] !== undefined ? data["is_reusable"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.minimum = data["minimum"] !== undefined ? data["minimum"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["document_id"] = this.document_id !== undefined ? this.document_id : <any>null;
        data["document_name"] = this.document_name !== undefined ? this.document_name : <any>null;
        data["drug_id"] = this.drug_id !== undefined ? this.drug_id : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toJSON() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["inner_amount"] = this.inner_amount !== undefined ? this.inner_amount : <any>null;
        data["is_reusable"] = this.is_reusable !== undefined ? this.is_reusable : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["minimum"] = this.minimum !== undefined ? this.minimum : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IDocumentItemDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    performer_id?: number | null;
    series_number?: number | null;
    type?: number | null;
}

export class Table implements ITable {
    code?: string | null;
    items?: Field[] | null;
    text?: string | null;
    type?: TableType | null;

    constructor(data?: ITable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Field.fromJS(item));
            }
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Table {
        data = typeof data === 'object' ? data : {};
        let result = new Table();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface ITable {
    code?: string | null;
    items?: Field[] | null;
    text?: string | null;
    type?: TableType | null;
}

export class LoginInfo implements ILoginInfo {
    authorities?: any | null;
    name?: string | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;

    constructor(data?: ILoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authorities = data["authorities"] !== undefined ? data["authorities"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.subdivisionName = data["subdivisionName"] !== undefined ? data["subdivisionName"] : <any>null;
        }
    }

    static fromJS(data: any): LoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorities"] = this.authorities !== undefined ? this.authorities : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["subdivisionName"] = this.subdivisionName !== undefined ? this.subdivisionName : <any>null;
        return data; 
    }
}

export interface ILoginInfo {
    authorities?: any | null;
    name?: string | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
}

export class IsoChronology implements IIsoChronology {
    calendarType?: string | null;
    id?: string | null;

    constructor(data?: IIsoChronology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calendarType = data["calendarType"] !== undefined ? data["calendarType"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
        }
    }

    static fromJS(data: any): IsoChronology {
        data = typeof data === 'object' ? data : {};
        let result = new IsoChronology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarType"] = this.calendarType !== undefined ? this.calendarType : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IIsoChronology {
    calendarType?: string | null;
    id?: string | null;
}

export class CallDto implements ICallDto {
    address?: CallFiasAddressDto | null;
    declarant?: CallDeclarantPartDto | null;
    general?: CallGeneralPartDto | null;
    patients?: CallPatientPartDto[] | null;
    similars?: string[] | null;

    constructor(data?: ICallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? CallFiasAddressDto.fromJS(data["address"]) : <any>null;
            this.declarant = data["declarant"] ? CallDeclarantPartDto.fromJS(data["declarant"]) : <any>null;
            this.general = data["general"] ? CallGeneralPartDto.fromJS(data["general"]) : <any>null;
            if (data["patients"] && data["patients"].constructor === Array) {
                this.patients = [];
                for (let item of data["patients"])
                    this.patients.push(CallPatientPartDto.fromJS(item));
            }
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
        }
    }

    static fromJS(data: any): CallDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["declarant"] = this.declarant ? this.declarant.toJSON() : <any>null;
        data["general"] = this.general ? this.general.toJSON() : <any>null;
        if (this.patients && this.patients.constructor === Array) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        return data; 
    }
}

export interface ICallDto {
    address?: CallFiasAddressDto | null;
    declarant?: CallDeclarantPartDto | null;
    general?: CallGeneralPartDto | null;
    patients?: CallPatientPartDto[] | null;
    similars?: string[] | null;
}

export class CardResultTransportingDto implements ICardResultTransportingDto {
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    transporting_date?: LocalDateTime | null;
    transporting_type_code?: string | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;

    constructor(data?: ICardResultTransportingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hosp_complications = data["hosp_complications"] !== undefined ? data["hosp_complications"] : <any>null;
            this.hosp_complications_text = data["hosp_complications_text"] !== undefined ? data["hosp_complications_text"] : <any>null;
            this.hosp_to_id = data["hosp_to_id"] !== undefined ? data["hosp_to_id"] : <any>null;
            this.hosp_to_name = data["hosp_to_name"] !== undefined ? data["hosp_to_name"] : <any>null;
            this.hosp_transportation_id = data["hosp_transportation_id"] !== undefined ? data["hosp_transportation_id"] : <any>null;
            this.hosp_transportation_name = data["hosp_transportation_name"] !== undefined ? data["hosp_transportation_name"] : <any>null;
            this.transporting_date = data["transporting_date"] ? LocalDateTime.fromJS(data["transporting_date"]) : <any>null;
            this.transporting_type_code = data["transporting_type_code"] !== undefined ? data["transporting_type_code"] : <any>null;
            this.transporting_type_id = data["transporting_type_id"] !== undefined ? data["transporting_type_id"] : <any>null;
            this.transporting_type_name = data["transporting_type_name"] !== undefined ? data["transporting_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultTransportingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTransportingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hosp_complications"] = this.hosp_complications !== undefined ? this.hosp_complications : <any>null;
        data["hosp_complications_text"] = this.hosp_complications_text !== undefined ? this.hosp_complications_text : <any>null;
        data["hosp_to_id"] = this.hosp_to_id !== undefined ? this.hosp_to_id : <any>null;
        data["hosp_to_name"] = this.hosp_to_name !== undefined ? this.hosp_to_name : <any>null;
        data["hosp_transportation_id"] = this.hosp_transportation_id !== undefined ? this.hosp_transportation_id : <any>null;
        data["hosp_transportation_name"] = this.hosp_transportation_name !== undefined ? this.hosp_transportation_name : <any>null;
        data["transporting_date"] = this.transporting_date ? this.transporting_date.toJSON() : <any>null;
        data["transporting_type_code"] = this.transporting_type_code !== undefined ? this.transporting_type_code : <any>null;
        data["transporting_type_id"] = this.transporting_type_id !== undefined ? this.transporting_type_id : <any>null;
        data["transporting_type_name"] = this.transporting_type_name !== undefined ? this.transporting_type_name : <any>null;
        return data; 
    }
}

export interface ICardResultTransportingDto {
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    transporting_date?: LocalDateTime | null;
    transporting_type_code?: string | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;
}

export class Geometry implements IGeometry {
    dimension?: number | null;
    firstPoint?: any | null;
    haveMeasure?: boolean | null;
    lastPoint?: any | null;
    measured?: boolean | null;
    srid?: number | null;
    type?: number | null;
    typeString?: string | null;
    value?: string | null;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dimension = data["dimension"] !== undefined ? data["dimension"] : <any>null;
            this.firstPoint = data["firstPoint"] !== undefined ? data["firstPoint"] : <any>null;
            this.haveMeasure = data["haveMeasure"] !== undefined ? data["haveMeasure"] : <any>null;
            this.lastPoint = data["lastPoint"] !== undefined ? data["lastPoint"] : <any>null;
            this.measured = data["measured"] !== undefined ? data["measured"] : <any>null;
            this.srid = data["srid"] !== undefined ? data["srid"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeString = data["typeString"] !== undefined ? data["typeString"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension !== undefined ? this.dimension : <any>null;
        data["firstPoint"] = this.firstPoint !== undefined ? this.firstPoint : <any>null;
        data["haveMeasure"] = this.haveMeasure !== undefined ? this.haveMeasure : <any>null;
        data["lastPoint"] = this.lastPoint !== undefined ? this.lastPoint : <any>null;
        data["measured"] = this.measured !== undefined ? this.measured : <any>null;
        data["srid"] = this.srid !== undefined ? this.srid : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeString"] = this.typeString !== undefined ? this.typeString : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IGeometry {
    dimension?: number | null;
    firstPoint?: any | null;
    haveMeasure?: boolean | null;
    lastPoint?: any | null;
    measured?: boolean | null;
    srid?: number | null;
    type?: number | null;
    typeString?: string | null;
    value?: string | null;
}

export class ReferenceTypeDto implements IReferenceTypeDto {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    system_value?: number | null;
    type?: string | null;

    constructor(data?: IReferenceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.default = data["default"] !== undefined ? data["default"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.system_value = data["system_value"] !== undefined ? data["system_value"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): ReferenceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["default"] = this.default !== undefined ? this.default : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["system_value"] = this.system_value !== undefined ? this.system_value : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReferenceTypeDto {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    system_value?: number | null;
    type?: string | null;
}

export class MobileCardRequest implements IMobileCardRequest {
    call_items?: MobileCall[] | null;
    guid?: string | null;

    constructor(data?: IMobileCardRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["call_items"] && data["call_items"].constructor === Array) {
                this.call_items = [];
                for (let item of data["call_items"])
                    this.call_items.push(MobileCall.fromJS(item));
            }
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.call_items && this.call_items.constructor === Array) {
            data["call_items"] = [];
            for (let item of this.call_items)
                data["call_items"].push(item.toJSON());
        }
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        return data; 
    }
}

export interface IMobileCardRequest {
    call_items?: MobileCall[] | null;
    guid?: string | null;
}

export class CardObjectiveTonsilsPartDto implements ICardObjectiveTonsilsPartDto {
    almonds_normal_large?: number | null;
    almonds_normal_large_name?: string | null;
    almonds_plaque?: boolean | null;

    constructor(data?: ICardObjectiveTonsilsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.almonds_normal_large = data["almonds_normal_large"] !== undefined ? data["almonds_normal_large"] : <any>null;
            this.almonds_normal_large_name = data["almonds_normal_large_name"] !== undefined ? data["almonds_normal_large_name"] : <any>null;
            this.almonds_plaque = data["almonds_plaque"] !== undefined ? data["almonds_plaque"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveTonsilsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveTonsilsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["almonds_normal_large"] = this.almonds_normal_large !== undefined ? this.almonds_normal_large : <any>null;
        data["almonds_normal_large_name"] = this.almonds_normal_large_name !== undefined ? this.almonds_normal_large_name : <any>null;
        data["almonds_plaque"] = this.almonds_plaque !== undefined ? this.almonds_plaque : <any>null;
        return data; 
    }
}

export interface ICardObjectiveTonsilsPartDto {
    almonds_normal_large?: number | null;
    almonds_normal_large_name?: string | null;
    almonds_plaque?: boolean | null;
}

export class CardAnamnesisHemodynamicsPartDto implements ICardAnamnesisHemodynamicsPartDto {
    post_therapy_hemodynamics?: string | null;

    constructor(data?: ICardAnamnesisHemodynamicsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.post_therapy_hemodynamics = data["post_therapy_hemodynamics"] !== undefined ? data["post_therapy_hemodynamics"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisHemodynamicsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisHemodynamicsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["post_therapy_hemodynamics"] = this.post_therapy_hemodynamics !== undefined ? this.post_therapy_hemodynamics : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisHemodynamicsPartDto {
    post_therapy_hemodynamics?: string | null;
}

export class PharmacyDocumentDto implements IPharmacyDocumentDto {
    card_id?: number | null;
    card_number?: string | null;
    counterparty_id?: number | null;
    counterparty_name?: string | null;
    date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    is_has_changes?: boolean | null;
    is_processed?: boolean | null;
    is_system?: boolean | null;
    items?: DocumentItemDto[] | null;
    number?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    process_date?: LocalDateTime | null;
    reason_id?: number | null;
    reason_text?: string | null;
    reason_type?: number | null;
    type?: number | null;
    type_text?: string | null;

    constructor(data?: IPharmacyDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.card_id = data["card_id"] !== undefined ? data["card_id"] : <any>null;
            this.card_number = data["card_number"] !== undefined ? data["card_number"] : <any>null;
            this.counterparty_id = data["counterparty_id"] !== undefined ? data["counterparty_id"] : <any>null;
            this.counterparty_name = data["counterparty_name"] !== undefined ? data["counterparty_name"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_has_changes = data["is_has_changes"] !== undefined ? data["is_has_changes"] : <any>null;
            this.is_processed = data["is_processed"] !== undefined ? data["is_processed"] : <any>null;
            this.is_system = data["is_system"] !== undefined ? data["is_system"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentItemDto.fromJS(item));
            }
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.process_date = data["process_date"] ? LocalDateTime.fromJS(data["process_date"]) : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_text = data["reason_text"] !== undefined ? data["reason_text"] : <any>null;
            this.reason_type = data["reason_type"] !== undefined ? data["reason_type"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_text = data["type_text"] !== undefined ? data["type_text"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["card_id"] = this.card_id !== undefined ? this.card_id : <any>null;
        data["card_number"] = this.card_number !== undefined ? this.card_number : <any>null;
        data["counterparty_id"] = this.counterparty_id !== undefined ? this.counterparty_id : <any>null;
        data["counterparty_name"] = this.counterparty_name !== undefined ? this.counterparty_name : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_has_changes"] = this.is_has_changes !== undefined ? this.is_has_changes : <any>null;
        data["is_processed"] = this.is_processed !== undefined ? this.is_processed : <any>null;
        data["is_system"] = this.is_system !== undefined ? this.is_system : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["process_date"] = this.process_date ? this.process_date.toJSON() : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_text"] = this.reason_text !== undefined ? this.reason_text : <any>null;
        data["reason_type"] = this.reason_type !== undefined ? this.reason_type : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_text"] = this.type_text !== undefined ? this.type_text : <any>null;
        return data; 
    }
}

export interface IPharmacyDocumentDto {
    card_id?: number | null;
    card_number?: string | null;
    counterparty_id?: number | null;
    counterparty_name?: string | null;
    date?: LocalDateTime | null;
    full_name?: string | null;
    id?: number | null;
    is_has_changes?: boolean | null;
    is_processed?: boolean | null;
    is_system?: boolean | null;
    items?: DocumentItemDto[] | null;
    number?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    process_date?: LocalDateTime | null;
    reason_id?: number | null;
    reason_text?: string | null;
    reason_type?: number | null;
    type?: number | null;
    type_text?: string | null;
}

export class BrigadeTypeDto implements IBrigadeTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IBrigadeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class RoutingDto implements IRoutingDto {
    hours?: string | null;
    km?: string | null;
    points?: RoutingPointDto[] | null;

    constructor(data?: IRoutingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hours = data["hours"] !== undefined ? data["hours"] : <any>null;
            this.km = data["km"] !== undefined ? data["km"] : <any>null;
            if (data["points"] && data["points"].constructor === Array) {
                this.points = [];
                for (let item of data["points"])
                    this.points.push(RoutingPointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoutingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoutingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hours"] = this.hours !== undefined ? this.hours : <any>null;
        data["km"] = this.km !== undefined ? this.km : <any>null;
        if (this.points && this.points.constructor === Array) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoutingDto {
    hours?: string | null;
    km?: string | null;
    points?: RoutingPointDto[] | null;
}

export class ScheduleType implements IScheduleType {
    days_off?: number | null;
    days_working?: number | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    name?: string | null;
    subdivision_id?: number | null;
    time_from?: string | null;
    time_working?: string | null;

    constructor(data?: IScheduleType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.days_off = data["days_off"] !== undefined ? data["days_off"] : <any>null;
            this.days_working = data["days_working"] !== undefined ? data["days_working"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.is_editable = data["is_editable"] !== undefined ? data["is_editable"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.time_from = data["time_from"] !== undefined ? data["time_from"] : <any>null;
            this.time_working = data["time_working"] !== undefined ? data["time_working"] : <any>null;
        }
    }

    static fromJS(data: any): ScheduleType {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["days_off"] = this.days_off !== undefined ? this.days_off : <any>null;
        data["days_working"] = this.days_working !== undefined ? this.days_working : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["is_editable"] = this.is_editable !== undefined ? this.is_editable : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["time_from"] = this.time_from !== undefined ? this.time_from : <any>null;
        data["time_working"] = this.time_working !== undefined ? this.time_working : <any>null;
        return data; 
    }
}

export interface IScheduleType {
    days_off?: number | null;
    days_working?: number | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    name?: string | null;
    subdivision_id?: number | null;
    time_from?: string | null;
    time_working?: string | null;
}

export class CardObjectiveBreathPartDto implements ICardObjectiveBreathPartDto {
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;

    constructor(data?: ICardObjectiveBreathPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.breath_absent = data["breath_absent"] !== undefined ? data["breath_absent"] : <any>null;
            this.breath_bronch = data["breath_bronch"] !== undefined ? data["breath_bronch"] : <any>null;
            this.breath_evenly = data["breath_evenly"] !== undefined ? data["breath_evenly"] : <any>null;
            this.breath_hard = data["breath_hard"] !== undefined ? data["breath_hard"] : <any>null;
            this.breath_puer = data["breath_puer"] !== undefined ? data["breath_puer"] : <any>null;
            this.breath_text = data["breath_text"] !== undefined ? data["breath_text"] : <any>null;
            this.breath_vesicul = data["breath_vesicul"] !== undefined ? data["breath_vesicul"] : <any>null;
            this.breath_weak = data["breath_weak"] !== undefined ? data["breath_weak"] : <any>null;
            this.dyspnea_id = data["dyspnea_id"] !== undefined ? data["dyspnea_id"] : <any>null;
            this.dyspnea_name = data["dyspnea_name"] !== undefined ? data["dyspnea_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveBreathPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveBreathPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["breath_absent"] = this.breath_absent !== undefined ? this.breath_absent : <any>null;
        data["breath_bronch"] = this.breath_bronch !== undefined ? this.breath_bronch : <any>null;
        data["breath_evenly"] = this.breath_evenly !== undefined ? this.breath_evenly : <any>null;
        data["breath_hard"] = this.breath_hard !== undefined ? this.breath_hard : <any>null;
        data["breath_puer"] = this.breath_puer !== undefined ? this.breath_puer : <any>null;
        data["breath_text"] = this.breath_text !== undefined ? this.breath_text : <any>null;
        data["breath_vesicul"] = this.breath_vesicul !== undefined ? this.breath_vesicul : <any>null;
        data["breath_weak"] = this.breath_weak !== undefined ? this.breath_weak : <any>null;
        data["dyspnea_id"] = this.dyspnea_id !== undefined ? this.dyspnea_id : <any>null;
        data["dyspnea_name"] = this.dyspnea_name !== undefined ? this.dyspnea_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveBreathPartDto {
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;
}

export class ListDtoOfPerformerDto implements IListDtoOfPerformerDto {
    list?: PerformerDto[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfPerformerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(PerformerDto.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfPerformerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfPerformerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfPerformerDto {
    list?: PerformerDto[] | null;
    size?: number | null;
    total?: number | null;
}

export class Unit implements IUnit {
    code?: string | null;
    name?: string | null;

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IUnit {
    code?: string | null;
    name?: string | null;
}

export class TransportBrigScheduleCreateDto implements ITransportBrigScheduleCreateDto {
    period_details?: PeriodDetails | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleCreateDto {
    period_details?: PeriodDetails | null;
    transport_id?: number | null;
}

export class CallDtoFLAT implements ICallDtoFLAT {
    action?: string | null;
    address?: CallFiasAddressDto | null;
    addressee?: number[] | null;
    audio_file_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: LocalDateTime | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
    is_unfounded?: boolean | null;
    patient?: CallPatientPartDto[] | null;
    performer_id?: number | null;
    performer_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    reason_id?: number | null;
    reason_name?: string | null;
    similars?: string[] | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICallDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"] !== undefined ? data["action"] : <any>null;
            this.address = data["address"] ? CallFiasAddressDto.fromJS(data["address"]) : <any>null;
            if (data["addressee"] && data["addressee"].constructor === Array) {
                this.addressee = [];
                for (let item of data["addressee"])
                    this.addressee.push(item);
            }
            this.audio_file_name = data["audio_file_name"] !== undefined ? data["audio_file_name"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_priority = data["call_priority"] !== undefined ? data["call_priority"] : <any>null;
            this.call_priority_name = data["call_priority_name"] !== undefined ? data["call_priority_name"] : <any>null;
            this.call_type_id = data["call_type_id"] !== undefined ? data["call_type_id"] : <any>null;
            this.call_type_name = data["call_type_name"] !== undefined ? data["call_type_name"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.declarant_type_id = data["declarant_type_id"] !== undefined ? data["declarant_type_id"] : <any>null;
            this.declarant_type_name = data["declarant_type_name"] !== undefined ? data["declarant_type_name"] : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            if (data["patient"] && data["patient"].constructor === Array) {
                this.patient = [];
                for (let item of data["patient"])
                    this.patient.push(CallPatientPartDto.fromJS(item));
            }
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.primary_call_id = data["primary_call_id"] !== undefined ? data["primary_call_id"] : <any>null;
            this.primary_call_number = data["primary_call_number"] !== undefined ? data["primary_call_number"] : <any>null;
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_extra = data["reason_extra"] !== undefined ? data["reason_extra"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CallDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action !== undefined ? this.action : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        if (this.addressee && this.addressee.constructor === Array) {
            data["addressee"] = [];
            for (let item of this.addressee)
                data["addressee"].push(item);
        }
        data["audio_file_name"] = this.audio_file_name !== undefined ? this.audio_file_name : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_priority"] = this.call_priority !== undefined ? this.call_priority : <any>null;
        data["call_priority_name"] = this.call_priority_name !== undefined ? this.call_priority_name : <any>null;
        data["call_type_id"] = this.call_type_id !== undefined ? this.call_type_id : <any>null;
        data["call_type_name"] = this.call_type_name !== undefined ? this.call_type_name : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["declarant_type_id"] = this.declarant_type_id !== undefined ? this.declarant_type_id : <any>null;
        data["declarant_type_name"] = this.declarant_type_name !== undefined ? this.declarant_type_name : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        if (this.patient && this.patient.constructor === Array) {
            data["patient"] = [];
            for (let item of this.patient)
                data["patient"].push(item.toJSON());
        }
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["primary_call_id"] = this.primary_call_id !== undefined ? this.primary_call_id : <any>null;
        data["primary_call_number"] = this.primary_call_number !== undefined ? this.primary_call_number : <any>null;
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_extra"] = this.reason_extra !== undefined ? this.reason_extra : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICallDtoFLAT {
    action?: string | null;
    address?: CallFiasAddressDto | null;
    addressee?: number[] | null;
    audio_file_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: LocalDateTime | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
    is_unfounded?: boolean | null;
    patient?: CallPatientPartDto[] | null;
    performer_id?: number | null;
    performer_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    reason_id?: number | null;
    reason_name?: string | null;
    similars?: string[] | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class PerformerBrigScheduleAvailableDto implements IPerformerBrigScheduleAvailableDto {
    first_name?: string | null;
    patronymic?: string | null;
    performer_id?: number | null;
    periods?: Period[] | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: IPerformerBrigScheduleAvailableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            if (data["periods"] && data["periods"].constructor === Array) {
                this.periods = [];
                for (let item of data["periods"])
                    this.periods.push(Period.fromJS(item));
            }
            this.second_name = data["second_name"] !== undefined ? data["second_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleAvailableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleAvailableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        if (this.periods && this.periods.constructor === Array) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item.toJSON());
        }
        data["second_name"] = this.second_name !== undefined ? this.second_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleAvailableDto {
    first_name?: string | null;
    patronymic?: string | null;
    performer_id?: number | null;
    periods?: Period[] | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class CallBrigadePartDto implements ICallBrigadePartDto {
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_subdivision_id?: number | null;
    brigade_subdivision_name?: string | null;
    brigade_subdivision_short_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    performers?: PerformerShortDto[] | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    state?: string | null;
    state_date?: LocalDateTime | null;
    transport_brand?: string | null;
    transport_class_name?: string | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    transport_type_name?: string | null;

    constructor(data?: ICallBrigadePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
            this.brigade_name = data["brigade_name"] !== undefined ? data["brigade_name"] : <any>null;
            this.brigade_schedule_id = data["brigade_schedule_id"] !== undefined ? data["brigade_schedule_id"] : <any>null;
            this.brigade_subdivision_id = data["brigade_subdivision_id"] !== undefined ? data["brigade_subdivision_id"] : <any>null;
            this.brigade_subdivision_name = data["brigade_subdivision_name"] !== undefined ? data["brigade_subdivision_name"] : <any>null;
            this.brigade_subdivision_short_name = data["brigade_subdivision_short_name"] !== undefined ? data["brigade_subdivision_short_name"] : <any>null;
            this.brigade_type_code = data["brigade_type_code"] !== undefined ? data["brigade_type_code"] : <any>null;
            this.brigade_type_id = data["brigade_type_id"] !== undefined ? data["brigade_type_id"] : <any>null;
            this.brigade_type_name = data["brigade_type_name"] !== undefined ? data["brigade_type_name"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_reason_id = data["call_reason_id"] !== undefined ? data["call_reason_id"] : <any>null;
            this.call_reason_name = data["call_reason_name"] !== undefined ? data["call_reason_name"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["messages"] && data["messages"].constructor === Array) {
                this.messages = [];
                for (let item of data["messages"])
                    this.messages.push(MessageEventDto.fromJS(item));
            }
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerShortDto.fromJS(item));
            }
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.state = data["state"] !== undefined ? data["state"] : <any>null;
            this.state_date = data["state_date"] ? LocalDateTime.fromJS(data["state_date"]) : <any>null;
            this.transport_brand = data["transport_brand"] !== undefined ? data["transport_brand"] : <any>null;
            this.transport_class_name = data["transport_class_name"] !== undefined ? data["transport_class_name"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
            this.transport_statemark = data["transport_statemark"] !== undefined ? data["transport_statemark"] : <any>null;
            this.transport_type_name = data["transport_type_name"] !== undefined ? data["transport_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallBrigadePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallBrigadePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        data["brigade_name"] = this.brigade_name !== undefined ? this.brigade_name : <any>null;
        data["brigade_schedule_id"] = this.brigade_schedule_id !== undefined ? this.brigade_schedule_id : <any>null;
        data["brigade_subdivision_id"] = this.brigade_subdivision_id !== undefined ? this.brigade_subdivision_id : <any>null;
        data["brigade_subdivision_name"] = this.brigade_subdivision_name !== undefined ? this.brigade_subdivision_name : <any>null;
        data["brigade_subdivision_short_name"] = this.brigade_subdivision_short_name !== undefined ? this.brigade_subdivision_short_name : <any>null;
        data["brigade_type_code"] = this.brigade_type_code !== undefined ? this.brigade_type_code : <any>null;
        data["brigade_type_id"] = this.brigade_type_id !== undefined ? this.brigade_type_id : <any>null;
        data["brigade_type_name"] = this.brigade_type_name !== undefined ? this.brigade_type_name : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_reason_id"] = this.call_reason_id !== undefined ? this.call_reason_id : <any>null;
        data["call_reason_name"] = this.call_reason_name !== undefined ? this.call_reason_name : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.messages && this.messages.constructor === Array) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["state_date"] = this.state_date ? this.state_date.toJSON() : <any>null;
        data["transport_brand"] = this.transport_brand !== undefined ? this.transport_brand : <any>null;
        data["transport_class_name"] = this.transport_class_name !== undefined ? this.transport_class_name : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        data["transport_statemark"] = this.transport_statemark !== undefined ? this.transport_statemark : <any>null;
        data["transport_type_name"] = this.transport_type_name !== undefined ? this.transport_type_name : <any>null;
        return data; 
    }
}

export interface ICallBrigadePartDto {
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_subdivision_id?: number | null;
    brigade_subdivision_name?: string | null;
    brigade_subdivision_short_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    performers?: PerformerShortDto[] | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    state?: string | null;
    state_date?: LocalDateTime | null;
    transport_brand?: string | null;
    transport_class_name?: string | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    transport_type_name?: string | null;
}

export class AddressObject implements IAddressObject {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    full_name?: string | null;
    gc_key?: string | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IAddressObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.gc_key = data["gc_key"] !== undefined ? data["gc_key"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): AddressObject {
        data = typeof data === 'object' ? data : {};
        let result = new AddressObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["gc_key"] = this.gc_key !== undefined ? this.gc_key : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IAddressObject {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    full_name?: string | null;
    gc_key?: string | null;
    id?: number | null;
    name?: string | null;
}

export class LongDto implements ILongDto {
    call_id?: number | null;

    constructor(data?: ILongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
        }
    }

    static fromJS(data: any): LongDto {
        data = typeof data === 'object' ? data : {};
        let result = new LongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        return data; 
    }
}

export interface ILongDto {
    call_id?: number | null;
}

export class FiasAddressHouseDto implements IFiasAddressHouseDto {
    building?: string | null;
    code?: string | null;
    full_name?: string | null;
    number?: string | null;
    structure?: string | null;

    constructor(data?: IFiasAddressHouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.structure = data["structure"] !== undefined ? data["structure"] : <any>null;
        }
    }

    static fromJS(data: any): FiasAddressHouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiasAddressHouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["structure"] = this.structure !== undefined ? this.structure : <any>null;
        return data; 
    }
}

export interface IFiasAddressHouseDto {
    building?: string | null;
    code?: string | null;
    full_name?: string | null;
    number?: string | null;
    structure?: string | null;
}

export class PharmacyOwner implements IPharmacyOwner {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    isDefault?: boolean | null;
    name?: string | null;
    systemValue?: number | null;
    type?: string | null;

    constructor(data?: IPharmacyOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.default = data["default"] !== undefined ? data["default"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.systemValue = data["systemValue"] !== undefined ? data["systemValue"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyOwner {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["default"] = this.default !== undefined ? this.default : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["systemValue"] = this.systemValue !== undefined ? this.systemValue : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyOwner {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    isDefault?: boolean | null;
    name?: string | null;
    systemValue?: number | null;
    type?: string | null;
}

export class CardPatientPartDto implements ICardPatientPartDto {
    alien_birthplace?: string | null;
    birthday?: LocalDateTime | null;
    document_date?: LocalDateTime | null;
    document_name?: string | null;
    document_number?: string | null;
    document_serial?: string | null;
    insurance_DMS_SMO?: string | null;
    insurance_OMS?: string | null;
    insurance_SMO?: string | null;
    is_dead?: boolean | null;
    job_place?: string | null;
    job_position?: string | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;
    registry_building?: string | null;
    registry_city?: string | null;
    registry_country?: string | null;
    registry_district?: string | null;
    registry_flat?: string | null;
    registry_house?: string | null;
    registry_region?: string | null;
    registry_street?: string | null;
    social_type_id?: number | null;
    social_type_name?: string | null;
    source_type_id?: number | null;
    source_type_name?: string | null;

    constructor(data?: ICardPatientPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.alien_birthplace = data["alien_birthplace"] !== undefined ? data["alien_birthplace"] : <any>null;
            this.birthday = data["birthday"] ? LocalDateTime.fromJS(data["birthday"]) : <any>null;
            this.document_date = data["document_date"] ? LocalDateTime.fromJS(data["document_date"]) : <any>null;
            this.document_name = data["document_name"] !== undefined ? data["document_name"] : <any>null;
            this.document_number = data["document_number"] !== undefined ? data["document_number"] : <any>null;
            this.document_serial = data["document_serial"] !== undefined ? data["document_serial"] : <any>null;
            this.insurance_DMS_SMO = data["insurance_DMS_SMO"] !== undefined ? data["insurance_DMS_SMO"] : <any>null;
            this.insurance_OMS = data["insurance_OMS"] !== undefined ? data["insurance_OMS"] : <any>null;
            this.insurance_SMO = data["insurance_SMO"] !== undefined ? data["insurance_SMO"] : <any>null;
            this.is_dead = data["is_dead"] !== undefined ? data["is_dead"] : <any>null;
            this.job_place = data["job_place"] !== undefined ? data["job_place"] : <any>null;
            this.job_position = data["job_position"] !== undefined ? data["job_position"] : <any>null;
            this.patient_age_days = data["patient_age_days"] !== undefined ? data["patient_age_days"] : <any>null;
            this.patient_age_months = data["patient_age_months"] !== undefined ? data["patient_age_months"] : <any>null;
            this.patient_age_years = data["patient_age_years"] !== undefined ? data["patient_age_years"] : <any>null;
            this.patient_firstname = data["patient_firstname"] !== undefined ? data["patient_firstname"] : <any>null;
            this.patient_id = data["patient_id"] !== undefined ? data["patient_id"] : <any>null;
            this.patient_patronymic = data["patient_patronymic"] !== undefined ? data["patient_patronymic"] : <any>null;
            this.patient_secondname = data["patient_secondname"] !== undefined ? data["patient_secondname"] : <any>null;
            this.patient_sex = data["patient_sex"] !== undefined ? data["patient_sex"] : <any>null;
            this.patient_sex_name = data["patient_sex_name"] !== undefined ? data["patient_sex_name"] : <any>null;
            this.patient_type_id = data["patient_type_id"] !== undefined ? data["patient_type_id"] : <any>null;
            this.patient_type_name = data["patient_type_name"] !== undefined ? data["patient_type_name"] : <any>null;
            this.registry_building = data["registry_building"] !== undefined ? data["registry_building"] : <any>null;
            this.registry_city = data["registry_city"] !== undefined ? data["registry_city"] : <any>null;
            this.registry_country = data["registry_country"] !== undefined ? data["registry_country"] : <any>null;
            this.registry_district = data["registry_district"] !== undefined ? data["registry_district"] : <any>null;
            this.registry_flat = data["registry_flat"] !== undefined ? data["registry_flat"] : <any>null;
            this.registry_house = data["registry_house"] !== undefined ? data["registry_house"] : <any>null;
            this.registry_region = data["registry_region"] !== undefined ? data["registry_region"] : <any>null;
            this.registry_street = data["registry_street"] !== undefined ? data["registry_street"] : <any>null;
            this.social_type_id = data["social_type_id"] !== undefined ? data["social_type_id"] : <any>null;
            this.social_type_name = data["social_type_name"] !== undefined ? data["social_type_name"] : <any>null;
            this.source_type_id = data["source_type_id"] !== undefined ? data["source_type_id"] : <any>null;
            this.source_type_name = data["source_type_name"] !== undefined ? data["source_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardPatientPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardPatientPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alien_birthplace"] = this.alien_birthplace !== undefined ? this.alien_birthplace : <any>null;
        data["birthday"] = this.birthday ? this.birthday.toJSON() : <any>null;
        data["document_date"] = this.document_date ? this.document_date.toJSON() : <any>null;
        data["document_name"] = this.document_name !== undefined ? this.document_name : <any>null;
        data["document_number"] = this.document_number !== undefined ? this.document_number : <any>null;
        data["document_serial"] = this.document_serial !== undefined ? this.document_serial : <any>null;
        data["insurance_DMS_SMO"] = this.insurance_DMS_SMO !== undefined ? this.insurance_DMS_SMO : <any>null;
        data["insurance_OMS"] = this.insurance_OMS !== undefined ? this.insurance_OMS : <any>null;
        data["insurance_SMO"] = this.insurance_SMO !== undefined ? this.insurance_SMO : <any>null;
        data["is_dead"] = this.is_dead !== undefined ? this.is_dead : <any>null;
        data["job_place"] = this.job_place !== undefined ? this.job_place : <any>null;
        data["job_position"] = this.job_position !== undefined ? this.job_position : <any>null;
        data["patient_age_days"] = this.patient_age_days !== undefined ? this.patient_age_days : <any>null;
        data["patient_age_months"] = this.patient_age_months !== undefined ? this.patient_age_months : <any>null;
        data["patient_age_years"] = this.patient_age_years !== undefined ? this.patient_age_years : <any>null;
        data["patient_firstname"] = this.patient_firstname !== undefined ? this.patient_firstname : <any>null;
        data["patient_id"] = this.patient_id !== undefined ? this.patient_id : <any>null;
        data["patient_patronymic"] = this.patient_patronymic !== undefined ? this.patient_patronymic : <any>null;
        data["patient_secondname"] = this.patient_secondname !== undefined ? this.patient_secondname : <any>null;
        data["patient_sex"] = this.patient_sex !== undefined ? this.patient_sex : <any>null;
        data["patient_sex_name"] = this.patient_sex_name !== undefined ? this.patient_sex_name : <any>null;
        data["patient_type_id"] = this.patient_type_id !== undefined ? this.patient_type_id : <any>null;
        data["patient_type_name"] = this.patient_type_name !== undefined ? this.patient_type_name : <any>null;
        data["registry_building"] = this.registry_building !== undefined ? this.registry_building : <any>null;
        data["registry_city"] = this.registry_city !== undefined ? this.registry_city : <any>null;
        data["registry_country"] = this.registry_country !== undefined ? this.registry_country : <any>null;
        data["registry_district"] = this.registry_district !== undefined ? this.registry_district : <any>null;
        data["registry_flat"] = this.registry_flat !== undefined ? this.registry_flat : <any>null;
        data["registry_house"] = this.registry_house !== undefined ? this.registry_house : <any>null;
        data["registry_region"] = this.registry_region !== undefined ? this.registry_region : <any>null;
        data["registry_street"] = this.registry_street !== undefined ? this.registry_street : <any>null;
        data["social_type_id"] = this.social_type_id !== undefined ? this.social_type_id : <any>null;
        data["social_type_name"] = this.social_type_name !== undefined ? this.social_type_name : <any>null;
        data["source_type_id"] = this.source_type_id !== undefined ? this.source_type_id : <any>null;
        data["source_type_name"] = this.source_type_name !== undefined ? this.source_type_name : <any>null;
        return data; 
    }
}

export interface ICardPatientPartDto {
    alien_birthplace?: string | null;
    birthday?: LocalDateTime | null;
    document_date?: LocalDateTime | null;
    document_name?: string | null;
    document_number?: string | null;
    document_serial?: string | null;
    insurance_DMS_SMO?: string | null;
    insurance_OMS?: string | null;
    insurance_SMO?: string | null;
    is_dead?: boolean | null;
    job_place?: string | null;
    job_position?: string | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;
    registry_building?: string | null;
    registry_city?: string | null;
    registry_country?: string | null;
    registry_district?: string | null;
    registry_flat?: string | null;
    registry_house?: string | null;
    registry_region?: string | null;
    registry_street?: string | null;
    social_type_id?: number | null;
    social_type_name?: string | null;
    source_type_id?: number | null;
    source_type_name?: string | null;
}

export class TherapyTemplateDto implements ITherapyTemplateDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    text?: string | null;

    constructor(data?: ITherapyTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    text?: string | null;
}

export class CardObjectivePupilsDto implements ICardObjectivePupilsDto {
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;

    constructor(data?: ICardObjectivePupilsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.penalties_anisocoria = data["penalties_anisocoria"] !== undefined ? data["penalties_anisocoria"] : <any>null;
            this.penalties_anisocoria_name = data["penalties_anisocoria_name"] !== undefined ? data["penalties_anisocoria_name"] : <any>null;
            this.penalties_d_s_id = data["penalties_d_s_id"] !== undefined ? data["penalties_d_s_id"] : <any>null;
            this.penalties_d_s_name = data["penalties_d_s_name"] !== undefined ? data["penalties_d_s_name"] : <any>null;
            this.penalties_id = data["penalties_id"] !== undefined ? data["penalties_id"] : <any>null;
            this.penalties_light = data["penalties_light"] !== undefined ? data["penalties_light"] : <any>null;
            this.penalties_light_name = data["penalties_light_name"] !== undefined ? data["penalties_light_name"] : <any>null;
            this.penalties_name = data["penalties_name"] !== undefined ? data["penalties_name"] : <any>null;
            this.penalties_nystagmus = data["penalties_nystagmus"] !== undefined ? data["penalties_nystagmus"] : <any>null;
            this.penalties_nystagmus_name = data["penalties_nystagmus_name"] !== undefined ? data["penalties_nystagmus_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePupilsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePupilsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["penalties_anisocoria"] = this.penalties_anisocoria !== undefined ? this.penalties_anisocoria : <any>null;
        data["penalties_anisocoria_name"] = this.penalties_anisocoria_name !== undefined ? this.penalties_anisocoria_name : <any>null;
        data["penalties_d_s_id"] = this.penalties_d_s_id !== undefined ? this.penalties_d_s_id : <any>null;
        data["penalties_d_s_name"] = this.penalties_d_s_name !== undefined ? this.penalties_d_s_name : <any>null;
        data["penalties_id"] = this.penalties_id !== undefined ? this.penalties_id : <any>null;
        data["penalties_light"] = this.penalties_light !== undefined ? this.penalties_light : <any>null;
        data["penalties_light_name"] = this.penalties_light_name !== undefined ? this.penalties_light_name : <any>null;
        data["penalties_name"] = this.penalties_name !== undefined ? this.penalties_name : <any>null;
        data["penalties_nystagmus"] = this.penalties_nystagmus !== undefined ? this.penalties_nystagmus : <any>null;
        data["penalties_nystagmus_name"] = this.penalties_nystagmus_name !== undefined ? this.penalties_nystagmus_name : <any>null;
        return data; 
    }
}

export interface ICardObjectivePupilsDto {
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;
}

export class GrantedAuthority implements IGrantedAuthority {
    authority?: string | null;

    constructor(data?: IGrantedAuthority) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
        }
    }

    static fromJS(data: any): GrantedAuthority {
        data = typeof data === 'object' ? data : {};
        let result = new GrantedAuthority();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        return data; 
    }
}

export interface IGrantedAuthority {
    authority?: string | null;
}

export class Resource implements IResource {
    description?: string | null;
    file?: any | null;
    filename?: string | null;
    inputStream?: any | null;
    open?: boolean | null;
    readable?: boolean | null;
    uri?: URI | null;
    url?: URL | null;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.filename = data["filename"] !== undefined ? data["filename"] : <any>null;
            this.inputStream = data["inputStream"] !== undefined ? data["inputStream"] : <any>null;
            this.open = data["open"] !== undefined ? data["open"] : <any>null;
            this.readable = data["readable"] !== undefined ? data["readable"] : <any>null;
            this.uri = data["uri"] ? URI.fromJS(data["uri"]) : <any>null;
            this.url = data["url"] ? URL.fromJS(data["url"]) : <any>null;
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["filename"] = this.filename !== undefined ? this.filename : <any>null;
        data["inputStream"] = this.inputStream !== undefined ? this.inputStream : <any>null;
        data["open"] = this.open !== undefined ? this.open : <any>null;
        data["readable"] = this.readable !== undefined ? this.readable : <any>null;
        data["uri"] = this.uri ? this.uri.toJSON() : <any>null;
        data["url"] = this.url ? this.url.toJSON() : <any>null;
        return data; 
    }
}

export interface IResource {
    description?: string | null;
    file?: any | null;
    filename?: string | null;
    inputStream?: any | null;
    open?: boolean | null;
    readable?: boolean | null;
    uri?: URI | null;
    url?: URL | null;
}

export class Period implements IPeriod {
    date_from?: LocalDateTime | null;
    date_to?: LocalDateTime | null;
    id?: number | null;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_from = data["date_from"] ? LocalDateTime.fromJS(data["date_from"]) : <any>null;
            this.date_to = data["date_to"] ? LocalDateTime.fromJS(data["date_to"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_from"] = this.date_from ? this.date_from.toJSON() : <any>null;
        data["date_to"] = this.date_to ? this.date_to.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IPeriod {
    date_from?: LocalDateTime | null;
    date_to?: LocalDateTime | null;
    id?: number | null;
}

export class PerformerScheduleDto2 implements IPerformerScheduleDto2 {
    deleted?: boolean | null;
    errors?: string[] | null;
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
    period_id?: number | null;
    period_type?: ScheduleType | null;
    scheduller_info?: PerformerScheduller | null;

    constructor(data?: IPerformerScheduleDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(item);
            }
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.period_id = data["period_id"] !== undefined ? data["period_id"] : <any>null;
            this.period_type = data["period_type"] ? ScheduleType.fromJS(data["period_type"]) : <any>null;
            this.scheduller_info = data["scheduller_info"] ? PerformerScheduller.fromJS(data["scheduller_info"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerScheduleDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerScheduleDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["period_id"] = this.period_id !== undefined ? this.period_id : <any>null;
        data["period_type"] = this.period_type ? this.period_type.toJSON() : <any>null;
        data["scheduller_info"] = this.scheduller_info ? this.scheduller_info.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerScheduleDto2 {
    deleted?: boolean | null;
    errors?: string[] | null;
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
    period_id?: number | null;
    period_type?: ScheduleType | null;
    scheduller_info?: PerformerScheduller | null;
}

export class CardResultAssistanceResultDto implements ICardResultAssistanceResultDto {
    assistance_result_id?: number | null;
    card_result_id?: number | null;
    name?: string | null;

    constructor(data?: ICardResultAssistanceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assistance_result_id = data["assistance_result_id"] !== undefined ? data["assistance_result_id"] : <any>null;
            this.card_result_id = data["card_result_id"] !== undefined ? data["card_result_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultAssistanceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultAssistanceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assistance_result_id"] = this.assistance_result_id !== undefined ? this.assistance_result_id : <any>null;
        data["card_result_id"] = this.card_result_id !== undefined ? this.card_result_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICardResultAssistanceResultDto {
    assistance_result_id?: number | null;
    card_result_id?: number | null;
    name?: string | null;
}

export class CallFiasAddressDto implements ICallFiasAddressDto {
    call_place_id?: number | null;
    call_place_name?: string | null;
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;

    constructor(data?: ICallFiasAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_place_id = data["call_place_id"] !== undefined ? data["call_place_id"] : <any>null;
            this.call_place_name = data["call_place_name"] !== undefined ? data["call_place_name"] : <any>null;
            this.country = data["country"] ? FiasAddressObjectDto.fromJS(data["country"]) : <any>null;
            this.district = data["district"] ? FiasAddressObjectDto.fromJS(data["district"]) : <any>null;
            this.entrance = data["entrance"] !== undefined ? data["entrance"] : <any>null;
            this.entrance_code = data["entrance_code"] !== undefined ? data["entrance_code"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.floor = data["floor"] !== undefined ? data["floor"] : <any>null;
            this.fullname = data["fullname"] !== undefined ? data["fullname"] : <any>null;
            this.geometry = data["geometry"] !== undefined ? data["geometry"] : <any>null;
            this.house = data["house"] ? FiasAddressHouseDto.fromJS(data["house"]) : <any>null;
            this.region = data["region"] ? FiasAddressObjectDto.fromJS(data["region"]) : <any>null;
            this.room = data["room"] !== undefined ? data["room"] : <any>null;
            this.settlement = data["settlement"] ? FiasAddressObjectDto.fromJS(data["settlement"]) : <any>null;
            this.street = data["street"] ? FiasAddressObjectDto.fromJS(data["street"]) : <any>null;
        }
    }

    static fromJS(data: any): CallFiasAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallFiasAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_place_id"] = this.call_place_id !== undefined ? this.call_place_id : <any>null;
        data["call_place_name"] = this.call_place_name !== undefined ? this.call_place_name : <any>null;
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        data["district"] = this.district ? this.district.toJSON() : <any>null;
        data["entrance"] = this.entrance !== undefined ? this.entrance : <any>null;
        data["entrance_code"] = this.entrance_code !== undefined ? this.entrance_code : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["fullname"] = this.fullname !== undefined ? this.fullname : <any>null;
        data["geometry"] = this.geometry !== undefined ? this.geometry : <any>null;
        data["house"] = this.house ? this.house.toJSON() : <any>null;
        data["region"] = this.region ? this.region.toJSON() : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["settlement"] = this.settlement ? this.settlement.toJSON() : <any>null;
        data["street"] = this.street ? this.street.toJSON() : <any>null;
        return data; 
    }
}

export interface ICallFiasAddressDto {
    call_place_id?: number | null;
    call_place_name?: string | null;
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;
}

export class CardResultTypeDto implements ICardResultTypeDto {
    system_value?: number | null;
    type_code?: string | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ICardResultTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.system_value = data["system_value"] !== undefined ? data["system_value"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_comment = data["type_comment"] !== undefined ? data["type_comment"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["system_value"] = this.system_value !== undefined ? this.system_value : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_comment"] = this.type_comment !== undefined ? this.type_comment : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ICardResultTypeDto {
    system_value?: number | null;
    type_code?: string | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class NomenclatureItem implements INomenclatureItem {
    expiryDate?: LocalDateTime | null;
    id?: number | null;
    owner?: PharmacyOwner | null;
    referenceItem?: PharmacyReferenceItem | null;
    reusable?: boolean | null;
    seriesNumber?: number | null;
    type?: NomenclatureItemType | null;

    constructor(data?: INomenclatureItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.expiryDate = data["expiryDate"] ? LocalDateTime.fromJS(data["expiryDate"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.owner = data["owner"] ? PharmacyOwner.fromJS(data["owner"]) : <any>null;
            this.referenceItem = data["referenceItem"] ? PharmacyReferenceItem.fromJS(data["referenceItem"]) : <any>null;
            this.reusable = data["reusable"] !== undefined ? data["reusable"] : <any>null;
            this.seriesNumber = data["seriesNumber"] !== undefined ? data["seriesNumber"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): NomenclatureItem {
        data = typeof data === 'object' ? data : {};
        let result = new NomenclatureItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>null;
        data["referenceItem"] = this.referenceItem ? this.referenceItem.toJSON() : <any>null;
        data["reusable"] = this.reusable !== undefined ? this.reusable : <any>null;
        data["seriesNumber"] = this.seriesNumber !== undefined ? this.seriesNumber : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface INomenclatureItem {
    expiryDate?: LocalDateTime | null;
    id?: number | null;
    owner?: PharmacyOwner | null;
    referenceItem?: PharmacyReferenceItem | null;
    reusable?: boolean | null;
    seriesNumber?: number | null;
    type?: NomenclatureItemType | null;
}

export class MkbDto implements IMkbDto {
    id?: number | null;
    info?: string | null;
    leaf?: boolean | null;
    name?: string | null;
    parent_id?: number | null;

    constructor(data?: IMkbDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.info = data["info"] !== undefined ? data["info"] : <any>null;
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
        }
    }

    static fromJS(data: any): MkbDto {
        data = typeof data === 'object' ? data : {};
        let result = new MkbDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["info"] = this.info !== undefined ? this.info : <any>null;
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        return data; 
    }
}

export interface IMkbDto {
    id?: number | null;
    info?: string | null;
    leaf?: boolean | null;
    name?: string | null;
    parent_id?: number | null;
}

export class FiasAddressDto implements IFiasAddressDto {
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;

    constructor(data?: IFiasAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.country = data["country"] ? FiasAddressObjectDto.fromJS(data["country"]) : <any>null;
            this.district = data["district"] ? FiasAddressObjectDto.fromJS(data["district"]) : <any>null;
            this.entrance = data["entrance"] !== undefined ? data["entrance"] : <any>null;
            this.entrance_code = data["entrance_code"] !== undefined ? data["entrance_code"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.floor = data["floor"] !== undefined ? data["floor"] : <any>null;
            this.fullname = data["fullname"] !== undefined ? data["fullname"] : <any>null;
            this.geometry = data["geometry"] !== undefined ? data["geometry"] : <any>null;
            this.house = data["house"] ? FiasAddressHouseDto.fromJS(data["house"]) : <any>null;
            this.region = data["region"] ? FiasAddressObjectDto.fromJS(data["region"]) : <any>null;
            this.room = data["room"] !== undefined ? data["room"] : <any>null;
            this.settlement = data["settlement"] ? FiasAddressObjectDto.fromJS(data["settlement"]) : <any>null;
            this.street = data["street"] ? FiasAddressObjectDto.fromJS(data["street"]) : <any>null;
        }
    }

    static fromJS(data: any): FiasAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiasAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        data["district"] = this.district ? this.district.toJSON() : <any>null;
        data["entrance"] = this.entrance !== undefined ? this.entrance : <any>null;
        data["entrance_code"] = this.entrance_code !== undefined ? this.entrance_code : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["fullname"] = this.fullname !== undefined ? this.fullname : <any>null;
        data["geometry"] = this.geometry !== undefined ? this.geometry : <any>null;
        data["house"] = this.house ? this.house.toJSON() : <any>null;
        data["region"] = this.region ? this.region.toJSON() : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["settlement"] = this.settlement ? this.settlement.toJSON() : <any>null;
        data["street"] = this.street ? this.street.toJSON() : <any>null;
        return data; 
    }
}

export interface IFiasAddressDto {
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;
}

export class DrugDto implements IDrugDto {
    code?: string | null;
    company?: string | null;
    container?: string | null;
    container_item?: string | null;
    container_item_count?: number | null;
    country?: string | null;
    full_name?: string | null;
    group?: string | null;
    id?: number | null;
    name?: string | null;
    type?: number | null;

    constructor(data?: IDrugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.container = data["container"] !== undefined ? data["container"] : <any>null;
            this.container_item = data["container_item"] !== undefined ? data["container_item"] : <any>null;
            this.container_item_count = data["container_item_count"] !== undefined ? data["container_item_count"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.group = data["group"] !== undefined ? data["group"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): DrugDto {
        data = typeof data === 'object' ? data : {};
        let result = new DrugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["container"] = this.container !== undefined ? this.container : <any>null;
        data["container_item"] = this.container_item !== undefined ? this.container_item : <any>null;
        data["container_item_count"] = this.container_item_count !== undefined ? this.container_item_count : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["group"] = this.group !== undefined ? this.group : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IDrugDto {
    code?: string | null;
    company?: string | null;
    container?: string | null;
    container_item?: string | null;
    container_item_count?: number | null;
    country?: string | null;
    full_name?: string | null;
    group?: string | null;
    id?: number | null;
    name?: string | null;
    type?: number | null;
}

export class Performer implements IPerformer {
    adminConfig?: string | null;
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    name?: string | null;
    online?: boolean | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    type?: PerformerType | null;
    typeId?: number | null;
    typeName?: string | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;

    constructor(data?: IPerformer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminConfig = data["adminConfig"] !== undefined ? data["adminConfig"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(Role.fromJS(item));
            }
            this.secondName = data["secondName"] !== undefined ? data["secondName"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            if (data["skills"] && data["skills"].constructor === Array) {
                this.skills = [];
                for (let item of data["skills"])
                    this.skills.push(Skill.fromJS(item));
            }
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.subdivisionName = data["subdivisionName"] !== undefined ? data["subdivisionName"] : <any>null;
            this.type = data["type"] ? PerformerType.fromJS(data["type"]) : <any>null;
            this.typeId = data["typeId"] !== undefined ? data["typeId"] : <any>null;
            this.typeName = data["typeName"] !== undefined ? data["typeName"] : <any>null;
            this.userConfig = data["userConfig"] !== undefined ? data["userConfig"] : <any>null;
            this.workplaceSubdivisionId = data["workplaceSubdivisionId"] !== undefined ? data["workplaceSubdivisionId"] : <any>null;
            this.workplaceSubdivisionName = data["workplaceSubdivisionName"] !== undefined ? data["workplaceSubdivisionName"] : <any>null;
        }
    }

    static fromJS(data: any): Performer {
        data = typeof data === 'object' ? data : {};
        let result = new Performer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminConfig"] = this.adminConfig !== undefined ? this.adminConfig : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["secondName"] = this.secondName !== undefined ? this.secondName : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        if (this.skills && this.skills.constructor === Array) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["subdivisionName"] = this.subdivisionName !== undefined ? this.subdivisionName : <any>null;
        data["type"] = this.type ? this.type.toJSON() : <any>null;
        data["typeId"] = this.typeId !== undefined ? this.typeId : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["userConfig"] = this.userConfig !== undefined ? this.userConfig : <any>null;
        data["workplaceSubdivisionId"] = this.workplaceSubdivisionId !== undefined ? this.workplaceSubdivisionId : <any>null;
        data["workplaceSubdivisionName"] = this.workplaceSubdivisionName !== undefined ? this.workplaceSubdivisionName : <any>null;
        return data; 
    }
}

export interface IPerformer {
    adminConfig?: string | null;
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    name?: string | null;
    online?: boolean | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    type?: PerformerType | null;
    typeId?: number | null;
    typeName?: string | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;
}

export class PharmacyReferenceItem implements IPharmacyReferenceItem {
    barcode?: number | null;
    code?: string | null;
    company?: string | null;
    container?: string | null;
    containerItem?: string | null;
    containerItemCount?: number | null;
    country?: string | null;
    group?: string | null;
    id?: number | null;
    legalEntity?: string | null;
    name?: string | null;
    normativeDocuments?: string | null;
    productInfo?: string | null;
    regCertCancellationDate?: LocalDate | null;
    regCertExpiryDate?: LocalDate | null;
    regCertNumber?: string | null;
    regDate?: LocalDate | null;
    type?: PharmacyReferenceItemType | null;

    constructor(data?: IPharmacyReferenceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barcode = data["barcode"] !== undefined ? data["barcode"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.container = data["container"] !== undefined ? data["container"] : <any>null;
            this.containerItem = data["containerItem"] !== undefined ? data["containerItem"] : <any>null;
            this.containerItemCount = data["containerItemCount"] !== undefined ? data["containerItemCount"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.group = data["group"] !== undefined ? data["group"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.legalEntity = data["legalEntity"] !== undefined ? data["legalEntity"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.normativeDocuments = data["normativeDocuments"] !== undefined ? data["normativeDocuments"] : <any>null;
            this.productInfo = data["productInfo"] !== undefined ? data["productInfo"] : <any>null;
            this.regCertCancellationDate = data["regCertCancellationDate"] ? LocalDate.fromJS(data["regCertCancellationDate"]) : <any>null;
            this.regCertExpiryDate = data["regCertExpiryDate"] ? LocalDate.fromJS(data["regCertExpiryDate"]) : <any>null;
            this.regCertNumber = data["regCertNumber"] !== undefined ? data["regCertNumber"] : <any>null;
            this.regDate = data["regDate"] ? LocalDate.fromJS(data["regDate"]) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyReferenceItem {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyReferenceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode !== undefined ? this.barcode : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["container"] = this.container !== undefined ? this.container : <any>null;
        data["containerItem"] = this.containerItem !== undefined ? this.containerItem : <any>null;
        data["containerItemCount"] = this.containerItemCount !== undefined ? this.containerItemCount : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["group"] = this.group !== undefined ? this.group : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["legalEntity"] = this.legalEntity !== undefined ? this.legalEntity : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["normativeDocuments"] = this.normativeDocuments !== undefined ? this.normativeDocuments : <any>null;
        data["productInfo"] = this.productInfo !== undefined ? this.productInfo : <any>null;
        data["regCertCancellationDate"] = this.regCertCancellationDate ? this.regCertCancellationDate.toJSON() : <any>null;
        data["regCertExpiryDate"] = this.regCertExpiryDate ? this.regCertExpiryDate.toJSON() : <any>null;
        data["regCertNumber"] = this.regCertNumber !== undefined ? this.regCertNumber : <any>null;
        data["regDate"] = this.regDate ? this.regDate.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyReferenceItem {
    barcode?: number | null;
    code?: string | null;
    company?: string | null;
    container?: string | null;
    containerItem?: string | null;
    containerItemCount?: number | null;
    country?: string | null;
    group?: string | null;
    id?: number | null;
    legalEntity?: string | null;
    name?: string | null;
    normativeDocuments?: string | null;
    productInfo?: string | null;
    regCertCancellationDate?: LocalDate | null;
    regCertExpiryDate?: LocalDate | null;
    regCertNumber?: string | null;
    regDate?: LocalDate | null;
    type?: PharmacyReferenceItemType | null;
}

export class BrigadeFindListDto implements IBrigadeFindListDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    call_id?: number | null;
    call_latitude?: number | null;
    call_longitude?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    can_use?: boolean | null;
    distanse?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    name?: string | null;
    performers?: PerformerBrigScheduleDto[] | null;
    prior?: boolean | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    recommended?: boolean | null;
    sub_id?: number | null;
    sub_short_name?: string | null;
    time?: string | null;
    transport?: TransportBrigScheduleDto | null;

    constructor(data?: IBrigadeFindListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.br_type_code = data["br_type_code"] !== undefined ? data["br_type_code"] : <any>null;
            this.br_type_id = data["br_type_id"] !== undefined ? data["br_type_id"] : <any>null;
            this.br_type_name = data["br_type_name"] !== undefined ? data["br_type_name"] : <any>null;
            this.brigade_schedule_id = data["brigade_schedule_id"] !== undefined ? data["brigade_schedule_id"] : <any>null;
            this.brigade_status_id = data["brigade_status_id"] !== undefined ? data["brigade_status_id"] : <any>null;
            this.brigade_status_name = data["brigade_status_name"] !== undefined ? data["brigade_status_name"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_latitude = data["call_latitude"] !== undefined ? data["call_latitude"] : <any>null;
            this.call_longitude = data["call_longitude"] !== undefined ? data["call_longitude"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_reason_id = data["call_reason_id"] !== undefined ? data["call_reason_id"] : <any>null;
            this.call_reason_name = data["call_reason_name"] !== undefined ? data["call_reason_name"] : <any>null;
            this.can_use = data["can_use"] !== undefined ? data["can_use"] : <any>null;
            this.distanse = data["distanse"] !== undefined ? data["distanse"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["messages"] && data["messages"].constructor === Array) {
                this.messages = [];
                for (let item of data["messages"])
                    this.messages.push(MessageEventDto.fromJS(item));
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerBrigScheduleDto.fromJS(item));
            }
            this.prior = data["prior"] !== undefined ? data["prior"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.recommended = data["recommended"] !== undefined ? data["recommended"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_short_name = data["sub_short_name"] !== undefined ? data["sub_short_name"] : <any>null;
            this.time = data["time"] !== undefined ? data["time"] : <any>null;
            this.transport = data["transport"] ? TransportBrigScheduleDto.fromJS(data["transport"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeFindListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeFindListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_type_code"] = this.br_type_code !== undefined ? this.br_type_code : <any>null;
        data["br_type_id"] = this.br_type_id !== undefined ? this.br_type_id : <any>null;
        data["br_type_name"] = this.br_type_name !== undefined ? this.br_type_name : <any>null;
        data["brigade_schedule_id"] = this.brigade_schedule_id !== undefined ? this.brigade_schedule_id : <any>null;
        data["brigade_status_id"] = this.brigade_status_id !== undefined ? this.brigade_status_id : <any>null;
        data["brigade_status_name"] = this.brigade_status_name !== undefined ? this.brigade_status_name : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_latitude"] = this.call_latitude !== undefined ? this.call_latitude : <any>null;
        data["call_longitude"] = this.call_longitude !== undefined ? this.call_longitude : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_reason_id"] = this.call_reason_id !== undefined ? this.call_reason_id : <any>null;
        data["call_reason_name"] = this.call_reason_name !== undefined ? this.call_reason_name : <any>null;
        data["can_use"] = this.can_use !== undefined ? this.can_use : <any>null;
        data["distanse"] = this.distanse !== undefined ? this.distanse : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.messages && this.messages.constructor === Array) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["prior"] = this.prior !== undefined ? this.prior : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["recommended"] = this.recommended !== undefined ? this.recommended : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_short_name"] = this.sub_short_name !== undefined ? this.sub_short_name : <any>null;
        data["time"] = this.time !== undefined ? this.time : <any>null;
        data["transport"] = this.transport ? this.transport.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeFindListDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    call_id?: number | null;
    call_latitude?: number | null;
    call_longitude?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    can_use?: boolean | null;
    distanse?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    name?: string | null;
    performers?: PerformerBrigScheduleDto[] | null;
    prior?: boolean | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    recommended?: boolean | null;
    sub_id?: number | null;
    sub_short_name?: string | null;
    time?: string | null;
    transport?: TransportBrigScheduleDto | null;
}

export class Packaging implements IPackaging {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;

    constructor(data?: IPackaging) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.product_id = data["product_id"] !== undefined ? data["product_id"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
            this.unit_count = data["unit_count"] !== undefined ? data["unit_count"] : <any>null;
        }
    }

    static fromJS(data: any): Packaging {
        data = typeof data === 'object' ? data : {};
        let result = new Packaging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["product_id"] = this.product_id !== undefined ? this.product_id : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        data["unit_count"] = this.unit_count !== undefined ? this.unit_count : <any>null;
        return data; 
    }
}

export interface IPackaging {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;
}

export class CardGeneralPartDto implements ICardGeneralPartDto {
    basic_dates?: CardBasicDatesPartDto | null;
    brigade_doctor?: CardBrigadeDoctorPartDto | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: LocalDateTime | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    dispatcher_accept_id?: number | null;
    dispatcher_accept_name?: string | null;
    dispatcher_received_id?: number | null;
    dispatcher_received_name?: string | null;
    number?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    shift_senior_doctor?: CardShiftSeniorDoctorPartDto | null;
    subdivision_head_doctor?: CardSubdivisionHeadDoctorPartDto | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICardGeneralPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.basic_dates = data["basic_dates"] ? CardBasicDatesPartDto.fromJS(data["basic_dates"]) : <any>null;
            this.brigade_doctor = data["brigade_doctor"] ? CardBrigadeDoctorPartDto.fromJS(data["brigade_doctor"]) : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_priority = data["call_priority"] !== undefined ? data["call_priority"] : <any>null;
            this.call_priority_name = data["call_priority_name"] !== undefined ? data["call_priority_name"] : <any>null;
            this.call_type_id = data["call_type_id"] !== undefined ? data["call_type_id"] : <any>null;
            this.call_type_name = data["call_type_name"] !== undefined ? data["call_type_name"] : <any>null;
            this.card_id = data["card_id"] !== undefined ? data["card_id"] : <any>null;
            this.card_status = data["card_status"] !== undefined ? data["card_status"] : <any>null;
            this.card_status_name = data["card_status_name"] !== undefined ? data["card_status_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.deleted_date = data["deleted_date"] ? LocalDateTime.fromJS(data["deleted_date"]) : <any>null;
            this.deleted_message = data["deleted_message"] !== undefined ? data["deleted_message"] : <any>null;
            this.deleted_performer_id = data["deleted_performer_id"] !== undefined ? data["deleted_performer_id"] : <any>null;
            this.deleted_performer_name = data["deleted_performer_name"] !== undefined ? data["deleted_performer_name"] : <any>null;
            this.dispatcher_accept_id = data["dispatcher_accept_id"] !== undefined ? data["dispatcher_accept_id"] : <any>null;
            this.dispatcher_accept_name = data["dispatcher_accept_name"] !== undefined ? data["dispatcher_accept_name"] : <any>null;
            this.dispatcher_received_id = data["dispatcher_received_id"] !== undefined ? data["dispatcher_received_id"] : <any>null;
            this.dispatcher_received_name = data["dispatcher_received_name"] !== undefined ? data["dispatcher_received_name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.shift_senior_doctor = data["shift_senior_doctor"] ? CardShiftSeniorDoctorPartDto.fromJS(data["shift_senior_doctor"]) : <any>null;
            this.subdivision_head_doctor = data["subdivision_head_doctor"] ? CardSubdivisionHeadDoctorPartDto.fromJS(data["subdivision_head_doctor"]) : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardGeneralPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardGeneralPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basic_dates"] = this.basic_dates ? this.basic_dates.toJSON() : <any>null;
        data["brigade_doctor"] = this.brigade_doctor ? this.brigade_doctor.toJSON() : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_priority"] = this.call_priority !== undefined ? this.call_priority : <any>null;
        data["call_priority_name"] = this.call_priority_name !== undefined ? this.call_priority_name : <any>null;
        data["call_type_id"] = this.call_type_id !== undefined ? this.call_type_id : <any>null;
        data["call_type_name"] = this.call_type_name !== undefined ? this.call_type_name : <any>null;
        data["card_id"] = this.card_id !== undefined ? this.card_id : <any>null;
        data["card_status"] = this.card_status !== undefined ? this.card_status : <any>null;
        data["card_status_name"] = this.card_status_name !== undefined ? this.card_status_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["deleted_date"] = this.deleted_date ? this.deleted_date.toJSON() : <any>null;
        data["deleted_message"] = this.deleted_message !== undefined ? this.deleted_message : <any>null;
        data["deleted_performer_id"] = this.deleted_performer_id !== undefined ? this.deleted_performer_id : <any>null;
        data["deleted_performer_name"] = this.deleted_performer_name !== undefined ? this.deleted_performer_name : <any>null;
        data["dispatcher_accept_id"] = this.dispatcher_accept_id !== undefined ? this.dispatcher_accept_id : <any>null;
        data["dispatcher_accept_name"] = this.dispatcher_accept_name !== undefined ? this.dispatcher_accept_name : <any>null;
        data["dispatcher_received_id"] = this.dispatcher_received_id !== undefined ? this.dispatcher_received_id : <any>null;
        data["dispatcher_received_name"] = this.dispatcher_received_name !== undefined ? this.dispatcher_received_name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["shift_senior_doctor"] = this.shift_senior_doctor ? this.shift_senior_doctor.toJSON() : <any>null;
        data["subdivision_head_doctor"] = this.subdivision_head_doctor ? this.subdivision_head_doctor.toJSON() : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICardGeneralPartDto {
    basic_dates?: CardBasicDatesPartDto | null;
    brigade_doctor?: CardBrigadeDoctorPartDto | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: LocalDateTime | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    dispatcher_accept_id?: number | null;
    dispatcher_accept_name?: string | null;
    dispatcher_received_id?: number | null;
    dispatcher_received_name?: string | null;
    number?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    shift_senior_doctor?: CardShiftSeniorDoctorPartDto | null;
    subdivision_head_doctor?: CardSubdivisionHeadDoctorPartDto | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class File implements IFile {
    absolute?: boolean | null;
    absoluteFile?: any | null;
    absolutePath?: string | null;
    canonicalFile?: any | null;
    canonicalPath?: string | null;
    directory?: boolean | null;
    file?: boolean | null;
    freeSpace?: number | null;
    hidden?: boolean | null;
    name?: string | null;
    parent?: string | null;
    parentFile?: any | null;
    path?: string | null;
    totalSpace?: number | null;
    usableSpace?: number | null;

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.absolute = data["absolute"] !== undefined ? data["absolute"] : <any>null;
            this.absoluteFile = data["absoluteFile"] !== undefined ? data["absoluteFile"] : <any>null;
            this.absolutePath = data["absolutePath"] !== undefined ? data["absolutePath"] : <any>null;
            this.canonicalFile = data["canonicalFile"] !== undefined ? data["canonicalFile"] : <any>null;
            this.canonicalPath = data["canonicalPath"] !== undefined ? data["canonicalPath"] : <any>null;
            this.directory = data["directory"] !== undefined ? data["directory"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.freeSpace = data["freeSpace"] !== undefined ? data["freeSpace"] : <any>null;
            this.hidden = data["hidden"] !== undefined ? data["hidden"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parent = data["parent"] !== undefined ? data["parent"] : <any>null;
            this.parentFile = data["parentFile"] !== undefined ? data["parentFile"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.totalSpace = data["totalSpace"] !== undefined ? data["totalSpace"] : <any>null;
            this.usableSpace = data["usableSpace"] !== undefined ? data["usableSpace"] : <any>null;
        }
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absolute"] = this.absolute !== undefined ? this.absolute : <any>null;
        data["absoluteFile"] = this.absoluteFile !== undefined ? this.absoluteFile : <any>null;
        data["absolutePath"] = this.absolutePath !== undefined ? this.absolutePath : <any>null;
        data["canonicalFile"] = this.canonicalFile !== undefined ? this.canonicalFile : <any>null;
        data["canonicalPath"] = this.canonicalPath !== undefined ? this.canonicalPath : <any>null;
        data["directory"] = this.directory !== undefined ? this.directory : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["freeSpace"] = this.freeSpace !== undefined ? this.freeSpace : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parent"] = this.parent !== undefined ? this.parent : <any>null;
        data["parentFile"] = this.parentFile !== undefined ? this.parentFile : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["totalSpace"] = this.totalSpace !== undefined ? this.totalSpace : <any>null;
        data["usableSpace"] = this.usableSpace !== undefined ? this.usableSpace : <any>null;
        return data; 
    }
}

export interface IFile {
    absolute?: boolean | null;
    absoluteFile?: any | null;
    absolutePath?: string | null;
    canonicalFile?: any | null;
    canonicalPath?: string | null;
    directory?: boolean | null;
    file?: boolean | null;
    freeSpace?: number | null;
    hidden?: boolean | null;
    name?: string | null;
    parent?: string | null;
    parentFile?: any | null;
    path?: string | null;
    totalSpace?: number | null;
    usableSpace?: number | null;
}

export class CardAnamnesisEpidemicPartDto implements ICardAnamnesisEpidemicPartDto {
    infect_contacts?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;

    constructor(data?: ICardAnamnesisEpidemicPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.infect_contacts = data["infect_contacts"] !== undefined ? data["infect_contacts"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisEpidemicPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisEpidemicPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["infect_contacts"] = this.infect_contacts !== undefined ? this.infect_contacts : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisEpidemicPartDto {
    infect_contacts?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;
}

export class CallGridDto implements ICallGridDto {
    address?: string | null;
    brigades?: string | null;
    call_id?: number | null;
    call_status?: number | null;
    call_status_name?: string | null;
    date?: LocalDateTime | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    district_name?: string | null;
    id?: number | null;
    is_unfounded?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    number?: string | null;
    patients?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;

    constructor(data?: ICallGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.brigades = data["brigades"] !== undefined ? data["brigades"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_status = data["call_status"] !== undefined ? data["call_status"] : <any>null;
            this.call_status_name = data["call_status_name"] !== undefined ? data["call_status_name"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.district_name = data["district_name"] !== undefined ? data["district_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patients = data["patients"] !== undefined ? data["patients"] : <any>null;
            this.performer_accept_id = data["performer_accept_id"] !== undefined ? data["performer_accept_id"] : <any>null;
            this.performer_accept_name = data["performer_accept_name"] !== undefined ? data["performer_accept_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.performer_send_id = data["performer_send_id"] !== undefined ? data["performer_send_id"] : <any>null;
            this.performer_send_name = data["performer_send_name"] !== undefined ? data["performer_send_name"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.subdivision_send_id = data["subdivision_send_id"] !== undefined ? data["subdivision_send_id"] : <any>null;
            this.subdivision_send_name = data["subdivision_send_name"] !== undefined ? data["subdivision_send_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["brigades"] = this.brigades !== undefined ? this.brigades : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_status"] = this.call_status !== undefined ? this.call_status : <any>null;
        data["call_status_name"] = this.call_status_name !== undefined ? this.call_status_name : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["district_name"] = this.district_name !== undefined ? this.district_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patients"] = this.patients !== undefined ? this.patients : <any>null;
        data["performer_accept_id"] = this.performer_accept_id !== undefined ? this.performer_accept_id : <any>null;
        data["performer_accept_name"] = this.performer_accept_name !== undefined ? this.performer_accept_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["performer_send_id"] = this.performer_send_id !== undefined ? this.performer_send_id : <any>null;
        data["performer_send_name"] = this.performer_send_name !== undefined ? this.performer_send_name : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["subdivision_send_id"] = this.subdivision_send_id !== undefined ? this.subdivision_send_id : <any>null;
        data["subdivision_send_name"] = this.subdivision_send_name !== undefined ? this.subdivision_send_name : <any>null;
        return data; 
    }
}

export interface ICallGridDto {
    address?: string | null;
    brigades?: string | null;
    call_id?: number | null;
    call_status?: number | null;
    call_status_name?: string | null;
    date?: LocalDateTime | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    district_name?: string | null;
    id?: number | null;
    is_unfounded?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    number?: string | null;
    patients?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;
}

export class InquirerDto implements IInquirerDto {
    answer_title?: string | null;
    brigade_types?: number[] | null;
    extra?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_title?: string | null;

    constructor(data?: IInquirerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer_title = data["answer_title"] !== undefined ? data["answer_title"] : <any>null;
            if (data["brigade_types"] && data["brigade_types"].constructor === Array) {
                this.brigade_types = [];
                for (let item of data["brigade_types"])
                    this.brigade_types.push(item);
            }
            this.extra = data["extra"] !== undefined ? data["extra"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.is_editable = data["is_editable"] !== undefined ? data["is_editable"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
            this.query_title = data["query_title"] !== undefined ? data["query_title"] : <any>null;
            this.reason_title = data["reason_title"] !== undefined ? data["reason_title"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer_title"] = this.answer_title !== undefined ? this.answer_title : <any>null;
        if (this.brigade_types && this.brigade_types.constructor === Array) {
            data["brigade_types"] = [];
            for (let item of this.brigade_types)
                data["brigade_types"].push(item);
        }
        data["extra"] = this.extra !== undefined ? this.extra : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["is_editable"] = this.is_editable !== undefined ? this.is_editable : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        data["query_title"] = this.query_title !== undefined ? this.query_title : <any>null;
        data["reason_title"] = this.reason_title !== undefined ? this.reason_title : <any>null;
        return data; 
    }
}

export interface IInquirerDto {
    answer_title?: string | null;
    brigade_types?: number[] | null;
    extra?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_title?: string | null;
}

export class SubdivisionDto implements ISubdivisionDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;

    constructor(data?: ISubdivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? FiasAddressDto.fromJS(data["address"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.district_code = data["district_code"] !== undefined ? data["district_code"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
            if (data["zone"] && data["zone"].constructor === Array) {
                this.zone = [];
                for (let item of data["zone"])
                    this.zone.push(item);
            }
        }
    }

    static fromJS(data: any): SubdivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["district_code"] = this.district_code !== undefined ? this.district_code : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        if (this.zone && this.zone.constructor === Array) {
            data["zone"] = [];
            for (let item of this.zone)
                data["zone"].push(item);
        }
        return data; 
    }
}

export interface ISubdivisionDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;
}

export class TransportClassDto implements ITransportClassDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ITransportClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TransportClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ITransportClassDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class Config implements IConfig {
    app_name?: string | null;
    app_version?: string | null;
    is_admin?: boolean | null;
    is_mb?: boolean | null;
    is_smp?: boolean | null;
    is_tcmk?: boolean | null;
    is_turn_on_routing?: boolean | null;
    is_user?: boolean | null;
    map_url?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    permissions?: Permission[] | null;
    roles?: string[] | null;
    sub_id?: number | null;
    sub_name?: string | null;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.app_name = data["app_name"] !== undefined ? data["app_name"] : <any>null;
            this.app_version = data["app_version"] !== undefined ? data["app_version"] : <any>null;
            this.is_admin = data["is_admin"] !== undefined ? data["is_admin"] : <any>null;
            this.is_mb = data["is_mb"] !== undefined ? data["is_mb"] : <any>null;
            this.is_smp = data["is_smp"] !== undefined ? data["is_smp"] : <any>null;
            this.is_tcmk = data["is_tcmk"] !== undefined ? data["is_tcmk"] : <any>null;
            this.is_turn_on_routing = data["is_turn_on_routing"] !== undefined ? data["is_turn_on_routing"] : <any>null;
            this.is_user = data["is_user"] !== undefined ? data["is_user"] : <any>null;
            this.map_url = data["map_url"] !== undefined ? data["map_url"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(Permission.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
        }
    }

    static fromJS(data: any): Config {
        data = typeof data === 'object' ? data : {};
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["app_name"] = this.app_name !== undefined ? this.app_name : <any>null;
        data["app_version"] = this.app_version !== undefined ? this.app_version : <any>null;
        data["is_admin"] = this.is_admin !== undefined ? this.is_admin : <any>null;
        data["is_mb"] = this.is_mb !== undefined ? this.is_mb : <any>null;
        data["is_smp"] = this.is_smp !== undefined ? this.is_smp : <any>null;
        data["is_tcmk"] = this.is_tcmk !== undefined ? this.is_tcmk : <any>null;
        data["is_turn_on_routing"] = this.is_turn_on_routing !== undefined ? this.is_turn_on_routing : <any>null;
        data["is_user"] = this.is_user !== undefined ? this.is_user : <any>null;
        data["map_url"] = this.map_url !== undefined ? this.map_url : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        return data; 
    }
}

export interface IConfig {
    app_name?: string | null;
    app_version?: string | null;
    is_admin?: boolean | null;
    is_mb?: boolean | null;
    is_smp?: boolean | null;
    is_tcmk?: boolean | null;
    is_turn_on_routing?: boolean | null;
    is_user?: boolean | null;
    map_url?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    permissions?: Permission[] | null;
    roles?: string[] | null;
    sub_id?: number | null;
    sub_name?: string | null;
}

export class ModelAndView implements IModelAndView {
    empty?: boolean | null;
    model?: any | null;
    modelMap?: { [key: string] : any; } | null;
    reference?: boolean | null;
    status?: ModelAndViewStatus | null;
    view?: View | null;
    viewName?: string | null;

    constructor(data?: IModelAndView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.empty = data["empty"] !== undefined ? data["empty"] : <any>null;
            this.model = data["model"] !== undefined ? data["model"] : <any>null;
            if (data["modelMap"]) {
                this.modelMap = {};
                for (let key in data["modelMap"]) {
                    if (data["modelMap"].hasOwnProperty(key))
                        this.modelMap[key] = data["modelMap"][key];
                }
            }
            this.reference = data["reference"] !== undefined ? data["reference"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.view = data["view"] ? View.fromJS(data["view"]) : <any>null;
            this.viewName = data["viewName"] !== undefined ? data["viewName"] : <any>null;
        }
    }

    static fromJS(data: any): ModelAndView {
        data = typeof data === 'object' ? data : {};
        let result = new ModelAndView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empty"] = this.empty !== undefined ? this.empty : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        if (this.modelMap) {
            data["modelMap"] = {};
            for (let key in this.modelMap) {
                if (this.modelMap.hasOwnProperty(key))
                    data["modelMap"][key] = this.modelMap[key] !== undefined ? this.modelMap[key] : <any>null;
            }
        }
        data["reference"] = this.reference !== undefined ? this.reference : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["view"] = this.view ? this.view.toJSON() : <any>null;
        data["viewName"] = this.viewName !== undefined ? this.viewName : <any>null;
        return data; 
    }
}

export interface IModelAndView {
    empty?: boolean | null;
    model?: any | null;
    modelMap?: { [key: string] : any; } | null;
    reference?: boolean | null;
    status?: ModelAndViewStatus | null;
    view?: View | null;
    viewName?: string | null;
}

export class CallTransferDto implements ICallTransferDto {
    call_id?: number | null;
    date_accept?: LocalDateTime | null;
    date_create?: LocalDateTime | null;
    date_received?: LocalDateTime | null;
    id?: number | null;
    number?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    recommended_brigades?: BrigadeScheduleDto[] | null;
    sub_from_id?: number | null;
    sub_from_name?: string | null;
    sub_to_id?: number | null;
    sub_to_name?: string | null;

    constructor(data?: ICallTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.date_accept = data["date_accept"] ? LocalDateTime.fromJS(data["date_accept"]) : <any>null;
            this.date_create = data["date_create"] ? LocalDateTime.fromJS(data["date_create"]) : <any>null;
            this.date_received = data["date_received"] ? LocalDateTime.fromJS(data["date_received"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.performer_accept_id = data["performer_accept_id"] !== undefined ? data["performer_accept_id"] : <any>null;
            this.performer_accept_name = data["performer_accept_name"] !== undefined ? data["performer_accept_name"] : <any>null;
            this.performer_send_id = data["performer_send_id"] !== undefined ? data["performer_send_id"] : <any>null;
            this.performer_send_name = data["performer_send_name"] !== undefined ? data["performer_send_name"] : <any>null;
            if (data["recommended_brigades"] && data["recommended_brigades"].constructor === Array) {
                this.recommended_brigades = [];
                for (let item of data["recommended_brigades"])
                    this.recommended_brigades.push(BrigadeScheduleDto.fromJS(item));
            }
            this.sub_from_id = data["sub_from_id"] !== undefined ? data["sub_from_id"] : <any>null;
            this.sub_from_name = data["sub_from_name"] !== undefined ? data["sub_from_name"] : <any>null;
            this.sub_to_id = data["sub_to_id"] !== undefined ? data["sub_to_id"] : <any>null;
            this.sub_to_name = data["sub_to_name"] !== undefined ? data["sub_to_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["date_accept"] = this.date_accept ? this.date_accept.toJSON() : <any>null;
        data["date_create"] = this.date_create ? this.date_create.toJSON() : <any>null;
        data["date_received"] = this.date_received ? this.date_received.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["performer_accept_id"] = this.performer_accept_id !== undefined ? this.performer_accept_id : <any>null;
        data["performer_accept_name"] = this.performer_accept_name !== undefined ? this.performer_accept_name : <any>null;
        data["performer_send_id"] = this.performer_send_id !== undefined ? this.performer_send_id : <any>null;
        data["performer_send_name"] = this.performer_send_name !== undefined ? this.performer_send_name : <any>null;
        if (this.recommended_brigades && this.recommended_brigades.constructor === Array) {
            data["recommended_brigades"] = [];
            for (let item of this.recommended_brigades)
                data["recommended_brigades"].push(item.toJSON());
        }
        data["sub_from_id"] = this.sub_from_id !== undefined ? this.sub_from_id : <any>null;
        data["sub_from_name"] = this.sub_from_name !== undefined ? this.sub_from_name : <any>null;
        data["sub_to_id"] = this.sub_to_id !== undefined ? this.sub_to_id : <any>null;
        data["sub_to_name"] = this.sub_to_name !== undefined ? this.sub_to_name : <any>null;
        return data; 
    }
}

export interface ICallTransferDto {
    call_id?: number | null;
    date_accept?: LocalDateTime | null;
    date_create?: LocalDateTime | null;
    date_received?: LocalDateTime | null;
    id?: number | null;
    number?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    recommended_brigades?: BrigadeScheduleDto[] | null;
    sub_from_id?: number | null;
    sub_from_name?: string | null;
    sub_to_id?: number | null;
    sub_to_name?: string | null;
}

export class CardResultEkg implements ICardResultEkg {
    ekg_ch_s_s?: number | null;
    ekg_comments?: string | null;
    ekg_rhythm?: string | null;

    constructor(data?: ICardResultEkg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ekg_ch_s_s = data["ekg_ch_s_s"] !== undefined ? data["ekg_ch_s_s"] : <any>null;
            this.ekg_comments = data["ekg_comments"] !== undefined ? data["ekg_comments"] : <any>null;
            this.ekg_rhythm = data["ekg_rhythm"] !== undefined ? data["ekg_rhythm"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultEkg {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultEkg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ekg_ch_s_s"] = this.ekg_ch_s_s !== undefined ? this.ekg_ch_s_s : <any>null;
        data["ekg_comments"] = this.ekg_comments !== undefined ? this.ekg_comments : <any>null;
        data["ekg_rhythm"] = this.ekg_rhythm !== undefined ? this.ekg_rhythm : <any>null;
        return data; 
    }
}

export interface ICardResultEkg {
    ekg_ch_s_s?: number | null;
    ekg_comments?: string | null;
    ekg_rhythm?: string | null;
}

export class ListDtoOfRole implements IListDtoOfRole {
    list?: Role[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(Role.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfRole {
    list?: Role[] | null;
    size?: number | null;
    total?: number | null;
}

export class CardBrigadePartDto implements ICardBrigadePartDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;

    constructor(data?: ICardBrigadePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.br_type_code = data["br_type_code"] !== undefined ? data["br_type_code"] : <any>null;
            this.br_type_id = data["br_type_id"] !== undefined ? data["br_type_id"] : <any>null;
            this.br_type_name = data["br_type_name"] !== undefined ? data["br_type_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerDto.fromJS(item));
            }
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.sub_code = data["sub_code"] !== undefined ? data["sub_code"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
            this.transport_statemark = data["transport_statemark"] !== undefined ? data["transport_statemark"] : <any>null;
            this.workplace_id = data["workplace_id"] !== undefined ? data["workplace_id"] : <any>null;
            this.workplace_name = data["workplace_name"] !== undefined ? data["workplace_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardBrigadePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardBrigadePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_type_code"] = this.br_type_code !== undefined ? this.br_type_code : <any>null;
        data["br_type_id"] = this.br_type_id !== undefined ? this.br_type_id : <any>null;
        data["br_type_name"] = this.br_type_name !== undefined ? this.br_type_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["sub_code"] = this.sub_code !== undefined ? this.sub_code : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        data["transport_statemark"] = this.transport_statemark !== undefined ? this.transport_statemark : <any>null;
        data["workplace_id"] = this.workplace_id !== undefined ? this.workplace_id : <any>null;
        data["workplace_name"] = this.workplace_name !== undefined ? this.workplace_name : <any>null;
        return data; 
    }
}

export interface ICardBrigadePartDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;
}

export class PharmacyMatrixGroupDto implements IPharmacyMatrixGroupDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;

    constructor(data?: IPharmacyMatrixGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyMatrixGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyMatrixGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IPharmacyMatrixGroupDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
}

export class BrigadeDutyRequestDto implements IBrigadeDutyRequestDto {
    comment?: string | null;
    date?: LocalDateTime | null;
    pharmacy_package_id?: number | null;

    constructor(data?: IBrigadeDutyRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.pharmacy_package_id = data["pharmacy_package_id"] !== undefined ? data["pharmacy_package_id"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeDutyRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeDutyRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["pharmacy_package_id"] = this.pharmacy_package_id !== undefined ? this.pharmacy_package_id : <any>null;
        return data; 
    }
}

export interface IBrigadeDutyRequestDto {
    comment?: string | null;
    date?: LocalDateTime | null;
    pharmacy_package_id?: number | null;
}

export class CardResultTherapyPartDto implements ICardResultTherapyPartDto {
    therapy?: string | null;

    constructor(data?: ICardResultTherapyPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.therapy = data["therapy"] !== undefined ? data["therapy"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultTherapyPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTherapyPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["therapy"] = this.therapy !== undefined ? this.therapy : <any>null;
        return data; 
    }
}

export interface ICardResultTherapyPartDto {
    therapy?: string | null;
}

export class PharmacyCounterpartyDto implements IPharmacyCounterpartyDto {
    id?: number | null;
    is_deleted?: boolean | null;
    name?: string | null;
    parent_id?: string | null;

    constructor(data?: IPharmacyCounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyCounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyCounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        return data; 
    }
}

export interface IPharmacyCounterpartyDto {
    id?: number | null;
    is_deleted?: boolean | null;
    name?: string | null;
    parent_id?: string | null;
}

export class PharmacyMatrixItemDto implements IPharmacyMatrixItemDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    type?: number | null;

    constructor(data?: IPharmacyMatrixItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyMatrixItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyMatrixItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyMatrixItemDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    type?: number | null;
}

export class SendBagDto implements ISendBagDto {
    bag_id?: number | null;
    brigade_id?: number | null;

    constructor(data?: ISendBagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
        }
    }

    static fromJS(data: any): SendBagDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendBagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        return data; 
    }
}

export interface ISendBagDto {
    bag_id?: number | null;
    brigade_id?: number | null;
}

export class Chronology implements IChronology {
    calendarType?: string | null;
    id?: string | null;

    constructor(data?: IChronology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calendarType = data["calendarType"] !== undefined ? data["calendarType"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
        }
    }

    static fromJS(data: any): Chronology {
        data = typeof data === 'object' ? data : {};
        let result = new Chronology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarType"] = this.calendarType !== undefined ? this.calendarType : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IChronology {
    calendarType?: string | null;
    id?: string | null;
}

export class CardObjectiveTonguePart implements ICardObjectiveTonguePart {
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;

    constructor(data?: ICardObjectiveTonguePart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tongue_clean_furred = data["tongue_clean_furred"] !== undefined ? data["tongue_clean_furred"] : <any>null;
            this.tongue_clean_furred_name = data["tongue_clean_furred_name"] !== undefined ? data["tongue_clean_furred_name"] : <any>null;
            this.tongue_weat_dry = data["tongue_weat_dry"] !== undefined ? data["tongue_weat_dry"] : <any>null;
            this.tongue_weat_dry_name = data["tongue_weat_dry_name"] !== undefined ? data["tongue_weat_dry_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveTonguePart {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveTonguePart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tongue_clean_furred"] = this.tongue_clean_furred !== undefined ? this.tongue_clean_furred : <any>null;
        data["tongue_clean_furred_name"] = this.tongue_clean_furred_name !== undefined ? this.tongue_clean_furred_name : <any>null;
        data["tongue_weat_dry"] = this.tongue_weat_dry !== undefined ? this.tongue_weat_dry : <any>null;
        data["tongue_weat_dry_name"] = this.tongue_weat_dry_name !== undefined ? this.tongue_weat_dry_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveTonguePart {
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;
}

export class CallDeclarantPartDto implements ICallDeclarantPartDto {
    audio_file_name?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;

    constructor(data?: ICallDeclarantPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audio_file_name = data["audio_file_name"] !== undefined ? data["audio_file_name"] : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.declarant_type_id = data["declarant_type_id"] !== undefined ? data["declarant_type_id"] : <any>null;
            this.declarant_type_name = data["declarant_type_name"] !== undefined ? data["declarant_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallDeclarantPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallDeclarantPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audio_file_name"] = this.audio_file_name !== undefined ? this.audio_file_name : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["declarant_type_id"] = this.declarant_type_id !== undefined ? this.declarant_type_id : <any>null;
        data["declarant_type_name"] = this.declarant_type_name !== undefined ? this.declarant_type_name : <any>null;
        return data; 
    }
}

export interface ICallDeclarantPartDto {
    audio_file_name?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
}

export class LogDto implements ILogDto {
    action_type?: string | null;
    date?: LocalDateTime | null;
    description?: string | null;
    id?: number | null;
    item_id?: number | null;
    item_type?: string | null;
    log_type?: string | null;
    performer_id?: number | null;
    performer_short_name?: string | null;
    subdivision_id?: number | null;
    subdivision_short_name?: string | null;
    transmit_error_text?: string | null;
    transmit_status?: string | null;

    constructor(data?: ILogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action_type = data["action_type"] !== undefined ? data["action_type"] : <any>null;
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.item_id = data["item_id"] !== undefined ? data["item_id"] : <any>null;
            this.item_type = data["item_type"] !== undefined ? data["item_type"] : <any>null;
            this.log_type = data["log_type"] !== undefined ? data["log_type"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_short_name = data["performer_short_name"] !== undefined ? data["performer_short_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_short_name = data["subdivision_short_name"] !== undefined ? data["subdivision_short_name"] : <any>null;
            this.transmit_error_text = data["transmit_error_text"] !== undefined ? data["transmit_error_text"] : <any>null;
            this.transmit_status = data["transmit_status"] !== undefined ? data["transmit_status"] : <any>null;
        }
    }

    static fromJS(data: any): LogDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action_type"] = this.action_type !== undefined ? this.action_type : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["item_id"] = this.item_id !== undefined ? this.item_id : <any>null;
        data["item_type"] = this.item_type !== undefined ? this.item_type : <any>null;
        data["log_type"] = this.log_type !== undefined ? this.log_type : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_short_name"] = this.performer_short_name !== undefined ? this.performer_short_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_short_name"] = this.subdivision_short_name !== undefined ? this.subdivision_short_name : <any>null;
        data["transmit_error_text"] = this.transmit_error_text !== undefined ? this.transmit_error_text : <any>null;
        data["transmit_status"] = this.transmit_status !== undefined ? this.transmit_status : <any>null;
        return data; 
    }
}

export interface ILogDto {
    action_type?: string | null;
    date?: LocalDateTime | null;
    description?: string | null;
    id?: number | null;
    item_id?: number | null;
    item_type?: string | null;
    log_type?: string | null;
    performer_id?: number | null;
    performer_short_name?: string | null;
    subdivision_id?: number | null;
    subdivision_short_name?: string | null;
    transmit_error_text?: string | null;
    transmit_status?: string | null;
}

export class MobileCardChronic implements IMobileCardChronic {
    date?: LocalDateTime | null;
    diagnosis?: string | null;
    doctor?: string | null;
    reason?: string | null;
    result?: string | null;

    constructor(data?: IMobileCardChronic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? LocalDateTime.fromJS(data["date"]) : <any>null;
            this.diagnosis = data["diagnosis"] !== undefined ? data["diagnosis"] : <any>null;
            this.doctor = data["doctor"] !== undefined ? data["doctor"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.result = data["result"] !== undefined ? data["result"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardChronic {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardChronic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["diagnosis"] = this.diagnosis !== undefined ? this.diagnosis : <any>null;
        data["doctor"] = this.doctor !== undefined ? this.doctor : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["result"] = this.result !== undefined ? this.result : <any>null;
        return data; 
    }
}

export interface IMobileCardChronic {
    date?: LocalDateTime | null;
    diagnosis?: string | null;
    doctor?: string | null;
    reason?: string | null;
    result?: string | null;
}

export class FiasAddressObjectDto implements IFiasAddressObjectDto {
    code?: string | null;
    full_name?: string | null;
    name?: string | null;

    constructor(data?: IFiasAddressObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): FiasAddressObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiasAddressObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IFiasAddressObjectDto {
    code?: string | null;
    full_name?: string | null;
    name?: string | null;
}

export class CardAnamnesisGynecologicPartDto implements ICardAnamnesisGynecologicPartDto {
    gynecologic_anamnesis?: string | null;

    constructor(data?: ICardAnamnesisGynecologicPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gynecologic_anamnesis = data["gynecologic_anamnesis"] !== undefined ? data["gynecologic_anamnesis"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisGynecologicPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisGynecologicPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gynecologic_anamnesis"] = this.gynecologic_anamnesis !== undefined ? this.gynecologic_anamnesis : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisGynecologicPartDto {
    gynecologic_anamnesis?: string | null;
}

export class PerformerType implements IPerformerType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    groupCode?: PerformerTypeGroupCode | null;
    id?: number | null;
    name?: string | null;
    shortName?: string | null;

    constructor(data?: IPerformerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.groupCode = data["groupCode"] !== undefined ? data["groupCode"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerType {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["groupCode"] = this.groupCode !== undefined ? this.groupCode : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        return data; 
    }
}

export interface IPerformerType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    groupCode?: PerformerTypeGroupCode | null;
    id?: number | null;
    name?: string | null;
    shortName?: string | null;
}

export class CardResultMaterialsDto implements ICardResultMaterialsDto {
    bandages?: number | null;
    catheters?: number | null;
    other_materials?: string | null;
    syringes?: number | null;
    transfusion_systems?: number | null;

    constructor(data?: ICardResultMaterialsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bandages = data["bandages"] !== undefined ? data["bandages"] : <any>null;
            this.catheters = data["catheters"] !== undefined ? data["catheters"] : <any>null;
            this.other_materials = data["other_materials"] !== undefined ? data["other_materials"] : <any>null;
            this.syringes = data["syringes"] !== undefined ? data["syringes"] : <any>null;
            this.transfusion_systems = data["transfusion_systems"] !== undefined ? data["transfusion_systems"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultMaterialsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultMaterialsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bandages"] = this.bandages !== undefined ? this.bandages : <any>null;
        data["catheters"] = this.catheters !== undefined ? this.catheters : <any>null;
        data["other_materials"] = this.other_materials !== undefined ? this.other_materials : <any>null;
        data["syringes"] = this.syringes !== undefined ? this.syringes : <any>null;
        data["transfusion_systems"] = this.transfusion_systems !== undefined ? this.transfusion_systems : <any>null;
        return data; 
    }
}

export interface ICardResultMaterialsDto {
    bandages?: number | null;
    catheters?: number | null;
    other_materials?: string | null;
    syringes?: number | null;
    transfusion_systems?: number | null;
}

export class Response implements IResponse {
    errorMessage?: string | null;
    guid?: string | null;
    items?: any[] | null;
    status?: number | null;
    success?: boolean | null;
    totalCount?: number | null;
    validationErrors?: { [key: string] : string; } | null;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorMessage = data["errorMessage"] !== undefined ? data["errorMessage"] : <any>null;
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(item);
            }
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            if (data["validationErrors"]) {
                this.validationErrors = {};
                for (let key in data["validationErrors"]) {
                    if (data["validationErrors"].hasOwnProperty(key))
                        this.validationErrors[key] = data["validationErrors"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (this.validationErrors) {
            data["validationErrors"] = {};
            for (let key in this.validationErrors) {
                if (this.validationErrors.hasOwnProperty(key))
                    data["validationErrors"][key] = this.validationErrors[key] !== undefined ? this.validationErrors[key] : <any>null;
            }
        }
        return data; 
    }
}

export interface IResponse {
    errorMessage?: string | null;
    guid?: string | null;
    items?: any[] | null;
    status?: number | null;
    success?: boolean | null;
    totalCount?: number | null;
    validationErrors?: { [key: string] : string; } | null;
}

export class PerformerDto implements IPerformerDto {
    admin_config?: string | null;
    change_password?: boolean | null;
    deleted?: boolean | null;
    first_name?: string | null;
    id?: number | null;
    login?: string | null;
    online?: boolean | null;
    password?: string | null;
    password2?: string | null;
    patronymic?: string | null;
    roles?: string | null;
    second_name?: string | null;
    short_name?: string | null;
    skills?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    user_config?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;

    constructor(data?: IPerformerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.admin_config = data["admin_config"] !== undefined ? data["admin_config"] : <any>null;
            this.change_password = data["change_password"] !== undefined ? data["change_password"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.password2 = data["password2"] !== undefined ? data["password2"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.roles = data["roles"] !== undefined ? data["roles"] : <any>null;
            this.second_name = data["second_name"] !== undefined ? data["second_name"] : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
            this.skills = data["skills"] !== undefined ? data["skills"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.user_config = data["user_config"] !== undefined ? data["user_config"] : <any>null;
            this.workplace_id = data["workplace_id"] !== undefined ? data["workplace_id"] : <any>null;
            this.workplace_name = data["workplace_name"] !== undefined ? data["workplace_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin_config"] = this.admin_config !== undefined ? this.admin_config : <any>null;
        data["change_password"] = this.change_password !== undefined ? this.change_password : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["password2"] = this.password2 !== undefined ? this.password2 : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["roles"] = this.roles !== undefined ? this.roles : <any>null;
        data["second_name"] = this.second_name !== undefined ? this.second_name : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        data["skills"] = this.skills !== undefined ? this.skills : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["user_config"] = this.user_config !== undefined ? this.user_config : <any>null;
        data["workplace_id"] = this.workplace_id !== undefined ? this.workplace_id : <any>null;
        data["workplace_name"] = this.workplace_name !== undefined ? this.workplace_name : <any>null;
        return data; 
    }
}

export interface IPerformerDto {
    admin_config?: string | null;
    change_password?: boolean | null;
    deleted?: boolean | null;
    first_name?: string | null;
    id?: number | null;
    login?: string | null;
    online?: boolean | null;
    password?: string | null;
    password2?: string | null;
    patronymic?: string | null;
    roles?: string | null;
    second_name?: string | null;
    short_name?: string | null;
    skills?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    user_config?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;
}

/** Модель данных первой стороны карты вызова */
export class CardSideOneDto implements ICardSideOneDto {
    address?: CallFiasAddressDto | null;
    brigade?: CardBrigadePartDto | null;
    declarant?: CardDeclarantPartDto | null;
    general?: CardGeneralPartDto | null;
    patient?: CardPatientPartDto | null;

    constructor(data?: ICardSideOneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? CallFiasAddressDto.fromJS(data["address"]) : <any>null;
            this.brigade = data["brigade"] ? CardBrigadePartDto.fromJS(data["brigade"]) : <any>null;
            this.declarant = data["declarant"] ? CardDeclarantPartDto.fromJS(data["declarant"]) : <any>null;
            this.general = data["general"] ? CardGeneralPartDto.fromJS(data["general"]) : <any>null;
            this.patient = data["patient"] ? CardPatientPartDto.fromJS(data["patient"]) : <any>null;
        }
    }

    static fromJS(data: any): CardSideOneDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardSideOneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["brigade"] = this.brigade ? this.brigade.toJSON() : <any>null;
        data["declarant"] = this.declarant ? this.declarant.toJSON() : <any>null;
        data["general"] = this.general ? this.general.toJSON() : <any>null;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>null;
        return data; 
    }
}

/** Модель данных первой стороны карты вызова */
export interface ICardSideOneDto {
    address?: CallFiasAddressDto | null;
    brigade?: CardBrigadePartDto | null;
    declarant?: CardDeclarantPartDto | null;
    general?: CardGeneralPartDto | null;
    patient?: CardPatientPartDto | null;
}

/** action */
export enum Action {
    LOGIN = "LOGIN", 
    LOGIN_FAILURE = "LOGIN_FAILURE", 
    LOGOUT = "LOGOUT", 
}

/** type */
export enum Type {
    STORAGE = "STORAGE", 
    PACKAGE = "PACKAGE", 
}

/** group_code */
export enum Group_code {
    MEDIC = "MEDIC", 
    DRIVER = "DRIVER", 
    MANAGER = "MANAGER", 
}

/** mode */
export enum Mode {
    OFFLINE = "OFFLINE", 
    ONLINE = "ONLINE", 
    UPCOMING = "UPCOMING", 
}

/** group_code */
export enum Group_code2 {
    MEDIC = "MEDIC", 
    DRIVER = "DRIVER", 
}

/** mode */
export enum Mode2 {
    DAY = "DAY", 
    PERIOD = "PERIOD", 
}

/** mode */
export enum Mode3 {
    ALL = "ALL", 
    ACTIVE = "ACTIVE", 
    ARCHIVED = "ARCHIVED", 
}

export enum LocalDateDayOfWeek {
    MONDAY = "MONDAY", 
    TUESDAY = "TUESDAY", 
    WEDNESDAY = "WEDNESDAY", 
    THURSDAY = "THURSDAY", 
    FRIDAY = "FRIDAY", 
    SATURDAY = "SATURDAY", 
    SUNDAY = "SUNDAY", 
}

export enum LocalDateMonth {
    JANUARY = "JANUARY", 
    FEBRUARY = "FEBRUARY", 
    MARCH = "MARCH", 
    APRIL = "APRIL", 
    MAY = "MAY", 
    JUNE = "JUNE", 
    JULY = "JULY", 
    AUGUST = "AUGUST", 
    SEPTEMBER = "SEPTEMBER", 
    OCTOBER = "OCTOBER", 
    NOVEMBER = "NOVEMBER", 
    DECEMBER = "DECEMBER", 
}

export enum PermissionType {
    MODULE = "MODULE", 
    SECTION = "SECTION", 
    ACTION = "ACTION", 
}

export enum PlaceType {
    STORAGE = "STORAGE", 
    PACKAGE = "PACKAGE", 
}

export enum ChatMessageType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
    _4 = "4", 
}

export enum LocalDateTimeDayOfWeek {
    MONDAY = "MONDAY", 
    TUESDAY = "TUESDAY", 
    WEDNESDAY = "WEDNESDAY", 
    THURSDAY = "THURSDAY", 
    FRIDAY = "FRIDAY", 
    SATURDAY = "SATURDAY", 
    SUNDAY = "SUNDAY", 
}

export enum LocalDateTimeMonth {
    JANUARY = "JANUARY", 
    FEBRUARY = "FEBRUARY", 
    MARCH = "MARCH", 
    APRIL = "APRIL", 
    MAY = "MAY", 
    JUNE = "JUNE", 
    JULY = "JULY", 
    AUGUST = "AUGUST", 
    SEPTEMBER = "SEPTEMBER", 
    OCTOBER = "OCTOBER", 
    NOVEMBER = "NOVEMBER", 
    DECEMBER = "DECEMBER", 
}

export enum ReportFormat {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
}

export enum ReportType {
    _0 = "0", 
    _1 = "1", 
}

export enum ChatType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
}

export enum TableType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
    _4 = "4", 
    _5 = "5", 
    _6 = "6", 
}

export enum NomenclatureItemType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
}

export enum PharmacyReferenceItemType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
}

export enum ModelAndViewStatus {
    _100_CONTINUE = "100 CONTINUE", 
    _101_SWITCHING_PROTOCOLS = "101 SWITCHING_PROTOCOLS", 
    _102_PROCESSING = "102 PROCESSING", 
    _103_CHECKPOINT = "103 CHECKPOINT", 
    _200_OK = "200 OK", 
    _201_CREATED = "201 CREATED", 
    _202_ACCEPTED = "202 ACCEPTED", 
    _203_NON_AUTHORITATIVE_INFORMATION = "203 NON_AUTHORITATIVE_INFORMATION", 
    _204_NO_CONTENT = "204 NO_CONTENT", 
    _205_RESET_CONTENT = "205 RESET_CONTENT", 
    _206_PARTIAL_CONTENT = "206 PARTIAL_CONTENT", 
    _207_MULTI_STATUS = "207 MULTI_STATUS", 
    _208_ALREADY_REPORTED = "208 ALREADY_REPORTED", 
    _226_IM_USED = "226 IM_USED", 
    _300_MULTIPLE_CHOICES = "300 MULTIPLE_CHOICES", 
    _301_MOVED_PERMANENTLY = "301 MOVED_PERMANENTLY", 
    _302_FOUND = "302 FOUND", 
    _302_MOVED_TEMPORARILY = "302 MOVED_TEMPORARILY", 
    _303_SEE_OTHER = "303 SEE_OTHER", 
    _304_NOT_MODIFIED = "304 NOT_MODIFIED", 
    _305_USE_PROXY = "305 USE_PROXY", 
    _307_TEMPORARY_REDIRECT = "307 TEMPORARY_REDIRECT", 
    _308_PERMANENT_REDIRECT = "308 PERMANENT_REDIRECT", 
    _400_BAD_REQUEST = "400 BAD_REQUEST", 
    _401_UNAUTHORIZED = "401 UNAUTHORIZED", 
    _402_PAYMENT_REQUIRED = "402 PAYMENT_REQUIRED", 
    _403_FORBIDDEN = "403 FORBIDDEN", 
    _404_NOT_FOUND = "404 NOT_FOUND", 
    _405_METHOD_NOT_ALLOWED = "405 METHOD_NOT_ALLOWED", 
    _406_NOT_ACCEPTABLE = "406 NOT_ACCEPTABLE", 
    _407_PROXY_AUTHENTICATION_REQUIRED = "407 PROXY_AUTHENTICATION_REQUIRED", 
    _408_REQUEST_TIMEOUT = "408 REQUEST_TIMEOUT", 
    _409_CONFLICT = "409 CONFLICT", 
    _410_GONE = "410 GONE", 
    _411_LENGTH_REQUIRED = "411 LENGTH_REQUIRED", 
    _412_PRECONDITION_FAILED = "412 PRECONDITION_FAILED", 
    _413_PAYLOAD_TOO_LARGE = "413 PAYLOAD_TOO_LARGE", 
    _413_REQUEST_ENTITY_TOO_LARGE = "413 REQUEST_ENTITY_TOO_LARGE", 
    _414_URI_TOO_LONG = "414 URI_TOO_LONG", 
    _414_REQUEST_URI_TOO_LONG = "414 REQUEST_URI_TOO_LONG", 
    _415_UNSUPPORTED_MEDIA_TYPE = "415 UNSUPPORTED_MEDIA_TYPE", 
    _416_REQUESTED_RANGE_NOT_SATISFIABLE = "416 REQUESTED_RANGE_NOT_SATISFIABLE", 
    _417_EXPECTATION_FAILED = "417 EXPECTATION_FAILED", 
    _418_I_AM_A_TEAPOT = "418 I_AM_A_TEAPOT", 
    _419_INSUFFICIENT_SPACE_ON_RESOURCE = "419 INSUFFICIENT_SPACE_ON_RESOURCE", 
    _420_METHOD_FAILURE = "420 METHOD_FAILURE", 
    _421_DESTINATION_LOCKED = "421 DESTINATION_LOCKED", 
    _422_UNPROCESSABLE_ENTITY = "422 UNPROCESSABLE_ENTITY", 
    _423_LOCKED = "423 LOCKED", 
    _424_FAILED_DEPENDENCY = "424 FAILED_DEPENDENCY", 
    _426_UPGRADE_REQUIRED = "426 UPGRADE_REQUIRED", 
    _428_PRECONDITION_REQUIRED = "428 PRECONDITION_REQUIRED", 
    _429_TOO_MANY_REQUESTS = "429 TOO_MANY_REQUESTS", 
    _431_REQUEST_HEADER_FIELDS_TOO_LARGE = "431 REQUEST_HEADER_FIELDS_TOO_LARGE", 
    _451_UNAVAILABLE_FOR_LEGAL_REASONS = "451 UNAVAILABLE_FOR_LEGAL_REASONS", 
    _500_INTERNAL_SERVER_ERROR = "500 INTERNAL_SERVER_ERROR", 
    _501_NOT_IMPLEMENTED = "501 NOT_IMPLEMENTED", 
    _502_BAD_GATEWAY = "502 BAD_GATEWAY", 
    _503_SERVICE_UNAVAILABLE = "503 SERVICE_UNAVAILABLE", 
    _504_GATEWAY_TIMEOUT = "504 GATEWAY_TIMEOUT", 
    _505_HTTP_VERSION_NOT_SUPPORTED = "505 HTTP_VERSION_NOT_SUPPORTED", 
    _506_VARIANT_ALSO_NEGOTIATES = "506 VARIANT_ALSO_NEGOTIATES", 
    _507_INSUFFICIENT_STORAGE = "507 INSUFFICIENT_STORAGE", 
    _508_LOOP_DETECTED = "508 LOOP_DETECTED", 
    _509_BANDWIDTH_LIMIT_EXCEEDED = "509 BANDWIDTH_LIMIT_EXCEEDED", 
    _510_NOT_EXTENDED = "510 NOT_EXTENDED", 
    _511_NETWORK_AUTHENTICATION_REQUIRED = "511 NETWORK_AUTHENTICATION_REQUIRED", 
}

export enum PerformerTypeGroupCode {
    MEDIC = "MEDIC", 
    DRIVER = "DRIVER", 
    MANAGER = "MANAGER", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}