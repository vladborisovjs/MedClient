/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.7.0 (NJsonSchema v9.10.70.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MedApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "172.16.6.166:8080/tcmk";
    }

    /**
     * [CREATE] роли -> получение списка пользователей по роли
     * @param subId (optional) subId
     * @param action (optional) action
     * @param date_from (optional) date_from
     * @param date_to (optional) date_to
     * @return OK
     */
    getLogsUsingGET(subId?: number | null | undefined, action?: Action | null | undefined, date_from?: string | null | undefined, date_to?: string | null | undefined): Observable<ListDtoOfLogDto> {
        let url_ = this.baseUrl + "/api/admin/logs?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&"; 
        if (date_from !== undefined)
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to !== undefined)
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogsUsingGET(response: HttpResponseBase): Observable<ListDtoOfLogDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfLogDto.fromJS(resultData200) : new ListDtoOfLogDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfLogDto>(<any>null);
    }

    /**
     * [READ] роли -> получение списка всех ролей
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET(deleted?: boolean | null | undefined): Observable<ListDtoOfRole> {
        let url_ = this.baseUrl + "/api/admin/roles?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfRole>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET(response: HttpResponseBase): Observable<ListDtoOfRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfRole.fromJS(resultData200) : new ListDtoOfRole();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfRole>(<any>null);
    }

    /**
     * [CREATE] роли -> создание новой роли
     * @param role role
     * @return OK
     */
    createUsingPOST(role: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/admin/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Role.fromJS(resultData200) : new Role();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    /**
     * [READ] роли -> получение роли по id
     * @param id id
     * @return OK
     */
    readOneUsingGET(id: number): Observable<Role> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Role.fromJS(resultData200) : new Role();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    /**
     * [UPDATE] роли -> изменение роли
     * @param id id
     * @param role role
     * @return OK
     */
    updateUsingPUT(id: number, role: Role): Observable<Role> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Role.fromJS(resultData200) : new Role();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    /**
     * [CREATE] роли -> получение списка пользователей по роли
     * @param id id
     * @return OK
     */
    getPerformersUsingGET(id: number): Observable<ListDtoOfPerformer> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}/performers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfPerformer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfPerformer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformersUsingGET(response: HttpResponseBase): Observable<ListDtoOfPerformer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfPerformer.fromJS(resultData200) : new ListDtoOfPerformer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfPerformer>(<any>null);
    }

    /**
     * [CREATE] роли -> получение структуры прав и разрешений
     * @param id id
     * @return OK
     */
    createUsingGET(id: number): Observable<ListDtoOfPermission> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfPermission>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfPermission>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingGET(response: HttpResponseBase): Observable<ListDtoOfPermission> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfPermission.fromJS(resultData200) : new ListDtoOfPermission();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfPermission>(<any>null);
    }

    /**
     * [CREATE] роли -> обновление прав и разрешений
     * @param id id
     * @param permissions permissions
     * @return OK
     */
    createPermissionsUsingPUT(id: number, permissions: string[]): Observable<ListDtoOfstring> {
        let url_ = this.baseUrl + "/api/admin/roles/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissions);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePermissionsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePermissionsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfstring>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfstring>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePermissionsUsingPUT(response: HttpResponseBase): Observable<ListDtoOfstring> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfstring.fromJS(resultData200) : new ListDtoOfstring();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfstring>(<any>null);
    }

    /**
     * addRolesToPerformer
     * @param roles roles
     * @param performerId (optional) performerId
     * @return OK
     */
    addRolesToPerformerUsingPOST(roles: RoleBean[], performerId?: number | null | undefined): Observable<ListContainerOfRoleBean> {
        let url_ = this.baseUrl + "/api/andy/admin/add_role?";
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roles);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToPerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToPerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfRoleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfRoleBean>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToPerformerUsingPOST(response: HttpResponseBase): Observable<ListContainerOfRoleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfRoleBean.fromJS(resultData200) : new ListContainerOfRoleBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfRoleBean>(<any>null);
    }

    /**
     * getPerformerByMeWithBrigade
     * @return OK
     */
    getPerformerByMeWithBrigadeUsingGET(): Observable<PerformerContainer> {
        let url_ = this.baseUrl + "/api/andy/admin/performer/additional";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerByMeWithBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerByMeWithBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerByMeWithBrigadeUsingGET(response: HttpResponseBase): Observable<PerformerContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerContainer.fromJS(resultData200) : new PerformerContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerContainer>(<any>null);
    }

    /**
     * getPerformerByMe
     * @return OK
     */
    getPerformerByMeUsingGET(): Observable<PerformerContainer> {
        let url_ = this.baseUrl + "/api/andy/admin/performer/main";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerByMeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerByMeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerByMeUsingGET(response: HttpResponseBase): Observable<PerformerContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerContainer.fromJS(resultData200) : new PerformerContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerContainer>(<any>null);
    }

    /**
     * getPerformerRoleList
     * @param id id
     * @return OK
     */
    getPerformerRoleListUsingGET(id: number): Observable<ListContainerOfRoleBean> {
        let url_ = this.baseUrl + "/api/andy/admin/performer_role_list/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerRoleListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerRoleListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfRoleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfRoleBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerRoleListUsingGET(response: HttpResponseBase): Observable<ListContainerOfRoleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfRoleBean.fromJS(resultData200) : new ListContainerOfRoleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfRoleBean>(<any>null);
    }

    /**
     * removeRolesFromPerformer
     * @param roles roles
     * @param performerId (optional) performerId
     * @return OK
     */
    removeRolesFromPerformerUsingPOST(roles: RoleBean[], performerId?: number | null | undefined): Observable<ListContainerOfRoleBean> {
        let url_ = this.baseUrl + "/api/andy/admin/remove_role?";
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roles);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRolesFromPerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRolesFromPerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfRoleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfRoleBean>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRolesFromPerformerUsingPOST(response: HttpResponseBase): Observable<ListContainerOfRoleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfRoleBean.fromJS(resultData200) : new ListContainerOfRoleBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfRoleBean>(<any>null);
    }

    /**
     * Удаление бригады по Id
     * @param id id
     * @return OK
     */
    deleteBrigadeUsingDELETE(id: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeUsingDELETE(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Получение бригады по Id
     * @param id id
     * @return OK
     */
    getBrigadeUsingGET(id: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeUsingGET(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Получение списка бригад
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getBrigadeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение сообщения бригады по Id
     * @param id id
     * @return OK
     */
    assignedBrigadeMessageBeanUsingGET(id: number): Observable<AssignedBrigadeMessageBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignedBrigadeMessageBeanUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignedBrigadeMessageBeanUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean>><any>_observableThrow(response_);
        }));
    }

    protected processAssignedBrigadeMessageBeanUsingGET(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssignedBrigadeMessageBean.fromJS(resultData200) : new AssignedBrigadeMessageBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean>(<any>null);
    }

    /**
     * Получение списка сообщений
     * @param brigadeId brigadeId
     * @param callId callId
     * @return OK
     */
    getAssignedBrigadeMessageListUsingGET(brigadeId: number, callId: number): Observable<AssignedBrigadeMessageBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/list?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined and cannot be null.");
        else
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined and cannot be null.");
        else
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignedBrigadeMessageListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignedBrigadeMessageListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssignedBrigadeMessageListUsingGET(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssignedBrigadeMessageBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean[]>(<any>null);
    }

    /**
     * Отправка сообщения
     * @param brigadeId brigadeId
     * @param callId callId
     * @param receivingType receivingType
     * @param messageType messageType
     * @param statusCode (optional) statusCode
     * @return OK
     */
    updateAssignedBrigadeMessageListUsingPOST(brigadeId: number, callId: number, receivingType: number, messageType: number, statusCode?: string | null | undefined): Observable<AssignedBrigadeMessageBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/send?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined and cannot be null.");
        else
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined and cannot be null.");
        else
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        if (receivingType === undefined || receivingType === null)
            throw new Error("The parameter 'receivingType' must be defined and cannot be null.");
        else
            url_ += "receivingType=" + encodeURIComponent("" + receivingType) + "&"; 
        if (messageType === undefined || messageType === null)
            throw new Error("The parameter 'messageType' must be defined and cannot be null.");
        else
            url_ += "messageType=" + encodeURIComponent("" + messageType) + "&"; 
        if (statusCode !== undefined)
            url_ += "statusCode=" + encodeURIComponent("" + statusCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssignedBrigadeMessageListUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssignedBrigadeMessageListUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssignedBrigadeMessageListUsingPOST(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssignedBrigadeMessageBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean[]>(<any>null);
    }

    /**
     * Обновление сообщений бригады
     * @param list list
     * @return OK
     */
    updateAssignedBrigadeMessageListUsingPOST_1(list: AssignedBrigadeMessageBean[]): Observable<AssignedBrigadeMessageBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/message/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(list);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssignedBrigadeMessageListUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssignedBrigadeMessageListUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedBrigadeMessageBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssignedBrigadeMessageListUsingPOST_1(response: HttpResponseBase): Observable<AssignedBrigadeMessageBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssignedBrigadeMessageBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssignedBrigadeMessageBean[]>(<any>null);
    }

    /**
     * Восстановление бригады по Id
     * @param id id
     * @return OK
     */
    restoreBrigadeUsingPOST(id: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBrigadeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBrigadeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBrigadeUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Получение расписания бригад
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param isBrigadeDeleted (optional) isBrigadeDeleted
     * @param isAvailable (optional) isAvailable
     * @param isTrimming (optional) isTrimming
     * @return OK
     */
    getBrigadeScheduleMapUsingGET(dateFrom: string, dateTo: string, isBrigadeDeleted?: boolean | null | undefined, isAvailable?: boolean | null | undefined, isTrimming?: boolean | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/all?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isBrigadeDeleted !== undefined)
            url_ += "isBrigadeDeleted=" + encodeURIComponent("" + isBrigadeDeleted) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (isTrimming !== undefined)
            url_ += "isTrimming=" + encodeURIComponent("" + isTrimming) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Получение списка доступных для назначения в бригаду сотрудников
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param type (optional) type
     * @return OK
     */
    getAvailablePerformersUsingGET(dateFrom: string, dateTo: string, type?: number | null | undefined): Observable<PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/available/performer?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailablePerformersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailablePerformersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailablePerformersUsingGET(response: HttpResponseBase): Observable<PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean[]>(<any>null);
    }

    /**
     * Получение списка доступного для назначения в бригаду транспорта
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @return OK
     */
    getAvailableTransportsUsingGET(dateFrom: string, dateTo: string): Observable<PairOfTransportBeanAndListOfBrigadeTransportScheduleBean[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/available/transport?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableTransportsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableTransportsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PairOfTransportBeanAndListOfBrigadeTransportScheduleBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfTransportBeanAndListOfBrigadeTransportScheduleBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableTransportsUsingGET(response: HttpResponseBase): Observable<PairOfTransportBeanAndListOfBrigadeTransportScheduleBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfTransportBeanAndListOfBrigadeTransportScheduleBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfTransportBeanAndListOfBrigadeTransportScheduleBean[]>(<any>null);
    }

    /**
     * Получение списка актуальных составов бригад
     * @param actualDate (optional) actualDate
     * @param isAvailable (optional) isAvailable
     * @return OK
     */
    getActualBrigadeCrewListUsingGET(actualDate?: string | null | undefined, isAvailable?: boolean | null | undefined): Observable<BrigadeContainer[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/crew/list/actual?";
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent("" + actualDate) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualBrigadeCrewListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualBrigadeCrewListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualBrigadeCrewListUsingGET(response: HttpResponseBase): Observable<BrigadeContainer[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeContainer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer[]>(<any>null);
    }

    /**
     * Получение списка актуальных составов бригад
     * @param brigadeIds (optional) brigadeIds
     * @param actualDate (optional) actualDate
     * @return OK
     */
    getActualBrigadeCrewListByIdsUsingGET(brigadeIds?: number[] | null | undefined, actualDate?: Date | null | undefined): Observable<BrigadeContainer[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/crew/list/ids?";
        if (brigadeIds !== undefined)
            brigadeIds && brigadeIds.forEach(item => { url_ += "brigadeIds=" + encodeURIComponent("" + item) + "&"; });
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent(actualDate ? "" + actualDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualBrigadeCrewListByIdsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualBrigadeCrewListByIdsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualBrigadeCrewListByIdsUsingGET(response: HttpResponseBase): Observable<BrigadeContainer[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeContainer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer[]>(<any>null);
    }

    /**
     * Получение актуального состава бригады
     * @param id id
     * @param actualDate (optional) actualDate
     * @return OK
     */
    getActualBrigadeCrewUsingGET(id: number, actualDate?: Date | null | undefined): Observable<BrigadeContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/crew/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (actualDate !== undefined)
            url_ += "actualDate=" + encodeURIComponent(actualDate ? "" + actualDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActualBrigadeCrewUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActualBrigadeCrewUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetActualBrigadeCrewUsingGET(response: HttpResponseBase): Observable<BrigadeContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeContainer.fromJS(resultData200) : new BrigadeContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeContainer>(<any>null);
    }

    /**
     * Удаление расписания бригады
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    deleteBrigadeScheduleUsingDELETE(brigadeScheduleId: number): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/delete/{brigadeScheduleId}";
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Получение расписания бригады по Id
     * @param id id
     * @return OK
     */
    getBrigadeScheduleUsingGET(id: number): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleUsingGET(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Расписание выведенных на линию бригад
     * @return OK
     */
    getOnLineBrigadeScheduleMapUsingGET(): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/online";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnLineBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnLineBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOnLineBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Расписание невыведенных на линию бригад
     * @return OK
     */
    getNotOnLineBrigadeScheduleMapUsingGET(): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/outline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotOnLineBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotOnLineBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotOnLineBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Снять бригаду с линии
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    resetBrigadeFromLineUsingPOST(brigadeScheduleId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/reset_from_line/{brigadeScheduleId}";
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetBrigadeFromLineUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetBrigadeFromLineUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetBrigadeFromLineUsingPOST(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Вывести бригаду на линию
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    setBrigadeOnLineUsingPOST(brigadeScheduleId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/set_on_line/{brigadeScheduleId}";
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetBrigadeOnLineUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetBrigadeOnLineUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetBrigadeOnLineUsingPOST(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Получение расписания бригад, которые скоро выйдут на линию
     * @param isBrigadeDeleted (optional) isBrigadeDeleted
     * @return OK
     */
    getSoonBrigadeScheduleMapUsingGET(isBrigadeDeleted?: boolean | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/soon?";
        if (isBrigadeDeleted !== undefined)
            url_ += "isBrigadeDeleted=" + encodeURIComponent("" + isBrigadeDeleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoonBrigadeScheduleMapUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoonBrigadeScheduleMapUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoonBrigadeScheduleMapUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Создание/обновление расписания бригады
     * @param bean bean
     * @return OK
     */
    updateBrigadeScheduleUsingPOST(bean: BrigadeScheduleBean): Observable<BrigadeScheduleBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeScheduleUsingPOST(response: HttpResponseBase): Observable<BrigadeScheduleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleBean.fromJS(resultData200) : new BrigadeScheduleBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleBean>(<any>null);
    }

    /**
     * Получение расписания бригады
     * @param brigadeId brigadeId
     * @param dateFrom dateFrom
     * @param dateTo dateTo
     * @param isAvailable (optional) isAvailable
     * @return OK
     */
    getBrigadeScheduleListUsingGET(brigadeId: number, dateFrom: string, dateTo: string, isAvailable?: boolean | null | undefined): Observable<{ [key: string] : any; }[]> {
        let url_ = this.baseUrl + "/api/andy/brigade/schedule/{brigadeId}/list?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleListUsingGET(response: HttpResponseBase): Observable<{ [key: string] : any; }[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }[]>(<any>null);
    }

    /**
     * Установить статус бригады: "Сигнал тревоги"
     * @param brigadeId brigadeId
     * @param latitude latitude
     * @param longitude longitude
     * @return OK
     */
    setAlarmUsingPOST(brigadeId: number, latitude: number, longitude: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/alarm/{brigadeId}?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (latitude === undefined || latitude === null)
            throw new Error("The parameter 'latitude' must be defined and cannot be null.");
        else
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&"; 
        if (longitude === undefined || longitude === null)
            throw new Error("The parameter 'longitude' must be defined and cannot be null.");
        else
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAlarmUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAlarmUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetAlarmUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Установить статус бригады: "На станции"
     * @param brigadeId brigadeId
     * @return OK
     */
    setOnBaseUsingPOST(brigadeId: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/base/{brigadeId}";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOnBaseUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOnBaseUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetOnBaseUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Установить статус бригады: "Не готова"
     * @param brigadeId brigadeId
     * @param statusCode statusCode
     * @return OK
     */
    setInactiveUsingPOST(brigadeId: number, statusCode: string): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/inactive/{brigadeId}?";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (statusCode === undefined || statusCode === null)
            throw new Error("The parameter 'statusCode' must be defined and cannot be null.");
        else
            url_ += "statusCode=" + encodeURIComponent("" + statusCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetInactiveUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetInactiveUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetInactiveUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Установить статус бригады: "В пути на станцию"
     * @param brigadeId brigadeId
     * @return OK
     */
    setReturningUsingPOST(brigadeId: number): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/status/returning/{brigadeId}";
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReturningUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReturningUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processSetReturningUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * Обновление/добавление бригады
     * @param bean bean
     * @return OK
     */
    updateBrigadeUsingPOST(bean: BrigadeBean): Observable<BrigadeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeUsingPOST(response: HttpResponseBase): Observable<BrigadeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeBean.fromJS(resultData200) : new BrigadeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeBean>(<any>null);
    }

    /**
     * deleteBrigadeStatus
     * @param id id
     * @return OK
     */
    deleteBrigadeStatusUsingDELETE(id: number): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeStatusUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeStatusUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeStatusUsingDELETE(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * getBrigadeStatus
     * @param id id
     * @return OK
     */
    getBrigadeStatusUsingGET(id: number): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeStatusUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeStatusUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeStatusUsingGET(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * Получение списка статусов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @param isAvailable (optional) isAvailable
     * @return OK
     */
    getBrigadeStatusListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined, isAvailable?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (isAvailable !== undefined)
            url_ += "isAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeStatusListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeStatusListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeStatusListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * restoreBrigadeStatus
     * @param id id
     * @return OK
     */
    restoreBrigadeStatusUsingPOST(id: number): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBrigadeStatusUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBrigadeStatusUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBrigadeStatusUsingPOST(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * updateBrigadeStatus
     * @param bean bean
     * @return OK
     */
    updateBrigadeStatusUsingPOST(bean: BrigadeStatusBean): Observable<BrigadeStatusBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeStatusUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeStatusUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeStatusBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeStatusBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeStatusUsingPOST(response: HttpResponseBase): Observable<BrigadeStatusBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeStatusBean.fromJS(resultData200) : new BrigadeStatusBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeStatusBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPerformerTypeVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/brigade_status/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * deleteBrigadeType
     * @param id id
     * @return OK
     */
    deleteBrigadeTypeUsingDELETE(id: number): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrigadeTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrigadeTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrigadeTypeUsingDELETE(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * getBrigadeType
     * @param id id
     * @return OK
     */
    getBrigadeTypeUsingGET(id: number): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeTypeUsingGET(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * Получение списка типов бригад
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    readBrigadeTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadBrigadeTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadBrigadeTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processReadBrigadeTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * restoreBrigadeType
     * @param id id
     * @return OK
     */
    restoreBrigadeTypeUsingPOST(id: number): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBrigadeTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBrigadeTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBrigadeTypeUsingPOST(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * updateBrigadeType
     * @param bean bean
     * @return OK
     */
    updateBrigadeTypeUsingPOST(bean: BrigadeTypeBean): Observable<BrigadeTypeBean> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeTypeUsingPOST(response: HttpResponseBase): Observable<BrigadeTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeBean.fromJS(resultData200) : new BrigadeTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPerformerTypeVersionUsingGET_1(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/brigade_type/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeVersionUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeVersionUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeVersionUsingGET_1(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Получение контейнера вызовов
     * @param id id
     * @return OK
     */
    getCallContainerUsingGET(id: number): Observable<CallContainer> {
        let url_ = this.baseUrl + "/api/andy/call/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallContainerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallContainerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallContainerUsingGET(response: HttpResponseBase): Observable<CallContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallContainer.fromJS(resultData200) : new CallContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallContainer>(<any>null);
    }

    /**
     * Получение списка архива вызовов
     * @param bean bean
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @return OK
     */
    getArchiveCallListUsingPOST(bean: ArchiveCallContainer, from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArchiveCallListUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArchiveCallListUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetArchiveCallListUsingPOST(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Получение списка вызовов
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param callStatusList (optional) callStatusList
     * @param callPriorityList (optional) callPriorityList
     * @param number (optional) number
     * @param declarantName (optional) declarantName
     * @param reason (optional) reason
     * @param brigadeId (optional) brigadeId
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    getCallListUsingGET(from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, callStatusList?: CallStatusList[] | null | undefined, callPriorityList?: CallPriorityList[] | null | undefined, number?: string | null | undefined, declarantName?: string | null | undefined, reason?: number | null | undefined, brigadeId?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/call/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (callStatusList !== undefined)
            callStatusList && callStatusList.forEach(item => { url_ += "callStatusList=" + encodeURIComponent("" + item) + "&"; });
        if (callPriorityList !== undefined)
            callPriorityList && callPriorityList.forEach(item => { url_ += "callPriorityList=" + encodeURIComponent("" + item) + "&"; });
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (declarantName !== undefined)
            url_ += "declarantName=" + encodeURIComponent("" + declarantName) + "&"; 
        if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        if (brigadeId !== undefined)
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Получение статуса вызовов
     * @param id id
     * @return OK
     */
    getCallStatusUsingGET(id: number): Observable<Anonymous> {
        let url_ = this.baseUrl + "/api/andy/call/status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallStatusUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallStatusUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Anonymous>><any>_observableThrow(e);
                }
            } else
                return <Observable<Anonymous>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallStatusUsingGET(response: HttpResponseBase): Observable<Anonymous> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Anonymous>(<any>null);
    }

    /**
     * Обновление вызова
     * @param bean bean
     * @return OK
     */
    updateCallUsingPOST(bean: CallBean): Observable<CallBean> {
        let url_ = this.baseUrl + "/api/andy/call/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCallUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCallUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCallUsingPOST(response: HttpResponseBase): Observable<CallBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBean.fromJS(resultData200) : new CallBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBean>(<any>null);
    }

    /**
     * Обновление контейнера вызовов
     * @param callContainer callContainer
     * @return OK
     */
    updateCallContainerUsingPOST(callContainer: CallContainer): Observable<CallContainer> {
        let url_ = this.baseUrl + "/api/andy/call/update_call_container";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(callContainer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCallContainerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCallContainerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallContainer>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCallContainerUsingPOST(response: HttpResponseBase): Observable<CallContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallContainer.fromJS(resultData200) : new CallContainer();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallContainer>(<any>null);
    }

    /**
     * Получение карты вызова
     * @param id id
     * @return OK
     */
    getCardUsingGET(id: number): Observable<CardBean> {
        let url_ = this.baseUrl + "/api/andy/card/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardUsingGET(response: HttpResponseBase): Observable<CardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBean.fromJS(resultData200) : new CardBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBean>(<any>null);
    }

    /**
     * Получение списка вызовов
     * @param from (optional) from
     * @param count (optional) count
     * @param orderBy (optional) orderBy
     * @param isAsc (optional) isAsc
     * @param cardStatusList (optional) cardStatusList
     * @param callId (optional) callId
     * @param patientId (optional) patientId
     * @param brigadeId (optional) brigadeId
     * @return OK
     */
    getCardListUsingGET(from?: number | null | undefined, count?: number | null | undefined, orderBy?: string | null | undefined, isAsc?: boolean | null | undefined, cardStatusList?: CardStatusList[] | null | undefined, callId?: number | null | undefined, patientId?: number | null | undefined, brigadeId?: number | null | undefined): Observable<ListContainerOfMapOfstringAndobject> {
        let url_ = this.baseUrl + "/api/andy/card/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (isAsc !== undefined)
            url_ += "isAsc=" + encodeURIComponent("" + isAsc) + "&"; 
        if (cardStatusList !== undefined)
            cardStatusList && cardStatusList.forEach(item => { url_ += "cardStatusList=" + encodeURIComponent("" + item) + "&"; });
        if (callId !== undefined)
            url_ += "callId=" + encodeURIComponent("" + callId) + "&"; 
        if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&"; 
        if (brigadeId !== undefined)
            url_ += "brigadeId=" + encodeURIComponent("" + brigadeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainerOfMapOfstringAndobject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardListUsingGET(response: HttpResponseBase): Observable<ListContainerOfMapOfstringAndobject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainerOfMapOfstringAndobject.fromJS(resultData200) : new ListContainerOfMapOfstringAndobject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainerOfMapOfstringAndobject>(<any>null);
    }

    /**
     * Обновление вызова
     * @param bean bean
     * @return OK
     */
    updateCallUsingPOST_1(bean: CardBean): Observable<CardBean> {
        let url_ = this.baseUrl + "/api/andy/card/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCallUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCallUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<CardBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCallUsingPOST_1(response: HttpResponseBase): Observable<CardBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBean.fromJS(resultData200) : new CardBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBean>(<any>null);
    }

    /**
     * Удаление опросника по Id
     * @param id id
     * @return OK
     */
    deleteInquirerUsingDELETE(id: number): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInquirerUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInquirerUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInquirerUsingDELETE(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Получение опросника по Id
     * @param id id
     * @return OK
     */
    getInquirerUsingGET(id: number): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInquirerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInquirerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetInquirerUsingGET(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Получение полного дерева опросников по Id
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullNodeUsingGET(deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfInquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/node/full?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfInquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfInquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNodeOfInquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfInquirerBean.fromJS(resultData200) : new AndyTreeNodeOfInquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfInquirerBean>(<any>null);
    }

    /**
     * Восстановление опросника по Id
     * @param id id
     * @return OK
     */
    restoreInquirerUsingPOST(id: number): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreInquirerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreInquirerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreInquirerUsingPOST(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Обновление опросника
     * @param bean bean
     * @return OK
     */
    updateInquirerUsingPOST(bean: InquirerBean): Observable<InquirerBean> {
        let url_ = this.baseUrl + "/api/andy/inquirer/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInquirerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInquirerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<InquirerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInquirerUsingPOST(response: HttpResponseBase): Observable<InquirerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerBean.fromJS(resultData200) : new InquirerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getInquirerVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/inquirer/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInquirerVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInquirerVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetInquirerVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Получение списка действий исполнителя
     * @param from (optional) От
     * @param count (optional) Количество
     * @param performerId (optional) ID исполнителя
     * @return OK
     */
    getLogListByUserUsingGET(from?: number | null | undefined, count?: number | null | undefined, performerId?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/performer/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (performerId !== undefined)
            url_ += "performerId=" + encodeURIComponent("" + performerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByUserUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByUserUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByUserUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка действий для конкретной записи
     * @param from (optional) От
     * @param count (optional) Количество
     * @param recordId (optional) ID записи
     * @param recordType (optional) Тип записи
     * @return OK
     */
    getLogListByRecordUsingGET(from?: number | null | undefined, count?: number | null | undefined, recordId?: number | null | undefined, recordType?: RecordType | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/record/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (recordId !== undefined)
            url_ += "recordId=" + encodeURIComponent("" + recordId) + "&"; 
        if (recordType !== undefined)
            url_ += "recordType=" + encodeURIComponent("" + recordType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByRecordUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByRecordUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByRecordUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение расширенного списка действий для конкретной записи
     * @param from (optional) От
     * @param count (optional) Количество
     * @param recordId (optional) ID записи
     * @param logType (optional) Тип лога
     * @param recordType (optional) Тип записи
     * @return OK
     */
    getExtendedLogListByRecordUsingGET(from?: number | null | undefined, count?: number | null | undefined, recordId?: number | null | undefined, logType?: number | null | undefined, recordType?: RecordType2 | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/record/list/extended?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (recordId !== undefined)
            url_ += "recordId=" + encodeURIComponent("" + recordId) + "&"; 
        if (logType !== undefined)
            url_ += "logType=" + encodeURIComponent("" + logType) + "&"; 
        if (recordType !== undefined)
            url_ += "recordType=" + encodeURIComponent("" + recordType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExtendedLogListByRecordUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExtendedLogListByRecordUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetExtendedLogListByRecordUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка действий для типа записи(таблицы)
     * @param from (optional) От
     * @param count (optional) Количество
     * @param logType (optional) Тип записи
     * @return OK
     */
    getLogListByTableUsingGET(from?: number | null | undefined, count?: number | null | undefined, logType?: number | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/log/table/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (logType !== undefined)
            url_ += "logType=" + encodeURIComponent("" + logType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogListByTableUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogListByTableUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogListByTableUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Удаление классификации МКБ по Id
     * @param id id
     * @return OK
     */
    deleteClassMkbUsingDELETE(id: number): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassMkbUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassMkbUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteClassMkbUsingDELETE(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Получение классификации МКБ по Id
     * @param id id
     * @return OK
     */
    getClassMkbUsingGET(id: number): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassMkbUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassMkbUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassMkbUsingGET(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Получение списка референсов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/mkb/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение следующего уровня дерева классификаций МКБ по Id родителя
     * @param rootId (optional) rootId
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullMkbNodeUsingGET(rootId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/node/branch?";
        if (rootId !== undefined)
            url_ += "rootId=" + encodeURIComponent("" + rootId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullMkbNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullMkbNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullMkbNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNodeOfClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfClassMkbBean.fromJS(resultData200) : new AndyTreeNodeOfClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfClassMkbBean>(<any>null);
    }

    /**
     * Получение полного дерева классификаций МКБ по Id
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullMkbNodeUsingGET_1(deleted?: boolean | null | undefined): Observable<AndyTreeNodeOfClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/node/full?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullMkbNodeUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullMkbNodeUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNodeOfClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullMkbNodeUsingGET_1(response: HttpResponseBase): Observable<AndyTreeNodeOfClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNodeOfClassMkbBean.fromJS(resultData200) : new AndyTreeNodeOfClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNodeOfClassMkbBean>(<any>null);
    }

    /**
     * Восстановление классификации МКБ по Id
     * @param id id
     * @return OK
     */
    restoreClassMkbUsingPOST(id: number): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreClassMkbUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreClassMkbUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreClassMkbUsingPOST(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Обновление классификации МКБ
     * @param bean bean
     * @return OK
     */
    updateClassMkbUsingPOST(bean: ClassMkbBean): Observable<ClassMkbBean> {
        let url_ = this.baseUrl + "/api/andy/mkb/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClassMkbUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClassMkbUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ClassMkbBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClassMkbBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateClassMkbUsingPOST(response: HttpResponseBase): Observable<ClassMkbBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClassMkbBean.fromJS(resultData200) : new ClassMkbBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClassMkbBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getClassMkbVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/mkb/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassMkbVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassMkbVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassMkbVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Полнотекстовый поиск улицы
     * @param cityAddress (optional) cityAddress
     * @param streetName (optional) streetName
     * @return OK
     */
    getBuildingListUsingGET(cityAddress?: string | null | undefined, streetName?: string | null | undefined): Observable<BuildingBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/building?";
        if (cityAddress !== undefined)
            url_ += "cityAddress=" + encodeURIComponent("" + cityAddress) + "&"; 
        if (streetName !== undefined)
            url_ += "streetName=" + encodeURIComponent("" + streetName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildingListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildingListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BuildingBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildingListUsingGET(response: HttpResponseBase): Observable<BuildingBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BuildingBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingBean[]>(<any>null);
    }

    /**
     * Полнотекстовый поиск района/области
     * @param query (optional) query
     * @return OK
     */
    getRegionListUsingGET(query?: string | null | undefined): Observable<RegionBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/region?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<RegionBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegionBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionListUsingGET(response: HttpResponseBase): Observable<RegionBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RegionBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegionBean[]>(<any>null);
    }

    /**
     * Полнотекстовый поиск населенного пункта
     * @param query (optional) query
     * @return OK
     */
    getSettlementListUsingGET(query?: string | null | undefined): Observable<SettlementBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/settlement?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettlementListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettlementListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SettlementBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettlementBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettlementListUsingGET(response: HttpResponseBase): Observable<SettlementBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SettlementBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettlementBean[]>(<any>null);
    }

    /**
     * Полнотекстовый поиск улицы
     * @param query (optional) query
     * @return OK
     */
    getStreetListUsingGET(query?: string | null | undefined): Observable<StreetBean[]> {
        let url_ = this.baseUrl + "/api/andy/osm/street?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStreetListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStreetListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<StreetBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StreetBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStreetListUsingGET(response: HttpResponseBase): Observable<StreetBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StreetBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StreetBean[]>(<any>null);
    }

    /**
     * Удаление пациента по Id
     * @param id id
     * @return OK
     */
    deletePatientUsingDELETE(id: number): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePatientUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePatientUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePatientUsingDELETE(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Получение пациента по Id
     * @param id id
     * @return OK
     */
    getPatientUsingGET(id: number): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatientUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatientUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPatientUsingGET(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Получение списка пациентов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param patientType (optional) patientType
     * @param surname (optional) surname
     * @return OK
     */
    getPatientListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, patientType?: number | null | undefined, surname?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/patients/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (patientType !== undefined)
            url_ += "patientType=" + encodeURIComponent("" + patientType) + "&"; 
        if (surname !== undefined)
            url_ += "surname=" + encodeURIComponent("" + surname) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatientListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatientListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPatientListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление пациента по Id
     * @param id id
     * @return OK
     */
    restorePatientUsingPOST(id: number): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePatientUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePatientUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePatientUsingPOST(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Обновление пациента
     * @param bean bean
     * @return OK
     */
    updatePatientUsingPOST(bean: PatientBean): Observable<PatientBean> {
        let url_ = this.baseUrl + "/api/andy/patients/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PatientBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatientUsingPOST(response: HttpResponseBase): Observable<PatientBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientBean.fromJS(resultData200) : new PatientBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientBean>(<any>null);
    }

    /**
     * Удаление расписания сотрудников
     * @param performerIds (optional) performerIds
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @param isBasic (optional) Тип удаляемых смен [true - по графику; false - БГ; null - все]
     * @return OK
     */
    scheduleClearUsingDELETE(performerIds?: number[] | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined, isBasic?: boolean | null | undefined): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/clear_schedule?";
        if (performerIds !== undefined)
            performerIds && performerIds.forEach(item => { url_ += "performerIds=" + encodeURIComponent("" + item) + "&"; });
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isBasic !== undefined)
            url_ += "isBasic=" + encodeURIComponent("" + isBasic) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleClearUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleClearUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleClearUsingDELETE(response: HttpResponseBase): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfPerformerBeanAndListOfMapOfstringAndobject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>(<any>null);
    }

    /**
     * Пролонгация расписания сотрудников
     * @param performerIds (optional) performerIds
     * @param scheduleTypeId (optional) scheduleTypeId
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @param isBasic (optional) isBasic
     * @return OK
     */
    scheduleProlongationUsingPOST(performerIds?: number[] | null | undefined, scheduleTypeId?: number | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined, isBasic?: boolean | null | undefined): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/create_schedule?";
        if (performerIds !== undefined)
            performerIds && performerIds.forEach(item => { url_ += "performerIds=" + encodeURIComponent("" + item) + "&"; });
        if (scheduleTypeId !== undefined)
            url_ += "scheduleTypeId=" + encodeURIComponent("" + scheduleTypeId) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        if (isBasic !== undefined)
            url_ += "isBasic=" + encodeURIComponent("" + isBasic) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleProlongationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleProlongationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleProlongationUsingPOST(response: HttpResponseBase): Observable<PairOfPerformerBeanAndListOfMapOfstringAndobject[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PairOfPerformerBeanAndListOfMapOfstringAndobject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PairOfPerformerBeanAndListOfMapOfstringAndobject[]>(<any>null);
    }

    /**
     * Удаление смены сотрудника
     * @param id id
     * @return OK
     */
    deletePerformerShiftUsingDELETE(id: number): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerShiftUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerShiftUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerShiftUsingDELETE(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Получение смены сотрудника
     * @param id id
     * @return OK
     */
    getPerformerShiftUsingGET(id: number): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerShiftUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerShiftUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerShiftUsingGET(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Восстановление смены сотрудника
     * @param id id
     * @return OK
     */
    restorePerformerShiftUsingPOST(id: number): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePerformerShiftUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePerformerShiftUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePerformerShiftUsingPOST(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Получение таблицы смен сотрудников
     * @param isPerformerDeleted (optional) isPerformerDeleted
     * @param isShiftDeleted (optional) isShiftDeleted
     * @param dateFrom (optional) dateFrom
     * @param dateTo (optional) dateTo
     * @return OK
     */
    getPerformerShiftTableUsingGET(isPerformerDeleted?: boolean | null | undefined, isShiftDeleted?: boolean | null | undefined, dateFrom?: string | null | undefined, dateTo?: string | null | undefined): Observable<Pair[]> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/table?";
        if (isPerformerDeleted !== undefined)
            url_ += "isPerformerDeleted=" + encodeURIComponent("" + isPerformerDeleted) + "&"; 
        if (isShiftDeleted !== undefined)
            url_ += "isShiftDeleted=" + encodeURIComponent("" + isShiftDeleted) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerShiftTableUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerShiftTableUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Pair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerShiftTableUsingGET(response: HttpResponseBase): Observable<Pair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Pair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pair[]>(<any>null);
    }

    /**
     * Создание/Обновление смены сотрудника
     * @param bean bean
     * @return OK
     */
    updatePerformerShiftUsingPOST(bean: PerformerShiftBean): Observable<PerformerShiftBean> {
        let url_ = this.baseUrl + "/api/andy/performer_shifts/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerShiftUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerShiftUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerShiftBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerShiftBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerShiftUsingPOST(response: HttpResponseBase): Observable<PerformerShiftBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerShiftBean.fromJS(resultData200) : new PerformerShiftBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerShiftBean>(<any>null);
    }

    /**
     * Удаление типа исполнителя по Id
     * @param id id
     * @return OK
     */
    deletePerformerTypeUsingDELETE(id: number): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerTypeUsingDELETE(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Получение типа исполнителя по Id
     * @param id id
     * @return OK
     */
    getPerformerTypeUsingGET(id: number): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeUsingGET(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Получение списка референсов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getPerformerTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/performer_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление типа исполнителя по Id
     * @param id id
     * @return OK
     */
    restorePerformerTypeUsingPOST(id: number): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePerformerTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePerformerTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePerformerTypeUsingPOST(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Обновление типа исполнителя
     * @param bean bean
     * @return OK
     */
    updatePerformerTypeUsingPOST(bean: PerformerTypeBean): Observable<PerformerTypeBean> {
        let url_ = this.baseUrl + "/api/andy/performer_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerTypeUsingPOST(response: HttpResponseBase): Observable<PerformerTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeBean.fromJS(resultData200) : new PerformerTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPerformerTypeVersionUsingGET_2(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/performer_type/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerTypeVersionUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerTypeVersionUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerTypeVersionUsingGET_2(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление исполнителя по Id
     * @param id id
     * @return OK
     */
    deletePerformerUsingDELETE(id: number): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerUsingDELETE(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Получение исполнителя по Id
     * @param id id
     * @return OK
     */
    getPerformerUsingGET(id: number): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerUsingGET(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Получение списка исполнителей
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param type (optional) type
     * @param name (optional) name
     * @param surname (optional) surname
     * @param code (optional) code
     * @return OK
     */
    getPerformerListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, type?: number | null | undefined, name?: string | null | undefined, surname?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/performers/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (surname !== undefined)
            url_ += "surname=" + encodeURIComponent("" + surname) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformerListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformerListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformerListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление исполнителя по Id
     * @param id id
     * @return OK
     */
    restorePerformerUsingPOST(id: number): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePerformerUsingPOST(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Обновление исполнителя
     * @param bean bean
     * @return OK
     */
    updatePerformerUsingPOST(bean: PerformerBean): Observable<PerformerBean> {
        let url_ = this.baseUrl + "/api/andy/performers/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerUsingPOST(response: HttpResponseBase): Observable<PerformerBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBean.fromJS(resultData200) : new PerformerBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBean>(<any>null);
    }

    /**
     * Удаление навыка по Id
     * @param id id
     * @return OK
     */
    deletePharmacyGroupUsingDELETE(id: number): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePharmacyGroupUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePharmacyGroupUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePharmacyGroupUsingDELETE(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Получение навыка по Id
     * @param id id
     * @return OK
     */
    getPharmacyGroupUsingGET(id: number): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPharmacyGroupUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPharmacyGroupUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetPharmacyGroupUsingGET(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Получение списка навыков
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getPharmacyGroupListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPharmacyGroupListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPharmacyGroupListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPharmacyGroupListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление навыка по Id
     * @param id id
     * @return OK
     */
    restorePharmacyGroupUsingPOST(id: number): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestorePharmacyGroupUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestorePharmacyGroupUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestorePharmacyGroupUsingPOST(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Обновление навыка
     * @param bean bean
     * @return OK
     */
    updatePharmacyGroupUsingPOST(bean: PharmacyGroupBean): Observable<PharmacyGroupBean> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePharmacyGroupUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePharmacyGroupUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePharmacyGroupUsingPOST(response: HttpResponseBase): Observable<PharmacyGroupBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupBean.fromJS(resultData200) : new PharmacyGroupBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getPharmacyGroupVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/pharmacy_group/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPharmacyGroupVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPharmacyGroupVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPharmacyGroupVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Сохранение PUSH-токена
     * @param token token
     * @return OK
     */
    createPushTokenUsingPOST(token: PushTokenBean): Observable<PushTokenBean> {
        let url_ = this.baseUrl + "/api/andy/push/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePushTokenUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePushTokenUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PushTokenBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<PushTokenBean>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePushTokenUsingPOST(response: HttpResponseBase): Observable<PushTokenBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PushTokenBean.fromJS(resultData200) : new PushTokenBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PushTokenBean>(<any>null);
    }

    /**
     * Получение списка токенов
     * @return OK
     */
    getPushTokenListUsingGET(): Observable<PushTokenBean[]> {
        let url_ = this.baseUrl + "/api/andy/push/list/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPushTokenListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPushTokenListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PushTokenBean[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PushTokenBean[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPushTokenListUsingGET(response: HttpResponseBase): Observable<PushTokenBean[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PushTokenBean.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PushTokenBean[]>(<any>null);
    }

    /**
     * Тестовая отправка сообщения о новом вызове
     * @param token token
     * @return OK
     */
    testNewCallNotificationUsingPOST(token: string): Observable<string> {
        let url_ = this.baseUrl + "/api/andy/push/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(token);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNewCallNotificationUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNewCallNotificationUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTestNewCallNotificationUsingPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Удаление записи справочника
     * @param id id
     * @return OK
     */
    deleteReferenceTypeUsingDELETE(id: number): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReferenceTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReferenceTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReferenceTypeUsingDELETE(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Получение записи справочника
     * @param id id
     * @return OK
     */
    getReferenceTypeUsingGET(id: number): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeUsingGET(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Получение списка референсов по активному визиту
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListActiveVisitUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/active_visit?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListActiveVisitUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListActiveVisitUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListActiveVisitUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов аллергии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getAllergyTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/allergy_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllergyTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllergyTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllergyTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов поведения
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBehaviourUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/behaviour?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBehaviourUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBehaviourUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBehaviourUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сообщений бригады
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBrigadeMessageUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/brigade_message?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBrigadeMessageUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBrigadeMessageUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBrigadeMessageUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка способов передачи сообщения бригадой
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBrigadeReceivingUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/brigade_receiving?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBrigadeReceivingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBrigadeReceivingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBrigadeReceivingUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов мест, где бригада получила вызов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListBrigadeReceivingPlaceUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/brigade_receiving_place?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListBrigadeReceivingPlaceUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListBrigadeReceivingPlaceUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListBrigadeReceivingPlaceUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов вызова
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListCallUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/call?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListCallUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов мест поступления вызовов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListCallPlaceUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/call_place?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListCallPlaceUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListCallPlaceUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListCallPlaceUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов осложнений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListComplicationsUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/complications?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListComplicationsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListComplicationsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListComplicationsUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов оказанной помощи при осложнениях
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListComplicationsHelpUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/complications_help?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListComplicationsHelpUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListComplicationsHelpUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListComplicationsHelpUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сознания
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListConsciousUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/conscious?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListConsciousUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListConsciousUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListConsciousUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов смерти
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDeathUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/death?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDeathUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDeathUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDeathUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов заявителя
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDeclarantUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/declarant?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDeclarantUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDeclarantUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDeclarantUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка причин задержек
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDelayReasonUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/delay_reason?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDelayReasonUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDelayReasonUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDelayReasonUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов одышки
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListDyspneaUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/dyspnea?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListDyspneaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListDyspneaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListDyspneaUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов общего состояния
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListGeneralStateUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/general_state?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListGeneralStateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListGeneralStateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListGeneralStateUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сердечных шумов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListHeartNoiseUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/heart_noise?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListHeartNoiseUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListHeartNoiseUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListHeartNoiseUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов пульса
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListHeartRateUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/heart_rate?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListHeartRateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListHeartRateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListHeartRateUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сердечных тонов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListHeartToneUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/heart_tone?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListHeartToneUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListHeartToneUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListHeartToneUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов инцидента
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListIncidentUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/incident?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListIncidentUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListIncidentUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListIncidentUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов отравления
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListIntoxicationUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/intoxication?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListIntoxicationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListIntoxicationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListIntoxicationUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов хрипов в легких
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListLungsWheezingUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/lungs_wheezing?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListLungsWheezingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListLungsWheezingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListLungsWheezingUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов чувствительности лимфатических узлов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getLymphNodeSensitivityListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/lymph_node_sensitivity?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLymphNodeSensitivityListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLymphNodeSensitivityListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLymphNodeSensitivityListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка размеров лимфатических узлов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getLymphNodeSizeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/lymph_node_size?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLymphNodeSizeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLymphNodeSizeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetLymphNodeSizeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов слизистой зева
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getMucousPharynxListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/mucous_pharynx?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMucousPharynxListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMucousPharynxListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetMucousPharynxListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка социальных категорий пациента
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPatientSocialTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/patient_social_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPatientSocialTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPatientSocialTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPatientSocialTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов предоставленного пациентом документа
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPatientSourceTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/patient_source_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPatientSourceTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPatientSourceTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPatientSourceTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка мест жительства пациента
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPatientTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/patient_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPatientTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPatientTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPatientTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов зрачков
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPenaltiesUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/penalties?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPenaltiesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPenaltiesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPenaltiesUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов зрачков DS
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPenaltiesDSUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/penalties_d_s?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPenaltiesDSUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPenaltiesDSUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPenaltiesDSUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов перкурторных звуков легких
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListPercLungsSoundUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/perc_lungs_sound?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListPercLungsSoundUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListPercLungsSoundUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListPercLungsSoundUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов получения сообщения
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListReceivingTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/receiving_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListReceivingTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListReceivingTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListReceivingTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов рефлексов DS
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListReflexesDSUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/reflexes_d_s?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListReflexesDSUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListReflexesDSUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListReflexesDSUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов результата
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListResultUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/result?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListResultUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListResultUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListResultUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка причин в результате карты Ф110
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListResultCauseUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/result_cause?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListResultCauseUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListResultCauseUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListResultCauseUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов вызово
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListRingTypeUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/ring_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListRingTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListRingTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListRingTypeUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов стула
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getShitTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/shit_type?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShitTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShitTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetShitTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка цветов кожи
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListSkinColorUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/skin_color?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListSkinColorUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListSkinColorUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListSkinColorUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов сухожильных рефлексов
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListTendonReflexesUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/tendon_reflexes?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListTendonReflexesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListTendonReflexesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListTendonReflexesUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка типов транспортировке
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param type (optional) type
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListTransportationUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, type?: string | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/transportation?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListTransportationUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListTransportationUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListTransportationUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка методов транспортировки
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getReferenceTypeListTransportationMethodUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/reference_type/list/transportation_method?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeListTransportationMethodUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeListTransportationMethodUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeListTransportationMethodUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление записи справочника
     * @param id id
     * @return OK
     */
    restoreReferenceTypeUsingPOST(id: number): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreReferenceTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreReferenceTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreReferenceTypeUsingPOST(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Создание/Обновление записи справочника
     * @param bean bean
     * @return OK
     */
    updateReferenceTypeUsingPOST(bean: ReferenceTypeBean): Observable<ReferenceTypeBean> {
        let url_ = this.baseUrl + "/api/andy/reference_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReferenceTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReferenceTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReferenceTypeUsingPOST(response: HttpResponseBase): Observable<ReferenceTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeBean.fromJS(resultData200) : new ReferenceTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getReferenceTypeTypeVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/reference_type/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReferenceTypeTypeVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenceTypeTypeVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenceTypeTypeVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Получение роли по Id
     * @param id id
     * @return OK
     */
    getInquirerUsingGET_1(id: number): Observable<RoleBean> {
        let url_ = this.baseUrl + "/api/andy/role/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInquirerUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInquirerUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<RoleBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetInquirerUsingGET_1(response: HttpResponseBase): Observable<RoleBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleBean.fromJS(resultData200) : new RoleBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleBean>(<any>null);
    }

    /**
     * Удаление типа расписания по Id
     * @param id id
     * @return OK
     */
    deleteScheduleTypeUsingDELETE(id: number): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteScheduleTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteScheduleTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteScheduleTypeUsingDELETE(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Получение типа расписания по Id
     * @param id id
     * @return OK
     */
    getScheduleTypeUsingGET(id: number): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleTypeUsingGET(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Получение списка типов расписаний
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getScheduleTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * восстановление типа расписания по Id
     * @param id id
     * @return OK
     */
    restoreScheduleTypeUsingPOST(id: number): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreScheduleTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreScheduleTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreScheduleTypeUsingPOST(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Обновление типа расписания
     * @param bean bean
     * @return OK
     */
    updateScheduleTypeUsingPOST(bean: ScheduleTypeBean): Observable<ScheduleTypeBean> {
        let url_ = this.baseUrl + "/api/andy/schedule_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheduleTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheduleTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheduleTypeUsingPOST(response: HttpResponseBase): Observable<ScheduleTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleTypeBean.fromJS(resultData200) : new ScheduleTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleTypeBean>(<any>null);
    }

    /**
     * Удаление навыка по Id
     * @param id id
     * @return OK
     */
    deleteSkillUsingDELETE(id: number): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkillUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkillUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkillUsingDELETE(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Получение навыка по Id
     * @param id id
     * @return OK
     */
    getSkillUsingGET(id: number): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillUsingGET(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Получение списка навыков
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getSkillListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/skill/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление навыка по Id
     * @param id id
     * @return OK
     */
    restoreSkillUsingPOST(id: number): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSkillUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSkillUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSkillUsingPOST(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Обновление навыка
     * @param bean bean
     * @return OK
     */
    updateSkillUsingPOST(bean: SkillBean): Observable<SkillBean> {
        let url_ = this.baseUrl + "/api/andy/skill/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkillUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkillUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SkillBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkillUsingPOST(response: HttpResponseBase): Observable<SkillBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillBean.fromJS(resultData200) : new SkillBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getSkillVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/skill/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkillVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkillVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkillVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление подразделения по Id
     * @param id id
     * @return OK
     */
    deleteSubdivisionUsingDELETE(id: number): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubdivisionUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubdivisionUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubdivisionUsingDELETE(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Получение подразделения по Id
     * @param id id
     * @return OK
     */
    getSubdivisionUsingGET(id: number): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionUsingGET(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Получение списка подразделений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param types (optional) types
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getSubdivisionListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, types?: number[] | null | undefined, name?: string | null | undefined, code?: string[] | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/subdivision/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (types !== undefined)
            types && types.forEach(item => { url_ += "types=" + encodeURIComponent("" + item) + "&"; });
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            code && code.forEach(item => { url_ += "code=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение списка основных подразделений
     * @param from (optional) from
     * @param count (optional) count
     * @param name (optional) name
     * @param deleted (optional) deleted
     * @return OK
     */
    getPrimarySubdivisionListUsingGET(from?: number | null | undefined, count?: number | null | undefined, name?: string | null | undefined, deleted?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/subdivision/list/primary?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimarySubdivisionListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimarySubdivisionListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrimarySubdivisionListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Получение полного списка подразделений
     * @param deleted (optional) deleted
     * @return OK
     */
    getFullSubdivisionNodeUsingGET(deleted?: boolean | null | undefined): Observable<AndyTreeNode> {
        let url_ = this.baseUrl + "/api/andy/subdivision/node/full?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFullSubdivisionNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFullSubdivisionNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNode>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNode>><any>_observableThrow(response_);
        }));
    }

    protected processGetFullSubdivisionNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNode> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNode.fromJS(resultData200) : new AndyTreeNode();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNode>(<any>null);
    }

    /**
     * Получение списка основных подразделений
     * @param id id
     * @param deleted (optional) deleted
     * @return OK
     */
    getPrimarySubdivisionNodeUsingGET(id: number, deleted?: boolean | null | undefined): Observable<AndyTreeNode> {
        let url_ = this.baseUrl + "/api/andy/subdivision/node/primary/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrimarySubdivisionNodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrimarySubdivisionNodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AndyTreeNode>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndyTreeNode>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrimarySubdivisionNodeUsingGET(response: HttpResponseBase): Observable<AndyTreeNode> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AndyTreeNode.fromJS(resultData200) : new AndyTreeNode();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndyTreeNode>(<any>null);
    }

    /**
     * Восстановление подразделения по Id
     * @param id id
     * @return OK
     */
    restoreSubdivisionUsingPOST(id: number): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSubdivisionUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSubdivisionUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSubdivisionUsingPOST(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Обновление подразделения
     * @param bean bean
     * @return OK
     */
    updateSubdivisionUsingPOST(bean: SubdivisionBean): Observable<SubdivisionBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubdivisionUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubdivisionUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubdivisionUsingPOST(response: HttpResponseBase): Observable<SubdivisionBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionBean.fromJS(resultData200) : new SubdivisionBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionBean>(<any>null);
    }

    /**
     * Удаление типа подразделения по Id
     * @param id id
     * @return OK
     */
    deleteSubdivisionTypeUsingDELETE(id: number): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubdivisionTypeUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubdivisionTypeUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubdivisionTypeUsingDELETE(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Получение типа подразделения по Id
     * @param id id
     * @return OK
     */
    getSubdivisionTypeUsingGET(id: number): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionTypeUsingGET(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Получение списка типов подразделений
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getSubdivisionTypeListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionTypeListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionTypeListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionTypeListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * восстановление типа подразделения по Id
     * @param id id
     * @return OK
     */
    restoreSubdivisionTypeUsingPOST(id: number): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSubdivisionTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSubdivisionTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreSubdivisionTypeUsingPOST(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Обновление типа подразделения
     * @param bean bean
     * @return OK
     */
    updateSubdivisionTypeUsingPOST(bean: SubdivisionTypeBean): Observable<SubdivisionTypeBean> {
        let url_ = this.baseUrl + "/api/andy/subdivision_type/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubdivisionTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubdivisionTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubdivisionTypeUsingPOST(response: HttpResponseBase): Observable<SubdivisionTypeBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeBean.fromJS(resultData200) : new SubdivisionTypeBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeBean>(<any>null);
    }

    /**
     * Удаление терапии по Id
     * @param id id
     * @return OK
     */
    deleteTherapyUsingDELETE(id: number): Observable<TherapyBean> {
        let url_ = this.baseUrl + "/api/andy/therapy/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapyUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapyUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TherapyBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapyUsingDELETE(response: HttpResponseBase): Observable<TherapyBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyBean.fromJS(resultData200) : new TherapyBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyBean>(<any>null);
    }

    /**
     * Получение терапии по Id
     * @param id id
     * @return OK
     */
    getTherapyUsingGET(id: number): Observable<TherapyBean> {
        let url_ = this.baseUrl + "/api/andy/therapy/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TherapyBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyUsingGET(response: HttpResponseBase): Observable<TherapyBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyBean.fromJS(resultData200) : new TherapyBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyBean>(<any>null);
    }

    /**
     * Получение списка терапий
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param date (optional) date
     * @param isLocal (optional) isLocal
     * @return OK
     */
    getTherapyListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, date?: Date | null | undefined, isLocal?: boolean | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/therapy/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        if (isLocal !== undefined)
            url_ += "isLocal=" + encodeURIComponent("" + isLocal) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление терапии по Id
     * @param id id
     * @return OK
     */
    restoreTherapyUsingPOST(id: number): Observable<TherapyBean> {
        let url_ = this.baseUrl + "/api/andy/therapy/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTherapyUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTherapyUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTherapyUsingPOST(response: HttpResponseBase): Observable<TherapyBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyBean.fromJS(resultData200) : new TherapyBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyBean>(<any>null);
    }

    /**
     * Обновление терапии
     * @param bean bean
     * @return OK
     */
    updateTherapyUsingPOST(bean: TherapyBean): Observable<TherapyBean> {
        let url_ = this.baseUrl + "/api/andy/therapy/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapyUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapyUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapyUsingPOST(response: HttpResponseBase): Observable<TherapyBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyBean.fromJS(resultData200) : new TherapyBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyBean>(<any>null);
    }

    /**
     * Удаление предмета терапии по Id
     * @param id id
     * @return OK
     */
    deleteTherapyItemUsingDELETE(id: number): Observable<TherapyItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_item/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapyItemUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapyItemUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TherapyItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapyItemUsingDELETE(response: HttpResponseBase): Observable<TherapyItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyItemBean.fromJS(resultData200) : new TherapyItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyItemBean>(<any>null);
    }

    /**
     * Получение предмета терапии по Id
     * @param id id
     * @return OK
     */
    getTherapyItemUsingGET(id: number): Observable<TherapyItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_item/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyItemUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyItemUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TherapyItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyItemUsingGET(response: HttpResponseBase): Observable<TherapyItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyItemBean.fromJS(resultData200) : new TherapyItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyItemBean>(<any>null);
    }

    /**
     * Получение списка предметов терапии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param therapyId (optional) therapyId
     * @param productName (optional) productName
     * @return OK
     */
    getTherapyItemListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, therapyId?: number | null | undefined, productName?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/therapy_item/list/all?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (therapyId !== undefined)
            url_ += "therapyId=" + encodeURIComponent("" + therapyId) + "&"; 
        if (productName !== undefined)
            url_ += "productName=" + encodeURIComponent("" + productName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyItemListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyItemListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyItemListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление предмета терапии по Id
     * @param id id
     * @return OK
     */
    restoreTherapyItemUsingPOST(id: number): Observable<TherapyItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_item/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTherapyItemUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTherapyItemUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTherapyItemUsingPOST(response: HttpResponseBase): Observable<TherapyItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyItemBean.fromJS(resultData200) : new TherapyItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyItemBean>(<any>null);
    }

    /**
     * Обновление предмета терапии
     * @param bean bean
     * @return OK
     */
    updateTherapyItemUsingPOST(bean: TherapyItemBean): Observable<TherapyItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_item/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapyItemUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapyItemUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapyItemUsingPOST(response: HttpResponseBase): Observable<TherapyItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyItemBean.fromJS(resultData200) : new TherapyItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyItemBean>(<any>null);
    }

    /**
     * Удаление шаблона терапии по Id
     * @param id id
     * @return OK
     */
    deleteTherapyTemplateUsingDELETE(id: number): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapyTemplateUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapyTemplateUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapyTemplateUsingDELETE(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Получение шаблона терапии по Id
     * @param id id
     * @return OK
     */
    getTherapyTemplateUsingGET(id: number): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateUsingGET(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Получение списка шаблонов терапии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getTherapyTemplateListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление шаблона терапии по Id
     * @param id id
     * @return OK
     */
    restoreTherapyTemplateUsingPOST(id: number): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTherapyTemplateUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTherapyTemplateUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTherapyTemplateUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Обновление шаблона терапии
     * @param bean bean
     * @return OK
     */
    updateTherapyTemplateUsingPOST(bean: TherapyTemplateBean): Observable<TherapyTemplateBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapyTemplateUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapyTemplateUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapyTemplateUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateBean.fromJS(resultData200) : new TherapyTemplateBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getTherapyTemplateVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/therapy_template/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление предмета терапии по Id
     * @param id id
     * @return OK
     */
    deleteTherapyTemplateItemUsingDELETE(id: number): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTherapyTemplateItemUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTherapyTemplateItemUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTherapyTemplateItemUsingDELETE(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Получение предмета терапии по Id
     * @param id id
     * @return OK
     */
    getTherapyTemplateItemUsingGET(id: number): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateItemUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateItemUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateItemUsingGET(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Получение списка предметов терапии
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getTherapyTemplateItemListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateItemListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateItemListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateItemListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление предмета терапии по Id
     * @param id id
     * @return OK
     */
    restoreTherapyTemplateItemUsingPOST(id: number): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTherapyTemplateItemUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTherapyTemplateItemUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTherapyTemplateItemUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Обновление предмета терапии
     * @param bean bean
     * @return OK
     */
    updateTherapyTemplateItemUsingPOST(bean: TherapyTemplateItemBean): Observable<TherapyTemplateItemBean> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTherapyTemplateItemUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTherapyTemplateItemUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTherapyTemplateItemUsingPOST(response: HttpResponseBase): Observable<TherapyTemplateItemBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemBean.fromJS(resultData200) : new TherapyTemplateItemBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getTherapyTemplateItemVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/therapy_template_item/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTherapyTemplateItemVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTherapyTemplateItemVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTherapyTemplateItemVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление транспорта по Id
     * @param id id
     * @return OK
     */
    deleteTransportUsingDELETE(id: number): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransportUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransportUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTransportUsingDELETE(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Получение транспорта по Id
     * @param id id
     * @return OK
     */
    getTransportUsingGET(id: number): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportUsingGET(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Получение списка транспорта
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getTransportListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/transport/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление транспорта по Id
     * @param id id
     * @return OK
     */
    restoreTransportUsingPOST(id: number): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreTransportUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreTransportUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreTransportUsingPOST(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Обновление/добавление транспорта
     * @param bean bean
     * @return OK
     */
    updateTransportUsingPOST(bean: TransportBean): Observable<TransportBean> {
        let url_ = this.baseUrl + "/api/andy/transport/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransportUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransportUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TransportBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransportUsingPOST(response: HttpResponseBase): Observable<TransportBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBean.fromJS(resultData200) : new TransportBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getTransportVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/transport/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * Удаление единицы по Id
     * @param id id
     * @return OK
     */
    deleteUnitUsingDELETE(id: number): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUnitUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUnitUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUnitUsingDELETE(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Получение единицы по Id
     * @param id id
     * @return OK
     */
    getUnitUsingGET(id: number): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitUsingGET(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Получение списка единиц
     * @param from (optional) from
     * @param count (optional) count
     * @param deleted (optional) deleted
     * @param name (optional) name
     * @param code (optional) code
     * @return OK
     */
    getUnitListUsingGET(from?: number | null | undefined, count?: number | null | undefined, deleted?: boolean | null | undefined, name?: string | null | undefined, code?: string | null | undefined): Observable<ListContainer> {
        let url_ = this.baseUrl + "/api/andy/unit/list?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListContainer>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListContainer>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitListUsingGET(response: HttpResponseBase): Observable<ListContainer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListContainer.fromJS(resultData200) : new ListContainer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListContainer>(<any>null);
    }

    /**
     * Восстановление единицы по Id
     * @param id id
     * @return OK
     */
    restoreUnitUsingPOST(id: number): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreUnitUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreUnitUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreUnitUsingPOST(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Обновление единицы
     * @param bean bean
     * @return OK
     */
    updateUnitUsingPOST(bean: UnitBean): Observable<UnitBean> {
        let url_ = this.baseUrl + "/api/andy/unit/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bean);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUnitUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUnitUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<UnitBean>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitBean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUnitUsingPOST(response: HttpResponseBase): Observable<UnitBean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnitBean.fromJS(resultData200) : new UnitBean();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitBean>(<any>null);
    }

    /**
     * Версия
     * @return OK
     */
    getUnitVersionUsingGET(): Observable<number> {
        let url_ = this.baseUrl + "/api/andy/unit/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitVersionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitVersionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitVersionUsingGET(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * возвращает список типов бригад
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_5(subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<BrigadeTypeDto[]> {
        let url_ = this.baseUrl + "/api/brigade_types?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_5(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_5(response: HttpResponseBase): Observable<BrigadeTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto[]>(<any>null);
    }

    /**
     * создание нового типа бригад
     * @param dto dto
     * @return OK
     */
    createUsingPOST_4(dto: BrigadeTypeDto): Observable<BrigadeTypeDto> {
        let url_ = this.baseUrl + "/api/brigade_types/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_4(response: HttpResponseBase): Observable<BrigadeTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeDto.fromJS(resultData200) : new BrigadeTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto>(<any>null);
    }

    /**
     * обновление сведений о типе бригад
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_4(dto: BrigadeTypeDto): Observable<BrigadeTypeDto> {
        let url_ = this.baseUrl + "/api/brigade_types/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_4(response: HttpResponseBase): Observable<BrigadeTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeDto.fromJS(resultData200) : new BrigadeTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto>(<any>null);
    }

    /**
     * возвращает тип бригад по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_4(id: number): Observable<BrigadeTypeDto> {
        let url_ = this.baseUrl + "/api/brigade_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_4(response: HttpResponseBase): Observable<BrigadeTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeTypeDto.fromJS(resultData200) : new BrigadeTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeTypeDto>(<any>null);
    }

    /**
     * DEPRECATED возвращает список бригад по заданным параметрам
     * @param deleted (optional) deleted
     * @param subdivisionId (optional) subdivisionId
     * @return OK
     */
    readAllUsingGET_4(deleted?: boolean | null | undefined, subdivisionId?: number | null | undefined): Observable<BrigadeDto[]> {
        let url_ = this.baseUrl + "/api/brigades?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_4(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_4(response: HttpResponseBase): Observable<BrigadeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto[]>(<any>null);
    }

    /**
     * создание новой бригады
     * @param dto dto
     * @return OK
     */
    createUsingPOST_3(dto: BrigadeDto): Observable<BrigadeDto> {
        let url_ = this.baseUrl + "/api/brigades/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_3(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_3(response: HttpResponseBase): Observable<BrigadeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeDto.fromJS(resultData200) : new BrigadeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto>(<any>null);
    }

    /**
     * обновление сведений о бригаде кроме статуса
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_3(dto: BrigadeDto): Observable<BrigadeDto> {
        let url_ = this.baseUrl + "/api/brigades/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_3(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_3(response: HttpResponseBase): Observable<BrigadeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeDto.fromJS(resultData200) : new BrigadeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto>(<any>null);
    }

    /**
     * возвращает бригаду по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_3(id: number): Observable<BrigadeDto> {
        let url_ = this.baseUrl + "/api/brigades/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_3(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_3(response: HttpResponseBase): Observable<BrigadeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeDto.fromJS(resultData200) : new BrigadeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto>(<any>null);
    }

    /**
     * [READ] бригада -> сотрудники
     * @param id id
     * @return OK
     */
    readPerformersInBrigadeUsingGET(id: number): Observable<PerformerDto[]> {
        let url_ = this.baseUrl + "/api/brigades/{id}/performers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPerformersInBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPerformersInBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadPerformersInBrigadeUsingGET(response: HttpResponseBase): Observable<PerformerDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto[]>(<any>null);
    }

    /**
     * возвращает список карт вызова в подразделении
     * @param mode (optional) mode
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_7(mode?: string | null | undefined, subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/cards?";
        if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_7(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_7(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * возвращает список записей МКБ 10 по текстовому поиску в коде/названии
     * @param s s
     * @return OK
     */
    findMkbListUsingGET(s: string): Observable<Mkb[]> {
        let url_ = this.baseUrl + "/api/cards/mkb?";
        if (s === undefined || s === null)
            throw new Error("The parameter 's' must be defined and cannot be null.");
        else
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindMkbListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindMkbListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Mkb[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mkb[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindMkbListUsingGET(response: HttpResponseBase): Observable<Mkb[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Mkb.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mkb[]>(<any>null);
    }

    /**
     * возвращает вложенные записи МКБ 10 по id parent-записи
     * @param id id
     * @return OK
     */
    readMkbListUsingGET(id: number): Observable<MkbDto[]> {
        let url_ = this.baseUrl + "/api/cards/mkb/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadMkbListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadMkbListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<MkbDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MkbDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadMkbListUsingGET(response: HttpResponseBase): Observable<MkbDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MkbDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MkbDto[]>(<any>null);
    }

    /**
     * возвращает список карт вызова по заданным параметрам поиска
     * @param subdivisionId (optional) 
     * @param number (optional) 
     * @param declarantName (optional) 
     * @param declarantPhone (optional) 
     * @param patientName (optional) 
     * @param patientSex (optional) 
     * @param patientAgeYears (optional) 
     * @param patientAgeMonths (optional) 
     * @param patientAgeDays (optional) 
     * @param incidentAoName (optional) 
     * @param incidentDistrictId (optional) 
     * @param performer (optional) 
     * @param callTypeId (optional) 
     * @param declarantTypeId (optional) 
     * @param callPlaceTypeId (optional) 
     * @param reasonTypeId (optional) 
     * @return OK
     */
    readAllUsingPOST_1(subdivisionId?: number | null | undefined, number?: string | null | undefined, declarantName?: string | null | undefined, declarantPhone?: string | null | undefined, patientName?: string | null | undefined, patientSex?: number | null | undefined, patientAgeYears?: number | null | undefined, patientAgeMonths?: number | null | undefined, patientAgeDays?: number | null | undefined, incidentAoName?: string | null | undefined, incidentDistrictId?: number | null | undefined, performer?: string | null | undefined, callTypeId?: number | null | undefined, declarantTypeId?: number | null | undefined, callPlaceTypeId?: number | null | undefined, reasonTypeId?: number | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/cards/request?";
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (declarantName !== undefined)
            url_ += "declarantName=" + encodeURIComponent("" + declarantName) + "&"; 
        if (declarantPhone !== undefined)
            url_ += "declarantPhone=" + encodeURIComponent("" + declarantPhone) + "&"; 
        if (patientName !== undefined)
            url_ += "patientName=" + encodeURIComponent("" + patientName) + "&"; 
        if (patientSex !== undefined)
            url_ += "patientSex=" + encodeURIComponent("" + patientSex) + "&"; 
        if (patientAgeYears !== undefined)
            url_ += "patientAgeYears=" + encodeURIComponent("" + patientAgeYears) + "&"; 
        if (patientAgeMonths !== undefined)
            url_ += "patientAgeMonths=" + encodeURIComponent("" + patientAgeMonths) + "&"; 
        if (patientAgeDays !== undefined)
            url_ += "patientAgeDays=" + encodeURIComponent("" + patientAgeDays) + "&"; 
        if (incidentAoName !== undefined)
            url_ += "incidentAoName=" + encodeURIComponent("" + incidentAoName) + "&"; 
        if (incidentDistrictId !== undefined)
            url_ += "incidentDistrictId=" + encodeURIComponent("" + incidentDistrictId) + "&"; 
        if (performer !== undefined)
            url_ += "performer=" + encodeURIComponent("" + performer) + "&"; 
        if (callTypeId !== undefined)
            url_ += "callTypeId=" + encodeURIComponent("" + callTypeId) + "&"; 
        if (declarantTypeId !== undefined)
            url_ += "declarantTypeId=" + encodeURIComponent("" + declarantTypeId) + "&"; 
        if (callPlaceTypeId !== undefined)
            url_ += "callPlaceTypeId=" + encodeURIComponent("" + callPlaceTypeId) + "&"; 
        if (reasonTypeId !== undefined)
            url_ += "reasonTypeId=" + encodeURIComponent("" + reasonTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingPOST_1(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> опросник
     * @param id (optional) id
     * @return OK
     */
    readOneUsingGET_6(id?: number | null | undefined): Observable<InquirerInCallDto> {
        let url_ = this.baseUrl + "/api/cards/side_one/inquirer?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_6(<any>response_);
                } catch (e) {
                    return <Observable<InquirerInCallDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerInCallDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_6(response: HttpResponseBase): Observable<InquirerInCallDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerInCallDto.fromJS(resultData200) : new InquirerInCallDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerInCallDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> быстрые поводы к вызову
     * @return OK
     */
    readBasicReasonsUsingGET(): Observable<InquirerInCallDto[]> {
        let url_ = this.baseUrl + "/api/cards/side_one/reasons/fast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadBasicReasonsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadBasicReasonsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerInCallDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerInCallDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadBasicReasonsUsingGET(response: HttpResponseBase): Observable<InquirerInCallDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InquirerInCallDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerInCallDto[]>(<any>null);
    }

    /**
     * только для генерации Api
     * @return OK
     */
    messageDtoForApiUsingGET(): Observable<MessageDto> {
        let url_ = this.baseUrl + "/api/cards/simple-message-dto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessageDtoForApiUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessageDtoForApiUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<MessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processMessageDtoForApiUsingGET(response: HttpResponseBase): Observable<MessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MessageDto.fromJS(resultData200) : new MessageDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageDto>(<any>null);
    }

    /**
     * [DELETE] аннулирование карты вызова.
     * @param cardId cardId
     * @param message message
     * @return OK
     */
    updateResultIllegalActionsPartUsingDELETE(cardId: number, message: MessageDto): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultIllegalActionsPartUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultIllegalActionsPartUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultIllegalActionsPartUsingDELETE(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> изъять из архива
     * @param cardId cardId
     * @param comment comment
     * @return OK
     */
    returnToVerifyUsingPUT(cardId: number, comment: string): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/get_from_archive";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnToVerifyUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnToVerifyUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processReturnToVerifyUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> укладка
     * @param cardId cardId
     * @return OK
     */
    readAllШnventoryUsingGET(cardId: number): Observable<Inventory[]> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/inventories";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllШnventoryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllШnventoryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Inventory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllШnventoryUsingGET(response: HttpResponseBase): Observable<Inventory[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Inventory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory[]>(<any>null);
    }

    /**
     * карта вызова -> протокол
     * @param cardId cardId
     * @return OK
     */
    readProtocolUsingGET_1(cardId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/protocol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolUsingGET_1(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * карта вызова -> результат
     * @param cardId cardId
     * @return OK
     */
    readCardResultUsingGET(cardId: number): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultUsingGET(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultUsingPUT(cardId: number, dto: CardResultDtoFLAT): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultUsingPUT(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> активное посещение
     * @param cardId cardId
     * @return OK
     */
    readCardResultActiveVisitPartUsingGET(cardId: number): Observable<CardResultActiveVisitDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/active_visit";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultActiveVisitPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultActiveVisitPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultActiveVisitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultActiveVisitDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultActiveVisitPartUsingGET(response: HttpResponseBase): Observable<CardResultActiveVisitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultActiveVisitDto.fromJS(resultData200) : new CardResultActiveVisitDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultActiveVisitDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> активное посещение
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultActiveVisitPartUsingPUT(cardId: number, dto: CardResultActiveVisitDto): Observable<CardResultActiveVisitDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/active_visit";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultActiveVisitPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultActiveVisitPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultActiveVisitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultActiveVisitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultActiveVisitPartUsingPUT(response: HttpResponseBase): Observable<CardResultActiveVisitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultActiveVisitDto.fromJS(resultData200) : new CardResultActiveVisitDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultActiveVisitDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> результат мероприятий
     * @param cardId cardId
     * @return OK
     */
    readAssistanceResultPartUsingGET(cardId: number): Observable<CardResultAssistanceResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/assistance_result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAssistanceResultPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAssistanceResultPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadAssistanceResultPartUsingGET(response: HttpResponseBase): Observable<CardResultAssistanceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultAssistanceResultDto.fromJS(resultData200) : new CardResultAssistanceResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultAssistanceResultDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> результат мероприятий
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAssistanceResultPartUsingPUT(cardId: number, dto: CardResultAssistanceResultDto): Observable<CardResultAssistanceResultDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/assistance_result";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssistanceResultPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssistanceResultPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultAssistanceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssistanceResultPartUsingPUT(response: HttpResponseBase): Observable<CardResultAssistanceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultAssistanceResultDto.fromJS(resultData200) : new CardResultAssistanceResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultAssistanceResultDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> Примечания
     * @param cardId cardId
     * @return OK
     */
    readCardResultCommentsPartUsingGET(cardId: number): Observable<CardResultCommentsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/comments";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultCommentsPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultCommentsPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultCommentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultCommentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultCommentsPartUsingGET(response: HttpResponseBase): Observable<CardResultCommentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultCommentsDto.fromJS(resultData200) : new CardResultCommentsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultCommentsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> примечания
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultCommentsPartUsingPUT(cardId: number, dto: CardResultCommentsDto): Observable<CardResultCommentsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/comments";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultCommentsPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultCommentsPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultCommentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultCommentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultCommentsPartUsingPUT(response: HttpResponseBase): Observable<CardResultCommentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultCommentsDto.fromJS(resultData200) : new CardResultCommentsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultCommentsDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> смерть
     * @param cardId cardId
     * @return OK
     */
    readDeathPartUsingGET(cardId: number): Observable<CardResultDeathDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/death";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadDeathPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadDeathPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDeathDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDeathDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadDeathPartUsingGET(response: HttpResponseBase): Observable<CardResultDeathDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDeathDto.fromJS(resultData200) : new CardResultDeathDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDeathDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> смерть
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateDeathPartUsingPUT(cardId: number, dto: CardResultDeathDto): Observable<CardResultDeathDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/death";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeathPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeathPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDeathDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDeathDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeathPartUsingPUT(response: HttpResponseBase): Observable<CardResultDeathDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDeathDto.fromJS(resultData200) : new CardResultDeathDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDeathDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> диагноз
     * @param cardId cardId
     * @return OK
     */
    readCardResultDiagnosisPartUsingGET(cardId: number): Observable<CardResultDiagnosisDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/diagnosis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultDiagnosisPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultDiagnosisPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDiagnosisDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDiagnosisDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultDiagnosisPartUsingGET(response: HttpResponseBase): Observable<CardResultDiagnosisDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDiagnosisDto.fromJS(resultData200) : new CardResultDiagnosisDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDiagnosisDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> диагноз
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultDiagnosisPartUsingPUT(cardId: number, dto: CardResultDiagnosisDto): Observable<CardResultDiagnosisDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/diagnosis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultDiagnosisPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultDiagnosisPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDiagnosisDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDiagnosisDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultDiagnosisPartUsingPUT(response: HttpResponseBase): Observable<CardResultDiagnosisDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDiagnosisDto.fromJS(resultData200) : new CardResultDiagnosisDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDiagnosisDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> ЭКГ
     * @param cardId cardId
     * @return OK
     */
    readCardResultEkgPartUsingGET(cardId: number): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultEkgPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultEkgPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultEkgPartUsingGET(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> экг
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultEkgPartUsingPUT(cardId: number, dto: CardResultEkg): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultEkgPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultEkgPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultEkgPartUsingPUT(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * карта вызова -> результат -> ЭКГ после мероприятий
     * @param cardId cardId
     * @return OK
     */
    readCardResultEkgAfterPartUsingGET(cardId: number): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg_after";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultEkgAfterPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultEkgAfterPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultEkgAfterPartUsingGET(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> экг после мероприятий
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultEkgAfterPartUsingPUT(cardId: number, dto: CardResultEkg): Observable<CardResultEkg> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/ekg_after";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultEkgAfterPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultEkgAfterPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEkg>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEkg>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultEkgAfterPartUsingPUT(response: HttpResponseBase): Observable<CardResultEkg> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEkg.fromJS(resultData200) : new CardResultEkg();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEkg>(<any>null);
    }

    /**
     * карта вызова -> результат -> противоправные действия
     * @param cardId cardId
     * @return OK
     */
    readCardResultIllegalActionsPartUsingGET(cardId: number): Observable<CardResultIllegalActionsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/illegal_actions";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultIllegalActionsPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultIllegalActionsPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultIllegalActionsPartUsingGET(response: HttpResponseBase): Observable<CardResultIllegalActionsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultIllegalActionsDto.fromJS(resultData200) : new CardResultIllegalActionsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultIllegalActionsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> противоправные действия
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultIllegalActionsPartUsingPUT(cardId: number, dto: CardResultIllegalActionsDto): Observable<CardResultIllegalActionsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/illegal_actions";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultIllegalActionsPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultIllegalActionsPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultIllegalActionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultIllegalActionsPartUsingPUT(response: HttpResponseBase): Observable<CardResultIllegalActionsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultIllegalActionsDto.fromJS(resultData200) : new CardResultIllegalActionsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultIllegalActionsDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий на месте
     * @param cardId cardId
     * @return OK
     */
    readCardResultLocalEfficiencyAssistancePartUsingGET(cardId: number): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/local_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultLocalEfficiencyAssistancePartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultLocalEfficiencyAssistancePartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultLocalEfficiencyAssistancePartUsingGET(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий на месте
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardResultLocalEfficiencyAssistancePartUsingPUT(cardId: number, dto: CardResultEfficiencyAssistance): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/local_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardResultLocalEfficiencyAssistancePartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardResultLocalEfficiencyAssistancePartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardResultLocalEfficiencyAssistancePartUsingPUT(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> расходные материалы
     * @param cardId cardId
     * @return OK
     */
    readCardResultMaterialsPartUsingGET(cardId: number): Observable<CardResultMaterialsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/materials";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultMaterialsPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultMaterialsPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultMaterialsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultMaterialsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultMaterialsPartUsingGET(response: HttpResponseBase): Observable<CardResultMaterialsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultMaterialsDto.fromJS(resultData200) : new CardResultMaterialsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultMaterialsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> материалы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultMaterialsPartUsingPUT(cardId: number, dto: CardResultMaterialsDto): Observable<CardResultMaterialsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/materials";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultMaterialsPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultMaterialsPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultMaterialsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultMaterialsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultMaterialsPartUsingPUT(response: HttpResponseBase): Observable<CardResultMaterialsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultMaterialsDto.fromJS(resultData200) : new CardResultMaterialsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultMaterialsDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> причина
     * @param cardId cardId
     * @return OK
     */
    readCardResultReasonPartUsingGET(cardId: number): Observable<CardResultReasonDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/reason";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultReasonPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultReasonPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultReasonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultReasonDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultReasonPartUsingGET(response: HttpResponseBase): Observable<CardResultReasonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultReasonDto.fromJS(resultData200) : new CardResultReasonDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultReasonDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> причина
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultReasonPartUsingPUT(cardId: number, dto: CardResultReasonDto): Observable<CardResultReasonDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/reason";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultReasonPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultReasonPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultReasonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultReasonDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultReasonPartUsingPUT(response: HttpResponseBase): Observable<CardResultReasonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultReasonDto.fromJS(resultData200) : new CardResultReasonDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultReasonDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> терапия
     * @param cardId cardId
     * @return OK
     */
    readCardResultМyPartUsingGET(cardId: number): Observable<CardResultTherapyPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/therapy";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultМyPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultМyPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTherapyPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTherapyPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultМyPartUsingGET(response: HttpResponseBase): Observable<CardResultTherapyPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTherapyPartDto.fromJS(resultData200) : new CardResultTherapyPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTherapyPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> терапия
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultTherapyPartUsingPUT(cardId: number, dto: CardResultTherapyPartDto): Observable<CardResultTherapyPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/therapy";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultTherapyPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultTherapyPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTherapyPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTherapyPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultTherapyPartUsingPUT(response: HttpResponseBase): Observable<CardResultTherapyPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTherapyPartDto.fromJS(resultData200) : new CardResultTherapyPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTherapyPartDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> передача спец. бригаде
     * @param cardId cardId
     * @return OK
     */
    readTransferPatientPartUsingGET(cardId: number): Observable<CardResultTransferPatientDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transfer_patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTransferPatientPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTransferPatientPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransferPatientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransferPatientDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadTransferPatientPartUsingGET(response: HttpResponseBase): Observable<CardResultTransferPatientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransferPatientDto.fromJS(resultData200) : new CardResultTransferPatientDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransferPatientDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> передача спец. бригаде
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateTransferPatientPartUsingPUT(cardId: number, dto: CardResultTransferPatientDto): Observable<CardResultTransferPatientDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transfer_patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransferPatientPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransferPatientPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransferPatientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransferPatientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransferPatientPartUsingPUT(response: HttpResponseBase): Observable<CardResultTransferPatientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransferPatientDto.fromJS(resultData200) : new CardResultTransferPatientDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransferPatientDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий в машине
     * @param cardId cardId
     * @return OK
     */
    readCardResultTransportEfficiencyAssistancePartUsingGET(cardId: number): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transport_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultTransportEfficiencyAssistancePartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultTransportEfficiencyAssistancePartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultTransportEfficiencyAssistancePartUsingGET(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> эффективность мероприятий в машине
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardResultTransportEfficiencyAssistancePartUsingPUT(cardId: number, dto: CardResultEfficiencyAssistance): Observable<CardResultEfficiencyAssistance> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transport_efficiency_assistance";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardResultTransportEfficiencyAssistancePartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardResultTransportEfficiencyAssistancePartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultEfficiencyAssistance>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardResultTransportEfficiencyAssistancePartUsingPUT(response: HttpResponseBase): Observable<CardResultEfficiencyAssistance> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultEfficiencyAssistance.fromJS(resultData200) : new CardResultEfficiencyAssistance();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultEfficiencyAssistance>(<any>null);
    }

    /**
     * карта вызова -> результат -> транспортировка
     * @param cardId cardId
     * @return OK
     */
    readCardResultTransportingPartUsingGET(cardId: number): Observable<CardResultTransportingDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transporting";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultTransportingPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultTransportingPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransportingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransportingDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultTransportingPartUsingGET(response: HttpResponseBase): Observable<CardResultTransportingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransportingDto.fromJS(resultData200) : new CardResultTransportingDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransportingDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> транспортировка
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultTransportingPartUsingPUT(cardId: number, dto: CardResultTransportingDto): Observable<CardResultTransportingDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/transporting";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultTransportingPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultTransportingPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTransportingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTransportingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultTransportingPartUsingPUT(response: HttpResponseBase): Observable<CardResultTransportingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTransportingDto.fromJS(resultData200) : new CardResultTransportingDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTransportingDto>(<any>null);
    }

    /**
     * карта вызова -> результат -> тип результата
     * @param cardId cardId
     * @return OK
     */
    readCardResultTypePartUsingGET(cardId: number): Observable<CardResultTypeDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/type";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardResultTypePartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardResultTypePartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardResultTypePartUsingGET(response: HttpResponseBase): Observable<CardResultTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTypeDto.fromJS(resultData200) : new CardResultTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTypeDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> результат -> тип результата
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateResultTypePartUsingPUT(cardId: number, dto: CardResultTypeDto): Observable<CardResultTypeDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/result/type";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResultTypePartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResultTypePartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardResultTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResultTypePartUsingPUT(response: HttpResponseBase): Observable<CardResultTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultTypeDto.fromJS(resultData200) : new CardResultTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultTypeDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> передать в архив
     * @param cardId cardId
     * @return OK
     */
    setToArchiveUsingPUT(cardId: number): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/set_to_archive";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetToArchiveUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetToArchiveUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetToArchiveUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> вернуть сотруднику
     * @param cardId cardId
     * @param comment comment
     * @return OK
     */
    returnToUndilledUsingPUT(cardId: number, comment: string): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/set_to_unfilled";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnToUndilledUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnToUndilledUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processReturnToUndilledUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * [CREATE] карта вызова -> передать на проверку
     * @param cardId cardId
     * @return OK
     */
    setVerifiedUsingPUT(cardId: number): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/set_to_verify";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetVerifiedUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetVerifiedUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetVerifiedUsingPUT(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона
     * @param cardId cardId
     * @return OK
     */
    readSideOneUsingGET(cardId: number): Observable<CardSideOneDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardSideOneDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideOneDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneUsingGET(response: HttpResponseBase): Observable<CardSideOneDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideOneDto.fromJS(resultData200) : new CardSideOneDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideOneDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> основные сведения
     * @param cardId cardId
     * @return OK
     */
    readSideOneGeneralPartUsingGET_1(cardId: number): Observable<CardGeneralPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneGeneralPartUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneGeneralPartUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<CardGeneralPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGeneralPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneGeneralPartUsingGET_1(response: HttpResponseBase): Observable<CardGeneralPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardGeneralPartDto.fromJS(resultData200) : new CardGeneralPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGeneralPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> временные этапы
     * @param cardId cardId
     * @return OK
     */
    getBasicDatesUsingGET(cardId: number): Observable<CardBasicDatesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/basic_dates";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBasicDatesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBasicDatesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardBasicDatesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBasicDatesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBasicDatesUsingGET(response: HttpResponseBase): Observable<CardBasicDatesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBasicDatesPartDto.fromJS(resultData200) : new CardBasicDatesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBasicDatesPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> первая сторона -> основные данные -> временные этапы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateBasicDatesUsingPUT(cardId: number, dto: CardBasicDatesPartDto): Observable<CardBasicDatesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/basic_dates";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBasicDatesUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBasicDatesUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardBasicDatesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBasicDatesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBasicDatesUsingPUT(response: HttpResponseBase): Observable<CardBasicDatesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBasicDatesPartDto.fromJS(resultData200) : new CardBasicDatesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBasicDatesPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> ответственный врач бригады
     * @param cardId cardId
     * @return OK
     */
    getBrigadeDoctorInfoUsingGET(cardId: number): Observable<CardBrigadeDoctorPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/brigade_doctor";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeDoctorInfoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeDoctorInfoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardBrigadeDoctorPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardBrigadeDoctorPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeDoctorInfoUsingGET(response: HttpResponseBase): Observable<CardBrigadeDoctorPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardBrigadeDoctorPartDto.fromJS(resultData200) : new CardBrigadeDoctorPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardBrigadeDoctorPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> старший врач смены
     * @param cardId cardId
     * @return OK
     */
    getShiftSeniorDoctorInfoUsingGET(cardId: number): Observable<CardShiftSeniorDoctorPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/shift_senior_doctor";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShiftSeniorDoctorInfoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShiftSeniorDoctorInfoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardShiftSeniorDoctorPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardShiftSeniorDoctorPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShiftSeniorDoctorInfoUsingGET(response: HttpResponseBase): Observable<CardShiftSeniorDoctorPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardShiftSeniorDoctorPartDto.fromJS(resultData200) : new CardShiftSeniorDoctorPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardShiftSeniorDoctorPartDto>(<any>null);
    }

    /**
     * [READ] карта вызова -> первая сторона -> заведущий отделением
     * @param cardId cardId
     * @return OK
     */
    getSubdivisionHeadDoctorInfoUsingGET(cardId: number): Observable<CardSubdivisionHeadDoctorPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/general/subdivision_head_doctor";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionHeadDoctorInfoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionHeadDoctorInfoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardSubdivisionHeadDoctorPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSubdivisionHeadDoctorPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionHeadDoctorInfoUsingGET(response: HttpResponseBase): Observable<CardSubdivisionHeadDoctorPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSubdivisionHeadDoctorPartDto.fromJS(resultData200) : new CardSubdivisionHeadDoctorPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSubdivisionHeadDoctorPartDto>(<any>null);
    }

    /**
     * карта вызова -> первая сторона -> пациент
     * @param cardId cardId
     * @return OK
     */
    readSideOnePatientPartUsingGET(cardId: number): Observable<CardPatientPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOnePatientPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOnePatientPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOnePatientPartUsingGET(response: HttpResponseBase): Observable<CardPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardPatientPartDto.fromJS(resultData200) : new CardPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardPatientPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> первая сторона -> пациент
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updatePatientPartUsingPUT(cardId: number, dto: CardPatientPartDto): Observable<CardPatientPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/patient";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatientPartUsingPUT(response: HttpResponseBase): Observable<CardPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardPatientPartDto.fromJS(resultData200) : new CardPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardPatientPartDto>(<any>null);
    }

    /**
     * карта вызова -> состояние -> протокол
     * @param cardId cardId
     * @param activityId activityId
     * @return OK
     */
    readStateProtocolUsingGET(cardId: number, activityId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_one/state/{activityId}/protocol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadStateProtocolUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadStateProtocolUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadStateProtocolUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона
     * @param cardId cardId
     * @return OK
     */
    readSideTwoUsingGET(cardId: number): Observable<CardSideTwoDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardSideTwoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardSideTwoDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoUsingGET(response: HttpResponseBase): Observable<CardSideTwoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardSideTwoDto.fromJS(resultData200) : new CardSideTwoDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardSideTwoDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез
     * @param cardId cardId
     * @return OK
     */
    readSideTwoAnamnesisUsingGET(cardId: number): Observable<CardAnamnesisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoAnamnesisUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoAnamnesisUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoAnamnesisUsingGET(response: HttpResponseBase): Observable<CardAnamnesisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisPartDto.fromJS(resultData200) : new CardAnamnesisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAnamnesisUsingPUT(cardId: number, dto: CardAnamnesisPartDtoFLAT): Observable<CardAnamnesisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnamnesisUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnamnesisUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnamnesisUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisPartDto.fromJS(resultData200) : new CardAnamnesisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> аллергический
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisAllergicUsingGET(cardId: number): Observable<CardAnamnesisEpidemicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/allergic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisAllergicUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisAllergicUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisAllergicUsingGET(response: HttpResponseBase): Observable<CardAnamnesisEpidemicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisEpidemicPartDto.fromJS(resultData200) : new CardAnamnesisEpidemicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisEpidemicPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> аллергический
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAllergicUsingPUT(cardId: number, dto: CardAnamnesisAllergicPartDto): Observable<CardAnamnesisAllergicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/allergic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllergicUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllergicUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisAllergicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisAllergicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllergicUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisAllergicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisAllergicPartDto.fromJS(resultData200) : new CardAnamnesisAllergicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisAllergicPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> жалобы
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisComplaintsUsingGET(cardId: number): Observable<CardAnamnesisComplaintsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/complaints";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisComplaintsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisComplaintsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisComplaintsUsingGET(response: HttpResponseBase): Observable<CardAnamnesisComplaintsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisComplaintsPartDto.fromJS(resultData200) : new CardAnamnesisComplaintsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisComplaintsPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> жалобы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateComplaintsUsingPUT(cardId: number, dto: CardAnamnesisComplaintsPartDto): Observable<CardAnamnesisComplaintsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/complaints";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComplaintsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComplaintsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisComplaintsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComplaintsUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisComplaintsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisComplaintsPartDto.fromJS(resultData200) : new CardAnamnesisComplaintsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisComplaintsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> эпидемиологический
     * @param cardId cardId
     * @return OK
     */
    readSideTwoAnamnesisEpidemicUsingGET(cardId: number): Observable<CardAnamnesisEpidemicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/epidemic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoAnamnesisEpidemicUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoAnamnesisEpidemicUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoAnamnesisEpidemicUsingGET(response: HttpResponseBase): Observable<CardAnamnesisEpidemicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisEpidemicPartDto.fromJS(resultData200) : new CardAnamnesisEpidemicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisEpidemicPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> эпидемиологический
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateEpidemicUsingPUT(cardId: number, dto: CardAnamnesisEpidemicPartDto): Observable<CardAnamnesisEpidemicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/epidemic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEpidemicUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEpidemicUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisEpidemicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEpidemicUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisEpidemicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisEpidemicPartDto.fromJS(resultData200) : new CardAnamnesisEpidemicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisEpidemicPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> гинекологический
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisGynecologicUsingGET(cardId: number): Observable<CardAnamnesisGynecologicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/gynecologic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisGynecologicUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisGynecologicUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisGynecologicUsingGET(response: HttpResponseBase): Observable<CardAnamnesisGynecologicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisGynecologicPartDto.fromJS(resultData200) : new CardAnamnesisGynecologicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisGynecologicPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> гинекологический
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateGynecologicUsingPUT(cardId: number, dto: CardAnamnesisGynecologicPartDto): Observable<CardAnamnesisGynecologicPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/gynecologic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGynecologicUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGynecologicUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisGynecologicPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGynecologicUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisGynecologicPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisGynecologicPartDto.fromJS(resultData200) : new CardAnamnesisGynecologicPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisGynecologicPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> заболевания
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisIllnesUsingGET(cardId: number): Observable<CardAnamnesisIllnesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/illnes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisIllnesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisIllnesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisIllnesUsingGET(response: HttpResponseBase): Observable<CardAnamnesisIllnesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisIllnesPartDto.fromJS(resultData200) : new CardAnamnesisIllnesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisIllnesPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> заболевания
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateIllnesUsingPUT(cardId: number, dto: CardAnamnesisIllnesPartDto): Observable<CardAnamnesisIllnesPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/anamnesis/illnes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIllnesUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIllnesUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisIllnesPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIllnesUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisIllnesPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisIllnesPartDto.fromJS(resultData200) : new CardAnamnesisIllnesPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisIllnesPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объек.данные
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesUsingGET(cardId: number): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesUsingGET(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardObjectiveUsingPUT(cardId: number, dto: CardObjectivePartDtoFLAT): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardObjectiveUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardObjectiveUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardObjectiveUsingPUT(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> дополнительные данные
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesAdditionUsingGET(cardId: number): Observable<CardObjectiveAdditionPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/addition";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesAdditionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesAdditionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesAdditionUsingGET(response: HttpResponseBase): Observable<CardObjectiveAdditionPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAdditionPartDto.fromJS(resultData200) : new CardObjectiveAdditionPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAdditionPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> дополнительные данные
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAdditionsUsingPUT(cardId: number, dto: CardObjectiveAdditionPartDto): Observable<CardObjectiveAdditionPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/addition";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdditionsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdditionsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAdditionPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdditionsUsingPUT(response: HttpResponseBase): Observable<CardObjectiveAdditionPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAdditionPartDto.fromJS(resultData200) : new CardObjectiveAdditionPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAdditionPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> призн.алк.опьянения
     * @param cardId cardId
     * @return OK
     */
    readCardObjectiveIAlcoUsingGET(cardId: number): Observable<CardObjectiveAlcoPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/alcohol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardObjectiveIAlcoUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardObjectiveIAlcoUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardObjectiveIAlcoUsingGET(response: HttpResponseBase): Observable<CardObjectiveAlcoPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAlcoPartDto.fromJS(resultData200) : new CardObjectiveAlcoPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAlcoPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> призн.алк.опьянения
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAlcoholUsingPUT(cardId: number, dto: CardObjectiveAlcoPartDto): Observable<CardObjectiveAlcoPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/alcohol";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAlcoholUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAlcoholUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveAlcoPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAlcoholUsingPUT(response: HttpResponseBase): Observable<CardObjectiveAlcoPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveAlcoPartDto.fromJS(resultData200) : new CardObjectiveAlcoPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveAlcoPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> дыхание
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesBreathUsingGET(cardId: number): Observable<CardObjectiveBreathPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/breath";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesBreathUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesBreathUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesBreathUsingGET(response: HttpResponseBase): Observable<CardObjectiveBreathPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveBreathPartDto.fromJS(resultData200) : new CardObjectiveBreathPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveBreathPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> дыхание
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateBreathUsingPUT(cardId: number, dto: CardObjectiveBreathPartDto): Observable<CardObjectiveBreathPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/breath";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBreathUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBreathUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveBreathPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBreathUsingPUT(response: HttpResponseBase): Observable<CardObjectiveBreathPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveBreathPartDto.fromJS(resultData200) : new CardObjectiveBreathPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveBreathPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> осложнения
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateComplicationsUsingPUT(cardId: number, dto: CardObjectiveComplicationsPartDto): Observable<CardObjectiveComplicationsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/complications";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComplicationsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComplicationsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveComplicationsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveComplicationsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComplicationsUsingPUT(response: HttpResponseBase): Observable<CardObjectiveComplicationsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveComplicationsPartDto.fromJS(resultData200) : new CardObjectiveComplicationsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveComplicationsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> диурез
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesDiuresisUsingGET(cardId: number): Observable<CardObjectiveDiuresisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/diuresis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesDiuresisUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesDiuresisUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesDiuresisUsingGET(response: HttpResponseBase): Observable<CardObjectiveDiuresisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDiuresisPartDto.fromJS(resultData200) : new CardObjectiveDiuresisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDiuresisPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> диурез
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateDiuresisUsingPUT(cardId: number, dto: CardObjectiveDiuresisPartDto): Observable<CardObjectiveDiuresisPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/diuresis";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDiuresisUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDiuresisUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDiuresisPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDiuresisUsingPUT(response: HttpResponseBase): Observable<CardObjectiveDiuresisPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDiuresisPartDto.fromJS(resultData200) : new CardObjectiveDiuresisPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDiuresisPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> дисп.явления
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesDyspepticUsingGET(cardId: number): Observable<CardObjectiveDyspepticPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/dyspeptic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesDyspepticUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesDyspepticUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesDyspepticUsingGET(response: HttpResponseBase): Observable<CardObjectiveDyspepticPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDyspepticPartDto.fromJS(resultData200) : new CardObjectiveDyspepticPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDyspepticPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> дисп.явления
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateDyspepticUsingPUT(cardId: number, dto: CardObjectiveDyspepticPartDto): Observable<CardObjectiveDyspepticPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/dyspeptic";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDyspepticUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDyspepticUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveDyspepticPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDyspepticUsingPUT(response: HttpResponseBase): Observable<CardObjectiveDyspepticPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveDyspepticPartDto.fromJS(resultData200) : new CardObjectiveDyspepticPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveDyspepticPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> отеки
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesEdemaUsingGET(cardId: number): Observable<CardObjectiveEdemaPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/edema";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesEdemaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesEdemaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesEdemaUsingGET(response: HttpResponseBase): Observable<CardObjectiveEdemaPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveEdemaPartDto.fromJS(resultData200) : new CardObjectiveEdemaPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveEdemaPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> отеки
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateEdemaUsingPUT(cardId: number, dto: CardObjectiveEdemaPartDto): Observable<CardObjectiveEdemaPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/edema";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdemaUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdemaUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveEdemaPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdemaUsingPUT(response: HttpResponseBase): Observable<CardObjectiveEdemaPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveEdemaPartDto.fromJS(resultData200) : new CardObjectiveEdemaPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveEdemaPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез-> cтул и мочеиспускание
     * @param cardId cardId
     * @return OK
     */
    readSideTwoAnamnesisExcretaUrineUsingGET(cardId: number): Observable<CardObjectiveExcretaUrinePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/excreta";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoAnamnesisExcretaUrineUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoAnamnesisExcretaUrineUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoAnamnesisExcretaUrineUsingGET(response: HttpResponseBase): Observable<CardObjectiveExcretaUrinePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveExcretaUrinePartDto.fromJS(resultData200) : new CardObjectiveExcretaUrinePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveExcretaUrinePartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> стул и мочеиспускание
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateExcretaUrineUsingPUT(cardId: number, dto: CardObjectiveExcretaUrinePartDto): Observable<CardObjectiveExcretaUrinePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/excreta";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateExcretaUrineUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExcretaUrineUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveExcretaUrinePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateExcretaUrineUsingPUT(response: HttpResponseBase): Observable<CardObjectiveExcretaUrinePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveExcretaUrinePartDto.fromJS(resultData200) : new CardObjectiveExcretaUrinePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveExcretaUrinePartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> общ.состояние
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesGeneralUsingGET(cardId: number): Observable<CardObjectiveGeneralStatePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/general_state";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesGeneralUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesGeneralUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesGeneralUsingGET(response: HttpResponseBase): Observable<CardObjectiveGeneralStatePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGeneralStatePartDto.fromJS(resultData200) : new CardObjectiveGeneralStatePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGeneralStatePartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> общ.состояние
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardObjectiveGeneralUsingPUT(cardId: number, dto: CardObjectiveGeneralStatePartDto): Observable<CardObjectiveGeneralStatePartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/general_state";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardObjectiveGeneralUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardObjectiveGeneralUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGeneralStatePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardObjectiveGeneralUsingPUT(response: HttpResponseBase): Observable<CardObjectiveGeneralStatePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGeneralStatePartDto.fromJS(resultData200) : new CardObjectiveGeneralStatePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGeneralStatePartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> GLASGOW
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesGlasgowUsingGET(cardId: number): Observable<CardObjectiveGlasgowPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/glasgow";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesGlasgowUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesGlasgowUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesGlasgowUsingGET(response: HttpResponseBase): Observable<CardObjectiveGlasgowPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGlasgowPartDto.fromJS(resultData200) : new CardObjectiveGlasgowPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGlasgowPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> GLASGOW
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateAdditionsUsingPUT_1(cardId: number, dto: CardObjectiveGlasgowPartDto): Observable<CardObjectiveGlasgowPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/glasgow";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdditionsUsingPUT_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdditionsUsingPUT_1(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveGlasgowPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdditionsUsingPUT_1(response: HttpResponseBase): Observable<CardObjectiveGlasgowPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveGlasgowPartDto.fromJS(resultData200) : new CardObjectiveGlasgowPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveGlasgowPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> сердце
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesHeartUsingGET(cardId: number): Observable<CardObjectiveHeartPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/heart";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesHeartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesHeartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesHeartUsingGET(response: HttpResponseBase): Observable<CardObjectiveHeartPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveHeartPartDto.fromJS(resultData200) : new CardObjectiveHeartPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveHeartPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> сердце
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateHeartUsingPUT(cardId: number, dto: CardObjectiveHeartPartDto): Observable<CardObjectiveHeartPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/heart";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHeartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHeartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveHeartPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHeartUsingPUT(response: HttpResponseBase): Observable<CardObjectiveHeartPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveHeartPartDto.fromJS(resultData200) : new CardObjectiveHeartPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveHeartPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> анамнез -> гемодинамика
     * @param cardId cardId
     * @return OK
     */
    readCardAnamnesisHemodynamicsUsingGET(cardId: number): Observable<CardAnamnesisHemodynamicsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/hemodynamics";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardAnamnesisHemodynamicsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardAnamnesisHemodynamicsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardAnamnesisHemodynamicsUsingGET(response: HttpResponseBase): Observable<CardAnamnesisHemodynamicsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisHemodynamicsPartDto.fromJS(resultData200) : new CardAnamnesisHemodynamicsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisHemodynamicsPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> анамнез -> гемодинамика
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateHemodynamicsUsingPUT(cardId: number, dto: CardAnamnesisHemodynamicsPartDto): Observable<CardAnamnesisHemodynamicsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/hemodynamics";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHemodynamicsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHemodynamicsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAnamnesisHemodynamicsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHemodynamicsUsingPUT(response: HttpResponseBase): Observable<CardAnamnesisHemodynamicsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardAnamnesisHemodynamicsPartDto.fromJS(resultData200) : new CardAnamnesisHemodynamicsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAnamnesisHemodynamicsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> печень
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesLiverUsingGET(cardId: number): Observable<CardObjectiveLiverPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/liver";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesLiverUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesLiverUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesLiverUsingGET(response: HttpResponseBase): Observable<CardObjectiveLiverPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLiverPartDto.fromJS(resultData200) : new CardObjectiveLiverPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLiverPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> печень
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateLiverUsingPUT(cardId: number, dto: CardObjectiveLiverPartDto): Observable<CardObjectiveLiverPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/liver";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLiverUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLiverUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLiverPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLiverUsingPUT(response: HttpResponseBase): Observable<CardObjectiveLiverPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLiverPartDto.fromJS(resultData200) : new CardObjectiveLiverPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLiverPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные - -> лимф.узлы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesLymphUsingGET(cardId: number): Observable<CardObjectiveLymphPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/lymph";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesLymphUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesLymphUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesLymphUsingGET(response: HttpResponseBase): Observable<CardObjectiveLymphPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLymphPartDto.fromJS(resultData200) : new CardObjectiveLymphPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLymphPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> лимф.узлы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateLymphUsingPUT(cardId: number, dto: CardObjectiveLymphPartDto): Observable<CardObjectiveLymphPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/lymph";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLymphUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLymphUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveLymphPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLymphUsingPUT(response: HttpResponseBase): Observable<CardObjectiveLymphPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveLymphPartDto.fromJS(resultData200) : new CardObjectiveLymphPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveLymphPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> другие показания
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesOtherUsingGET(cardId: number): Observable<CardObjectiveOtherPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/other";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesOtherUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesOtherUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesOtherUsingGET(response: HttpResponseBase): Observable<CardObjectiveOtherPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveOtherPartDto.fromJS(resultData200) : new CardObjectiveOtherPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveOtherPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> другие показания
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateOtherUsingPUT(cardId: number, dto: CardObjectiveOtherPartDto): Observable<CardObjectiveOtherPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/other";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOtherUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOtherUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveOtherPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOtherUsingPUT(response: HttpResponseBase): Observable<CardObjectiveOtherPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveOtherPartDto.fromJS(resultData200) : new CardObjectiveOtherPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveOtherPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> перкуторно
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesPercUsingGET(cardId: number): Observable<CardObjectivePercPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/perc";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesPercUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesPercUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePercPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePercPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesPercUsingGET(response: HttpResponseBase): Observable<CardObjectivePercPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePercPartDto.fromJS(resultData200) : new CardObjectivePercPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePercPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> перкуторно
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updatePercUsingPUT(cardId: number, dto: CardObjectivePercPartDto): Observable<CardObjectivePercPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/perc";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePercUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePercUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePercPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePercPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePercUsingPUT(response: HttpResponseBase): Observable<CardObjectivePercPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePercPartDto.fromJS(resultData200) : new CardObjectivePercPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePercPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные --> зрачки
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesPupilsUsingGET(cardId: number): Observable<CardObjectivePupilsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/pupils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesPupilsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesPupilsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePupilsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePupilsDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesPupilsUsingGET(response: HttpResponseBase): Observable<CardObjectivePupilsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePupilsDto.fromJS(resultData200) : new CardObjectivePupilsDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePupilsDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> зрачки
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updatePupilsUsingPUT(cardId: number, dto: CardObjectivePupilsDto): Observable<CardObjectivePupilsDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/pupils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePupilsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePupilsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePupilsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePupilsDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePupilsUsingPUT(response: HttpResponseBase): Observable<CardObjectivePupilsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePupilsDto.fromJS(resultData200) : new CardObjectivePupilsDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePupilsDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> рефлексы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesReflexesUsingGET(cardId: number): Observable<CardObjectiveReflexesDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/reflexes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesReflexesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesReflexesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesReflexesUsingGET(response: HttpResponseBase): Observable<CardObjectiveReflexesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveReflexesDto.fromJS(resultData200) : new CardObjectiveReflexesDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveReflexesDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> рефлексы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateCardObjectiveGeneralUsingPUT_1(cardId: number, dto: CardObjectiveReflexesDto): Observable<CardObjectiveReflexesDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/reflexes";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCardObjectiveGeneralUsingPUT_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCardObjectiveGeneralUsingPUT_1(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveReflexesDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCardObjectiveGeneralUsingPUT_1(response: HttpResponseBase): Observable<CardObjectiveReflexesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveReflexesDto.fromJS(resultData200) : new CardObjectiveReflexesDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveReflexesDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> кож.покровы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesSkinUsingGET(cardId: number): Observable<CardObjectiveSkinPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/skin";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesSkinUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesSkinUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesSkinUsingGET(response: HttpResponseBase): Observable<CardObjectiveSkinPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveSkinPartDto.fromJS(resultData200) : new CardObjectiveSkinPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveSkinPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> кож.покровы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateSkinUsingPUT(cardId: number, dto: CardObjectiveSkinPartDto): Observable<CardObjectiveSkinPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/skin";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkinUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkinUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveSkinPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkinUsingPUT(response: HttpResponseBase): Observable<CardObjectiveSkinPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveSkinPartDto.fromJS(resultData200) : new CardObjectiveSkinPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveSkinPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> живот
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesStomachUsingGET(cardId: number): Observable<CardObjectiveStomachPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/stomach";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesStomachUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesStomachUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesStomachUsingGET(response: HttpResponseBase): Observable<CardObjectiveStomachPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveStomachPartDto.fromJS(resultData200) : new CardObjectiveStomachPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveStomachPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> живот
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateStomachUsingPUT(cardId: number, dto: CardObjectiveStomachPartDto): Observable<CardObjectiveStomachPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/stomach";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStomachUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStomachUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveStomachPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStomachUsingPUT(response: HttpResponseBase): Observable<CardObjectiveStomachPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveStomachPartDto.fromJS(resultData200) : new CardObjectiveStomachPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveStomachPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> слиз.зева
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesThroatUsingGET(cardId: number): Observable<CardObjectiveThroatPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/throat";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesThroatUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesThroatUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesThroatUsingGET(response: HttpResponseBase): Observable<CardObjectiveThroatPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveThroatPartDto.fromJS(resultData200) : new CardObjectiveThroatPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveThroatPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> слиз.зева
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateThroatUsingPUT(cardId: number, dto: CardObjectiveThroatPartDto): Observable<CardObjectiveThroatPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/throat";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateThroatUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateThroatUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveThroatPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateThroatUsingPUT(response: HttpResponseBase): Observable<CardObjectiveThroatPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveThroatPartDto.fromJS(resultData200) : new CardObjectiveThroatPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveThroatPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> язык
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesTongueUsingGET(cardId: number): Observable<CardObjectiveTonguePart> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tongue";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesTongueUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesTongueUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonguePart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonguePart>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesTongueUsingGET(response: HttpResponseBase): Observable<CardObjectiveTonguePart> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonguePart.fromJS(resultData200) : new CardObjectiveTonguePart();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonguePart>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> язык
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateTongueUsingPUT(cardId: number, dto: CardObjectiveTonguePart): Observable<CardObjectiveTonguePart> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tongue";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTongueUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTongueUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonguePart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonguePart>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTongueUsingPUT(response: HttpResponseBase): Observable<CardObjectiveTonguePart> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonguePart.fromJS(resultData200) : new CardObjectiveTonguePart();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonguePart>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> миндалины
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesTonsilsUsingGET(cardId: number): Observable<CardObjectiveTonsilsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tonsils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesTonsilsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesTonsilsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesTonsilsUsingGET(response: HttpResponseBase): Observable<CardObjectiveTonsilsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonsilsPartDto.fromJS(resultData200) : new CardObjectiveTonsilsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonsilsPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> миндалины
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateTonsilsUsingPUT(cardId: number, dto: CardObjectiveTonsilsPartDto): Observable<CardObjectiveTonsilsPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/tonsils";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTonsilsUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTonsilsUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveTonsilsPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTonsilsUsingPUT(response: HttpResponseBase): Observable<CardObjectiveTonsilsPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveTonsilsPartDto.fromJS(resultData200) : new CardObjectiveTonsilsPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveTonsilsPartDto>(<any>null);
    }

    /**
     * карта вызова -> вторая сторона -> объект.данные -> хрипы
     * @param cardId cardId
     * @return OK
     */
    readSideTwoObjectivesWheezingUsingGET(cardId: number): Observable<CardObjectiveWheezingPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/wheezing";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideTwoObjectivesWheezingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideTwoObjectivesWheezingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideTwoObjectivesWheezingUsingGET(response: HttpResponseBase): Observable<CardObjectiveWheezingPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveWheezingPartDto.fromJS(resultData200) : new CardObjectiveWheezingPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveWheezingPartDto>(<any>null);
    }

    /**
     * [UPDATE] карта вызова -> вторая сторона -> объект.данные -> хрипы
     * @param cardId cardId
     * @param dto dto
     * @return OK
     */
    updateWheezingUsingPUT(cardId: number, dto: CardObjectiveWheezingPartDto): Observable<CardObjectiveWheezingPartDto> {
        let url_ = this.baseUrl + "/api/cards/{cardId}/side_two/objectives/wheezing";
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWheezingUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWheezingUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectiveWheezingPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWheezingUsingPUT(response: HttpResponseBase): Observable<CardObjectiveWheezingPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectiveWheezingPartDto.fromJS(resultData200) : new CardObjectiveWheezingPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectiveWheezingPartDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_7(id: number): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards_objective/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_7(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_7(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_6(dto: CardObjectivePartDto): Observable<CardObjectivePartDto> {
        let url_ = this.baseUrl + "/api/cards_objective/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_6(<any>response_);
                } catch (e) {
                    return <Observable<CardObjectivePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardObjectivePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_6(response: HttpResponseBase): Observable<CardObjectivePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardObjectivePartDto.fromJS(resultData200) : new CardObjectivePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardObjectivePartDto>(<any>null);
    }

    /**
     * readAll
     * @param chatId (optional) chatId
     * @param query (optional) query
     * @return OK
     */
    readAllUsingGET_9(chatId?: number | null | undefined, query?: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/chat_messages?";
        if (chatId !== undefined)
            url_ += "chatId=" + encodeURIComponent("" + chatId) + "&"; 
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_9(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_9(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * create
     * @param chatMessage chatMessage
     * @return OK
     */
    createUsingPOST_7(chatMessage: ChatMessage): Observable<ChatMessage> {
        let url_ = this.baseUrl + "/api/chat_messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chatMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_7(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessage>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_7(response: HttpResponseBase): Observable<ChatMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessage.fromJS(resultData200) : new ChatMessage();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessage>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_10(id: number): Observable<ChatMessage> {
        let url_ = this.baseUrl + "/api/chat_messages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_10(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessage>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_10(response: HttpResponseBase): Observable<ChatMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessage.fromJS(resultData200) : new ChatMessage();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessage>(<any>null);
    }

    /**
     * update
     * @param chatMessage chatMessage
     * @return OK
     */
    updateUsingPUT_9(chatMessage: ChatMessage): Observable<ChatMessage> {
        let url_ = this.baseUrl + "/api/chat_messages/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chatMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_9(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessage>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_9(response: HttpResponseBase): Observable<ChatMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessage.fromJS(resultData200) : new ChatMessage();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessage>(<any>null);
    }

    /**
     * readAll
     * @param query (optional) query
     * @return OK
     */
    readAllUsingGET_8(query?: string | null | undefined): Observable<Chat[]> {
        let url_ = this.baseUrl + "/api/chats?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_8(<any>response_);
                } catch (e) {
                    return <Observable<Chat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_8(response: HttpResponseBase): Observable<Chat[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Chat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat[]>(<any>null);
    }

    /**
     * create
     * @param chat chat
     * @return OK
     */
    createUsingPOST_6(chat: Chat): Observable<Chat> {
        let url_ = this.baseUrl + "/api/chats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chat);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_6(<any>response_);
                } catch (e) {
                    return <Observable<Chat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_6(response: HttpResponseBase): Observable<Chat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Chat.fromJS(resultData200) : new Chat();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat>(<any>null);
    }

    /**
     * readAllPlaces
     * @return OK
     */
    readAllPlacesUsingGET(): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/chats/places";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPlacesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPlacesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPlacesUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_9(id: number): Observable<Chat> {
        let url_ = this.baseUrl + "/api/chats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_9(<any>response_);
                } catch (e) {
                    return <Observable<Chat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_9(response: HttpResponseBase): Observable<Chat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Chat.fromJS(resultData200) : new Chat();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat>(<any>null);
    }

    /**
     * update
     * @param chat chat
     * @return OK
     */
    updateUsingPUT_8(chat: Chat): Observable<Chat> {
        let url_ = this.baseUrl + "/api/chats/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chat);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_8(<any>response_);
                } catch (e) {
                    return <Observable<Chat>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chat>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_8(response: HttpResponseBase): Observable<Chat> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Chat.fromJS(resultData200) : new Chat();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chat>(<any>null);
    }

    /**
     * previewUnreadMessages
     * @param id id
     * @param performerId performerId
     * @return OK
     */
    previewUnreadMessagesUsingPUT(id: number, performerId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/chats/{id}/performers/{performerId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewUnreadMessagesUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewUnreadMessagesUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPreviewUnreadMessagesUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * read
     * @return OK
     */
    readUsingGET(): Observable<Config> {
        let url_ = this.baseUrl + "/api/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Config>><any>_observableThrow(e);
                }
            } else
                return <Observable<Config>><any>_observableThrow(response_);
        }));
    }

    protected processReadUsingGET(response: HttpResponseBase): Observable<Config> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Config.fromJS(resultData200) : new Config();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Config>(<any>null);
    }

    /**
     * readAll
     * @param deleted (optional) deleted
     * @param with_geom (optional) with_geom
     * @return OK
     */
    readAllUsingGET_10(deleted?: boolean | null | undefined, with_geom?: boolean | null | undefined): Observable<DistrictDto[]> {
        let url_ = this.baseUrl + "/api/districts?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (with_geom !== undefined)
            url_ += "with_geom=" + encodeURIComponent("" + with_geom) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_10(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_10(response: HttpResponseBase): Observable<DistrictDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DistrictDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_8(dto: DistrictDto): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_8(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_8(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readOneByCode
     * @param code code
     * @return OK
     */
    readOneByCodeUsingGET(code: string): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/by_code/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneByCodeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneByCodeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneByCodeUsingGET(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readOneByFiasId
     * @param id id
     * @return OK
     */
    readOneByFiasIdUsingGET(id: number): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/by_fiasId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneByFiasIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneByFiasIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneByFiasIdUsingGET(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_11(id: number): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_11(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_11(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_10(dto: DistrictDto): Observable<DistrictDto> {
        let url_ = this.baseUrl + "/api/districts/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_10(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_10(response: HttpResponseBase): Observable<DistrictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DistrictDto.fromJS(resultData200) : new DistrictDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDto>(<any>null);
    }

    /**
     * readAll
     * @param document_id document_id
     * @return OK
     */
    readAllUsingGET_12(document_id: number): Observable<DocumentNomenclature[]> {
        let url_ = this.baseUrl + "/api/document_nomenclatures?";
        if (document_id === undefined || document_id === null)
            throw new Error("The parameter 'document_id' must be defined and cannot be null.");
        else
            url_ += "document_id=" + encodeURIComponent("" + document_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_12(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_12(response: HttpResponseBase): Observable<DocumentNomenclature[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentNomenclature.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature[]>(<any>null);
    }

    /**
     * create
     * @param documentNomenclature documentNomenclature
     * @return OK
     */
    createUsingPOST_10(documentNomenclature: DocumentNomenclature): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentNomenclature);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_10(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_10(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_13(id: number): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_13(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_13(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * update
     * @param documentNomenclature documentNomenclature
     * @return OK
     */
    updateUsingPUT_12(documentNomenclature: DocumentNomenclature): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentNomenclature);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_12(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_12(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE_1(id: number): Observable<DocumentNomenclature> {
        let url_ = this.baseUrl + "/api/document_nomenclatures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_1(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNomenclature>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNomenclature>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_1(response: HttpResponseBase): Observable<DocumentNomenclature> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentNomenclature.fromJS(resultData200) : new DocumentNomenclature();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNomenclature>(<any>null);
    }

    /**
     * readAll
     * @param is_archived (optional) is_archived
     * @return OK
     */
    readAllUsingGET_11(is_archived?: boolean | null | undefined): Observable<Document[]> {
        let url_ = this.baseUrl + "/api/documents?";
        if (is_archived !== undefined)
            url_ += "is_archived=" + encodeURIComponent("" + is_archived) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_11(<any>response_);
                } catch (e) {
                    return <Observable<Document[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_11(response: HttpResponseBase): Observable<Document[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Document.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document[]>(<any>null);
    }

    /**
     * create
     * @param document document
     * @param accept (optional) accept
     * @return OK
     */
    createUsingPOST_9(document: Document, accept?: boolean | null | undefined): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents?";
        if (accept !== undefined)
            url_ += "accept=" + encodeURIComponent("" + accept) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_9(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_9(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * removeAccept
     * @param id id
     * @return OK
     */
    removeAcceptUsingGET(id: number): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents/remove_accept/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAcceptUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAcceptUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAcceptUsingGET(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_12(id: number): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_12(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_12(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * update
     * @param document document
     * @param accept (optional) accept
     * @return OK
     */
    updateUsingPUT_11(document: Document, accept?: boolean | null | undefined): Observable<Document> {
        let url_ = this.baseUrl + "/api/documents/{id}?";
        if (accept !== undefined)
            url_ += "accept=" + encodeURIComponent("" + accept) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_11(<any>response_);
                } catch (e) {
                    return <Observable<Document>><any>_observableThrow(e);
                }
            } else
                return <Observable<Document>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_11(response: HttpResponseBase): Observable<Document> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Document>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * archived
     * @param id id
     * @param archived (optional) archived
     * @return OK
     */
    archivedUsingGET(id: number, archived?: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/{id}/archive?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (archived !== undefined)
            url_ += "archived=" + encodeURIComponent("" + archived) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processArchivedUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchivedUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processArchivedUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param s (optional) s
     * @return OK
     */
    readAllUsingGET_13(s?: string | null | undefined): Observable<DrugDto[]> {
        let url_ = this.baseUrl + "/api/drugs?";
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_13(<any>response_);
                } catch (e) {
                    return <Observable<DrugDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DrugDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_13(response: HttpResponseBase): Observable<DrugDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DrugDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DrugDto[]>(<any>null);
    }

    /**
     * readAllCodes
     * @param s (optional) s
     * @return OK
     */
    readAllCodesUsingGET(s?: string | null | undefined): Observable<Code[]> {
        let url_ = this.baseUrl + "/api/drugs/codes?";
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllCodesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllCodesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Code[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Code[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllCodesUsingGET(response: HttpResponseBase): Observable<Code[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Code.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Code[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_14(id: number): Observable<PharmacyReferenceItem> {
        let url_ = this.baseUrl + "/api/drugs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_14(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyReferenceItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyReferenceItem>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_14(response: HttpResponseBase): Observable<PharmacyReferenceItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyReferenceItem.fromJS(resultData200) : new PharmacyReferenceItem();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyReferenceItem>(<any>null);
    }

    /**
     * readAllAddressObject
     * @param diId (optional) diId
     * @param query (optional) query
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllAddressObjectUsingGET(diId?: number | null | undefined, query?: string | null | undefined, deleted?: boolean | null | undefined): Observable<AddressObject[]> {
        let url_ = this.baseUrl + "/api/fias/aos?";
        if (diId !== undefined)
            url_ += "diId=" + encodeURIComponent("" + diId) + "&"; 
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllAddressObjectUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllAddressObjectUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<AddressObject[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressObject[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllAddressObjectUsingGET(response: HttpResponseBase): Observable<AddressObject[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AddressObject.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressObject[]>(<any>null);
    }

    /**
     * readAllDistrict
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllDistrictUsingGET_1(deleted?: boolean | null | undefined): Observable<District[]> {
        let url_ = this.baseUrl + "/api/fias/districts?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllDistrictUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllDistrictUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllDistrictUsingGET_1(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(District.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    /**
     * readOneDistrict
     * @param id id
     * @return OK
     */
    readOneDistrictUsingGET(id: number): Observable<District> {
        let url_ = this.baseUrl + "/api/fias/districts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneDistrictUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneDistrictUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<District>><any>_observableThrow(e);
                }
            } else
                return <Observable<District>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneDistrictUsingGET(response: HttpResponseBase): Observable<District> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? District.fromJS(resultData200) : new District();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District>(<any>null);
    }

    /**
     * findDistrict
     * @param aoId aoId
     * @return OK
     */
    findDistrictUsingGET(aoId: number): Observable<District[]> {
        let url_ = this.baseUrl + "/api/fias/find_district?";
        if (aoId === undefined || aoId === null)
            throw new Error("The parameter 'aoId' must be defined and cannot be null.");
        else
            url_ += "aoId=" + encodeURIComponent("" + aoId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindDistrictUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindDistrictUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindDistrictUsingGET(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(District.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    /**
     * cписок домов, принадлежащих address object
     * @param addressObjectId addressObjectId
     * @return OK
     */
    readHousesByAOidUsingGET(addressObjectId: number): Observable<CardAddressHouseDto[]> {
        let url_ = this.baseUrl + "/api/fias/{addressObjectId}/houses";
        if (addressObjectId === undefined || addressObjectId === null)
            throw new Error("The parameter 'addressObjectId' must be defined.");
        url_ = url_.replace("{addressObjectId}", encodeURIComponent("" + addressObjectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadHousesByAOidUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadHousesByAOidUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAddressHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAddressHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadHousesByAOidUsingGET(response: HttpResponseBase): Observable<CardAddressHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardAddressHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAddressHouseDto[]>(<any>null);
    }

    /**
     * cписок корпусов, принадлежащих address object
     * @param addressObjectId addressObjectId
     * @return OK
     */
    readStructuresByhouseIdUsingGET(addressObjectId: number): Observable<CardAddressHouseDto[]> {
        let url_ = this.baseUrl + "/api/fias/{addressObjectId}/houses/{houseNumber}";
        if (addressObjectId === undefined || addressObjectId === null)
            throw new Error("The parameter 'addressObjectId' must be defined.");
        url_ = url_.replace("{addressObjectId}", encodeURIComponent("" + addressObjectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadStructuresByhouseIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadStructuresByhouseIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardAddressHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardAddressHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadStructuresByhouseIdUsingGET(response: HttpResponseBase): Observable<CardAddressHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardAddressHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardAddressHouseDto[]>(<any>null);
    }

    /**
     * completeAddress
     * @param dto dto
     * @return OK
     */
    completeAddressUsingPOST(dto: CallFiasAddressDto): Observable<CallFiasAddressDto> {
        let url_ = this.baseUrl + "/api/fias2/address/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteAddressUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteAddressUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallFiasAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallFiasAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteAddressUsingPOST(response: HttpResponseBase): Observable<CallFiasAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallFiasAddressDto.fromJS(resultData200) : new CallFiasAddressDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallFiasAddressDto>(<any>null);
    }

    /**
     * readAllCountries
     * @param q (optional) q
     * @return OK
     */
    readAllCountriesUsingGET(q?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/countries?";
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllCountriesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllCountriesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllCountriesUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllDistrict
     * @param region_code region_code
     * @param q (optional) q
     * @return OK
     */
    readAllDistrictUsingGET(region_code: string, q?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/districts?";
        if (region_code === undefined || region_code === null)
            throw new Error("The parameter 'region_code' must be defined and cannot be null.");
        else
            url_ += "region_code=" + encodeURIComponent("" + region_code) + "&"; 
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllDistrictUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllDistrictUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllDistrictUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllHouses
     * @param number (optional) number
     * @param building (optional) building
     * @param structure (optional) structure
     * @param settlement_code (optional) settlement_code
     * @param street_code (optional) street_code
     * @return OK
     */
    readAllHousesUsingGET(number?: string | null | undefined, building?: string | null | undefined, structure?: string | null | undefined, settlement_code?: string | null | undefined, street_code?: string | null | undefined): Observable<FiasAddressHouseDto[]> {
        let url_ = this.baseUrl + "/api/fias2/houses?";
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (building !== undefined)
            url_ += "building=" + encodeURIComponent("" + building) + "&"; 
        if (structure !== undefined)
            url_ += "structure=" + encodeURIComponent("" + structure) + "&"; 
        if (settlement_code !== undefined)
            url_ += "settlement_code=" + encodeURIComponent("" + settlement_code) + "&"; 
        if (street_code !== undefined)
            url_ += "street_code=" + encodeURIComponent("" + street_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllHousesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllHousesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllHousesUsingGET(response: HttpResponseBase): Observable<FiasAddressHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressHouseDto[]>(<any>null);
    }

    /**
     * readAllRegions
     * @param q (optional) q
     * @return OK
     */
    readAllRegionsUsingGET(q?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/regions?";
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllRegionsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllRegionsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllRegionsUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllSettlements
     * @param q q
     * @param region_code region_code
     * @param district_code (optional) district_code
     * @return OK
     */
    readAllSettlementsUsingGET(q: string, region_code: string, district_code?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/settlements?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (region_code === undefined || region_code === null)
            throw new Error("The parameter 'region_code' must be defined and cannot be null.");
        else
            url_ += "region_code=" + encodeURIComponent("" + region_code) + "&"; 
        if (district_code !== undefined)
            url_ += "district_code=" + encodeURIComponent("" + district_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllSettlementsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllSettlementsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllSettlementsUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * readAllStreets
     * @param region_code region_code
     * @param district_code district_code
     * @param q (optional) q
     * @param settlement_code (optional) settlement_code
     * @return OK
     */
    readAllStreetsUsingGET(region_code: string, district_code: string, q?: string | null | undefined, settlement_code?: string | null | undefined): Observable<FiasAddressObjectDto[]> {
        let url_ = this.baseUrl + "/api/fias2/streets?";
        if (region_code === undefined || region_code === null)
            throw new Error("The parameter 'region_code' must be defined and cannot be null.");
        else
            url_ += "region_code=" + encodeURIComponent("" + region_code) + "&"; 
        if (district_code === undefined || district_code === null)
            throw new Error("The parameter 'district_code' must be defined and cannot be null.");
        else
            url_ += "district_code=" + encodeURIComponent("" + district_code) + "&"; 
        if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (settlement_code !== undefined)
            url_ += "settlement_code=" + encodeURIComponent("" + settlement_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllStreetsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllStreetsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressObjectDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllStreetsUsingGET(response: HttpResponseBase): Observable<FiasAddressObjectDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FiasAddressObjectDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressObjectDto[]>(<any>null);
    }

    /**
     * getManual
     * @return OK
     */
    getManualUsingGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/help/manual";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManualUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManualUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetManualUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param parId (optional) parId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_15(parId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<HospitalDto[]> {
        let url_ = this.baseUrl + "/api/hospitals?";
        if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_15(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_15(response: HttpResponseBase): Observable<HospitalDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HospitalDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_11(dto: HospitalDto): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/hospitals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_11(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_11(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HospitalDto.fromJS(resultData200) : new HospitalDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_13(dto: HospitalDto): Observable<HospitalDto> {
        let url_ = this.baseUrl + "/api/hospitals/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_13(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_13(response: HttpResponseBase): Observable<HospitalDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HospitalDto.fromJS(resultData200) : new HospitalDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_15(id: number): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/hospitals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_15(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_15(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * create112
     * @return OK
     */
    create112UsingGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/imitation/create112";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate112UsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate112UsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate112UsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * createNezabudka
     * @param phone phone
     * @return OK
     */
    createNezabudkaUsingGET(phone: string): Observable<CallGridDto[]> {
        let url_ = this.baseUrl + "/api/imitation/nezabudka/calls/find?";
        if (phone === undefined || phone === null)
            throw new Error("The parameter 'phone' must be defined and cannot be null.");
        else
            url_ += "phone=" + encodeURIComponent("" + phone) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNezabudkaUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNezabudkaUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNezabudkaUsingGET(response: HttpResponseBase): Observable<CallGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGridDto[]>(<any>null);
    }

    /**
     * routing
     * @param turn_on (optional) turn_on
     * @return OK
     */
    routingUsingGET(turn_on?: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/imitation/routing?";
        if (turn_on !== undefined)
            url_ += "turn_on=" + encodeURIComponent("" + turn_on) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoutingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoutingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRoutingUsingGET(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * опросник -> запись
     * @param dto dto
     * @return OK
     */
    updateObjectUsingPOST(dto: InquirerDto): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateObjectUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateObjectUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateObjectUsingPOST(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * опросник -> запись - > новая
     * @param parentId parentId
     * @return OK
     */
    getCreateUsingGET(parentId: number): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer/create/{parentId}";
        if (parentId === undefined || parentId === null)
            throw new Error("The parameter 'parentId' must be defined.");
        url_ = url_.replace("{parentId}", encodeURIComponent("" + parentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreateUsingGET(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * опросник в виде дерева
     * @param parentId (optional) parentId
     * @return OK
     */
    readTreeUsingGET(parentId?: number | null | undefined): Observable<InquirerTreeNode[]> {
        let url_ = this.baseUrl + "/api/inquirer/tree?";
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerTreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerTreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeUsingGET(response: HttpResponseBase): Observable<InquirerTreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InquirerTreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerTreeNode[]>(<any>null);
    }

    /**
     * опросник -> запись
     * @param id id
     * @return OK
     */
    readObjectUsingGET(id: number): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadObjectUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadObjectUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadObjectUsingGET(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * [UPDATE] опросник -> запись
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateObjectUsingPUT(id: number, dto: InquirerDto): Observable<InquirerDto> {
        let url_ = this.baseUrl + "/api/inquirer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateObjectUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateObjectUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<InquirerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquirerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateObjectUsingPUT(response: HttpResponseBase): Observable<InquirerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InquirerDto.fromJS(resultData200) : new InquirerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquirerDto>(<any>null);
    }

    /**
     * [UPDATE] опросник -> запись
     * @param id id
     * @return OK
     */
    deleteObjectReasonUsingDELETE(id: number): Observable<Inquirer> {
        let url_ = this.baseUrl + "/api/inquirer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteObjectReasonUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteObjectReasonUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<Inquirer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inquirer>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteObjectReasonUsingDELETE(response: HttpResponseBase): Observable<Inquirer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inquirer.fromJS(resultData200) : new Inquirer();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inquirer>(<any>null);
    }

    /**
     * readAll
     * @param place_id (optional) place_id
     * @param product_id (optional) product_id
     * @return OK
     */
    readAllUsingGET_16(place_id?: number | null | undefined, product_id?: number | null | undefined): Observable<Inventory[]> {
        let url_ = this.baseUrl + "/api/inventories?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (product_id !== undefined)
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_16(<any>response_);
                } catch (e) {
                    return <Observable<Inventory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_16(response: HttpResponseBase): Observable<Inventory[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Inventory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory[]>(<any>null);
    }

    /**
     * create
     * @param inventory inventory
     * @return OK
     */
    createUsingPOST_12(inventory: Inventory): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inventory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_12(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_12(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * readOneForProductAndPlace
     * @param place_id place_id
     * @param product_id product_id
     * @return OK
     */
    readOneForProductAndPlaceUsingGET(place_id: number, product_id: number): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories/for_product_and_place?";
        if (place_id === undefined || place_id === null)
            throw new Error("The parameter 'place_id' must be defined and cannot be null.");
        else
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (product_id === undefined || product_id === null)
            throw new Error("The parameter 'product_id' must be defined and cannot be null.");
        else
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneForProductAndPlaceUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneForProductAndPlaceUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneForProductAndPlaceUsingGET(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * getMovementOfInventory
     * @param inventory_id inventory_id
     * @return OK
     */
    getMovementOfInventoryUsingGET(inventory_id: number): Observable<ProductMove[]> {
        let url_ = this.baseUrl + "/api/inventories/movements?";
        if (inventory_id === undefined || inventory_id === null)
            throw new Error("The parameter 'inventory_id' must be defined and cannot be null.");
        else
            url_ += "inventory_id=" + encodeURIComponent("" + inventory_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMovementOfInventoryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMovementOfInventoryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ProductMove[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductMove[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMovementOfInventoryUsingGET(response: HttpResponseBase): Observable<ProductMove[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductMove.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductMove[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_16(id: number): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_16(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_16(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * update
     * @param inventory inventory
     * @return OK
     */
    updateUsingPUT_14(inventory: Inventory): Observable<Inventory> {
        let url_ = this.baseUrl + "/api/inventories/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inventory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_14(<any>response_);
                } catch (e) {
                    return <Observable<Inventory>><any>_observableThrow(e);
                }
            } else
                return <Observable<Inventory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_14(response: HttpResponseBase): Observable<Inventory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inventory.fromJS(resultData200) : new Inventory();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Inventory>(<any>null);
    }

    /**
     * readAll
     * @param inventory_id (optional) inventory_id
     * @param product_id (optional) product_id
     * @return OK
     */
    readAllUsingGET_17(inventory_id?: number | null | undefined, product_id?: number | null | undefined): Observable<InventoryNomenclature[]> {
        let url_ = this.baseUrl + "/api/inventory_nomenclatures?";
        if (inventory_id !== undefined)
            url_ += "inventory_id=" + encodeURIComponent("" + inventory_id) + "&"; 
        if (product_id !== undefined)
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_17(<any>response_);
                } catch (e) {
                    return <Observable<InventoryNomenclature[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InventoryNomenclature[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_17(response: HttpResponseBase): Observable<InventoryNomenclature[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InventoryNomenclature.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InventoryNomenclature[]>(<any>null);
    }

    /**
     * login
     * @return OK
     */
    loginUsingGET(): Observable<LoginInfo> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LoginInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginInfo>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingGET(response: HttpResponseBase): Observable<LoginInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginInfo.fromJS(resultData200) : new LoginInfo();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginInfo>(<any>null);
    }

    /**
     * login
     * @param login login
     * @return OK
     */
    loginUsingPOST(login: LoginPair): Observable<LoginInfo> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<LoginInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginInfo>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingPOST(response: HttpResponseBase): Observable<LoginInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginInfo.fromJS(resultData200) : new LoginInfo();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginInfo>(<any>null);
    }

    /**
     * logout
     * @return OK
     */
    logoutUsingGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogoutUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogoutUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogoutUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param itemId itemId
     * @param item_type (optional) item_type
     * @param type (optional) type
     * @param action_type (optional) action_type
     * @param date_from (optional) date_from
     * @param date_to (optional) date_to
     * @return OK
     */
    readAllUsingGET_18(itemId: number, item_type?: string | null | undefined, type?: string | null | undefined, action_type?: string | null | undefined, date_from?: string | null | undefined, date_to?: string | null | undefined): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/logs/{itemId}?";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId)); 
        if (item_type !== undefined)
            url_ += "item_type=" + encodeURIComponent("" + item_type) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (action_type !== undefined)
            url_ += "action_type=" + encodeURIComponent("" + action_type) + "&"; 
        if (date_from !== undefined)
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to !== undefined)
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_18(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_18(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> поиск бригад
     * @return OK
     */
    findBrigadesUsingGET_1(): Observable<BrigadeFindListDto[]> {
        let url_ = this.baseUrl + "/api/maps/brigade_schedules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindBrigadesUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindBrigadesUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeFindListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeFindListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindBrigadesUsingGET_1(response: HttpResponseBase): Observable<BrigadeFindListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeFindListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeFindListDto[]>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_27(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/materials?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_27(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_27(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_26(id: number): Observable<PharmacyReferenceItem> {
        let url_ = this.baseUrl + "/api/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_26(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyReferenceItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyReferenceItem>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_26(response: HttpResponseBase): Observable<PharmacyReferenceItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyReferenceItem.fromJS(resultData200) : new PharmacyReferenceItem();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyReferenceItem>(<any>null);
    }

    /**
     * readOne
     * @return OK
     */
    readOneUsingGET_17(): Observable<NotificationObject> {
        let url_ = this.baseUrl + "/api/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_17(<any>response_);
                } catch (e) {
                    return <Observable<NotificationObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationObject>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_17(response: HttpResponseBase): Observable<NotificationObject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NotificationObject.fromJS(resultData200) : new NotificationObject();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationObject>(<any>null);
    }

    /**
     * readHelloWorld
     * @return OK
     */
    readHelloWorldUsingGET(): Observable<string> {
        let url_ = this.baseUrl + "/api/notifications/nosecurity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadHelloWorldUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadHelloWorldUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processReadHelloWorldUsingGET(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * карта -> tile [image.png]
     * @param z z
     * @param x x
     * @param y y
     * @return OK
     */
    getUsingGET(z: number, x: number, y: number): Observable<void> {
        let url_ = this.baseUrl + "/api/osm_tiles/{z}/{x}/{y}";
        if (z === undefined || z === null)
            throw new Error("The parameter 'z' must be defined.");
        url_ = url_.replace("{z}", encodeURIComponent("" + z)); 
        if (x === undefined || x === null)
            throw new Error("The parameter 'x' must be defined.");
        url_ = url_.replace("{x}", encodeURIComponent("" + x)); 
        if (y === undefined || y === null)
            throw new Error("The parameter 'y' must be defined.");
        url_ = url_.replace("{y}", encodeURIComponent("" + y)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param product_id product_id
     * @return OK
     */
    readAllUsingGET_19(product_id: number): Observable<Packaging[]> {
        let url_ = this.baseUrl + "/api/packagings?";
        if (product_id === undefined || product_id === null)
            throw new Error("The parameter 'product_id' must be defined and cannot be null.");
        else
            url_ += "product_id=" + encodeURIComponent("" + product_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_19(<any>response_);
                } catch (e) {
                    return <Observable<Packaging[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_19(response: HttpResponseBase): Observable<Packaging[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Packaging.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging[]>(<any>null);
    }

    /**
     * create
     * @param packaging packaging
     * @return OK
     */
    createUsingPOST_13(packaging: Packaging): Observable<Packaging> {
        let url_ = this.baseUrl + "/api/packagings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(packaging);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_13(<any>response_);
                } catch (e) {
                    return <Observable<Packaging>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_13(response: HttpResponseBase): Observable<Packaging> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Packaging.fromJS(resultData200) : new Packaging();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_18(id: number): Observable<Packaging> {
        let url_ = this.baseUrl + "/api/packagings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_18(<any>response_);
                } catch (e) {
                    return <Observable<Packaging>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_18(response: HttpResponseBase): Observable<Packaging> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Packaging.fromJS(resultData200) : new Packaging();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging>(<any>null);
    }

    /**
     * update
     * @param packaging packaging
     * @return OK
     */
    updateUsingPUT_15(packaging: Packaging): Observable<Packaging> {
        let url_ = this.baseUrl + "/api/packagings/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(packaging);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_15(<any>response_);
                } catch (e) {
                    return <Observable<Packaging>><any>_observableThrow(e);
                }
            } else
                return <Observable<Packaging>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_15(response: HttpResponseBase): Observable<Packaging> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Packaging.fromJS(resultData200) : new Packaging();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Packaging>(<any>null);
    }

    /**
     * readAll
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_21(deleted?: boolean | null | undefined): Observable<PerformerTypeDto[]> {
        let url_ = this.baseUrl + "/api/performer_types?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_21(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_21(response: HttpResponseBase): Observable<PerformerTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_15(dto: PerformerTypeDto): Observable<PerformerTypeDto> {
        let url_ = this.baseUrl + "/api/performer_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_15(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_15(response: HttpResponseBase): Observable<PerformerTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeDto.fromJS(resultData200) : new PerformerTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_20(id: number): Observable<PerformerTypeDto> {
        let url_ = this.baseUrl + "/api/performer_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_20(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_20(response: HttpResponseBase): Observable<PerformerTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeDto.fromJS(resultData200) : new PerformerTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_17(dto: PerformerTypeDto): Observable<PerformerTypeDto> {
        let url_ = this.baseUrl + "/api/performer_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_17(<any>response_);
                } catch (e) {
                    return <Observable<PerformerTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_17(response: HttpResponseBase): Observable<PerformerTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerTypeDto.fromJS(resultData200) : new PerformerTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerTypeDto>(<any>null);
    }

    /**
     * readAll
     * @param subId (optional) subId
     * @param f110Id (optional) f110Id
     * @param deleted (optional) deleted
     * @param skills (optional) skills
     * @param query (optional) query
     * @param brigade_scheduleId (optional) brigade_scheduleId
     * @return OK
     */
    readAllUsingGET_20(subId?: number | null | undefined, f110Id?: number | null | undefined, deleted?: boolean | null | undefined, skills?: boolean | null | undefined, query?: string | null | undefined, brigade_scheduleId?: number | null | undefined): Observable<ListDtoOfPerformerDto> {
        let url_ = this.baseUrl + "/api/performers?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (f110Id !== undefined)
            url_ += "f110Id=" + encodeURIComponent("" + f110Id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (skills !== undefined)
            url_ += "skills=" + encodeURIComponent("" + skills) + "&"; 
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        if (brigade_scheduleId !== undefined)
            url_ += "brigade_scheduleId=" + encodeURIComponent("" + brigade_scheduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_20(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfPerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfPerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_20(response: HttpResponseBase): Observable<ListDtoOfPerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfPerformerDto.fromJS(resultData200) : new ListDtoOfPerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfPerformerDto>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_14(dto: PerformerDto): Observable<PerformerDto> {
        let url_ = this.baseUrl + "/api/performers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_14(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_14(response: HttpResponseBase): Observable<PerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerDto.fromJS(resultData200) : new PerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto>(<any>null);
    }

    /**
     * updatePassword
     * @param login login
     * @return OK
     */
    updatePasswordUsingGET(login: string): Observable<void> {
        let url_ = this.baseUrl + "/api/performers/password?";
        if (login === undefined || login === null)
            throw new Error("The parameter 'login' must be defined and cannot be null.");
        else
            url_ += "login=" + encodeURIComponent("" + login) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePasswordUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * updatePassword
     * @param dto dto
     * @param password password
     * @param password2 password2
     * @return OK
     */
    updatePasswordUsingPOST(dto: PerformerDto, password: string, password2: string): Observable<void> {
        let url_ = this.baseUrl + "/api/performers/password?";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (password2 === undefined || password2 === null)
            throw new Error("The parameter 'password2' must be defined and cannot be null.");
        else
            url_ += "password2=" + encodeURIComponent("" + password2) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePasswordUsingPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readRoles
     * @param id id
     * @return OK
     */
    readRolesUsingGET(id: number): Observable<ListDtoOfRole> {
        let url_ = this.baseUrl + "/api/performers/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadRolesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadRolesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ListDtoOfRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListDtoOfRole>><any>_observableThrow(response_);
        }));
    }

    protected processReadRolesUsingGET(response: HttpResponseBase): Observable<ListDtoOfRole> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListDtoOfRole.fromJS(resultData200) : new ListDtoOfRole();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListDtoOfRole>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @param skills (optional) skills
     * @return OK
     */
    readOneUsingGET_19(id: number, skills?: boolean | null | undefined): Observable<PerformerDto> {
        let url_ = this.baseUrl + "/api/performers/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (skills !== undefined)
            url_ += "skills=" + encodeURIComponent("" + skills) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_19(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_19(response: HttpResponseBase): Observable<PerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerDto.fromJS(resultData200) : new PerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_16(id: number, dto: PerformerDto): Observable<PerformerDto> {
        let url_ = this.baseUrl + "/api/performers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_16(<any>response_);
                } catch (e) {
                    return <Observable<PerformerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_16(response: HttpResponseBase): Observable<PerformerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerDto.fromJS(resultData200) : new PerformerDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerDto>(<any>null);
    }

    /**
     * readAll
     * @param place_id (optional) place_id
     * @param drug_id (optional) drug_id
     * @param code (optional) code
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_22(place_id?: number | null | undefined, drug_id?: number | null | undefined, code?: string | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (drug_id !== undefined)
            url_ += "drug_id=" + encodeURIComponent("" + drug_id) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_22(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_22(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllDrugs
     * @param place_id (optional) place_id
     * @param drug_id (optional) drug_id
     * @param type (optional) type
     * @param group_id (optional) group_id
     * @param is_narcotic (optional) is_narcotic
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllDrugsUsingGET(place_id?: number | null | undefined, drug_id?: number | null | undefined, type?: number | null | undefined, group_id?: number | null | undefined, is_narcotic?: boolean | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/drugs?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (drug_id !== undefined)
            url_ += "drug_id=" + encodeURIComponent("" + drug_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (group_id !== undefined)
            url_ += "group_id=" + encodeURIComponent("" + group_id) + "&"; 
        if (is_narcotic !== undefined)
            url_ += "is_narcotic=" + encodeURIComponent("" + is_narcotic) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllDrugsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllDrugsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllDrugsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllTotalDrugs
     * @param place_id (optional) place_id
     * @param is_narcotic (optional) is_narcotic
     * @return OK
     */
    readAllTotalDrugsUsingGET(place_id?: number | null | undefined, is_narcotic?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/drugs/total?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (is_narcotic !== undefined)
            url_ += "is_narcotic=" + encodeURIComponent("" + is_narcotic) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllTotalDrugsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllTotalDrugsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllTotalDrugsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllMaterials
     * @param place_id (optional) place_id
     * @param drug_id (optional) drug_id
     * @param type (optional) type
     * @param group_id (optional) group_id
     * @param is_bandages (optional) is_bandages
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllMaterialsUsingGET(place_id?: number | null | undefined, drug_id?: number | null | undefined, type?: number | null | undefined, group_id?: number | null | undefined, is_bandages?: boolean | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/materials?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (drug_id !== undefined)
            url_ += "drug_id=" + encodeURIComponent("" + drug_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (group_id !== undefined)
            url_ += "group_id=" + encodeURIComponent("" + group_id) + "&"; 
        if (is_bandages !== undefined)
            url_ += "is_bandages=" + encodeURIComponent("" + is_bandages) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllMaterialsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllMaterialsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllMaterialsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readAllTotalMaterials
     * @param place_id (optional) place_id
     * @param is_bandages (optional) is_bandages
     * @return OK
     */
    readAllTotalMaterialsUsingGET(place_id?: number | null | undefined, is_bandages?: boolean | null | undefined): Observable<PharmacyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy/references/materials/total?";
        if (place_id !== undefined)
            url_ += "place_id=" + encodeURIComponent("" + place_id) + "&"; 
        if (is_bandages !== undefined)
            url_ += "is_bandages=" + encodeURIComponent("" + is_bandages) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllTotalMaterialsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllTotalMaterialsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllTotalMaterialsUsingGET(response: HttpResponseBase): Observable<PharmacyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_21(id: number): Observable<PharmacyDto> {
        let url_ = this.baseUrl + "/api/pharmacy/references/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_21(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_21(response: HttpResponseBase): Observable<PharmacyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDto.fromJS(resultData200) : new PharmacyDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDto>(<any>null);
    }

    /**
     * updateDrug
     * @param pharmacyItem pharmacyItem
     * @return OK
     */
    updateDrugUsingPUT(pharmacyItem: PharmacyItem): Observable<PharmacyItem> {
        let url_ = this.baseUrl + "/api/pharmacy/references/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pharmacyItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDrugUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDrugUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyItem>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDrugUsingPUT(response: HttpResponseBase): Observable<PharmacyItem> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyItem.fromJS(resultData200) : new PharmacyItem();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyItem>(<any>null);
    }

    /**
     * readAll
     * @param owner_id (optional) owner_id
     * @param bag_id (optional) bag_id
     * @return OK
     */
    readAllUsingGET_2(owner_id?: number | null | undefined, bag_id?: number | null | undefined): Observable<BagItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items?";
        if (owner_id !== undefined)
            url_ += "owner_id=" + encodeURIComponent("" + owner_id) + "&"; 
        if (bag_id !== undefined)
            url_ += "bag_id=" + encodeURIComponent("" + bag_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_2(response: HttpResponseBase): Observable<BagItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_2(dto: BagItemDto): Observable<BagItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_2(response: HttpResponseBase): Observable<BagItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagItemDto.fromJS(resultData200) : new BagItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto>(<any>null);
    }

    /**
     * readAllByTemplate
     * @param template_id (optional) template_id
     * @return OK
     */
    readAllByTemplateUsingGET(template_id?: number | null | undefined): Observable<BagItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items/templates/{id}?";
        if (template_id !== undefined)
            url_ += "template_id=" + encodeURIComponent("" + template_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllByTemplateUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllByTemplateUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllByTemplateUsingGET(response: HttpResponseBase): Observable<BagItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_2(id: number): Observable<BagItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_2(response: HttpResponseBase): Observable<BagItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagItemDto.fromJS(resultData200) : new BagItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_2(dto: BagItemDto): Observable<BagItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_items/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_2(<any>response_);
                } catch (e) {
                    return <Observable<BagItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_2(response: HttpResponseBase): Observable<BagItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagItemDto.fromJS(resultData200) : new BagItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagItemDto>(<any>null);
    }

    /**
     * readAll
     * @param bag_id (optional) bag_id
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_3(bag_id?: number | null | undefined, matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<BagMatrixItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bag_matrix_items?";
        if (bag_id !== undefined)
            url_ += "bag_id=" + encodeURIComponent("" + bag_id) + "&"; 
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_3(<any>response_);
                } catch (e) {
                    return <Observable<BagMatrixItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagMatrixItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_3(response: HttpResponseBase): Observable<BagMatrixItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagMatrixItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagMatrixItemDto[]>(<any>null);
    }

    /**
     * readAll
     * @param owner_id (optional) owner_id
     * @return OK
     */
    readAllUsingGET_1(owner_id?: number | null | undefined): Observable<BagDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_bags?";
        if (owner_id !== undefined)
            url_ += "owner_id=" + encodeURIComponent("" + owner_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_1(response: HttpResponseBase): Observable<BagDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BagDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_1(dto: BagDto): Observable<BagDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_1(response: HttpResponseBase): Observable<BagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagDto.fromJS(resultData200) : new BagDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto>(<any>null);
    }

    /**
     * sendBag
     * @param dto dto
     * @return OK
     */
    sendBagUsingPUT(dto: SendBagDto): Observable<void> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/sending";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendBagUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendBagUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendBagUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_1(id: number): Observable<BagDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_1(response: HttpResponseBase): Observable<BagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagDto.fromJS(resultData200) : new BagDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_1(id: number, dto: BagDto): Observable<BagDto> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_1(<any>response_);
                } catch (e) {
                    return <Observable<BagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_1(response: HttpResponseBase): Observable<BagDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BagDto.fromJS(resultData200) : new BagDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BagDto>(<any>null);
    }

    /**
     * unpacking
     * @param id id
     * @param dto dto
     * @return OK
     */
    unpackingUsingPUT(id: number, dto: BagDto): Observable<void> {
        let url_ = this.baseUrl + "/api/pharmacy_bags/{id}/unpacking";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpackingUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpackingUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnpackingUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_23(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyCounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_23(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyCounterpartyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyCounterpartyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_23(response: HttpResponseBase): Observable<PharmacyCounterpartyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyCounterpartyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyCounterpartyDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_16(dto: PharmacyCounterpartyDto): Observable<PharmacyCounterpartyDto> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_16(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_16(response: HttpResponseBase): Observable<PharmacyCounterpartyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyCounterpartyDto.fromJS(resultData200) : new PharmacyCounterpartyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyCounterpartyDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_22(id: number): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_22(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_22(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_18(dto: PharmacyCounterpartyDto): Observable<PharmacyCounterpartyDto> {
        let url_ = this.baseUrl + "/api/pharmacy_counterparties/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_18(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyCounterpartyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_18(response: HttpResponseBase): Observable<PharmacyCounterpartyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyCounterpartyDto.fromJS(resultData200) : new PharmacyCounterpartyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyCounterpartyDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param type (optional) type
     * @param counterparty_id (optional) counterparty_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_24(sub_id?: number | null | undefined, type?: number | null | undefined, counterparty_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyDocumentDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_documents?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (counterparty_id !== undefined)
            url_ += "counterparty_id=" + encodeURIComponent("" + counterparty_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_24(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_24(response: HttpResponseBase): Observable<PharmacyDocumentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyDocumentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_17(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_17(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_17(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_19(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_19(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_19(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readAllNomenclatureItems
     * @param owner_id (optional) owner_id
     * @param type (optional) type
     * @return OK
     */
    readAllNomenclatureItemsUsingGET(owner_id?: number | null | undefined, type?: number | null | undefined): Observable<PharmacyNomenclatureDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/nomenclature_items?";
        if (owner_id !== undefined)
            url_ += "owner_id=" + encodeURIComponent("" + owner_id) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllNomenclatureItemsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllNomenclatureItemsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyNomenclatureDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyNomenclatureDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllNomenclatureItemsUsingGET(response: HttpResponseBase): Observable<PharmacyNomenclatureDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyNomenclatureDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyNomenclatureDto[]>(<any>null);
    }

    /**
     * createAndProcessing
     * @param dto dto
     * @return OK
     */
    createAndProcessingUsingPOST(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/processing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAndProcessingUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAndProcessingUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAndProcessingUsingPOST(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * updateAndProcessing
     * @param dto dto
     * @return OK
     */
    updateAndProcessingUsingPUT(dto: PharmacyDocumentDto): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/processing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAndProcessingUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAndProcessingUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAndProcessingUsingPUT(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_23(id: number): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_23(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_23(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readAllItems
     * @param id id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllItemsUsingGET(id: number, deleted?: boolean | null | undefined): Observable<DocumentItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/{id}/items?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllItemsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllItemsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<DocumentItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllItemsUsingGET(response: HttpResponseBase): Observable<DocumentItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentItemDto[]>(<any>null);
    }

    /**
     * processing
     * @param id id
     * @return OK
     */
    processingUsingGET(id: number): Observable<PharmacyDocumentDto> {
        let url_ = this.baseUrl + "/api/pharmacy_documents/{id}/processing";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessingUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessingUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processProcessingUsingGET(response: HttpResponseBase): Observable<PharmacyDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyDocumentDto.fromJS(resultData200) : new PharmacyDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyDocumentDto>(<any>null);
    }

    /**
     * readAll
     * @param bag_id (optional) bag_id
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_14(bag_id?: number | null | undefined, matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<GroupBagItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_group_bag_items?";
        if (bag_id !== undefined)
            url_ += "bag_id=" + encodeURIComponent("" + bag_id) + "&"; 
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_14(<any>response_);
                } catch (e) {
                    return <Observable<GroupBagItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupBagItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_14(response: HttpResponseBase): Observable<GroupBagItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GroupBagItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupBagItemDto[]>(<any>null);
    }

    /**
     * readAll
     * @param group_id (optional) group_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_26(group_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyGroupReferenceDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references?";
        if (group_id !== undefined)
            url_ += "group_id=" + encodeURIComponent("" + group_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_26(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_26(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyGroupReferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_19(dto: PharmacyGroupReferenceDto): Observable<PharmacyGroupReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_19(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_19(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_19(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupReferenceDto.fromJS(resultData200) : new PharmacyGroupReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_25(id: number): Observable<PharmacyGroupReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_25(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_25(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupReferenceDto.fromJS(resultData200) : new PharmacyGroupReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_21(dto: PharmacyGroupReferenceDto): Observable<PharmacyGroupReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_group_references/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_21(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyGroupReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_21(response: HttpResponseBase): Observable<PharmacyGroupReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyGroupReferenceDto.fromJS(resultData200) : new PharmacyGroupReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyGroupReferenceDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_25(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ReferenceDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_groups?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_25(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_25(response: HttpResponseBase): Observable<ReferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_18(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_18(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_18(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_18(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_24(id: number): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_24(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_24(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_20(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_groups/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_20(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_20(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_29(sub_id?: number | null | undefined, matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyMatrixGroupDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_29(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_29(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyMatrixGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_21(dto: PharmacyMatrixGroupDto): Observable<PharmacyMatrixGroupDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_21(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_21(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_21(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixGroupDto.fromJS(resultData200) : new PharmacyMatrixGroupDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_28(id: number): Observable<PharmacyMatrixGroupDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_28(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_28(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixGroupDto.fromJS(resultData200) : new PharmacyMatrixGroupDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_23(dto: PharmacyMatrixGroupDto): Observable<PharmacyMatrixGroupDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_groups/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_23(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_23(response: HttpResponseBase): Observable<PharmacyMatrixGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixGroupDto.fromJS(resultData200) : new PharmacyMatrixGroupDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixGroupDto>(<any>null);
    }

    /**
     * readAll
     * @param matrix_id (optional) matrix_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_30(matrix_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<PharmacyMatrixItemDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items?";
        if (matrix_id !== undefined)
            url_ += "matrix_id=" + encodeURIComponent("" + matrix_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_30(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_30(response: HttpResponseBase): Observable<PharmacyMatrixItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PharmacyMatrixItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_22(dto: PharmacyMatrixItemDto): Observable<PharmacyMatrixItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_22(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_22(response: HttpResponseBase): Observable<PharmacyMatrixItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixItemDto.fromJS(resultData200) : new PharmacyMatrixItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_29(id: number): Observable<PharmacyMatrixItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_29(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_29(response: HttpResponseBase): Observable<PharmacyMatrixItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixItemDto.fromJS(resultData200) : new PharmacyMatrixItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_24(dto: PharmacyMatrixItemDto): Observable<PharmacyMatrixItemDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrix_items/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_24(<any>response_);
                } catch (e) {
                    return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PharmacyMatrixItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_24(response: HttpResponseBase): Observable<PharmacyMatrixItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PharmacyMatrixItemDto.fromJS(resultData200) : new PharmacyMatrixItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PharmacyMatrixItemDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_28(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<ReferenceDto[]> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_28(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_28(response: HttpResponseBase): Observable<ReferenceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReferenceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_20(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_20(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_20(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_20(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_27(id: number): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_27(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_27(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_22(dto: ReferenceDto): Observable<ReferenceDto> {
        let url_ = this.baseUrl + "/api/pharmacy_matrixes/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_22(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_22(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_22(response: HttpResponseBase): Observable<ReferenceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceDto.fromJS(resultData200) : new ReferenceDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceDto>(<any>null);
    }

    /**
     * readAll
     * @param subdivision_id subdivision_id
     * @param without_owner (optional) without_owner
     * @param type (optional) type
     * @return OK
     */
    readAllUsingGET_31(subdivision_id: number, without_owner?: boolean | null | undefined, type?: Type | null | undefined): Observable<Place[]> {
        let url_ = this.baseUrl + "/api/places?";
        if (subdivision_id === undefined || subdivision_id === null)
            throw new Error("The parameter 'subdivision_id' must be defined and cannot be null.");
        else
            url_ += "subdivision_id=" + encodeURIComponent("" + subdivision_id) + "&"; 
        if (without_owner !== undefined)
            url_ += "without_owner=" + encodeURIComponent("" + without_owner) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_31(<any>response_);
                } catch (e) {
                    return <Observable<Place[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_31(response: HttpResponseBase): Observable<Place[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Place.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place[]>(<any>null);
    }

    /**
     * create
     * @param place place
     * @return OK
     */
    createUsingPOST_23(place: Place): Observable<Place> {
        let url_ = this.baseUrl + "/api/places";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(place);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_23(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_23(<any>response_);
                } catch (e) {
                    return <Observable<Place>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_23(response: HttpResponseBase): Observable<Place> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Place.fromJS(resultData200) : new Place();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_30(id: number): Observable<Place> {
        let url_ = this.baseUrl + "/api/places/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_30(<any>response_);
                } catch (e) {
                    return <Observable<Place>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_30(response: HttpResponseBase): Observable<Place> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Place.fromJS(resultData200) : new Place();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place>(<any>null);
    }

    /**
     * update
     * @param place place
     * @return OK
     */
    updateUsingPUT_25(place: Place): Observable<Place> {
        let url_ = this.baseUrl + "/api/places/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(place);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_25(<any>response_);
                } catch (e) {
                    return <Observable<Place>><any>_observableThrow(e);
                }
            } else
                return <Observable<Place>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_25(response: HttpResponseBase): Observable<Place> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Place.fromJS(resultData200) : new Place();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Place>(<any>null);
    }

    /**
     * readAll
     * @return OK
     */
    readAllUsingGET_33(): Observable<ProductType[]> {
        let url_ = this.baseUrl + "/api/product_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_33(<any>response_);
                } catch (e) {
                    return <Observable<ProductType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_33(response: HttpResponseBase): Observable<ProductType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType[]>(<any>null);
    }

    /**
     * create
     * @param productType productType
     * @return OK
     */
    createUsingPOST_25(productType: ProductType): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/product_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_25(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_25(<any>response_);
                } catch (e) {
                    return <Observable<ProductType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_25(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductType.fromJS(resultData200) : new ProductType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_32(id: number): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/product_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_32(<any>response_);
                } catch (e) {
                    return <Observable<ProductType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_32(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductType.fromJS(resultData200) : new ProductType();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType>(<any>null);
    }

    /**
     * update
     * @param productType productType
     * @return OK
     */
    updateUsingPUT_27(productType: ProductType): Observable<ProductType> {
        let url_ = this.baseUrl + "/api/product_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(productType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_27(<any>response_);
                } catch (e) {
                    return <Observable<ProductType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_27(response: HttpResponseBase): Observable<ProductType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductType.fromJS(resultData200) : new ProductType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType>(<any>null);
    }

    /**
     * readAll
     * @param s (optional) s
     * @return OK
     */
    readAllUsingGET_32(s?: string | null | undefined): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/products?";
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_32(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_32(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }

    /**
     * create
     * @param product product
     * @return OK
     */
    createUsingPOST_24(product: Product): Observable<Product> {
        let url_ = this.baseUrl + "/api/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_24(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_24(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_24(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_31(id: number): Observable<Product> {
        let url_ = this.baseUrl + "/api/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_31(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_31(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * update
     * @param product product
     * @return OK
     */
    updateUsingPUT_26(product: Product): Observable<Product> {
        let url_ = this.baseUrl + "/api/products/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_26(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_26(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * readAll
     * @param type type
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_34(type: string, deleted?: boolean | null | undefined): Observable<ReferenceTypeDto[]> {
        let url_ = this.baseUrl + "/api/reference_types?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_34(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_34(response: HttpResponseBase): Observable<ReferenceTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReferenceTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_26(dto: ReferenceTypeDto): Observable<ReferenceTypeDto> {
        let url_ = this.baseUrl + "/api/reference_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_26(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_26(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_26(response: HttpResponseBase): Observable<ReferenceTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeDto.fromJS(resultData200) : new ReferenceTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_33(id: number): Observable<ReferenceTypeDto> {
        let url_ = this.baseUrl + "/api/reference_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_33(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_33(response: HttpResponseBase): Observable<ReferenceTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeDto.fromJS(resultData200) : new ReferenceTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_28(id: number, dto: ReferenceTypeDto): Observable<ReferenceTypeDto> {
        let url_ = this.baseUrl + "/api/reference_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_28(<any>response_);
                } catch (e) {
                    return <Observable<ReferenceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferenceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_28(response: HttpResponseBase): Observable<ReferenceTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReferenceTypeDto.fromJS(resultData200) : new ReferenceTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferenceTypeDto>(<any>null);
    }

    /**
     * печать карт вызовов
     * @return OK
     */
    generateCardReportUsingGET_2(): Observable<ModelAndView> {
        let url_ = this.baseUrl + "/api/report";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCardReportUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCardReportUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<ModelAndView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelAndView>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCardReportUsingGET_2(response: HttpResponseBase): Observable<ModelAndView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ModelAndView.fromJS(resultData200) : new ModelAndView();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelAndView>(<any>null);
    }

    /**
     * печать карты вызова
     * @param id id
     * @return OK
     */
    generateCardReportUsingGET_1(id: number): Observable<ModelAndView> {
        let url_ = this.baseUrl + "/api/report/cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCardReportUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCardReportUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ModelAndView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelAndView>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCardReportUsingGET_1(response: HttpResponseBase): Observable<ModelAndView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ModelAndView.fromJS(resultData200) : new ModelAndView();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelAndView>(<any>null);
    }

    /**
     * печать сопроводит. листа и талона к нему
     * @param id id
     * @return OK
     */
    generateCardReportUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/report/cards/{id}/ticket";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCardReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCardReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCardReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать графика нарядов бригад СМП
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @return OK
     */
    generateBrigadeCalendarUsingGET(id: number, date_from: string, date_to: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/calendars/brigades?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBrigadeCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBrigadeCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateBrigadeCalendarUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать графика работы сотрудников
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @param group_code group_code
     * @return OK
     */
    generatePerforemerCalendarUsingGET(id: number, date_from: string, date_to: string, group_code: Group_code): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/calendars/performers?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        if (group_code === undefined || group_code === null)
            throw new Error("The parameter 'group_code' must be defined and cannot be null.");
        else
            url_ += "group_code=" + encodeURIComponent("" + group_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePerforemerCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePerforemerCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePerforemerCalendarUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать дневника работы СМП
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @return OK
     */
    generateDiaryReportUsingGET(id: number, date_from: string, date_to: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/cards/diary?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDiaryReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDiaryReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDiaryReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать жарнала вызовов в подразделении
     * @param id id
     * @param date_from date_from
     * @param date_to date_to
     * @return OK
     */
    generateJournalReportUsingGET(id: number, date_from: string, date_to: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/cards/journal?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date_from === undefined || date_from === null)
            throw new Error("The parameter 'date_from' must be defined and cannot be null.");
        else
            url_ += "date_from=" + encodeURIComponent("" + date_from) + "&"; 
        if (date_to === undefined || date_to === null)
            throw new Error("The parameter 'date_to' must be defined and cannot be null.");
        else
            url_ += "date_to=" + encodeURIComponent("" + date_to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateJournalReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateJournalReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateJournalReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать ежедневного отчета
     * @param id id
     * @param date date
     * @return OK
     */
    generateDailyReportUsingGET(id: number, date: string): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{id}/daily?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent("" + date) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDailyReportUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDailyReportUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDailyReportUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать сигнального талона
     * @param subId subId
     * @param cardId cardId
     * @return OK
     */
    generateAlarmTicketUsingGET(subId: number, cardId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{subId}/cards/{cardId}/alarm_ticket";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateAlarmTicketUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateAlarmTicketUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateAlarmTicketUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * печать протокола констатации смерти
     * @param subId subId
     * @param cardId cardId
     * @return OK
     */
    generateDeathProtocolUsingGET(subId: number, cardId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/report/subdivisions/{subId}/cards/{cardId}/death_protocol";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (cardId === undefined || cardId === null)
            throw new Error("The parameter 'cardId' must be defined.");
        url_ = url_.replace("{cardId}", encodeURIComponent("" + cardId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateDeathProtocolUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateDeathProtocolUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateDeathProtocolUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param node node
     * @return OK
     */
    readAllUsingGET_35(node: string): Observable<ReportGroup[]> {
        let url_ = this.baseUrl + "/api/report_groups/tree?";
        if (node === undefined || node === null)
            throw new Error("The parameter 'node' must be defined and cannot be null.");
        else
            url_ += "node=" + encodeURIComponent("" + node) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_35(<any>response_);
                } catch (e) {
                    return <Observable<ReportGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_35(response: HttpResponseBase): Observable<ReportGroup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportGroup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportGroup[]>(<any>null);
    }

    /**
     * readAllByGroupCodeAndSubdivisionId
     * @param group_code group_code
     * @return OK
     */
    readAllByGroupCodeAndSubdivisionIdUsingGET(group_code: string): Observable<Report[]> {
        let url_ = this.baseUrl + "/api/reports?";
        if (group_code === undefined || group_code === null)
            throw new Error("The parameter 'group_code' must be defined and cannot be null.");
        else
            url_ += "group_code=" + encodeURIComponent("" + group_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllByGroupCodeAndSubdivisionIdUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllByGroupCodeAndSubdivisionIdUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Report[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllByGroupCodeAndSubdivisionIdUsingGET(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Report.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report[]>(<any>null);
    }

    /**
     * create
     * @param form (optional) form
     * @return OK
     */
    createUsingPOST_27(form?: UploadFileForm | null | undefined): Observable<Report> {
        let url_ = this.baseUrl + "/api/reports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_27(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_27(<any>response_);
                } catch (e) {
                    return <Observable<Report>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_27(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Report.fromJS(resultData200) : new Report();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report>(<any>null);
    }

    /**
     * пустой метод, для автогенерации клиентского кода
     * @return OK
     */
    createEmptyUploadFormUsingGET(): Observable<UploadFileForm> {
        let url_ = this.baseUrl + "/api/reports/create-empty-upload-from";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmptyUploadFormUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmptyUploadFormUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<UploadFileForm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadFileForm>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEmptyUploadFormUsingGET(response: HttpResponseBase): Observable<UploadFileForm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadFileForm.fromJS(resultData200) : new UploadFileForm();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadFileForm>(<any>null);
    }

    /**
     * download
     * @param id id
     * @return OK
     */
    downloadUsingGET(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reports/download/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * print
     * @param map map
     * @return OK
     */
    printUsingPOST(map: string): Observable<string> {
        let url_ = this.baseUrl + "/api/reports/entities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(map);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrintUsingPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * getTables
     * @return OK
     */
    getTablesUsingGET(): Observable<Table[]> {
        let url_ = this.baseUrl + "/api/reports/entities/root";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTablesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTablesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Table[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Table[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTablesUsingGET(response: HttpResponseBase): Observable<Table[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Table.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Table[]>(<any>null);
    }

    /**
     * getFieldsByType
     * @param type type
     * @return OK
     */
    getFieldsByTypeUsingGET(type: number): Observable<Field[]> {
        let url_ = this.baseUrl + "/api/reports/entities/{type}/fields";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldsByTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldsByTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Field[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Field[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldsByTypeUsingGET(response: HttpResponseBase): Observable<Field[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Field.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Field[]>(<any>null);
    }

    /**
     * readReportList
     * @param code code
     * @param type type
     * @param format format
     * @return OK
     */
    readReportListUsingGET(code: string, type: number, format: number): Observable<Report[]> {
        let url_ = this.baseUrl + "/api/reports/list?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined and cannot be null.");
        else
            url_ += "format=" + encodeURIComponent("" + format) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadReportListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadReportListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Report[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadReportListUsingGET(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Report.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report[]>(<any>null);
    }

    /**
     * prepareCommon
     * @param dto dto
     * @return OK
     */
    prepareCommonUsingPOST(dto: ReportRequestDto): Observable<string> {
        let url_ = this.baseUrl + "/api/reports/prepare_card";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCommonUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCommonUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCommonUsingPOST(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * print
     * @param uid uid
     * @return OK
     */
    printUsingGET(uid: string): Observable<void> {
        let url_ = this.baseUrl + "/api/reports/print?";
        if (uid === undefined || uid === null)
            throw new Error("The parameter 'uid' must be defined and cannot be null.");
        else
            url_ += "uid=" + encodeURIComponent("" + uid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrintUsingGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_34(id: number): Observable<Report> {
        let url_ = this.baseUrl + "/api/reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_34(<any>response_);
                } catch (e) {
                    return <Observable<Report>><any>_observableThrow(e);
                }
            } else
                return <Observable<Report>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_34(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Report.fromJS(resultData200) : new Report();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Report>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE_2(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [DEPRECATED] возвращает список записей МКБ 10 по текстовому поиску в коде/названии
     * @param s s
     * @return OK
     */
    findMkbListUsingGET_1(s: string): Observable<MkbDto[]> {
        let url_ = this.baseUrl + "/api/results/mkb?";
        if (s === undefined || s === null)
            throw new Error("The parameter 's' must be defined and cannot be null.");
        else
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindMkbListUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindMkbListUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<MkbDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MkbDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindMkbListUsingGET_1(response: HttpResponseBase): Observable<MkbDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MkbDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MkbDto[]>(<any>null);
    }

    /**
     * [DEPRECATED] возвращает вложенные записи МКБ 10 по id parent-записи
     * @param id id
     * @return OK
     */
    readMkbListUsingGET_1(id: number): Observable<MkbDto[]> {
        let url_ = this.baseUrl + "/api/results/mkb/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadMkbListUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadMkbListUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<MkbDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MkbDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadMkbListUsingGET_1(response: HttpResponseBase): Observable<MkbDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MkbDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MkbDto[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_8(id: number): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/results/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_8(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_8(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_7(dto: CardResultDto): Observable<CardResultDto> {
        let url_ = this.baseUrl + "/api/results/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_7(<any>response_);
                } catch (e) {
                    return <Observable<CardResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_7(response: HttpResponseBase): Observable<CardResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardResultDto.fromJS(resultData200) : new CardResultDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardResultDto>(<any>null);
    }

    /**
     * read
     * @param coords coords
     * @return OK
     */
    readUsingPOST(coords: number[][]): Observable<RoutingDto> {
        let url_ = this.baseUrl + "/api/routing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(coords);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<RoutingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutingDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadUsingPOST(response: HttpResponseBase): Observable<RoutingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoutingDto.fromJS(resultData200) : new RoutingDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutingDto>(<any>null);
    }

    /**
     * readAll
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_36(subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<SkillDto[]> {
        let url_ = this.baseUrl + "/api/skills?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_36(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_36(response: HttpResponseBase): Observable<SkillDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SkillDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_28(dto: SkillDto): Observable<SkillDto> {
        let url_ = this.baseUrl + "/api/skills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_28(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_28(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_28(response: HttpResponseBase): Observable<SkillDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillDto.fromJS(resultData200) : new SkillDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_35(id: number): Observable<SkillDto> {
        let url_ = this.baseUrl + "/api/skills/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_35(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_35(response: HttpResponseBase): Observable<SkillDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillDto.fromJS(resultData200) : new SkillDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_29(dto: SkillDto): Observable<SkillDto> {
        let url_ = this.baseUrl + "/api/skills/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_29(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_29(response: HttpResponseBase): Observable<SkillDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkillDto.fromJS(resultData200) : new SkillDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto>(<any>null);
    }

    /**
     * readAll
     * @param parId (optional) parId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_39(parId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<SubdivisionTypeDto[]> {
        let url_ = this.baseUrl + "/api/subdivision_types?";
        if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_39(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_39(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_39(response: HttpResponseBase): Observable<SubdivisionTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_30(dto: SubdivisionDto): Observable<SubdivisionTypeDto> {
        let url_ = this.baseUrl + "/api/subdivision_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_30(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_30(response: HttpResponseBase): Observable<SubdivisionTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeDto.fromJS(resultData200) : new SubdivisionTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto>(<any>null);
    }

    /**
     * readTree
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeUsingGET_2(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivision_types/tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeUsingGET_2(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_37(id: number): Observable<SubdivisionTypeDto> {
        let url_ = this.baseUrl + "/api/subdivision_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_37(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_37(response: HttpResponseBase): Observable<SubdivisionTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeDto.fromJS(resultData200) : new SubdivisionTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_31(dto: SubdivisionDto): Observable<SubdivisionTypeDto> {
        let url_ = this.baseUrl + "/api/subdivision_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_31(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_31(response: HttpResponseBase): Observable<SubdivisionTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionTypeDto.fromJS(resultData200) : new SubdivisionTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionTypeDto>(<any>null);
    }

    /**
     * [READ] список подразделений -> все
     * @param query (optional) query
     * @param parId (optional) parId
     * @param with_par (optional) with_par
     * @param typeId (optional) typeId
     * @param type_code (optional) type_code
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_38(query?: string | null | undefined, parId?: number | null | undefined, with_par?: boolean | null | undefined, typeId?: number | null | undefined, type_code?: string | null | undefined, deleted?: boolean | null | undefined): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions?";
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        if (parId !== undefined)
            url_ += "parId=" + encodeURIComponent("" + parId) + "&"; 
        if (with_par !== undefined)
            url_ += "with_par=" + encodeURIComponent("" + with_par) + "&"; 
        if (typeId !== undefined)
            url_ += "typeId=" + encodeURIComponent("" + typeId) + "&"; 
        if (type_code !== undefined)
            url_ += "type_code=" + encodeURIComponent("" + type_code) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_38(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_38(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_38(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_29(dto: SubdivisionFlatDto): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/subdivisions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_29(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_29(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_29(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * [READ] список подразделений с родителями -> все
     * @return OK
     */
    readAllWithParentUsingGET(): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllWithParentUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllWithParentUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllWithParentUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * [READ] дерево подразделений с бригадами -> все
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeWithBrigadesUsingGET(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/brigade_tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeWithBrigadesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeWithBrigadesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeWithBrigadesUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * ????)
     * @return OK
     */
    readAllWithBrigadesUsingGET(): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/brigades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllWithBrigadesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllWithBrigadesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllWithBrigadesUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * ???? денис???)
     * @return OK
     */
    readBrigadeTreeUsingGET(): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/brigades/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadBrigadeTreeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadBrigadeTreeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadBrigadeTreeUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * [READ] список подразделений -> основные (ТЦМК/Отделения)
     * @param deleted (optional) deleted
     * @param cardId (optional) cardId
     * @param with_current (optional) with_current
     * @return OK
     */
    readAllPrimaryUsingGET_1(deleted?: boolean | null | undefined, cardId?: number | null | undefined, with_current?: boolean | null | undefined): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/primary?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&"; 
        if (with_current !== undefined)
            url_ += "with_current=" + encodeURIComponent("" + with_current) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPrimaryUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPrimaryUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPrimaryUsingGET_1(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * [READ] дерево подразделений -> основные (ТЦМК/Отделения)
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllPrimaryTreeUsingGET(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/primary/tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPrimaryTreeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPrimaryTreeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPrimaryTreeUsingGET(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * [READ] дерево подразделений -> все
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeUsingGET_1(deleted?: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/subdivisions/tree?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeUsingGET_1(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * readTreeFlat
     * @param deleted (optional) deleted
     * @return OK
     */
    readTreeFlatUsingGET(deleted?: boolean | null | undefined): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/tree/flat?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadTreeFlatUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadTreeFlatUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadTreeFlatUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * [READ] подразделение
     * @param id id
     * @return OK
     */
    readOneUsingGET_36(id: number): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_36(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_36(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_30(dto: SubdivisionFlatDto): Observable<SubdivisionFlatDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_30(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_30(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionFlatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionFlatDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_30(response: HttpResponseBase): Observable<SubdivisionFlatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubdivisionFlatDto.fromJS(resultData200) : new SubdivisionFlatDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionFlatDto>(<any>null);
    }

    /**
     * возвращает список бригад в подразделении
     * @param subId subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_37(subId: number, deleted?: boolean | null | undefined): Observable<BrigadeDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/brigades?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_37(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_37(response: HttpResponseBase): Observable<BrigadeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeDto[]>(<any>null);
    }

    /**
     * возвращает список актуальных смен бригад в подразделении
     * @param subId subId
     * @param mode (optional) mode
     * @return OK
     */
    readAllActualUsingGET(subId: number, mode?: Mode | null | undefined): Observable<BrigadeScheduleDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllActualUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllActualUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllActualUsingGET(response: HttpResponseBase): Observable<BrigadeScheduleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeScheduleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto[]>(<any>null);
    }

    /**
     * вывод бригады из смены
     * @param subId subId
     * @param brigadeScheduleId brigadeScheduleId
     * @param dto dto
     * @return OK
     */
    endBrigadeDutyUsingPUT(subId: number, brigadeScheduleId: number, dto: BrigadeDutyRequestDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules/{brigadeScheduleId}/end_duty";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndBrigadeDutyUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndBrigadeDutyUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processEndBrigadeDutyUsingPUT(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * возвращает хронологию изменений статусов бригады
     * @param subId subId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    getBrigadeScheduleCallTransferHistoryUsingGET(subId: number, brigadeScheduleId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules/{brigadeScheduleId}/protocol";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallTransferHistoryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallTransferHistoryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallTransferHistoryUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * вывод бригады в смену
     * @param subId subId
     * @param brigadeScheduleId brigadeScheduleId
     * @param dto dto
     * @return OK
     */
    startBrigadeDutyUsingPUT(subId: number, brigadeScheduleId: number, dto: BrigadeDutyRequestDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigade_schedules/{brigadeScheduleId}/start_duty";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartBrigadeDutyUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartBrigadeDutyUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processStartBrigadeDutyUsingPUT(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * возвращает список рабочих периодов всех бригад в подразделении
     * @param subId subId
     * @param from (optional) from
     * @param to (optional) to
     * @return OK
     */
    readPerformersCalendarUsingGET(subId: number, from?: string | null | undefined, to?: string | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPerformersCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPerformersCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processReadPerformersCalendarUsingGET(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * возвращает список свободных сотрудников для назначения в бригаду
     * @param subId subId
     * @param from from
     * @param group_code group_code
     * @param to to
     * @param s (optional) s
     * @param chosen_list (optional) список id сотрудников, добавленных в бригаду
     * @return OK
     */
    readAllAvailablePerformersUsingGET(subId: number, from: string, group_code: Group_code2, to: string, s?: string | null | undefined, chosen_list?: number[] | null | undefined): Observable<PerformerBrigScheduleAvailableDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/performers/available?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (group_code === undefined || group_code === null)
            throw new Error("The parameter 'group_code' must be defined and cannot be null.");
        else
            url_ += "group_code=" + encodeURIComponent("" + group_code) + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        if (chosen_list !== undefined)
            chosen_list && chosen_list.forEach(item => { url_ += "chosen_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllAvailablePerformersUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllAvailablePerformersUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleAvailableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleAvailableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllAvailablePerformersUsingGET(response: HttpResponseBase): Observable<PerformerBrigScheduleAvailableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerBrigScheduleAvailableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleAvailableDto[]>(<any>null);
    }

    /**
     * возвращает список свободных транспортных средств для назначения в бригаду
     * @param subId subId
     * @param from from
     * @param to to
     * @param s (optional) s
     * @param excludeId_list (optional) список id авто, добавленных в бригаду
     * @return OK
     */
    readAllAvailableTranspotsUsingGET(subId: number, from: string, to: string, s?: string | null | undefined, excludeId_list?: number[] | null | undefined): Observable<TransportBrigScheduleAvailableDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/transport/available?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        if (excludeId_list !== undefined)
            excludeId_list && excludeId_list.forEach(item => { url_ += "excludeId_list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllAvailableTranspotsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllAvailableTranspotsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportBrigScheduleAvailableDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBrigScheduleAvailableDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllAvailableTranspotsUsingGET(response: HttpResponseBase): Observable<TransportBrigScheduleAvailableDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportBrigScheduleAvailableDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBrigScheduleAvailableDto[]>(<any>null);
    }

    /**
     * создание рабочего периода (смены) для бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param dto dto
     * @return OK
     */
    createBrigadeScheduleUsingPOST(subId: number, brigadeId: number, dto: BrigadeScheduleCreateDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrigadeScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrigadeScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBrigadeScheduleUsingPOST(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * возвращает рабочий период бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @return OK
     */
    getBrigadeScheduleUsingGET_2(subId: number, brigadeId: number, scheduleId: number): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleUsingGET_2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleUsingGET_2(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleUsingGET_2(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * редактирование рабочего периода для бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param dto dto
     * @return OK
     */
    updateBrigadeScheduleUsingPUT(subId: number, brigadeId: number, scheduleId: number, dto: BrigadeScheduleUpdateDto): Observable<BrigadeScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeScheduleUsingPUT(response: HttpResponseBase): Observable<BrigadeScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BrigadeScheduleDto.fromJS(resultData200) : new BrigadeScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeScheduleDto>(<any>null);
    }

    /**
     * удаление рабочего периода бригады
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @return OK
     */
    updateBrigadeScheduleUsingDELETE(subId: number, brigadeId: number, scheduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * возвращает список вызовов по наряду
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @return OK
     */
    getBrigadeScheduleCallsUsingGET(subId: number, brigadeId: number, scheduleId: number): Observable<BrigadeCallDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/calls";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeCallDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeCallDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallsUsingGET(response: HttpResponseBase): Observable<BrigadeCallDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeCallDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeCallDto[]>(<any>null);
    }

    /**
     * создание рабочего периода сотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param dto dto
     * @return OK
     */
    createPerformerBrigScheduleUsingPOST(subId: number, brigadeId: number, scheduleId: number, dto: PerformerBrigScheduleCreateDto): Observable<PerformerBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerformerBrigScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerformerBrigScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerformerBrigScheduleUsingPOST(response: HttpResponseBase): Observable<PerformerBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBrigScheduleDto.fromJS(resultData200) : new PerformerBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleDto>(<any>null);
    }

    /**
     * возвращает рабочий период cотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param performerScheduleId performerScheduleId
     * @return OK
     */
    getBrigadeScheduleUsingGET_1(subId: number, brigadeId: number, scheduleId: number, performerScheduleId: number): Observable<PerformerBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers/{performerScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (performerScheduleId === undefined || performerScheduleId === null)
            throw new Error("The parameter 'performerScheduleId' must be defined.");
        url_ = url_.replace("{performerScheduleId}", encodeURIComponent("" + performerScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleUsingGET_1(response: HttpResponseBase): Observable<PerformerBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBrigScheduleDto.fromJS(resultData200) : new PerformerBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleDto>(<any>null);
    }

    /**
     * редактирование рабочего периода сотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param performerScheduleId performerScheduleId
     * @param dto dto
     * @return OK
     */
    updatePerformerBrigScheduleUsingPUT(subId: number, brigadeId: number, scheduleId: number, performerScheduleId: number, dto: PerformerBrigScheduleUpdateDto): Observable<PerformerBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers/{performerScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (performerScheduleId === undefined || performerScheduleId === null)
            throw new Error("The parameter 'performerScheduleId' must be defined.");
        url_ = url_.replace("{performerScheduleId}", encodeURIComponent("" + performerScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformerBrigScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformerBrigScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformerBrigScheduleUsingPUT(response: HttpResponseBase): Observable<PerformerBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerBrigScheduleDto.fromJS(resultData200) : new PerformerBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerBrigScheduleDto>(<any>null);
    }

    /**
     * удаление рабочего периода сотрудника в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param performerScheduleId performerScheduleId
     * @return OK
     */
    deletePerformerBrigadeScheduleUsingDELETE(subId: number, brigadeId: number, scheduleId: number, performerScheduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/performers/{performerScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (performerScheduleId === undefined || performerScheduleId === null)
            throw new Error("The parameter 'performerScheduleId' must be defined.");
        url_ = url_.replace("{performerScheduleId}", encodeURIComponent("" + performerScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformerBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformerBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformerBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * создание рабочего периода транспорта в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param dto dto
     * @return OK
     */
    createCarBrigScheduleUsingPOST(subId: number, brigadeId: number, scheduleId: number, dto: TransportBrigScheduleCreateDto): Observable<TransportBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/transport";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCarBrigScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCarBrigScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<TransportBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCarBrigScheduleUsingPOST(response: HttpResponseBase): Observable<TransportBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBrigScheduleDto.fromJS(resultData200) : new TransportBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBrigScheduleDto>(<any>null);
    }

    /**
     * редактирование рабочего периода транспорта в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param transportScheduleId transportScheduleId
     * @param dto dto
     * @return OK
     */
    updateCarBrigScheduleUsingPUT(subId: number, brigadeId: number, scheduleId: number, transportScheduleId: number, dto: TransportBrigScheduleUpdateDto): Observable<TransportBrigScheduleDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/transport/{transportScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (transportScheduleId === undefined || transportScheduleId === null)
            throw new Error("The parameter 'transportScheduleId' must be defined.");
        url_ = url_.replace("{transportScheduleId}", encodeURIComponent("" + transportScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCarBrigScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCarBrigScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<TransportBrigScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportBrigScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCarBrigScheduleUsingPUT(response: HttpResponseBase): Observable<TransportBrigScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportBrigScheduleDto.fromJS(resultData200) : new TransportBrigScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportBrigScheduleDto>(<any>null);
    }

    /**
     * удаление рабочего периода транспорта в бригаде
     * @param subId subId
     * @param brigadeId brigadeId
     * @param scheduleId scheduleId
     * @param transportScheduleId transportScheduleId
     * @return OK
     */
    deleteCarBrigadeScheduleUsingDELETE(subId: number, brigadeId: number, scheduleId: number, transportScheduleId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/brigades/{brigadeId}/schedules/{scheduleId}/transport/{transportScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (brigadeId === undefined || brigadeId === null)
            throw new Error("The parameter 'brigadeId' must be defined.");
        url_ = url_.replace("{brigadeId}", encodeURIComponent("" + brigadeId)); 
        if (scheduleId === undefined || scheduleId === null)
            throw new Error("The parameter 'scheduleId' must be defined.");
        url_ = url_.replace("{scheduleId}", encodeURIComponent("" + scheduleId)); 
        if (transportScheduleId === undefined || transportScheduleId === null)
            throw new Error("The parameter 'transportScheduleId' must be defined.");
        url_ = url_.replace("{transportScheduleId}", encodeURIComponent("" + transportScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCarBrigadeScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCarBrigadeScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCarBrigadeScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * возвращает список рабочих периодов всех сотрудников в подразделении
     * @param subId (optional) id текущего подразделения
     * @param from (optional) дата начала 'yyyy-MM-ddTHH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-ddTHH:mm:ss'
     * @param subdivisionId (optional) id подразделения для календаря
     * @return OK
     */
    readPerformersCalendarUsingGET_1(subId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined, subdivisionId?: number | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPerformersCalendarUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPerformersCalendarUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processReadPerformersCalendarUsingGET_1(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * возвращает шаблон для пролонгации календаря в подразделении
     * @param subId (optional) id текущего подразделения
     * @param from (optional) дата начала 'yyyy-MM-dd'T'HH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-dd'T'HH:mm:ss'
     * @return OK
     */
    generatePerformerScheduleCalendarUsingGET(subId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/generate?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePerformerScheduleCalendarUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePerformerScheduleCalendarUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePerformerScheduleCalendarUsingGET(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * формирует календрарь в подразделении по шаблону
     * @param map map
     * @param subId (optional) id текущего подразделения
     * @return OK
     */
    createPerformersCalendarUsingPOST(map: Container, subId?: number | null | undefined): Observable<Container> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/generate";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(map);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerformersCalendarUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerformersCalendarUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Container>><any>_observableThrow(e);
                }
            } else
                return <Observable<Container>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerformersCalendarUsingPOST(response: HttpResponseBase): Observable<Container> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Container.fromJS(resultData200) : new Container();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Container>(<any>null);
    }

    /**
     * протокол календаря в подразделении
     * @param subId (optional) id текущего подразделения
     * @param subdivisionId (optional) id подразделения для календаря
     * @param from (optional) дата начала 'yyyy-MM-ddTHH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-ddTHH:mm:ss'
     * @return OK
     */
    readProtocolForSubdivisionUsingGET(subId?: number | null | undefined, subdivisionId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/protocol?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolForSubdivisionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolForSubdivisionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolForSubdivisionUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * [READ] список типов смены в календаре
     * @param subId subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllScheduleTypeUsingGET(subId: number, deleted?: boolean | null | undefined): Observable<ScheduleType[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllScheduleTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllScheduleTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllScheduleTypeUsingGET(response: HttpResponseBase): Observable<ScheduleType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ScheduleType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType[]>(<any>null);
    }

    /**
     * [CREATE] создание нового типа смены в календаре
     * @param subId subId
     * @param scheduleType scheduleType
     * @return OK
     */
    createScheduleTypeUsingPOST(subId: number, scheduleType: ScheduleType): Observable<ScheduleType> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateScheduleTypeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateScheduleTypeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType>><any>_observableThrow(response_);
        }));
    }

    protected processCreateScheduleTypeUsingPOST(response: HttpResponseBase): Observable<ScheduleType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleType.fromJS(resultData200) : new ScheduleType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType>(<any>null);
    }

    /**
     * [READ] тип смены в календаре
     * @param subId subId
     * @param id id
     * @return OK
     */
    readScheduleTypeUsingGET(subId: number, id: number): Observable<ScheduleType> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadScheduleTypeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadScheduleTypeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType>><any>_observableThrow(response_);
        }));
    }

    protected processReadScheduleTypeUsingGET(response: HttpResponseBase): Observable<ScheduleType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleType.fromJS(resultData200) : new ScheduleType();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType>(<any>null);
    }

    /**
     * [UPDATE] изменение типа смены в календаре
     * @param subId subId
     * @param id id
     * @param scheduleType scheduleType
     * @return OK
     */
    updateScheduleTypeUsingPUT(subId: number, id: number, scheduleType: ScheduleType): Observable<ScheduleType> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheduleTypeUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheduleTypeUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheduleTypeUsingPUT(response: HttpResponseBase): Observable<ScheduleType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScheduleType.fromJS(resultData200) : new ScheduleType();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleType>(<any>null);
    }

    /**
     * [READ] расчет периода смены в календаре
     * @param subId subId
     * @param id id
     * @param mode mode
     * @param from from
     * @param to (optional) to
     * @return OK
     */
    calculateScheduleUsingGET(subId: number, id: number, mode: Mode2, from: string, to?: string | null | undefined): Observable<Period> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/schedule_types/{id}/calculate?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (mode === undefined || mode === null)
            throw new Error("The parameter 'mode' must be defined and cannot be null.");
        else
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Period>><any>_observableThrow(e);
                }
            } else
                return <Observable<Period>><any>_observableThrow(response_);
        }));
    }

    protected processCalculateScheduleUsingGET(response: HttpResponseBase): Observable<Period> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Period.fromJS(resultData200) : new Period();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Period>(<any>null);
    }

    /**
     * протокол календаря для сотрудника
     * @param subId (optional) id текущего подразделения
     * @param performerId (optional) id сотрудника в календаре
     * @param from (optional) дата начала 'yyyy-MM-ddTHH:mm:ss'
     * @param to (optional) дата окончания 'yyyy-MM-ddTHH:mm:ss'
     * @return OK
     */
    readProtocolForPerformerUsingGET(subId?: number | null | undefined, performerId?: number | null | undefined, from?: string | null | undefined, to?: string | null | undefined): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/protocol?";
        if (subId !== null && subId !== undefined)
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        else
            url_ = url_.replace("/{subId}", "");
        if (performerId !== null && performerId !== undefined)
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        else
            url_ = url_.replace("/{performerId}", "");
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolForPerformerUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolForPerformerUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolForPerformerUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * возвращает список рабочих периодов сотрудника по id
     * @param subId subId
     * @param performerId performerId
     * @param from (optional) from
     * @param to (optional) to
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllSchedulesUsingGET(subId: number, performerId: number, from?: string | null | undefined, to?: string | null | undefined, deleted?: boolean | null | undefined): Observable<PerformerScheduleDto2[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllSchedulesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllSchedulesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllSchedulesUsingGET(response: HttpResponseBase): Observable<PerformerScheduleDto2[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerScheduleDto2.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerScheduleDto2[]>(<any>null);
    }

    /**
     * создание рабочего периода для сотрудника
     * @param subId subId
     * @param performerId performerId
     * @param dto dto
     * @return OK
     */
    createPerformerScheduleUsingPOST(subId: number, performerId: number, dto: PerformerScheduleDto2): Observable<PerformerScheduleDto2[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerformerScheduleUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerformerScheduleUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerScheduleDto2[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerformerScheduleUsingPOST(response: HttpResponseBase): Observable<PerformerScheduleDto2[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PerformerScheduleDto2.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerScheduleDto2[]>(<any>null);
    }

    /**
     * обновление сведений о конкретоном рабочем периоде сотрудника
     * @param subId subId
     * @param performerId performerId
     * @param dto dto
     * @return OK
     */
    updatePerformersScheduleUsingPUT(subId: number, performerId: number, dto: PerformerScheduleDto2): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerformersScheduleUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerformersScheduleUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerformersScheduleUsingPUT(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * возвращает рабочий период сотрудника по id
     * @param subId subId
     * @param performerId performerId
     * @param id id
     * @return OK
     */
    readOnePerformerScheduleUsingGET(subId: number, performerId: number, id: number): Observable<PerformerScheduleDto2> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOnePerformerScheduleUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOnePerformerScheduleUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<PerformerScheduleDto2>><any>_observableThrow(e);
                }
            } else
                return <Observable<PerformerScheduleDto2>><any>_observableThrow(response_);
        }));
    }

    protected processReadOnePerformerScheduleUsingGET(response: HttpResponseBase): Observable<PerformerScheduleDto2> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PerformerScheduleDto2.fromJS(resultData200) : new PerformerScheduleDto2();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerformerScheduleDto2>(<any>null);
    }

    /**
     * удаление рабочего периода сотрудника
     * @param subId subId
     * @param performerId performerId
     * @param id id
     * @return OK
     */
    deletePerformersScheduleUsingDELETE(subId: number, performerId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calendars/performers/{performerId}/schedules/{id}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (performerId === undefined || performerId === null)
            throw new Error("The parameter 'performerId' must be defined.");
        url_ = url_.replace("{performerId}", encodeURIComponent("" + performerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformersScheduleUsingDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformersScheduleUsingDELETE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformersScheduleUsingDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы
     * @param subId subId
     * @param mode (optional) mode
     * @return OK
     */
    readAllUsingGET_6(subId: number, mode?: Mode3 | null | undefined): Observable<CallGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_6(<any>response_);
                } catch (e) {
                    return <Observable<CallGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_6(response: HttpResponseBase): Observable<CallGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGridDto[]>(<any>null);
    }

    /**
     * [CREATE] создание нового вызова [возвращает callId]
     * @param subId subId
     * @param dto dto
     * @return OK
     */
    createUsingPOST_5(subId: number, dto: CallDtoFLAT): Observable<LongDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_5(<any>response_);
                } catch (e) {
                    return <Observable<LongDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LongDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_5(response: HttpResponseBase): Observable<LongDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LongDto.fromJS(resultData200) : new LongDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LongDto>(<any>null);
    }

    /**
     * [READ] получение данных для создания нового вызова
     * @param subId subId
     * @param phone (optional) phone
     * @param audio_file_name (optional) audio_file_name
     * @return OK
     */
    prepareCallUsingGET(subId: number, phone?: string | null | undefined, audio_file_name?: string | null | undefined): Observable<CallDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/create?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&"; 
        if (audio_file_name !== undefined)
            url_ += "audio_file_name=" + encodeURIComponent("" + audio_file_name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCallUsingGET(response: HttpResponseBase): Observable<CallDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDto.fromJS(resultData200) : new CallDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDto>(<any>null);
    }

    /**
     * [CREATE] поиск первичного вызова
     * @param subId subId
     * @param dto dto
     * @return OK
     */
    findSimilarCallsUsingPOST(subId: number, dto: CallSimilarRequestDto): Observable<CallShortDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/primary/find";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindSimilarCallsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindSimilarCallsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallShortDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallShortDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindSimilarCallsUsingPOST(response: HttpResponseBase): Observable<CallShortDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallShortDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallShortDto[]>(<any>null);
    }

    /**
     * [READ] возвращает список вызовов по заданным параметрам поиска
     * @param subId subId
     * @param subdivisionId (optional) 
     * @param dateFrom (optional) 
     * @param dateTo (optional) 
     * @param number (optional) 
     * @param declarantName (optional) 
     * @param declarantPhone (optional) 
     * @param patientName (optional) 
     * @param patientSex (optional) 
     * @param patientAgeYears (optional) 
     * @param patientAgeMonths (optional) 
     * @param patientAgeDays (optional) 
     * @param aoName (optional) 
     * @param districtId (optional) 
     * @param performer (optional) 
     * @param callTypeId (optional) 
     * @param declarantTypeId (optional) 
     * @param phone (optional) 
     * @param callPlaceTypeId (optional) 
     * @param reasonTypeId (optional) 
     * @return OK
     */
    readAllUsingPOST(subId: number, subdivisionId?: number | null | undefined, dateFrom?: Date | null | undefined, dateTo?: Date | null | undefined, number?: string | null | undefined, declarantName?: string | null | undefined, declarantPhone?: string | null | undefined, patientName?: string | null | undefined, patientSex?: number | null | undefined, patientAgeYears?: number | null | undefined, patientAgeMonths?: number | null | undefined, patientAgeDays?: number | null | undefined, aoName?: string | null | undefined, districtId?: number | null | undefined, performer?: string | null | undefined, callTypeId?: number | null | undefined, declarantTypeId?: number | null | undefined, phone?: string | null | undefined, callPlaceTypeId?: number | null | undefined, reasonTypeId?: number | null | undefined): Observable<CallGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/request?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (subdivisionId !== undefined)
            url_ += "subdivisionId=" + encodeURIComponent("" + subdivisionId) + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&"; 
        if (number !== undefined)
            url_ += "number=" + encodeURIComponent("" + number) + "&"; 
        if (declarantName !== undefined)
            url_ += "declarantName=" + encodeURIComponent("" + declarantName) + "&"; 
        if (declarantPhone !== undefined)
            url_ += "declarantPhone=" + encodeURIComponent("" + declarantPhone) + "&"; 
        if (patientName !== undefined)
            url_ += "patientName=" + encodeURIComponent("" + patientName) + "&"; 
        if (patientSex !== undefined)
            url_ += "patientSex=" + encodeURIComponent("" + patientSex) + "&"; 
        if (patientAgeYears !== undefined)
            url_ += "patientAgeYears=" + encodeURIComponent("" + patientAgeYears) + "&"; 
        if (patientAgeMonths !== undefined)
            url_ += "patientAgeMonths=" + encodeURIComponent("" + patientAgeMonths) + "&"; 
        if (patientAgeDays !== undefined)
            url_ += "patientAgeDays=" + encodeURIComponent("" + patientAgeDays) + "&"; 
        if (aoName !== undefined)
            url_ += "aoName=" + encodeURIComponent("" + aoName) + "&"; 
        if (districtId !== undefined)
            url_ += "districtId=" + encodeURIComponent("" + districtId) + "&"; 
        if (performer !== undefined)
            url_ += "performer=" + encodeURIComponent("" + performer) + "&"; 
        if (callTypeId !== undefined)
            url_ += "callTypeId=" + encodeURIComponent("" + callTypeId) + "&"; 
        if (declarantTypeId !== undefined)
            url_ += "declarantTypeId=" + encodeURIComponent("" + declarantTypeId) + "&"; 
        if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&"; 
        if (callPlaceTypeId !== undefined)
            url_ += "callPlaceTypeId=" + encodeURIComponent("" + callPlaceTypeId) + "&"; 
        if (reasonTypeId !== undefined)
            url_ += "reasonTypeId=" + encodeURIComponent("" + reasonTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingPOST(response: HttpResponseBase): Observable<CallGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGridDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы -> входящие
     * @param subId subId
     * @return OK
     */
    getReceivedListUsingGET(subId: number): Observable<CallTransferDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/transfer";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallTransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallTransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReceivedListUsingGET(response: HttpResponseBase): Observable<CallTransferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallTransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallTransferDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readOneUsingGET_5(subId: number, callId: number): Observable<CallDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_5(<any>response_);
                } catch (e) {
                    return <Observable<CallDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_5(response: HttpResponseBase): Observable<CallDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDto.fromJS(resultData200) : new CallDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> адрес
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readSideOneAddressPartUsingGET(subId: number, callId: number): Observable<FiasAddressDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/address";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneAddressPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneAddressPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneAddressPartUsingGET(response: HttpResponseBase): Observable<FiasAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiasAddressDto.fromJS(resultData200) : new FiasAddressDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> адрес
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateAddressPartUsingPUT(subId: number, callId: number, dto: CallFiasAddressDto): Observable<FiasAddressDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/address";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAddressPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAddressPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<FiasAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiasAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAddressPartUsingPUT(response: HttpResponseBase): Observable<FiasAddressDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiasAddressDto.fromJS(resultData200) : new FiasAddressDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiasAddressDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> адрес -> локация
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateLocationPartUsingPUT(subId: number, callId: number, dto: CallLocationPartDto): Observable<CallLocationPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/address/location";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLocationPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLocationPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CallLocationPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallLocationPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLocationPartUsingPUT(response: HttpResponseBase): Observable<CallLocationPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallLocationPartDto.fromJS(resultData200) : new CallLocationPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallLocationPartDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> все назначенные смены бригад
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    getBrigadesFromCallUsingGET(subId: number, callId: number): Observable<CallBrigadePartDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadesFromCallUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadesFromCallUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallBrigadePartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallBrigadePartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadesFromCallUsingGET(response: HttpResponseBase): Observable<CallBrigadePartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallBrigadePartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBrigadePartDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> назначение бригады
     * @param subId subId
     * @param callId callId
     * @param dtoList dtoList
     * @return OK
     */
    setBrigadeUsingPOST(subId: number, callId: number, dtoList: BrigadeAppointRequestDto[]): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dtoList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetBrigadeUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetBrigadeUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetBrigadeUsingPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> конкретная назначенная смена бригады
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    getBrigadeScheduleCallTransferUsingGET(subId: number, callId: number, brigadeScheduleId: number): Observable<CallBrigadePartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallTransferUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallTransferUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallBrigadePartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallBrigadePartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallTransferUsingGET(response: HttpResponseBase): Observable<CallBrigadePartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBrigadePartDto.fromJS(resultData200) : new CallBrigadePartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallBrigadePartDto>(<any>null);
    }

    /**
     * возвращает список карт вызова в бригаде
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @param deleted (optional) deleted
     * @return OK
     */
    readCardsByCallAndBrigadeUsingGET(subId: number, callId: number, brigadeScheduleId: number, deleted?: boolean | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/cards?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardsByCallAndBrigadeUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardsByCallAndBrigadeUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardsByCallAndBrigadeUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> бригада -> Форма 110/у
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    createCardUsingPOST(callId: number, brigadeScheduleId: number): Observable<CardDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/cards";
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCardUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCardUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCardUsingPOST(response: HttpResponseBase): Observable<CardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CardDto.fromJS(resultData200) : new CardDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> смена бригады -> история сообщений
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    getBrigadeScheduleCallTransferHistoryUsingGET_1(subId: number, callId: number, brigadeScheduleId: number): Observable<MessageEventDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/history";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrigadeScheduleCallTransferHistoryUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrigadeScheduleCallTransferHistoryUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<MessageEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrigadeScheduleCallTransferHistoryUsingGET_1(response: HttpResponseBase): Observable<MessageEventDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageEventDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> смена бригады -> доступные сообщения
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @return OK
     */
    readAvailableEventsUsingGET(subId: number, callId: number, brigadeScheduleId: number): Observable<MessageEventDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/messages";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAvailableEventsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAvailableEventsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<MessageEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAvailableEventsUsingGET(response: HttpResponseBase): Observable<MessageEventDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageEventDto[]>(<any>null);
    }

    /**
     * [CREATE] создание нового сообщения бригады
     * @param subId subId
     * @param callId callId
     * @param brigadeScheduleId brigadeScheduleId
     * @param dtoList dtoList
     * @return OK
     */
    createNewMessageUsingPOST(subId: number, callId: number, brigadeScheduleId: number, dtoList: MessageEventDto[]): Observable<MessageEventDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/brigade_schedules/{brigadeScheduleId}/messages";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (brigadeScheduleId === undefined || brigadeScheduleId === null)
            throw new Error("The parameter 'brigadeScheduleId' must be defined.");
        url_ = url_.replace("{brigadeScheduleId}", encodeURIComponent("" + brigadeScheduleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dtoList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNewMessageUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNewMessageUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<MessageEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNewMessageUsingPOST(response: HttpResponseBase): Observable<MessageEventDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MessageEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageEventDto[]>(<any>null);
    }

    /**
     * возвращает список карт вызова в вызове
     * @param subId subId
     * @param callId callId
     * @param deleted (optional) deleted
     * @return OK
     */
    readCardsByCallAndSubdivisionUsingGET(subId: number, callId: number, deleted?: boolean | null | undefined): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/cards?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadCardsByCallAndSubdivisionUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadCardsByCallAndSubdivisionUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadCardsByCallAndSubdivisionUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> заявитель
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readSideOneDeclarantPartUsingGET(subId: number, callId: number): Observable<CallDeclarantPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/declarant";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneDeclarantPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneDeclarantPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallDeclarantPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDeclarantPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneDeclarantPartUsingGET(response: HttpResponseBase): Observable<CallDeclarantPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDeclarantPartDto.fromJS(resultData200) : new CallDeclarantPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDeclarantPartDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> декларант
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateDeclarantPartUsingPUT(subId: number, callId: number, dto: CallDeclarantPartDto): Observable<CallDeclarantPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/declarant";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeclarantPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeclarantPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CallDeclarantPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallDeclarantPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeclarantPartUsingPUT(response: HttpResponseBase): Observable<CallDeclarantPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallDeclarantPartDto.fromJS(resultData200) : new CallDeclarantPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallDeclarantPartDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> поиск бригад
     * @param subId subId
     * @param callId callId
     * @param radius (optional) radius
     * @param routing (optional) routing
     * @return OK
     */
    findBrigadesUsingGET(subId: number, callId: number, radius?: number | null | undefined, routing?: boolean | null | undefined): Observable<BrigadeFindListDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/find?";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (radius !== undefined)
            url_ += "radius=" + encodeURIComponent("" + radius) + "&"; 
        if (routing !== undefined)
            url_ += "routing=" + encodeURIComponent("" + routing) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindBrigadesUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindBrigadesUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<BrigadeFindListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrigadeFindListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindBrigadesUsingGET(response: HttpResponseBase): Observable<BrigadeFindListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrigadeFindListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrigadeFindListDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> основные сведения
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readSideOneGeneralPartUsingGET(subId: number, callId: number): Observable<CallGeneralPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/general";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadSideOneGeneralPartUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadSideOneGeneralPartUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallGeneralPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGeneralPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadSideOneGeneralPartUsingGET(response: HttpResponseBase): Observable<CallGeneralPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallGeneralPartDto.fromJS(resultData200) : new CallGeneralPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGeneralPartDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> основные сведения
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updateGeneralPartUsingPUT(subId: number, callId: number, dto: CallGeneralPartDto): Observable<CallGeneralPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/general";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralPartUsingPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralPartUsingPUT(<any>response_);
                } catch (e) {
                    return <Observable<CallGeneralPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallGeneralPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGeneralPartUsingPUT(response: HttpResponseBase): Observable<CallGeneralPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallGeneralPartDto.fromJS(resultData200) : new CallGeneralPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallGeneralPartDto>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> все пациенты
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readAllPatientsUsingGET(subId: number, callId: number): Observable<CallPatientPartDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPatientsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPatientsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPatientsUsingGET(response: HttpResponseBase): Observable<CallPatientPartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallPatientPartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> больные
     * @param subId subId
     * @param callId callId
     * @param dto dto
     * @return OK
     */
    updatePatientsUsingPOST(subId: number, callId: number, dto: CallPatientPartDto[]): Observable<CallPatientPartDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatientsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatientsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatientsUsingPOST(response: HttpResponseBase): Observable<CallPatientPartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallPatientPartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы -> поиск карт по данным пациента
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    getAllChronicCardsUsingGET(subId: number, callId: number): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/chronic/cards";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChronicCardsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChronicCardsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChronicCardsUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * [READ] подразделение -> вызов -> пациент
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @return OK
     */
    readOnePatientUsingGET(subId: number, callId: number, patientId: number): Observable<CallPatientPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOnePatientUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOnePatientUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOnePatientUsingGET(response: HttpResponseBase): Observable<CallPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallPatientPartDto.fromJS(resultData200) : new CallPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto>(<any>null);
    }

    /**
     * [UPDATE] подразделение -> вызов -> пациент
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_5(subId: number, callId: number, patientId: number, dto: CallPatientPartDto): Observable<CallPatientPartDto> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_5(<any>response_);
                } catch (e) {
                    return <Observable<CallPatientPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallPatientPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_5(response: HttpResponseBase): Observable<CallPatientPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallPatientPartDto.fromJS(resultData200) : new CallPatientPartDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallPatientPartDto>(<any>null);
    }

    /**
     * [DELETE] подразделение -> вызов -> пациент
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @return OK
     */
    deletePatientUsingDELETE_1(subId: number, callId: number, patientId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePatientUsingDELETE_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePatientUsingDELETE_1(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePatientUsingDELETE_1(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение -> вызовы -> пациент -> поиск карт по данным пациента
     * @param subId subId
     * @param callId callId
     * @param patientId patientId
     * @return OK
     */
    getChronicCardUsingGET(subId: number, callId: number, patientId: number): Observable<CardGridDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/patients/{patientId}/chronic/cards";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        if (patientId === undefined || patientId === null)
            throw new Error("The parameter 'patientId' must be defined.");
        url_ = url_.replace("{patientId}", encodeURIComponent("" + patientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChronicCardUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChronicCardUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CardGridDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardGridDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChronicCardUsingGET(response: HttpResponseBase): Observable<CardGridDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CardGridDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardGridDto[]>(<any>null);
    }

    /**
     * вызов -> протокол
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readProtocolUsingGET(subId: number, callId: number): Observable<LogDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/protocol";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadProtocolUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadProtocolUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<LogDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LogDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadProtocolUsingGET(response: HttpResponseBase): Observable<LogDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LogDto[]>(<any>null);
    }

    /**
     * [READ] подразделение ->  вызов -> передача -> список подразделений-получателей
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    getSendListUsingGET(subId: number, callId: number): Observable<CallTransferDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/transfer";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSendListUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSendListUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<CallTransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CallTransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSendListUsingGET(response: HttpResponseBase): Observable<CallTransferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CallTransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CallTransferDto[]>(<any>null);
    }

    /**
     * [CREATE] подразделение -> вызов -> передача
     * @param subId subId
     * @param callId callId
     * @param request request
     * @return OK
     */
    getSubdivisionsForCallTransferUsingPOST(subId: number, callId: number, request: TransferAddresseeDto[]): Observable<void> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/transfer";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubdivisionsForCallTransferUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubdivisionsForCallTransferUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubdivisionsForCallTransferUsingPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * [READ] подразделение ->  вызов -> передача -> список доступных подразделений
     * @param subId subId
     * @param callId callId
     * @return OK
     */
    readAllPrimaryUsingGET(subId: number, callId: number): Observable<SubdivisionDto[]> {
        let url_ = this.baseUrl + "/api/subdivisions/{subId}/calls/{callId}/transfer/available";
        if (subId === undefined || subId === null)
            throw new Error("The parameter 'subId' must be defined.");
        url_ = url_.replace("{subId}", encodeURIComponent("" + subId)); 
        if (callId === undefined || callId === null)
            throw new Error("The parameter 'callId' must be defined.");
        url_ = url_.replace("{callId}", encodeURIComponent("" + callId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllPrimaryUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllPrimaryUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<SubdivisionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubdivisionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllPrimaryUsingGET(response: HttpResponseBase): Observable<SubdivisionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubdivisionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubdivisionDto[]>(<any>null);
    }

    /**
     * readAll
     * @param result_id (optional) result_id
     * @param is_local (optional) is_local
     * @return OK
     */
    readAllUsingGET_40(result_id?: number | null | undefined, is_local?: boolean | null | undefined): Observable<TherapyDto[]> {
        let url_ = this.baseUrl + "/api/therapies?";
        if (result_id !== undefined)
            url_ += "result_id=" + encodeURIComponent("" + result_id) + "&"; 
        if (is_local !== undefined)
            url_ += "is_local=" + encodeURIComponent("" + is_local) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_40(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_40(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_40(response: HttpResponseBase): Observable<TherapyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TherapyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_31(dto: TherapyDto): Observable<TherapyDto> {
        let url_ = this.baseUrl + "/api/therapies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_31(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_31(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_31(response: HttpResponseBase): Observable<TherapyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyDto.fromJS(resultData200) : new TherapyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_38(id: number): Observable<TherapyDto> {
        let url_ = this.baseUrl + "/api/therapies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_38(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_38(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_38(response: HttpResponseBase): Observable<TherapyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyDto.fromJS(resultData200) : new TherapyDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto>(<any>null);
    }

    /**
     * update
     * @param id id
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_32(id: number, dto: TherapyDto): Observable<TherapyDto> {
        let url_ = this.baseUrl + "/api/therapies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_32(<any>response_);
                } catch (e) {
                    return <Observable<TherapyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_32(response: HttpResponseBase): Observable<TherapyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyDto.fromJS(resultData200) : new TherapyDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyDto>(<any>null);
    }

    /**
     * delete
     * @param id id
     * @return OK
     */
    deleteUsingDELETE_3(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/therapies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * readAll
     * @param template_id (optional) template_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_42(template_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<TherapyTemplateItemDto[]> {
        let url_ = this.baseUrl + "/api/therapy_template_items?";
        if (template_id !== undefined)
            url_ += "template_id=" + encodeURIComponent("" + template_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_42(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_42(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_42(response: HttpResponseBase): Observable<TherapyTemplateItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TherapyTemplateItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_33(dto: TherapyTemplateItemDto): Observable<TherapyTemplateItemDto> {
        let url_ = this.baseUrl + "/api/therapy_template_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_33(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_33(response: HttpResponseBase): Observable<TherapyTemplateItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemDto.fromJS(resultData200) : new TherapyTemplateItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_40(id: number): Observable<TherapyTemplateItemDto> {
        let url_ = this.baseUrl + "/api/therapy_template_items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_40(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_40(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_40(response: HttpResponseBase): Observable<TherapyTemplateItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemDto.fromJS(resultData200) : new TherapyTemplateItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_34(dto: TherapyTemplateItemDto): Observable<TherapyTemplateItemDto> {
        let url_ = this.baseUrl + "/api/therapy_template_items/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_34(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_34(response: HttpResponseBase): Observable<TherapyTemplateItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateItemDto.fromJS(resultData200) : new TherapyTemplateItemDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateItemDto>(<any>null);
    }

    /**
     * readAll
     * @param sub_id (optional) sub_id
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_41(sub_id?: number | null | undefined, deleted?: boolean | null | undefined): Observable<TherapyTemplateDto[]> {
        let url_ = this.baseUrl + "/api/therapy_templates?";
        if (sub_id !== undefined)
            url_ += "sub_id=" + encodeURIComponent("" + sub_id) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_41(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_41(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_41(response: HttpResponseBase): Observable<TherapyTemplateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TherapyTemplateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto[]>(<any>null);
    }

    /**
     * create
     * @param dto dto
     * @return OK
     */
    createUsingPOST_32(dto: TherapyTemplateDto): Observable<TherapyTemplateDto> {
        let url_ = this.baseUrl + "/api/therapy_templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_32(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_32(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_32(response: HttpResponseBase): Observable<TherapyTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateDto.fromJS(resultData200) : new TherapyTemplateDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto>(<any>null);
    }

    /**
     * readOne
     * @param id id
     * @return OK
     */
    readOneUsingGET_39(id: number): Observable<TherapyTemplateDto> {
        let url_ = this.baseUrl + "/api/therapy_templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_39(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_39(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_39(response: HttpResponseBase): Observable<TherapyTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateDto.fromJS(resultData200) : new TherapyTemplateDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto>(<any>null);
    }

    /**
     * update
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_33(dto: TherapyTemplateDto): Observable<TherapyTemplateDto> {
        let url_ = this.baseUrl + "/api/therapy_templates/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_33(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_33(<any>response_);
                } catch (e) {
                    return <Observable<TherapyTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TherapyTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_33(response: HttpResponseBase): Observable<TherapyTemplateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TherapyTemplateDto.fromJS(resultData200) : new TherapyTemplateDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TherapyTemplateDto>(<any>null);
    }

    /**
     * возвращает список всех транспортных средств в подразделении
     * @param subId (optional) subId
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_44(subId?: number | null | undefined, deleted?: boolean | null | undefined): Observable<TransportDto[]> {
        let url_ = this.baseUrl + "/api/transport?";
        if (subId !== undefined)
            url_ += "subId=" + encodeURIComponent("" + subId) + "&"; 
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_44(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_44(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_44(response: HttpResponseBase): Observable<TransportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto[]>(<any>null);
    }

    /**
     * создание нового транспортного средства
     * @param dto dto
     * @return OK
     */
    createUsingPOST_35(dto: TransportDto): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/transport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_35(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_35(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportDto.fromJS(resultData200) : new TransportDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(<any>null);
    }

    /**
     * возвращает список всех транспортных средств c мониторинга
     * @param params params
     * @return OK
     */
    readPathUsingPOST(params: CarPathParams): Observable<MonPoint[]> {
        let url_ = this.baseUrl + "/api/transport/path";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(params);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadPathUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadPathUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<MonPoint[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MonPoint[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadPathUsingPOST(response: HttpResponseBase): Observable<MonPoint[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MonPoint.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MonPoint[]>(<any>null);
    }

    /**
     * readAllStateMarks
     * @return OK
     */
    readAllStateMarksUsingGET(): Observable<TransportDto[]> {
        let url_ = this.baseUrl + "/api/transport/state_marks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllStateMarksUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllStateMarksUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllStateMarksUsingGET(response: HttpResponseBase): Observable<TransportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto[]>(<any>null);
    }

    /**
     * возвращает конкретное транспортное средство по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_42(id: number): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/transport/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_42(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_42(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_42(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportDto.fromJS(resultData200) : new TransportDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(<any>null);
    }

    /**
     * обновление сведений об транспортном средстве
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_36(dto: TransportDto): Observable<TransportDto> {
        let url_ = this.baseUrl + "/api/transport/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_36(<any>response_);
                } catch (e) {
                    return <Observable<TransportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_36(response: HttpResponseBase): Observable<TransportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportDto.fromJS(resultData200) : new TransportDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportDto>(<any>null);
    }

    /**
     * возвращает список классов транспортных средств
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_43(deleted?: boolean | null | undefined): Observable<TransportClassDto[]> {
        let url_ = this.baseUrl + "/api/transport_classes?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_43(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_43(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_43(response: HttpResponseBase): Observable<TransportClassDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportClassDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto[]>(<any>null);
    }

    /**
     * создание нового класса транспортных средств
     * @param dto dto
     * @return OK
     */
    createUsingPOST_34(dto: TransportClassDto): Observable<TransportClassDto> {
        let url_ = this.baseUrl + "/api/transport_classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_34(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_34(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_34(response: HttpResponseBase): Observable<TransportClassDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportClassDto.fromJS(resultData200) : new TransportClassDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto>(<any>null);
    }

    /**
     * возвращает класс транспортных средств по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_41(id: number): Observable<TransportClassDto> {
        let url_ = this.baseUrl + "/api/transport_classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_41(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_41(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_41(response: HttpResponseBase): Observable<TransportClassDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportClassDto.fromJS(resultData200) : new TransportClassDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto>(<any>null);
    }

    /**
     * обновление сведений о классе транспортных средств
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_35(dto: TransportClassDto): Observable<TransportClassDto> {
        let url_ = this.baseUrl + "/api/transport_classes/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_35(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_35(<any>response_);
                } catch (e) {
                    return <Observable<TransportClassDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportClassDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_35(response: HttpResponseBase): Observable<TransportClassDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportClassDto.fromJS(resultData200) : new TransportClassDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportClassDto>(<any>null);
    }

    /**
     * возвращает список типов транспортных средств
     * @param deleted (optional) deleted
     * @return OK
     */
    readAllUsingGET_45(deleted?: boolean | null | undefined): Observable<TransportTypeDto[]> {
        let url_ = this.baseUrl + "/api/transport_types?";
        if (deleted !== undefined)
            url_ += "deleted=" + encodeURIComponent("" + deleted) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_45(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_45(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_45(response: HttpResponseBase): Observable<TransportTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TransportTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto[]>(<any>null);
    }

    /**
     * создание нового типа транспортных средств
     * @param dto dto
     * @return OK
     */
    createUsingPOST_36(dto: TransportTypeDto): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/transport_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_36(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_36(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_36(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportTypeDto.fromJS(resultData200) : new TransportTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(<any>null);
    }

    /**
     * возвращает тип транспортных средств по id
     * @param id id
     * @return OK
     */
    readOneUsingGET_43(id: number): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/transport_types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_43(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_43(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_43(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportTypeDto.fromJS(resultData200) : new TransportTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(<any>null);
    }

    /**
     * обновление сведений о типе транспортных средств
     * @param dto dto
     * @return OK
     */
    updateUsingPUT_37(dto: TransportTypeDto): Observable<TransportTypeDto> {
        let url_ = this.baseUrl + "/api/transport_types/{id}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_37(<any>response_);
                } catch (e) {
                    return <Observable<TransportTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_37(response: HttpResponseBase): Observable<TransportTypeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransportTypeDto.fromJS(resultData200) : new TransportTypeDto();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportTypeDto>(<any>null);
    }

    /**
     * readAll
     * @return OK
     */
    readAllUsingGET_46(): Observable<Unit[]> {
        let url_ = this.baseUrl + "/api/units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllUsingGET_46(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllUsingGET_46(<any>response_);
                } catch (e) {
                    return <Observable<Unit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit[]>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllUsingGET_46(response: HttpResponseBase): Observable<Unit[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Unit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit[]>(<any>null);
    }

    /**
     * create
     * @param unit unit
     * @return OK
     */
    createUsingPOST_37(unit: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/api/units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unit);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUsingPOST_37(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUsingPOST_37(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUsingPOST_37(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200) : new Unit();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * readOne
     * @param code code
     * @return OK
     */
    readOneUsingGET_44(code: string): Observable<Unit> {
        let url_ = this.baseUrl + "/api/units/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadOneUsingGET_44(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadOneUsingGET_44(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processReadOneUsingGET_44(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200) : new Unit();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * update
     * @param unit unit
     * @return OK
     */
    updateUsingPUT_38(unit: Unit): Observable<Unit> {
        let url_ = this.baseUrl + "/api/units/{code}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unit);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUsingPUT_38(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUsingPUT_38(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUsingPUT_38(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Unit.fromJS(resultData200) : new Unit();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * delete
     * @param code code
     * @return OK
     */
    deleteUsingDELETE_4(code: string): Observable<void> {
        let url_ = this.baseUrl + "/api/units/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUsingDELETE_4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUsingDELETE_4(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUsingDELETE_4(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * login
     * @param error (optional) error
     * @param logout (optional) logout
     * @return OK
     */
    loginUsingGET_1(error?: string | null | undefined, logout?: string | null | undefined): Observable<ModelAndView> {
        let url_ = this.baseUrl + "/login?";
        if (error !== undefined)
            url_ += "error=" + encodeURIComponent("" + error) + "&"; 
        if (logout !== undefined)
            url_ += "logout=" + encodeURIComponent("" + logout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUsingGET_1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUsingGET_1(<any>response_);
                } catch (e) {
                    return <Observable<ModelAndView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelAndView>><any>_observableThrow(response_);
        }));
    }

    protected processLoginUsingGET_1(response: HttpResponseBase): Observable<ModelAndView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ModelAndView.fromJS(resultData200) : new ModelAndView();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelAndView>(<any>null);
    }

    /**
     * readAllBrigadeMedicine
     * @param brigade (optional) brigade
     * @return OK
     */
    readAllBrigadeMedicineUsingGET(brigade?: string | null | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/bag?";
        if (brigade !== undefined)
            url_ += "brigade=" + encodeURIComponent("" + brigade) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllBrigadeMedicineUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllBrigadeMedicineUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllBrigadeMedicineUsingGET(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * writeAllMedicineConsumption
     * @param items items
     * @return OK
     */
    writeAllMedicineConsumptionUsingPOST(items: Medicine[]): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/bag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWriteAllMedicineConsumptionUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWriteAllMedicineConsumptionUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processWriteAllMedicineConsumptionUsingPOST(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * readAllCalls
     * @return OK
     */
    readAllCallsUsingGET(): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/calls";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadAllCallsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadAllCallsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processReadAllCallsUsingGET(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * confirmAllCalls
     * @param guid guid
     * @return OK
     */
    confirmAllCallsUsingGET(guid: string): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/calls/confirm?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmAllCallsUsingGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmAllCallsUsingGET(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmAllCallsUsingGET(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * создание карточек вызовов
     * @param request request
     * @return OK
     */
    createCardsUsingPOST(request: MobileCardRequest): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/cards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCardsUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCardsUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCardsUsingPOST(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * receiveMobileMessage
     * @param mobileMessage mobileMessage
     * @return OK
     */
    receiveMobileMessageUsingPOST(mobileMessage: MobileMessage): Observable<Response> {
        let url_ = this.baseUrl + "/mobile/message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mobileMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReceiveMobileMessageUsingPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReceiveMobileMessageUsingPOST(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processReceiveMobileMessageUsingPOST(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Response.fromJS(resultData200) : new Response();
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }
}

export class CardResultIllegalActionsDto implements ICardResultIllegalActionsDto {
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;

    constructor(data?: ICardResultIllegalActionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.illegal_actions = data["illegal_actions"] !== undefined ? data["illegal_actions"] : <any>null;
            this.illegal_actions_text = data["illegal_actions_text"] !== undefined ? data["illegal_actions_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultIllegalActionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultIllegalActionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["illegal_actions"] = this.illegal_actions !== undefined ? this.illegal_actions : <any>null;
        data["illegal_actions_text"] = this.illegal_actions_text !== undefined ? this.illegal_actions_text : <any>null;
        return data; 
    }
}

export interface ICardResultIllegalActionsDto {
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;
}

export class CallPatientPartDto implements ICallPatientPartDto {
    deleted?: boolean | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;

    constructor(data?: ICallPatientPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.patient_age_days = data["patient_age_days"] !== undefined ? data["patient_age_days"] : <any>null;
            this.patient_age_months = data["patient_age_months"] !== undefined ? data["patient_age_months"] : <any>null;
            this.patient_age_years = data["patient_age_years"] !== undefined ? data["patient_age_years"] : <any>null;
            this.patient_firstname = data["patient_firstname"] !== undefined ? data["patient_firstname"] : <any>null;
            this.patient_id = data["patient_id"] !== undefined ? data["patient_id"] : <any>null;
            this.patient_patronymic = data["patient_patronymic"] !== undefined ? data["patient_patronymic"] : <any>null;
            this.patient_secondname = data["patient_secondname"] !== undefined ? data["patient_secondname"] : <any>null;
            this.patient_sex = data["patient_sex"] !== undefined ? data["patient_sex"] : <any>null;
            this.patient_sex_name = data["patient_sex_name"] !== undefined ? data["patient_sex_name"] : <any>null;
            this.patient_type_id = data["patient_type_id"] !== undefined ? data["patient_type_id"] : <any>null;
            this.patient_type_name = data["patient_type_name"] !== undefined ? data["patient_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallPatientPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallPatientPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["patient_age_days"] = this.patient_age_days !== undefined ? this.patient_age_days : <any>null;
        data["patient_age_months"] = this.patient_age_months !== undefined ? this.patient_age_months : <any>null;
        data["patient_age_years"] = this.patient_age_years !== undefined ? this.patient_age_years : <any>null;
        data["patient_firstname"] = this.patient_firstname !== undefined ? this.patient_firstname : <any>null;
        data["patient_id"] = this.patient_id !== undefined ? this.patient_id : <any>null;
        data["patient_patronymic"] = this.patient_patronymic !== undefined ? this.patient_patronymic : <any>null;
        data["patient_secondname"] = this.patient_secondname !== undefined ? this.patient_secondname : <any>null;
        data["patient_sex"] = this.patient_sex !== undefined ? this.patient_sex : <any>null;
        data["patient_sex_name"] = this.patient_sex_name !== undefined ? this.patient_sex_name : <any>null;
        data["patient_type_id"] = this.patient_type_id !== undefined ? this.patient_type_id : <any>null;
        data["patient_type_name"] = this.patient_type_name !== undefined ? this.patient_type_name : <any>null;
        return data; 
    }
}

export interface ICallPatientPartDto {
    deleted?: boolean | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;
}

export class CardResultDiagnosisDto implements ICardResultDiagnosisDto {
    complication_id?: number | null;
    complication_name?: string | null;
    concomitant_diagnosis?: MkbDto | null;
    main_diagnosis?: MkbDto | null;

    constructor(data?: ICardResultDiagnosisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.complication_id = data["complication_id"] !== undefined ? data["complication_id"] : <any>null;
            this.complication_name = data["complication_name"] !== undefined ? data["complication_name"] : <any>null;
            this.concomitant_diagnosis = data["concomitant_diagnosis"] ? MkbDto.fromJS(data["concomitant_diagnosis"]) : <any>null;
            this.main_diagnosis = data["main_diagnosis"] ? MkbDto.fromJS(data["main_diagnosis"]) : <any>null;
        }
    }

    static fromJS(data: any): CardResultDiagnosisDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDiagnosisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complication_id"] = this.complication_id !== undefined ? this.complication_id : <any>null;
        data["complication_name"] = this.complication_name !== undefined ? this.complication_name : <any>null;
        data["concomitant_diagnosis"] = this.concomitant_diagnosis ? this.concomitant_diagnosis.toJSON() : <any>null;
        data["main_diagnosis"] = this.main_diagnosis ? this.main_diagnosis.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardResultDiagnosisDto {
    complication_id?: number | null;
    complication_name?: string | null;
    concomitant_diagnosis?: MkbDto | null;
    main_diagnosis?: MkbDto | null;
}

export class CallGeneralPartDto implements ICallGeneralPartDto {
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_status?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: Date | null;
    is_unfounded?: boolean | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_accept_id?: number | null;
    subdivision_accept_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;

    constructor(data?: ICallGeneralPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_priority = data["call_priority"] !== undefined ? data["call_priority"] : <any>null;
            this.call_priority_name = data["call_priority_name"] !== undefined ? data["call_priority_name"] : <any>null;
            this.call_status = data["call_status"] !== undefined ? data["call_status"] : <any>null;
            this.call_type_id = data["call_type_id"] !== undefined ? data["call_type_id"] : <any>null;
            this.call_type_name = data["call_type_name"] !== undefined ? data["call_type_name"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            this.performer_accept_id = data["performer_accept_id"] !== undefined ? data["performer_accept_id"] : <any>null;
            this.performer_accept_name = data["performer_accept_name"] !== undefined ? data["performer_accept_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.performer_send_id = data["performer_send_id"] !== undefined ? data["performer_send_id"] : <any>null;
            this.performer_send_name = data["performer_send_name"] !== undefined ? data["performer_send_name"] : <any>null;
            this.primary_call_id = data["primary_call_id"] !== undefined ? data["primary_call_id"] : <any>null;
            this.primary_call_number = data["primary_call_number"] !== undefined ? data["primary_call_number"] : <any>null;
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.subdivision_accept_id = data["subdivision_accept_id"] !== undefined ? data["subdivision_accept_id"] : <any>null;
            this.subdivision_accept_name = data["subdivision_accept_name"] !== undefined ? data["subdivision_accept_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.subdivision_send_id = data["subdivision_send_id"] !== undefined ? data["subdivision_send_id"] : <any>null;
            this.subdivision_send_name = data["subdivision_send_name"] !== undefined ? data["subdivision_send_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallGeneralPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallGeneralPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_priority"] = this.call_priority !== undefined ? this.call_priority : <any>null;
        data["call_priority_name"] = this.call_priority_name !== undefined ? this.call_priority_name : <any>null;
        data["call_status"] = this.call_status !== undefined ? this.call_status : <any>null;
        data["call_type_id"] = this.call_type_id !== undefined ? this.call_type_id : <any>null;
        data["call_type_name"] = this.call_type_name !== undefined ? this.call_type_name : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        data["performer_accept_id"] = this.performer_accept_id !== undefined ? this.performer_accept_id : <any>null;
        data["performer_accept_name"] = this.performer_accept_name !== undefined ? this.performer_accept_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["performer_send_id"] = this.performer_send_id !== undefined ? this.performer_send_id : <any>null;
        data["performer_send_name"] = this.performer_send_name !== undefined ? this.performer_send_name : <any>null;
        data["primary_call_id"] = this.primary_call_id !== undefined ? this.primary_call_id : <any>null;
        data["primary_call_number"] = this.primary_call_number !== undefined ? this.primary_call_number : <any>null;
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["subdivision_accept_id"] = this.subdivision_accept_id !== undefined ? this.subdivision_accept_id : <any>null;
        data["subdivision_accept_name"] = this.subdivision_accept_name !== undefined ? this.subdivision_accept_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["subdivision_send_id"] = this.subdivision_send_id !== undefined ? this.subdivision_send_id : <any>null;
        data["subdivision_send_name"] = this.subdivision_send_name !== undefined ? this.subdivision_send_name : <any>null;
        return data; 
    }
}

export interface ICallGeneralPartDto {
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_status?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: Date | null;
    is_unfounded?: boolean | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_accept_id?: number | null;
    subdivision_accept_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;
}

export class Product implements IProduct {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    productType?: ProductType | null;
    unit_code?: string | null;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.productType = data["productType"] ? ProductType.fromJS(data["productType"]) : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["productType"] = this.productType ? this.productType.toJSON() : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IProduct {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    productType?: ProductType | null;
    unit_code?: string | null;
}

export class CardAnamnesisHeaderDto implements ICardAnamnesisHeaderDto {
    is_created?: boolean | null;

    constructor(data?: ICardAnamnesisHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisHeaderDto {
    is_created?: boolean | null;
}

export class BrigadeScheduleUpdateDto implements IBrigadeScheduleUpdateDto {
    period_details?: PeriodDetails | null;

    constructor(data?: IBrigadeScheduleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeScheduleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeScheduleUpdateDto {
    period_details?: PeriodDetails | null;
}

export class Document implements IDocument {
    accepted?: boolean | null;
    archived?: boolean | null;
    date_doc?: Date | null;
    id?: number | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    organization?: string | null;
    performer?: Performer | null;
    placeFrom?: Place | null;
    placeTo?: Place | null;
    type?: number | null;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accepted = data["accepted"] !== undefined ? data["accepted"] : <any>null;
            this.archived = data["archived"] !== undefined ? data["archived"] : <any>null;
            this.date_doc = data["date_doc"] ? new Date(data["date_doc"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["nomenclatures"] && data["nomenclatures"].constructor === Array) {
                this.nomenclatures = [];
                for (let item of data["nomenclatures"])
                    this.nomenclatures.push(DocumentNomenclature.fromJS(item));
            }
            this.number_doc = data["number_doc"] !== undefined ? data["number_doc"] : <any>null;
            this.organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            this.performer = data["performer"] ? Performer.fromJS(data["performer"]) : <any>null;
            this.placeFrom = data["placeFrom"] ? Place.fromJS(data["placeFrom"]) : <any>null;
            this.placeTo = data["placeTo"] ? Place.fromJS(data["placeTo"]) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accepted"] = this.accepted !== undefined ? this.accepted : <any>null;
        data["archived"] = this.archived !== undefined ? this.archived : <any>null;
        data["date_doc"] = this.date_doc ? this.date_doc.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.nomenclatures && this.nomenclatures.constructor === Array) {
            data["nomenclatures"] = [];
            for (let item of this.nomenclatures)
                data["nomenclatures"].push(item.toJSON());
        }
        data["number_doc"] = this.number_doc !== undefined ? this.number_doc : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>null;
        data["placeFrom"] = this.placeFrom ? this.placeFrom.toJSON() : <any>null;
        data["placeTo"] = this.placeTo ? this.placeTo.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IDocument {
    accepted?: boolean | null;
    archived?: boolean | null;
    date_doc?: Date | null;
    id?: number | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    organization?: string | null;
    performer?: Performer | null;
    placeFrom?: Place | null;
    placeTo?: Place | null;
    type?: number | null;
}

export class AssignedBrigadeMessageBean implements IAssignedBrigadeMessageBean {
    /** ID бригады */
    brigade?: number | null;
    /** ID звонка */
    call?: number | null;
    /** Время передачи сообщения */
    date?: Date | null;
    id?: number | null;
    /** Тип переданного сообщения */
    messageTypeFK?: ReferenceTypeBean | null;
    /** Способ передачи сообщения */
    receivingTypeFK?: ReferenceTypeBean | null;

    constructor(data?: IAssignedBrigadeMessageBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade = data["brigade"] !== undefined ? data["brigade"] : <any>null;
            this.call = data["call"] !== undefined ? data["call"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.messageTypeFK = data["messageTypeFK"] ? ReferenceTypeBean.fromJS(data["messageTypeFK"]) : <any>null;
            this.receivingTypeFK = data["receivingTypeFK"] ? ReferenceTypeBean.fromJS(data["receivingTypeFK"]) : <any>null;
        }
    }

    static fromJS(data: any): AssignedBrigadeMessageBean {
        data = typeof data === 'object' ? data : {};
        let result = new AssignedBrigadeMessageBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade"] = this.brigade !== undefined ? this.brigade : <any>null;
        data["call"] = this.call !== undefined ? this.call : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["messageTypeFK"] = this.messageTypeFK ? this.messageTypeFK.toJSON() : <any>null;
        data["receivingTypeFK"] = this.receivingTypeFK ? this.receivingTypeFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IAssignedBrigadeMessageBean {
    /** ID бригады */
    brigade?: number | null;
    /** ID звонка */
    call?: number | null;
    /** Время передачи сообщения */
    date?: Date | null;
    id?: number | null;
    /** Тип переданного сообщения */
    messageTypeFK?: ReferenceTypeBean | null;
    /** Способ передачи сообщения */
    receivingTypeFK?: ReferenceTypeBean | null;
}

export class BrigadeCallDto implements IBrigadeCallDto {
    call_id?: number | null;
    call_number?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    reason_extra?: boolean | null;
    reason_name?: string | null;
    state?: string | null;
    state_date?: Date | null;

    constructor(data?: IBrigadeCallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.reason_extra = data["reason_extra"] !== undefined ? data["reason_extra"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.state = data["state"] !== undefined ? data["state"] : <any>null;
            this.state_date = data["state_date"] ? new Date(data["state_date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeCallDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeCallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["reason_extra"] = this.reason_extra !== undefined ? this.reason_extra : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["state_date"] = this.state_date ? this.state_date.toISOString() : <any>null;
        return data; 
    }
}

export interface IBrigadeCallDto {
    call_id?: number | null;
    call_number?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    reason_extra?: boolean | null;
    reason_name?: string | null;
    state?: string | null;
    state_date?: Date | null;
}

export class PerformerScheduller implements IPerformerScheduller {
    basic?: boolean | null;
    dateFrom?: Date | null;
    dateTo?: Date | null;
    id?: number | null;

    constructor(data?: IPerformerScheduller) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.basic = data["basic"] !== undefined ? data["basic"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerScheduller {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerScheduller();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basic"] = this.basic !== undefined ? this.basic : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IPerformerScheduller {
    basic?: boolean | null;
    dateFrom?: Date | null;
    dateTo?: Date | null;
    id?: number | null;
}

export class PerformerBrigScheduleCreateDto implements IPerformerBrigScheduleCreateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;

    constructor(data?: IPerformerBrigScheduleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleCreateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
}

export class MobileCardDrug implements IMobileCardDrug {
    count?: number | null;
    in_car?: boolean | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;

    constructor(data?: IMobileCardDrug) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.in_car = data["in_car"] !== undefined ? data["in_car"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.uid = data["uid"] !== undefined ? data["uid"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardDrug {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardDrug();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["in_car"] = this.in_car !== undefined ? this.in_car : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["uid"] = this.uid !== undefined ? this.uid : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IMobileCardDrug {
    count?: number | null;
    in_car?: boolean | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;
}

export class PharmacyItem implements IPharmacyItem {
    amount?: number | null;
    id?: number | null;
    innerAmount?: number | null;
    nomenclatureItem?: NomenclatureItem | null;
    owner?: PharmacyOwner | null;

    constructor(data?: IPharmacyItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.innerAmount = data["innerAmount"] !== undefined ? data["innerAmount"] : <any>null;
            this.nomenclatureItem = data["nomenclatureItem"] ? NomenclatureItem.fromJS(data["nomenclatureItem"]) : <any>null;
            this.owner = data["owner"] ? PharmacyOwner.fromJS(data["owner"]) : <any>null;
        }
    }

    static fromJS(data: any): PharmacyItem {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["innerAmount"] = this.innerAmount !== undefined ? this.innerAmount : <any>null;
        data["nomenclatureItem"] = this.nomenclatureItem ? this.nomenclatureItem.toJSON() : <any>null;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>null;
        return data; 
    }
}

export interface IPharmacyItem {
    amount?: number | null;
    id?: number | null;
    innerAmount?: number | null;
    nomenclatureItem?: NomenclatureItem | null;
    owner?: PharmacyOwner | null;
}

export class Permission implements IPermission {
    checked?: boolean | null;
    code?: string | null;
    items?: Permission[] | null;
    leaf?: boolean | null;
    name?: string | null;
    type?: PermissionType | null;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checked = data["checked"] !== undefined ? data["checked"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Permission.fromJS(item));
            }
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checked"] = this.checked !== undefined ? this.checked : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPermission {
    checked?: boolean | null;
    code?: string | null;
    items?: Permission[] | null;
    leaf?: boolean | null;
    name?: string | null;
    type?: PermissionType | null;
}

export class CardObjectiveBean implements ICardObjectiveBean {
    /** WTF!? [7] */
    additionObjectives?: string | null;
    /** ALCOOVERDOZE: Свежее дыхание */
    alcoBreath?: boolean | null;
    /** ALCOOVERDOZE: Лабильность */
    alcoEmotionLability?: boolean | null;
    /** ALCOOVERDOZE: Неадекват */
    alcoInadequate?: boolean | null;
    /** ALCOOVERDOZE: Поза Ромберга */
    alcoRombergPose?: boolean | null;
    /** ALCOOVERDOZE: Лунная алкопоходка */
    alcoShakyWalk?: boolean | null;
    /** ALCOOVERDOZE: Умение зачитывать по пьяни Rap God */
    alcoSpeechBehavior?: boolean | null;
    /** Наличие аллергии: признак */
    allergicAnamnesis?: boolean | null;
    /** Наличие аллергии: описание */
    allergicAnamnesisText?: string | null;
    /** Миндалины нормального размера */
    almondsNormalLarge?: boolean | null;
    /** WTF!? [3] */
    almondsPlaque?: boolean | null;
    /** Поведение */
    behaviourFK?: ReferenceTypeBean | null;
    /** Сухожильные рефлексы */
    breathAbsent?: boolean | null;
    /** Бронхиальное */
    breathBronchial?: boolean | null;
    /** Равномерное */
    breathEvenly?: boolean | null;
    /** Слабое/тяжелое(t/f) */
    breathIsWeak?: boolean | null;
    /** Чистое */
    breathPure?: boolean | null;
    /** Дыхание: комментарий */
    breathText?: string | null;
    /** Везикулярное */
    breathVesicular?: boolean | null;
    /** Жалобы и анамнез */
    complaintsAnamnesis?: string | null;
    /** Осложнения */
    complicationsFK?: ReferenceTypeBean | null;
    /** Осложнения (комментарий) */
    complicationsText?: string | null;
    /** Сознание */
    consciousFK?: ReferenceTypeBean | null;
    /** Дата заполнения карты */
    date?: Date | null;
    /** Дизурия */
    diuresisDisuria?: boolean | null;
    /** Гематурия */
    diuresisHematuria?: boolean | null;
    /** Диурез отсутствует */
    diuresisNo?: boolean | null;
    /** Олигурия */
    diuresisOliguria?: boolean | null;
    /** Расстройства пищеварения: диарея */
    dyspepticDiarrhea?: boolean | null;
    /** Расстройства пищеварения: тошнота */
    dyspepticNausea?: boolean | null;
    /** Расстройства пищеварения: запор */
    dyspepticRetch?: boolean | null;
    /** Расстройства пищеварения: нет */
    dyspepticsNo?: boolean | null;
    /** Сухожильные рефлексы */
    dyspneaFK?: ReferenceTypeBean | null;
    /** Признак наличия выделительной системы */
    excreta?: boolean | null;
    /** Состояние выделительной системы */
    excretaText?: string | null;
    /** ШКГ - Тест открывания глаз (E) */
    eyeOpening?: number | null;
    /** Общее состояние */
    generalStateFK?: ReferenceTypeBean | null;
    /** Глюкометрия */
    glucometry?: string | null;
    /** Гинекологический анамнез */
    gynecologicAnamnesis?: string | null;
    /** Сердце: АД */
    heartAd?: string | null;
    /** Сердце: АД максимальное */
    heartAdMax?: string | null;
    /** Сердце: АДН */
    heartAdn?: string | null;
    /** WTF!? [6] */
    heartBodyTemp?: string | null;
    /** Сердце: ЧД */
    heartChd?: string | null;
    /** Сердце: ЧСС */
    heartChss?: string | null;
    /** Сердечные шумы */
    heartNoiseFK?: ReferenceTypeBean | null;
    /** Сердце: Пульс */
    heartPs?: string | null;
    /** Пульс */
    heartPulseFK?: ReferenceTypeBean | null;
    /** Частота сердцебиения */
    heartRateFK?: ReferenceTypeBean | null;
    /** Тоны сердца */
    heartToneFK?: ReferenceTypeBean | null;
    id?: number | null;
    /** Анамнез болезней (чем сейчас болеет) */
    illnessAnamnesis?: string | null;
    /** Инфекционность */
    infectContacts?: string | null;
    /** WTF!? [4] */
    lionTappingLeft?: boolean | null;
    /** WTF!? [5] */
    lionTappingRight?: boolean | null;
    /** Печень: нормального размера */
    liverNormalLarge?: boolean | null;
    /** Печень: синдром Ортнера */
    liverOrtner?: boolean | null;
    /** Печень: размер */
    liverSizeText?: string | null;
    /** Легочные хрипы */
    lungsWheezing?: number | null;
    /** Легочные хрипы */
    lungsWheezingFK?: ReferenceTypeBean | null;
    /** Хрипы в легких: комментарий */
    lungsWheezingText?: string | null;
    /** Лимфоузлы: нормальный размер */
    lymphNodesNormalLarge?: boolean | null;
    /** Лимфоузлы: болезненные ощущения */
    lymphNodesPainful?: boolean | null;
    /** Лимфоузлы: комментарий */
    lymphNodesText?: string | null;
    /** Менингиальные синдромы */
    meningealReflexes?: boolean | null;
    /** ШКГ - Двигательный тест (M) */
    motorResponse?: number | null;
    /** WTF!? */
    multipleZevaCleanHyper?: boolean | null;
    /** Анамнез болезней (чем раньше болел) */
    pastIllnesses?: string | null;
    /** Патологические стопные рефлексы */
    pathologicalReflexes?: boolean | null;
    /** Анизокория */
    penaltiesAnisocoria?: boolean | null;
    /** Состояние зрачков одинаково выражено (D ? S) */
    penaltiesDsFK?: ReferenceTypeBean | null;
    /** Состояние зрачков */
    penaltiesFK?: ReferenceTypeBean | null;
    /** Реакция на свет */
    penaltiesLight?: boolean | null;
    /** Нистагм */
    penaltiesNystagmus?: boolean | null;
    /** Сравнительная перкуссия легких */
    percLungsSoundFK?: ReferenceTypeBean | null;
    /** Звук при перкуссии легких */
    percLungsSoundText?: string | null;
    /** Гемодинамика посттерапии */
    postTherapyHemodynamics?: string | null;
    /** ПульсOXXXYметрия */
    pulseOximetry?: string | null;
    /** Карантин */
    quarantine?: string | null;
    /** Рефлексы одинаково выражены (D ? S) */
    reflexesDsFK?: ReferenceTypeBean | null;
    /** Акроцианоз */
    skinAcrosianosis?: boolean | null;
    /** Цвет кожи */
    skinColorFK?: ReferenceTypeBean | null;
    /** Гиперимированность */
    skinHyperemetic?: boolean | null;
    /** Цианоз */
    skinIntegCyanotic?: boolean | null;
    /** Сухость/Потливость (t/f) */
    skinIsDry?: boolean | null;
    /** Кожа нормальная/нет */
    skinIsNormal?: boolean | null;
    /** Сыпь */
    skinRashes?: boolean | null;
    /** Желудочный асцит */
    stomachAscites?: boolean | null;
    /** Живот участвует в акте дыхания */
    stomachBreathingInvolved?: boolean | null;
    /** Желудок ??? */
    stomachDisklike?: boolean | null;
    /** Желудок вздутый */
    stomachInflated?: boolean | null;
    /** Желудок твердый */
    stomachIsHard?: boolean | null;
    /** Боль в желудке */
    stomachIsPainful?: boolean | null;
    /** Желудок в норме */
    stomachNormal?: boolean | null;
    /** Перитонит */
    stomachPeritonit?: boolean | null;
    /** Описание состояния брюшной полости */
    stomachText?: string | null;
    /** Сухожильные рефлексы */
    tendonReflexesFK?: ReferenceTypeBean | null;
    /** WTF!? [1] */
    titles?: boolean | null;
    /** WTF!? [2] */
    titlesText?: string | null;
    /** Признак влажности/сухости языка */
    tongueCleanFurred?: number | null;
    /** Признак чистоты языка */
    tongueWeatDry?: boolean | null;
    /** Мочеиспускание */
    urineText?: string | null;
    /** Вакцинация */
    vaccination?: string | null;
    /** ШКГ - Речевой тест (V) */
    verbalResponse?: number | null;

    constructor(data?: ICardObjectiveBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionObjectives = data["additionObjectives"] !== undefined ? data["additionObjectives"] : <any>null;
            this.alcoBreath = data["alcoBreath"] !== undefined ? data["alcoBreath"] : <any>null;
            this.alcoEmotionLability = data["alcoEmotionLability"] !== undefined ? data["alcoEmotionLability"] : <any>null;
            this.alcoInadequate = data["alcoInadequate"] !== undefined ? data["alcoInadequate"] : <any>null;
            this.alcoRombergPose = data["alcoRombergPose"] !== undefined ? data["alcoRombergPose"] : <any>null;
            this.alcoShakyWalk = data["alcoShakyWalk"] !== undefined ? data["alcoShakyWalk"] : <any>null;
            this.alcoSpeechBehavior = data["alcoSpeechBehavior"] !== undefined ? data["alcoSpeechBehavior"] : <any>null;
            this.allergicAnamnesis = data["allergicAnamnesis"] !== undefined ? data["allergicAnamnesis"] : <any>null;
            this.allergicAnamnesisText = data["allergicAnamnesisText"] !== undefined ? data["allergicAnamnesisText"] : <any>null;
            this.almondsNormalLarge = data["almondsNormalLarge"] !== undefined ? data["almondsNormalLarge"] : <any>null;
            this.almondsPlaque = data["almondsPlaque"] !== undefined ? data["almondsPlaque"] : <any>null;
            this.behaviourFK = data["behaviourFK"] ? ReferenceTypeBean.fromJS(data["behaviourFK"]) : <any>null;
            this.breathAbsent = data["breathAbsent"] !== undefined ? data["breathAbsent"] : <any>null;
            this.breathBronchial = data["breathBronchial"] !== undefined ? data["breathBronchial"] : <any>null;
            this.breathEvenly = data["breathEvenly"] !== undefined ? data["breathEvenly"] : <any>null;
            this.breathIsWeak = data["breathIsWeak"] !== undefined ? data["breathIsWeak"] : <any>null;
            this.breathPure = data["breathPure"] !== undefined ? data["breathPure"] : <any>null;
            this.breathText = data["breathText"] !== undefined ? data["breathText"] : <any>null;
            this.breathVesicular = data["breathVesicular"] !== undefined ? data["breathVesicular"] : <any>null;
            this.complaintsAnamnesis = data["complaintsAnamnesis"] !== undefined ? data["complaintsAnamnesis"] : <any>null;
            this.complicationsFK = data["complicationsFK"] ? ReferenceTypeBean.fromJS(data["complicationsFK"]) : <any>null;
            this.complicationsText = data["complicationsText"] !== undefined ? data["complicationsText"] : <any>null;
            this.consciousFK = data["consciousFK"] ? ReferenceTypeBean.fromJS(data["consciousFK"]) : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.diuresisDisuria = data["diuresisDisuria"] !== undefined ? data["diuresisDisuria"] : <any>null;
            this.diuresisHematuria = data["diuresisHematuria"] !== undefined ? data["diuresisHematuria"] : <any>null;
            this.diuresisNo = data["diuresisNo"] !== undefined ? data["diuresisNo"] : <any>null;
            this.diuresisOliguria = data["diuresisOliguria"] !== undefined ? data["diuresisOliguria"] : <any>null;
            this.dyspepticDiarrhea = data["dyspepticDiarrhea"] !== undefined ? data["dyspepticDiarrhea"] : <any>null;
            this.dyspepticNausea = data["dyspepticNausea"] !== undefined ? data["dyspepticNausea"] : <any>null;
            this.dyspepticRetch = data["dyspepticRetch"] !== undefined ? data["dyspepticRetch"] : <any>null;
            this.dyspepticsNo = data["dyspepticsNo"] !== undefined ? data["dyspepticsNo"] : <any>null;
            this.dyspneaFK = data["dyspneaFK"] ? ReferenceTypeBean.fromJS(data["dyspneaFK"]) : <any>null;
            this.excreta = data["excreta"] !== undefined ? data["excreta"] : <any>null;
            this.excretaText = data["excretaText"] !== undefined ? data["excretaText"] : <any>null;
            this.eyeOpening = data["eyeOpening"] !== undefined ? data["eyeOpening"] : <any>null;
            this.generalStateFK = data["generalStateFK"] ? ReferenceTypeBean.fromJS(data["generalStateFK"]) : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.gynecologicAnamnesis = data["gynecologicAnamnesis"] !== undefined ? data["gynecologicAnamnesis"] : <any>null;
            this.heartAd = data["heartAd"] !== undefined ? data["heartAd"] : <any>null;
            this.heartAdMax = data["heartAdMax"] !== undefined ? data["heartAdMax"] : <any>null;
            this.heartAdn = data["heartAdn"] !== undefined ? data["heartAdn"] : <any>null;
            this.heartBodyTemp = data["heartBodyTemp"] !== undefined ? data["heartBodyTemp"] : <any>null;
            this.heartChd = data["heartChd"] !== undefined ? data["heartChd"] : <any>null;
            this.heartChss = data["heartChss"] !== undefined ? data["heartChss"] : <any>null;
            this.heartNoiseFK = data["heartNoiseFK"] ? ReferenceTypeBean.fromJS(data["heartNoiseFK"]) : <any>null;
            this.heartPs = data["heartPs"] !== undefined ? data["heartPs"] : <any>null;
            this.heartPulseFK = data["heartPulseFK"] ? ReferenceTypeBean.fromJS(data["heartPulseFK"]) : <any>null;
            this.heartRateFK = data["heartRateFK"] ? ReferenceTypeBean.fromJS(data["heartRateFK"]) : <any>null;
            this.heartToneFK = data["heartToneFK"] ? ReferenceTypeBean.fromJS(data["heartToneFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.illnessAnamnesis = data["illnessAnamnesis"] !== undefined ? data["illnessAnamnesis"] : <any>null;
            this.infectContacts = data["infectContacts"] !== undefined ? data["infectContacts"] : <any>null;
            this.lionTappingLeft = data["lionTappingLeft"] !== undefined ? data["lionTappingLeft"] : <any>null;
            this.lionTappingRight = data["lionTappingRight"] !== undefined ? data["lionTappingRight"] : <any>null;
            this.liverNormalLarge = data["liverNormalLarge"] !== undefined ? data["liverNormalLarge"] : <any>null;
            this.liverOrtner = data["liverOrtner"] !== undefined ? data["liverOrtner"] : <any>null;
            this.liverSizeText = data["liverSizeText"] !== undefined ? data["liverSizeText"] : <any>null;
            this.lungsWheezing = data["lungsWheezing"] !== undefined ? data["lungsWheezing"] : <any>null;
            this.lungsWheezingFK = data["lungsWheezingFK"] ? ReferenceTypeBean.fromJS(data["lungsWheezingFK"]) : <any>null;
            this.lungsWheezingText = data["lungsWheezingText"] !== undefined ? data["lungsWheezingText"] : <any>null;
            this.lymphNodesNormalLarge = data["lymphNodesNormalLarge"] !== undefined ? data["lymphNodesNormalLarge"] : <any>null;
            this.lymphNodesPainful = data["lymphNodesPainful"] !== undefined ? data["lymphNodesPainful"] : <any>null;
            this.lymphNodesText = data["lymphNodesText"] !== undefined ? data["lymphNodesText"] : <any>null;
            this.meningealReflexes = data["meningealReflexes"] !== undefined ? data["meningealReflexes"] : <any>null;
            this.motorResponse = data["motorResponse"] !== undefined ? data["motorResponse"] : <any>null;
            this.multipleZevaCleanHyper = data["multipleZevaCleanHyper"] !== undefined ? data["multipleZevaCleanHyper"] : <any>null;
            this.pastIllnesses = data["pastIllnesses"] !== undefined ? data["pastIllnesses"] : <any>null;
            this.pathologicalReflexes = data["pathologicalReflexes"] !== undefined ? data["pathologicalReflexes"] : <any>null;
            this.penaltiesAnisocoria = data["penaltiesAnisocoria"] !== undefined ? data["penaltiesAnisocoria"] : <any>null;
            this.penaltiesDsFK = data["penaltiesDsFK"] ? ReferenceTypeBean.fromJS(data["penaltiesDsFK"]) : <any>null;
            this.penaltiesFK = data["penaltiesFK"] ? ReferenceTypeBean.fromJS(data["penaltiesFK"]) : <any>null;
            this.penaltiesLight = data["penaltiesLight"] !== undefined ? data["penaltiesLight"] : <any>null;
            this.penaltiesNystagmus = data["penaltiesNystagmus"] !== undefined ? data["penaltiesNystagmus"] : <any>null;
            this.percLungsSoundFK = data["percLungsSoundFK"] ? ReferenceTypeBean.fromJS(data["percLungsSoundFK"]) : <any>null;
            this.percLungsSoundText = data["percLungsSoundText"] !== undefined ? data["percLungsSoundText"] : <any>null;
            this.postTherapyHemodynamics = data["postTherapyHemodynamics"] !== undefined ? data["postTherapyHemodynamics"] : <any>null;
            this.pulseOximetry = data["pulseOximetry"] !== undefined ? data["pulseOximetry"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.reflexesDsFK = data["reflexesDsFK"] ? ReferenceTypeBean.fromJS(data["reflexesDsFK"]) : <any>null;
            this.skinAcrosianosis = data["skinAcrosianosis"] !== undefined ? data["skinAcrosianosis"] : <any>null;
            this.skinColorFK = data["skinColorFK"] ? ReferenceTypeBean.fromJS(data["skinColorFK"]) : <any>null;
            this.skinHyperemetic = data["skinHyperemetic"] !== undefined ? data["skinHyperemetic"] : <any>null;
            this.skinIntegCyanotic = data["skinIntegCyanotic"] !== undefined ? data["skinIntegCyanotic"] : <any>null;
            this.skinIsDry = data["skinIsDry"] !== undefined ? data["skinIsDry"] : <any>null;
            this.skinIsNormal = data["skinIsNormal"] !== undefined ? data["skinIsNormal"] : <any>null;
            this.skinRashes = data["skinRashes"] !== undefined ? data["skinRashes"] : <any>null;
            this.stomachAscites = data["stomachAscites"] !== undefined ? data["stomachAscites"] : <any>null;
            this.stomachBreathingInvolved = data["stomachBreathingInvolved"] !== undefined ? data["stomachBreathingInvolved"] : <any>null;
            this.stomachDisklike = data["stomachDisklike"] !== undefined ? data["stomachDisklike"] : <any>null;
            this.stomachInflated = data["stomachInflated"] !== undefined ? data["stomachInflated"] : <any>null;
            this.stomachIsHard = data["stomachIsHard"] !== undefined ? data["stomachIsHard"] : <any>null;
            this.stomachIsPainful = data["stomachIsPainful"] !== undefined ? data["stomachIsPainful"] : <any>null;
            this.stomachNormal = data["stomachNormal"] !== undefined ? data["stomachNormal"] : <any>null;
            this.stomachPeritonit = data["stomachPeritonit"] !== undefined ? data["stomachPeritonit"] : <any>null;
            this.stomachText = data["stomachText"] !== undefined ? data["stomachText"] : <any>null;
            this.tendonReflexesFK = data["tendonReflexesFK"] ? ReferenceTypeBean.fromJS(data["tendonReflexesFK"]) : <any>null;
            this.titles = data["titles"] !== undefined ? data["titles"] : <any>null;
            this.titlesText = data["titlesText"] !== undefined ? data["titlesText"] : <any>null;
            this.tongueCleanFurred = data["tongueCleanFurred"] !== undefined ? data["tongueCleanFurred"] : <any>null;
            this.tongueWeatDry = data["tongueWeatDry"] !== undefined ? data["tongueWeatDry"] : <any>null;
            this.urineText = data["urineText"] !== undefined ? data["urineText"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
            this.verbalResponse = data["verbalResponse"] !== undefined ? data["verbalResponse"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveBean {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionObjectives"] = this.additionObjectives !== undefined ? this.additionObjectives : <any>null;
        data["alcoBreath"] = this.alcoBreath !== undefined ? this.alcoBreath : <any>null;
        data["alcoEmotionLability"] = this.alcoEmotionLability !== undefined ? this.alcoEmotionLability : <any>null;
        data["alcoInadequate"] = this.alcoInadequate !== undefined ? this.alcoInadequate : <any>null;
        data["alcoRombergPose"] = this.alcoRombergPose !== undefined ? this.alcoRombergPose : <any>null;
        data["alcoShakyWalk"] = this.alcoShakyWalk !== undefined ? this.alcoShakyWalk : <any>null;
        data["alcoSpeechBehavior"] = this.alcoSpeechBehavior !== undefined ? this.alcoSpeechBehavior : <any>null;
        data["allergicAnamnesis"] = this.allergicAnamnesis !== undefined ? this.allergicAnamnesis : <any>null;
        data["allergicAnamnesisText"] = this.allergicAnamnesisText !== undefined ? this.allergicAnamnesisText : <any>null;
        data["almondsNormalLarge"] = this.almondsNormalLarge !== undefined ? this.almondsNormalLarge : <any>null;
        data["almondsPlaque"] = this.almondsPlaque !== undefined ? this.almondsPlaque : <any>null;
        data["behaviourFK"] = this.behaviourFK ? this.behaviourFK.toJSON() : <any>null;
        data["breathAbsent"] = this.breathAbsent !== undefined ? this.breathAbsent : <any>null;
        data["breathBronchial"] = this.breathBronchial !== undefined ? this.breathBronchial : <any>null;
        data["breathEvenly"] = this.breathEvenly !== undefined ? this.breathEvenly : <any>null;
        data["breathIsWeak"] = this.breathIsWeak !== undefined ? this.breathIsWeak : <any>null;
        data["breathPure"] = this.breathPure !== undefined ? this.breathPure : <any>null;
        data["breathText"] = this.breathText !== undefined ? this.breathText : <any>null;
        data["breathVesicular"] = this.breathVesicular !== undefined ? this.breathVesicular : <any>null;
        data["complaintsAnamnesis"] = this.complaintsAnamnesis !== undefined ? this.complaintsAnamnesis : <any>null;
        data["complicationsFK"] = this.complicationsFK ? this.complicationsFK.toJSON() : <any>null;
        data["complicationsText"] = this.complicationsText !== undefined ? this.complicationsText : <any>null;
        data["consciousFK"] = this.consciousFK ? this.consciousFK.toJSON() : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["diuresisDisuria"] = this.diuresisDisuria !== undefined ? this.diuresisDisuria : <any>null;
        data["diuresisHematuria"] = this.diuresisHematuria !== undefined ? this.diuresisHematuria : <any>null;
        data["diuresisNo"] = this.diuresisNo !== undefined ? this.diuresisNo : <any>null;
        data["diuresisOliguria"] = this.diuresisOliguria !== undefined ? this.diuresisOliguria : <any>null;
        data["dyspepticDiarrhea"] = this.dyspepticDiarrhea !== undefined ? this.dyspepticDiarrhea : <any>null;
        data["dyspepticNausea"] = this.dyspepticNausea !== undefined ? this.dyspepticNausea : <any>null;
        data["dyspepticRetch"] = this.dyspepticRetch !== undefined ? this.dyspepticRetch : <any>null;
        data["dyspepticsNo"] = this.dyspepticsNo !== undefined ? this.dyspepticsNo : <any>null;
        data["dyspneaFK"] = this.dyspneaFK ? this.dyspneaFK.toJSON() : <any>null;
        data["excreta"] = this.excreta !== undefined ? this.excreta : <any>null;
        data["excretaText"] = this.excretaText !== undefined ? this.excretaText : <any>null;
        data["eyeOpening"] = this.eyeOpening !== undefined ? this.eyeOpening : <any>null;
        data["generalStateFK"] = this.generalStateFK ? this.generalStateFK.toJSON() : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["gynecologicAnamnesis"] = this.gynecologicAnamnesis !== undefined ? this.gynecologicAnamnesis : <any>null;
        data["heartAd"] = this.heartAd !== undefined ? this.heartAd : <any>null;
        data["heartAdMax"] = this.heartAdMax !== undefined ? this.heartAdMax : <any>null;
        data["heartAdn"] = this.heartAdn !== undefined ? this.heartAdn : <any>null;
        data["heartBodyTemp"] = this.heartBodyTemp !== undefined ? this.heartBodyTemp : <any>null;
        data["heartChd"] = this.heartChd !== undefined ? this.heartChd : <any>null;
        data["heartChss"] = this.heartChss !== undefined ? this.heartChss : <any>null;
        data["heartNoiseFK"] = this.heartNoiseFK ? this.heartNoiseFK.toJSON() : <any>null;
        data["heartPs"] = this.heartPs !== undefined ? this.heartPs : <any>null;
        data["heartPulseFK"] = this.heartPulseFK ? this.heartPulseFK.toJSON() : <any>null;
        data["heartRateFK"] = this.heartRateFK ? this.heartRateFK.toJSON() : <any>null;
        data["heartToneFK"] = this.heartToneFK ? this.heartToneFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["illnessAnamnesis"] = this.illnessAnamnesis !== undefined ? this.illnessAnamnesis : <any>null;
        data["infectContacts"] = this.infectContacts !== undefined ? this.infectContacts : <any>null;
        data["lionTappingLeft"] = this.lionTappingLeft !== undefined ? this.lionTappingLeft : <any>null;
        data["lionTappingRight"] = this.lionTappingRight !== undefined ? this.lionTappingRight : <any>null;
        data["liverNormalLarge"] = this.liverNormalLarge !== undefined ? this.liverNormalLarge : <any>null;
        data["liverOrtner"] = this.liverOrtner !== undefined ? this.liverOrtner : <any>null;
        data["liverSizeText"] = this.liverSizeText !== undefined ? this.liverSizeText : <any>null;
        data["lungsWheezing"] = this.lungsWheezing !== undefined ? this.lungsWheezing : <any>null;
        data["lungsWheezingFK"] = this.lungsWheezingFK ? this.lungsWheezingFK.toJSON() : <any>null;
        data["lungsWheezingText"] = this.lungsWheezingText !== undefined ? this.lungsWheezingText : <any>null;
        data["lymphNodesNormalLarge"] = this.lymphNodesNormalLarge !== undefined ? this.lymphNodesNormalLarge : <any>null;
        data["lymphNodesPainful"] = this.lymphNodesPainful !== undefined ? this.lymphNodesPainful : <any>null;
        data["lymphNodesText"] = this.lymphNodesText !== undefined ? this.lymphNodesText : <any>null;
        data["meningealReflexes"] = this.meningealReflexes !== undefined ? this.meningealReflexes : <any>null;
        data["motorResponse"] = this.motorResponse !== undefined ? this.motorResponse : <any>null;
        data["multipleZevaCleanHyper"] = this.multipleZevaCleanHyper !== undefined ? this.multipleZevaCleanHyper : <any>null;
        data["pastIllnesses"] = this.pastIllnesses !== undefined ? this.pastIllnesses : <any>null;
        data["pathologicalReflexes"] = this.pathologicalReflexes !== undefined ? this.pathologicalReflexes : <any>null;
        data["penaltiesAnisocoria"] = this.penaltiesAnisocoria !== undefined ? this.penaltiesAnisocoria : <any>null;
        data["penaltiesDsFK"] = this.penaltiesDsFK ? this.penaltiesDsFK.toJSON() : <any>null;
        data["penaltiesFK"] = this.penaltiesFK ? this.penaltiesFK.toJSON() : <any>null;
        data["penaltiesLight"] = this.penaltiesLight !== undefined ? this.penaltiesLight : <any>null;
        data["penaltiesNystagmus"] = this.penaltiesNystagmus !== undefined ? this.penaltiesNystagmus : <any>null;
        data["percLungsSoundFK"] = this.percLungsSoundFK ? this.percLungsSoundFK.toJSON() : <any>null;
        data["percLungsSoundText"] = this.percLungsSoundText !== undefined ? this.percLungsSoundText : <any>null;
        data["postTherapyHemodynamics"] = this.postTherapyHemodynamics !== undefined ? this.postTherapyHemodynamics : <any>null;
        data["pulseOximetry"] = this.pulseOximetry !== undefined ? this.pulseOximetry : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["reflexesDsFK"] = this.reflexesDsFK ? this.reflexesDsFK.toJSON() : <any>null;
        data["skinAcrosianosis"] = this.skinAcrosianosis !== undefined ? this.skinAcrosianosis : <any>null;
        data["skinColorFK"] = this.skinColorFK ? this.skinColorFK.toJSON() : <any>null;
        data["skinHyperemetic"] = this.skinHyperemetic !== undefined ? this.skinHyperemetic : <any>null;
        data["skinIntegCyanotic"] = this.skinIntegCyanotic !== undefined ? this.skinIntegCyanotic : <any>null;
        data["skinIsDry"] = this.skinIsDry !== undefined ? this.skinIsDry : <any>null;
        data["skinIsNormal"] = this.skinIsNormal !== undefined ? this.skinIsNormal : <any>null;
        data["skinRashes"] = this.skinRashes !== undefined ? this.skinRashes : <any>null;
        data["stomachAscites"] = this.stomachAscites !== undefined ? this.stomachAscites : <any>null;
        data["stomachBreathingInvolved"] = this.stomachBreathingInvolved !== undefined ? this.stomachBreathingInvolved : <any>null;
        data["stomachDisklike"] = this.stomachDisklike !== undefined ? this.stomachDisklike : <any>null;
        data["stomachInflated"] = this.stomachInflated !== undefined ? this.stomachInflated : <any>null;
        data["stomachIsHard"] = this.stomachIsHard !== undefined ? this.stomachIsHard : <any>null;
        data["stomachIsPainful"] = this.stomachIsPainful !== undefined ? this.stomachIsPainful : <any>null;
        data["stomachNormal"] = this.stomachNormal !== undefined ? this.stomachNormal : <any>null;
        data["stomachPeritonit"] = this.stomachPeritonit !== undefined ? this.stomachPeritonit : <any>null;
        data["stomachText"] = this.stomachText !== undefined ? this.stomachText : <any>null;
        data["tendonReflexesFK"] = this.tendonReflexesFK ? this.tendonReflexesFK.toJSON() : <any>null;
        data["titles"] = this.titles !== undefined ? this.titles : <any>null;
        data["titlesText"] = this.titlesText !== undefined ? this.titlesText : <any>null;
        data["tongueCleanFurred"] = this.tongueCleanFurred !== undefined ? this.tongueCleanFurred : <any>null;
        data["tongueWeatDry"] = this.tongueWeatDry !== undefined ? this.tongueWeatDry : <any>null;
        data["urineText"] = this.urineText !== undefined ? this.urineText : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        data["verbalResponse"] = this.verbalResponse !== undefined ? this.verbalResponse : <any>null;
        return data; 
    }
}

export interface ICardObjectiveBean {
    /** WTF!? [7] */
    additionObjectives?: string | null;
    /** ALCOOVERDOZE: Свежее дыхание */
    alcoBreath?: boolean | null;
    /** ALCOOVERDOZE: Лабильность */
    alcoEmotionLability?: boolean | null;
    /** ALCOOVERDOZE: Неадекват */
    alcoInadequate?: boolean | null;
    /** ALCOOVERDOZE: Поза Ромберга */
    alcoRombergPose?: boolean | null;
    /** ALCOOVERDOZE: Лунная алкопоходка */
    alcoShakyWalk?: boolean | null;
    /** ALCOOVERDOZE: Умение зачитывать по пьяни Rap God */
    alcoSpeechBehavior?: boolean | null;
    /** Наличие аллергии: признак */
    allergicAnamnesis?: boolean | null;
    /** Наличие аллергии: описание */
    allergicAnamnesisText?: string | null;
    /** Миндалины нормального размера */
    almondsNormalLarge?: boolean | null;
    /** WTF!? [3] */
    almondsPlaque?: boolean | null;
    /** Поведение */
    behaviourFK?: ReferenceTypeBean | null;
    /** Сухожильные рефлексы */
    breathAbsent?: boolean | null;
    /** Бронхиальное */
    breathBronchial?: boolean | null;
    /** Равномерное */
    breathEvenly?: boolean | null;
    /** Слабое/тяжелое(t/f) */
    breathIsWeak?: boolean | null;
    /** Чистое */
    breathPure?: boolean | null;
    /** Дыхание: комментарий */
    breathText?: string | null;
    /** Везикулярное */
    breathVesicular?: boolean | null;
    /** Жалобы и анамнез */
    complaintsAnamnesis?: string | null;
    /** Осложнения */
    complicationsFK?: ReferenceTypeBean | null;
    /** Осложнения (комментарий) */
    complicationsText?: string | null;
    /** Сознание */
    consciousFK?: ReferenceTypeBean | null;
    /** Дата заполнения карты */
    date?: Date | null;
    /** Дизурия */
    diuresisDisuria?: boolean | null;
    /** Гематурия */
    diuresisHematuria?: boolean | null;
    /** Диурез отсутствует */
    diuresisNo?: boolean | null;
    /** Олигурия */
    diuresisOliguria?: boolean | null;
    /** Расстройства пищеварения: диарея */
    dyspepticDiarrhea?: boolean | null;
    /** Расстройства пищеварения: тошнота */
    dyspepticNausea?: boolean | null;
    /** Расстройства пищеварения: запор */
    dyspepticRetch?: boolean | null;
    /** Расстройства пищеварения: нет */
    dyspepticsNo?: boolean | null;
    /** Сухожильные рефлексы */
    dyspneaFK?: ReferenceTypeBean | null;
    /** Признак наличия выделительной системы */
    excreta?: boolean | null;
    /** Состояние выделительной системы */
    excretaText?: string | null;
    /** ШКГ - Тест открывания глаз (E) */
    eyeOpening?: number | null;
    /** Общее состояние */
    generalStateFK?: ReferenceTypeBean | null;
    /** Глюкометрия */
    glucometry?: string | null;
    /** Гинекологический анамнез */
    gynecologicAnamnesis?: string | null;
    /** Сердце: АД */
    heartAd?: string | null;
    /** Сердце: АД максимальное */
    heartAdMax?: string | null;
    /** Сердце: АДН */
    heartAdn?: string | null;
    /** WTF!? [6] */
    heartBodyTemp?: string | null;
    /** Сердце: ЧД */
    heartChd?: string | null;
    /** Сердце: ЧСС */
    heartChss?: string | null;
    /** Сердечные шумы */
    heartNoiseFK?: ReferenceTypeBean | null;
    /** Сердце: Пульс */
    heartPs?: string | null;
    /** Пульс */
    heartPulseFK?: ReferenceTypeBean | null;
    /** Частота сердцебиения */
    heartRateFK?: ReferenceTypeBean | null;
    /** Тоны сердца */
    heartToneFK?: ReferenceTypeBean | null;
    id?: number | null;
    /** Анамнез болезней (чем сейчас болеет) */
    illnessAnamnesis?: string | null;
    /** Инфекционность */
    infectContacts?: string | null;
    /** WTF!? [4] */
    lionTappingLeft?: boolean | null;
    /** WTF!? [5] */
    lionTappingRight?: boolean | null;
    /** Печень: нормального размера */
    liverNormalLarge?: boolean | null;
    /** Печень: синдром Ортнера */
    liverOrtner?: boolean | null;
    /** Печень: размер */
    liverSizeText?: string | null;
    /** Легочные хрипы */
    lungsWheezing?: number | null;
    /** Легочные хрипы */
    lungsWheezingFK?: ReferenceTypeBean | null;
    /** Хрипы в легких: комментарий */
    lungsWheezingText?: string | null;
    /** Лимфоузлы: нормальный размер */
    lymphNodesNormalLarge?: boolean | null;
    /** Лимфоузлы: болезненные ощущения */
    lymphNodesPainful?: boolean | null;
    /** Лимфоузлы: комментарий */
    lymphNodesText?: string | null;
    /** Менингиальные синдромы */
    meningealReflexes?: boolean | null;
    /** ШКГ - Двигательный тест (M) */
    motorResponse?: number | null;
    /** WTF!? */
    multipleZevaCleanHyper?: boolean | null;
    /** Анамнез болезней (чем раньше болел) */
    pastIllnesses?: string | null;
    /** Патологические стопные рефлексы */
    pathologicalReflexes?: boolean | null;
    /** Анизокория */
    penaltiesAnisocoria?: boolean | null;
    /** Состояние зрачков одинаково выражено (D ? S) */
    penaltiesDsFK?: ReferenceTypeBean | null;
    /** Состояние зрачков */
    penaltiesFK?: ReferenceTypeBean | null;
    /** Реакция на свет */
    penaltiesLight?: boolean | null;
    /** Нистагм */
    penaltiesNystagmus?: boolean | null;
    /** Сравнительная перкуссия легких */
    percLungsSoundFK?: ReferenceTypeBean | null;
    /** Звук при перкуссии легких */
    percLungsSoundText?: string | null;
    /** Гемодинамика посттерапии */
    postTherapyHemodynamics?: string | null;
    /** ПульсOXXXYметрия */
    pulseOximetry?: string | null;
    /** Карантин */
    quarantine?: string | null;
    /** Рефлексы одинаково выражены (D ? S) */
    reflexesDsFK?: ReferenceTypeBean | null;
    /** Акроцианоз */
    skinAcrosianosis?: boolean | null;
    /** Цвет кожи */
    skinColorFK?: ReferenceTypeBean | null;
    /** Гиперимированность */
    skinHyperemetic?: boolean | null;
    /** Цианоз */
    skinIntegCyanotic?: boolean | null;
    /** Сухость/Потливость (t/f) */
    skinIsDry?: boolean | null;
    /** Кожа нормальная/нет */
    skinIsNormal?: boolean | null;
    /** Сыпь */
    skinRashes?: boolean | null;
    /** Желудочный асцит */
    stomachAscites?: boolean | null;
    /** Живот участвует в акте дыхания */
    stomachBreathingInvolved?: boolean | null;
    /** Желудок ??? */
    stomachDisklike?: boolean | null;
    /** Желудок вздутый */
    stomachInflated?: boolean | null;
    /** Желудок твердый */
    stomachIsHard?: boolean | null;
    /** Боль в желудке */
    stomachIsPainful?: boolean | null;
    /** Желудок в норме */
    stomachNormal?: boolean | null;
    /** Перитонит */
    stomachPeritonit?: boolean | null;
    /** Описание состояния брюшной полости */
    stomachText?: string | null;
    /** Сухожильные рефлексы */
    tendonReflexesFK?: ReferenceTypeBean | null;
    /** WTF!? [1] */
    titles?: boolean | null;
    /** WTF!? [2] */
    titlesText?: string | null;
    /** Признак влажности/сухости языка */
    tongueCleanFurred?: number | null;
    /** Признак чистоты языка */
    tongueWeatDry?: boolean | null;
    /** Мочеиспускание */
    urineText?: string | null;
    /** Вакцинация */
    vaccination?: string | null;
    /** ШКГ - Речевой тест (V) */
    verbalResponse?: number | null;
}

export class MobileCall implements IMobileCall {
    build?: string | null;
    caller_name?: string | null;
    caller_phone?: string | null;
    cards?: MobileCard[] | null;
    city?: string | null;
    date?: string | null;
    flat?: string | null;
    guid?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    patients?: MobilePatient[] | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    street?: string | null;
    time?: string | null;

    constructor(data?: IMobileCall) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.build = data["build"] !== undefined ? data["build"] : <any>null;
            this.caller_name = data["caller_name"] !== undefined ? data["caller_name"] : <any>null;
            this.caller_phone = data["caller_phone"] !== undefined ? data["caller_phone"] : <any>null;
            if (data["cards"] && data["cards"].constructor === Array) {
                this.cards = [];
                for (let item of data["cards"])
                    this.cards.push(MobileCard.fromJS(item));
            }
            this.city = data["city"] !== undefined ? data["city"] : <any>null;
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["patients"] && data["patients"].constructor === Array) {
                this.patients = [];
                for (let item of data["patients"])
                    this.patients.push(MobilePatient.fromJS(item));
            }
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_extra = data["reason_extra"] !== undefined ? data["reason_extra"] : <any>null;
            this.street = data["street"] !== undefined ? data["street"] : <any>null;
            this.time = data["time"] !== undefined ? data["time"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCall {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCall();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["build"] = this.build !== undefined ? this.build : <any>null;
        data["caller_name"] = this.caller_name !== undefined ? this.caller_name : <any>null;
        data["caller_phone"] = this.caller_phone !== undefined ? this.caller_phone : <any>null;
        if (this.cards && this.cards.constructor === Array) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.patients && this.patients.constructor === Array) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_extra"] = this.reason_extra !== undefined ? this.reason_extra : <any>null;
        data["street"] = this.street !== undefined ? this.street : <any>null;
        data["time"] = this.time !== undefined ? this.time : <any>null;
        return data; 
    }
}

export interface IMobileCall {
    build?: string | null;
    caller_name?: string | null;
    caller_phone?: string | null;
    cards?: MobileCard[] | null;
    city?: string | null;
    date?: string | null;
    flat?: string | null;
    guid?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    patients?: MobilePatient[] | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    street?: string | null;
    time?: string | null;
}

export class DocumentNomenclature implements IDocumentNomenclature {
    accepted?: boolean | null;
    adminConfig?: string | null;
    archived?: boolean | null;
    code?: string | null;
    date_doc?: Date | null;
    deleted?: boolean | null;
    description?: string | null;
    document?: Document | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    name?: string | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    online?: boolean | null;
    organization?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    packaging?: Packaging | null;
    packaging_count?: number | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    product?: Product | null;
    product_count?: number | null;
    product_id?: number | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    typeId?: number | null;
    typeName?: string | null;
    type_name?: string | null;
    unit_code?: string | null;
    unit_count?: number | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;

    constructor(data?: IDocumentNomenclature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accepted = data["accepted"] !== undefined ? data["accepted"] : <any>null;
            this.adminConfig = data["adminConfig"] !== undefined ? data["adminConfig"] : <any>null;
            this.archived = data["archived"] !== undefined ? data["archived"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.date_doc = data["date_doc"] ? new Date(data["date_doc"].toString()) : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.document = data["document"] ? Document.fromJS(data["document"]) : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["nomenclatures"] && data["nomenclatures"].constructor === Array) {
                this.nomenclatures = [];
                for (let item of data["nomenclatures"])
                    this.nomenclatures.push(DocumentNomenclature.fromJS(item));
            }
            this.number_doc = data["number_doc"] !== undefined ? data["number_doc"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.packaging = data["packaging"] ? Packaging.fromJS(data["packaging"]) : <any>null;
            this.packaging_count = data["packaging_count"] !== undefined ? data["packaging_count"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>null;
            this.product_count = data["product_count"] !== undefined ? data["product_count"] : <any>null;
            this.product_id = data["product_id"] !== undefined ? data["product_id"] : <any>null;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(Role.fromJS(item));
            }
            this.secondName = data["secondName"] !== undefined ? data["secondName"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            if (data["skills"] && data["skills"].constructor === Array) {
                this.skills = [];
                for (let item of data["skills"])
                    this.skills.push(Skill.fromJS(item));
            }
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.subdivisionName = data["subdivisionName"] !== undefined ? data["subdivisionName"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeId = data["typeId"] !== undefined ? data["typeId"] : <any>null;
            this.typeName = data["typeName"] !== undefined ? data["typeName"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
            this.unit_count = data["unit_count"] !== undefined ? data["unit_count"] : <any>null;
            this.userConfig = data["userConfig"] !== undefined ? data["userConfig"] : <any>null;
            this.workplaceSubdivisionId = data["workplaceSubdivisionId"] !== undefined ? data["workplaceSubdivisionId"] : <any>null;
            this.workplaceSubdivisionName = data["workplaceSubdivisionName"] !== undefined ? data["workplaceSubdivisionName"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentNomenclature {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentNomenclature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accepted"] = this.accepted !== undefined ? this.accepted : <any>null;
        data["adminConfig"] = this.adminConfig !== undefined ? this.adminConfig : <any>null;
        data["archived"] = this.archived !== undefined ? this.archived : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["date_doc"] = this.date_doc ? this.date_doc.toISOString() : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["document"] = this.document ? this.document.toJSON() : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.nomenclatures && this.nomenclatures.constructor === Array) {
            data["nomenclatures"] = [];
            for (let item of this.nomenclatures)
                data["nomenclatures"].push(item.toJSON());
        }
        data["number_doc"] = this.number_doc !== undefined ? this.number_doc : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["packaging"] = this.packaging ? this.packaging.toJSON() : <any>null;
        data["packaging_count"] = this.packaging_count !== undefined ? this.packaging_count : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["product_count"] = this.product_count !== undefined ? this.product_count : <any>null;
        data["product_id"] = this.product_id !== undefined ? this.product_id : <any>null;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["secondName"] = this.secondName !== undefined ? this.secondName : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        if (this.skills && this.skills.constructor === Array) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["subdivisionName"] = this.subdivisionName !== undefined ? this.subdivisionName : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeId"] = this.typeId !== undefined ? this.typeId : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        data["unit_count"] = this.unit_count !== undefined ? this.unit_count : <any>null;
        data["userConfig"] = this.userConfig !== undefined ? this.userConfig : <any>null;
        data["workplaceSubdivisionId"] = this.workplaceSubdivisionId !== undefined ? this.workplaceSubdivisionId : <any>null;
        data["workplaceSubdivisionName"] = this.workplaceSubdivisionName !== undefined ? this.workplaceSubdivisionName : <any>null;
        return data; 
    }
}

export interface IDocumentNomenclature {
    accepted?: boolean | null;
    adminConfig?: string | null;
    archived?: boolean | null;
    code?: string | null;
    date_doc?: Date | null;
    deleted?: boolean | null;
    description?: string | null;
    document?: Document | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    name?: string | null;
    nomenclatures?: DocumentNomenclature[] | null;
    number_doc?: string | null;
    online?: boolean | null;
    organization?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    packaging?: Packaging | null;
    packaging_count?: number | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    product?: Product | null;
    product_count?: number | null;
    product_id?: number | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    typeId?: number | null;
    typeName?: string | null;
    type_name?: string | null;
    unit_code?: string | null;
    unit_count?: number | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;
}

export class ListContainerOfPatientBean implements IListContainerOfPatientBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPatientBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPatientBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPatientBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPatientBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ProductType implements IProductType {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IProductType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ProductType {
        data = typeof data === 'object' ? data : {};
        let result = new ProductType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IProductType {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CarPathParams implements ICarPathParams {
    date_from?: Date | null;
    date_to?: Date | null;
    maxRow?: number | null;
    polygon?: MonPoint[] | null;
    statemark?: string | null;

    constructor(data?: ICarPathParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_from = data["date_from"] ? new Date(data["date_from"].toString()) : <any>null;
            this.date_to = data["date_to"] ? new Date(data["date_to"].toString()) : <any>null;
            this.maxRow = data["maxRow"] !== undefined ? data["maxRow"] : <any>null;
            if (data["polygon"] && data["polygon"].constructor === Array) {
                this.polygon = [];
                for (let item of data["polygon"])
                    this.polygon.push(MonPoint.fromJS(item));
            }
            this.statemark = data["statemark"] !== undefined ? data["statemark"] : <any>null;
        }
    }

    static fromJS(data: any): CarPathParams {
        data = typeof data === 'object' ? data : {};
        let result = new CarPathParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_from"] = this.date_from ? this.date_from.toISOString() : <any>null;
        data["date_to"] = this.date_to ? this.date_to.toISOString() : <any>null;
        data["maxRow"] = this.maxRow !== undefined ? this.maxRow : <any>null;
        if (this.polygon && this.polygon.constructor === Array) {
            data["polygon"] = [];
            for (let item of this.polygon)
                data["polygon"].push(item.toJSON());
        }
        data["statemark"] = this.statemark !== undefined ? this.statemark : <any>null;
        return data; 
    }
}

export interface ICarPathParams {
    date_from?: Date | null;
    date_to?: Date | null;
    maxRow?: number | null;
    polygon?: MonPoint[] | null;
    statemark?: string | null;
}

export class Code implements ICode {
    value?: string | null;

    constructor(data?: ICode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Code {
        data = typeof data === 'object' ? data : {};
        let result = new Code();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface ICode {
    value?: string | null;
}

export class PerformerTypeBean implements IPerformerTypeBean {
    code?: string | null;
    /** Группа сотрудника */
    groupCode?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Краткое наименование */
    shortName?: string | null;

    constructor(data?: IPerformerTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.groupCode = data["groupCode"] !== undefined ? data["groupCode"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["groupCode"] = this.groupCode !== undefined ? this.groupCode : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        return data; 
    }
}

export interface IPerformerTypeBean {
    code?: string | null;
    /** Группа сотрудника */
    groupCode?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Краткое наименование */
    shortName?: string | null;
}

export class CardObjectivePercPartDto implements ICardObjectivePercPartDto {
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;

    constructor(data?: ICardObjectivePercPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.perc_lungs_sound_id = data["perc_lungs_sound_id"] !== undefined ? data["perc_lungs_sound_id"] : <any>null;
            this.perc_lungs_sound_name = data["perc_lungs_sound_name"] !== undefined ? data["perc_lungs_sound_name"] : <any>null;
            this.perc_lungs_sound_text = data["perc_lungs_sound_text"] !== undefined ? data["perc_lungs_sound_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePercPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePercPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["perc_lungs_sound_id"] = this.perc_lungs_sound_id !== undefined ? this.perc_lungs_sound_id : <any>null;
        data["perc_lungs_sound_name"] = this.perc_lungs_sound_name !== undefined ? this.perc_lungs_sound_name : <any>null;
        data["perc_lungs_sound_text"] = this.perc_lungs_sound_text !== undefined ? this.perc_lungs_sound_text : <any>null;
        return data; 
    }
}

export interface ICardObjectivePercPartDto {
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;
}

export class CardObjectiveStomachPartDto implements ICardObjectiveStomachPartDto {
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;

    constructor(data?: ICardObjectiveStomachPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stomach_ascites = data["stomach_ascites"] !== undefined ? data["stomach_ascites"] : <any>null;
            this.stomach_breathing_involved = data["stomach_breathing_involved"] !== undefined ? data["stomach_breathing_involved"] : <any>null;
            this.stomach_breathing_involved_name = data["stomach_breathing_involved_name"] !== undefined ? data["stomach_breathing_involved_name"] : <any>null;
            this.stomach_disklike = data["stomach_disklike"] !== undefined ? data["stomach_disklike"] : <any>null;
            this.stomach_hard = data["stomach_hard"] !== undefined ? data["stomach_hard"] : <any>null;
            this.stomach_infliat = data["stomach_infliat"] !== undefined ? data["stomach_infliat"] : <any>null;
            this.stomach_normal = data["stomach_normal"] !== undefined ? data["stomach_normal"] : <any>null;
            this.stomach_painful = data["stomach_painful"] !== undefined ? data["stomach_painful"] : <any>null;
            this.stomach_peritonit = data["stomach_peritonit"] !== undefined ? data["stomach_peritonit"] : <any>null;
            this.stomach_peritonit_name = data["stomach_peritonit_name"] !== undefined ? data["stomach_peritonit_name"] : <any>null;
            this.stomach_soft = data["stomach_soft"] !== undefined ? data["stomach_soft"] : <any>null;
            this.stomach_text = data["stomach_text"] !== undefined ? data["stomach_text"] : <any>null;
            this.stomach_unpainful = data["stomach_unpainful"] !== undefined ? data["stomach_unpainful"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveStomachPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveStomachPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stomach_ascites"] = this.stomach_ascites !== undefined ? this.stomach_ascites : <any>null;
        data["stomach_breathing_involved"] = this.stomach_breathing_involved !== undefined ? this.stomach_breathing_involved : <any>null;
        data["stomach_breathing_involved_name"] = this.stomach_breathing_involved_name !== undefined ? this.stomach_breathing_involved_name : <any>null;
        data["stomach_disklike"] = this.stomach_disklike !== undefined ? this.stomach_disklike : <any>null;
        data["stomach_hard"] = this.stomach_hard !== undefined ? this.stomach_hard : <any>null;
        data["stomach_infliat"] = this.stomach_infliat !== undefined ? this.stomach_infliat : <any>null;
        data["stomach_normal"] = this.stomach_normal !== undefined ? this.stomach_normal : <any>null;
        data["stomach_painful"] = this.stomach_painful !== undefined ? this.stomach_painful : <any>null;
        data["stomach_peritonit"] = this.stomach_peritonit !== undefined ? this.stomach_peritonit : <any>null;
        data["stomach_peritonit_name"] = this.stomach_peritonit_name !== undefined ? this.stomach_peritonit_name : <any>null;
        data["stomach_soft"] = this.stomach_soft !== undefined ? this.stomach_soft : <any>null;
        data["stomach_text"] = this.stomach_text !== undefined ? this.stomach_text : <any>null;
        data["stomach_unpainful"] = this.stomach_unpainful !== undefined ? this.stomach_unpainful : <any>null;
        return data; 
    }
}

export interface ICardObjectiveStomachPartDto {
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;
}

export class TransportDto implements ITransportDto {
    brand?: string | null;
    can_use?: boolean | null;
    class_id?: number | null;
    class_name?: string | null;
    color?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    picture?: string | null;
    state_mark?: string | null;
    status_description?: string | null;
    status_id?: number | null;
    status_name?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ITransportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brand = data["brand"] !== undefined ? data["brand"] : <any>null;
            this.can_use = data["can_use"] !== undefined ? data["can_use"] : <any>null;
            this.class_id = data["class_id"] !== undefined ? data["class_id"] : <any>null;
            this.class_name = data["class_name"] !== undefined ? data["class_name"] : <any>null;
            this.color = data["color"] !== undefined ? data["color"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.state_mark = data["state_mark"] !== undefined ? data["state_mark"] : <any>null;
            this.status_description = data["status_description"] !== undefined ? data["status_description"] : <any>null;
            this.status_id = data["status_id"] !== undefined ? data["status_id"] : <any>null;
            this.status_name = data["status_name"] !== undefined ? data["status_name"] : <any>null;
            this.sub_code = data["sub_code"] !== undefined ? data["sub_code"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): TransportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand !== undefined ? this.brand : <any>null;
        data["can_use"] = this.can_use !== undefined ? this.can_use : <any>null;
        data["class_id"] = this.class_id !== undefined ? this.class_id : <any>null;
        data["class_name"] = this.class_name !== undefined ? this.class_name : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["state_mark"] = this.state_mark !== undefined ? this.state_mark : <any>null;
        data["status_description"] = this.status_description !== undefined ? this.status_description : <any>null;
        data["status_id"] = this.status_id !== undefined ? this.status_id : <any>null;
        data["status_name"] = this.status_name !== undefined ? this.status_name : <any>null;
        data["sub_code"] = this.sub_code !== undefined ? this.sub_code : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ITransportDto {
    brand?: string | null;
    can_use?: boolean | null;
    class_id?: number | null;
    class_name?: string | null;
    color?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    picture?: string | null;
    state_mark?: string | null;
    status_description?: string | null;
    status_id?: number | null;
    status_name?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class AndyTreeNodeOfClassMkbBean implements IAndyTreeNodeOfClassMkbBean {
    children?: AndyTreeNodeOfClassMkbBean[] | null;
    data?: ClassMkbBean | null;

    constructor(data?: IAndyTreeNodeOfClassMkbBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(AndyTreeNodeOfClassMkbBean.fromJS(item));
            }
            this.data = data["data"] ? ClassMkbBean.fromJS(data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): AndyTreeNodeOfClassMkbBean {
        data = typeof data === 'object' ? data : {};
        let result = new AndyTreeNodeOfClassMkbBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IAndyTreeNodeOfClassMkbBean {
    children?: AndyTreeNodeOfClassMkbBean[] | null;
    data?: ClassMkbBean | null;
}

export class CardAnamnesisPartDto implements ICardAnamnesisPartDto {
    allergic?: CardAnamnesisAllergicPartDto | null;
    complaints?: CardAnamnesisComplaintsPartDto | null;
    epidemic?: CardAnamnesisEpidemicPartDto | null;
    gynecologic?: CardAnamnesisGynecologicPartDto | null;
    header?: CardAnamnesisHeaderDto | null;
    illnes?: CardAnamnesisIllnesPartDto | null;

    constructor(data?: ICardAnamnesisPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic = data["allergic"] ? CardAnamnesisAllergicPartDto.fromJS(data["allergic"]) : <any>null;
            this.complaints = data["complaints"] ? CardAnamnesisComplaintsPartDto.fromJS(data["complaints"]) : <any>null;
            this.epidemic = data["epidemic"] ? CardAnamnesisEpidemicPartDto.fromJS(data["epidemic"]) : <any>null;
            this.gynecologic = data["gynecologic"] ? CardAnamnesisGynecologicPartDto.fromJS(data["gynecologic"]) : <any>null;
            this.header = data["header"] ? CardAnamnesisHeaderDto.fromJS(data["header"]) : <any>null;
            this.illnes = data["illnes"] ? CardAnamnesisIllnesPartDto.fromJS(data["illnes"]) : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic"] = this.allergic ? this.allergic.toJSON() : <any>null;
        data["complaints"] = this.complaints ? this.complaints.toJSON() : <any>null;
        data["epidemic"] = this.epidemic ? this.epidemic.toJSON() : <any>null;
        data["gynecologic"] = this.gynecologic ? this.gynecologic.toJSON() : <any>null;
        data["header"] = this.header ? this.header.toJSON() : <any>null;
        data["illnes"] = this.illnes ? this.illnes.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisPartDto {
    allergic?: CardAnamnesisAllergicPartDto | null;
    complaints?: CardAnamnesisComplaintsPartDto | null;
    epidemic?: CardAnamnesisEpidemicPartDto | null;
    gynecologic?: CardAnamnesisGynecologicPartDto | null;
    header?: CardAnamnesisHeaderDto | null;
    illnes?: CardAnamnesisIllnesPartDto | null;
}

export class TransportBean implements ITransportBean {
    /** Номер */
    code?: string | null;
    /** Цвет */
    color?: string | null;
    id?: number | null;
    /** Признак выхода из зоны */
    isAreaOut?: boolean | null;
    /** Признак возможности использования */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    /** Расположение */
    location?: PGgeometry | null;
    /** Марка/модель автомобиля */
    name?: string | null;
    /** Изображение транспорта */
    picture?: string | null;
    /** Описание статуса */
    statusDescription?: string | null;
    /** ID подразделения */
    subdivision?: number | null;

    constructor(data?: ITransportBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.color = data["color"] !== undefined ? data["color"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAreaOut = data["isAreaOut"] !== undefined ? data["isAreaOut"] : <any>null;
            this.isAvailable = data["isAvailable"] !== undefined ? data["isAvailable"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.location = data["location"] ? PGgeometry.fromJS(data["location"]) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.statusDescription = data["statusDescription"] !== undefined ? data["statusDescription"] : <any>null;
            this.subdivision = data["subdivision"] !== undefined ? data["subdivision"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBean {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAreaOut"] = this.isAreaOut !== undefined ? this.isAreaOut : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["statusDescription"] = this.statusDescription !== undefined ? this.statusDescription : <any>null;
        data["subdivision"] = this.subdivision !== undefined ? this.subdivision : <any>null;
        return data; 
    }
}

export interface ITransportBean {
    /** Номер */
    code?: string | null;
    /** Цвет */
    color?: string | null;
    id?: number | null;
    /** Признак выхода из зоны */
    isAreaOut?: boolean | null;
    /** Признак возможности использования */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    /** Расположение */
    location?: PGgeometry | null;
    /** Марка/модель автомобиля */
    name?: string | null;
    /** Изображение транспорта */
    picture?: string | null;
    /** Описание статуса */
    statusDescription?: string | null;
    /** ID подразделения */
    subdivision?: number | null;
}

export class BrigadePerformerScheduleBean implements IBrigadePerformerScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;

    constructor(data?: IBrigadePerformerScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeSchedule = data["brigadeSchedule"] !== undefined ? data["brigadeSchedule"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.dutyEndDate = data["dutyEndDate"] ? new Date(data["dutyEndDate"].toString()) : <any>null;
            this.dutyStartDate = data["dutyStartDate"] ? new Date(data["dutyStartDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadePerformerScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadePerformerScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeSchedule"] = this.brigadeSchedule !== undefined ? this.brigadeSchedule : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["dutyEndDate"] = this.dutyEndDate ? this.dutyEndDate.toISOString() : <any>null;
        data["dutyStartDate"] = this.dutyStartDate ? this.dutyStartDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadePerformerScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;
}

export class MobileCardAddress implements IMobileCardAddress {
    building?: string | null;
    city?: string | null;
    country?: string | null;
    district?: string | null;
    flat?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    region?: string | null;
    street?: string | null;

    constructor(data?: IMobileCardAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.city = data["city"] !== undefined ? data["city"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.region = data["region"] !== undefined ? data["region"] : <any>null;
            this.street = data["street"] !== undefined ? data["street"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardAddress {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["region"] = this.region !== undefined ? this.region : <any>null;
        data["street"] = this.street !== undefined ? this.street : <any>null;
        return data; 
    }
}

export interface IMobileCardAddress {
    building?: string | null;
    city?: string | null;
    country?: string | null;
    district?: string | null;
    flat?: string | null;
    house?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    region?: string | null;
    street?: string | null;
}

export class SettlementBean implements ISettlementBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Район */
    district?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Землепользование */
    landuse?: string | null;
    /** Наименование населенного пункта */
    name?: string | null;
    /** Регион */
    regionAddress?: string | null;

    constructor(data?: ISettlementBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityAddress = data["cityAddress"] !== undefined ? data["cityAddress"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.geometry = data["geometry"] ? PGgeometry.fromJS(data["geometry"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.idOSM = data["idOSM"] !== undefined ? data["idOSM"] : <any>null;
            this.landuse = data["landuse"] !== undefined ? data["landuse"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.regionAddress = data["regionAddress"] !== undefined ? data["regionAddress"] : <any>null;
        }
    }

    static fromJS(data: any): SettlementBean {
        data = typeof data === 'object' ? data : {};
        let result = new SettlementBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityAddress"] = this.cityAddress !== undefined ? this.cityAddress : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["idOSM"] = this.idOSM !== undefined ? this.idOSM : <any>null;
        data["landuse"] = this.landuse !== undefined ? this.landuse : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["regionAddress"] = this.regionAddress !== undefined ? this.regionAddress : <any>null;
        return data; 
    }
}

export interface ISettlementBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Район */
    district?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Землепользование */
    landuse?: string | null;
    /** Наименование населенного пункта */
    name?: string | null;
    /** Регион */
    regionAddress?: string | null;
}

export class PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean implements IPairOfPerformerBeanAndListOfBrigadePerformerScheduleBean {
    first?: PerformerBean | null;
    second?: BrigadePerformerScheduleBean[] | null;

    constructor(data?: IPairOfPerformerBeanAndListOfBrigadePerformerScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? PerformerBean.fromJS(data["first"]) : <any>null;
            if (data["second"] && data["second"].constructor === Array) {
                this.second = [];
                for (let item of data["second"])
                    this.second.push(BrigadePerformerScheduleBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfPerformerBeanAndListOfBrigadePerformerScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        if (this.second && this.second.constructor === Array) {
            data["second"] = [];
            for (let item of this.second)
                data["second"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPairOfPerformerBeanAndListOfBrigadePerformerScheduleBean {
    first?: PerformerBean | null;
    second?: BrigadePerformerScheduleBean[] | null;
}

export class Inventory implements IInventory {
    code?: string | null;
    count?: number | null;
    count_current?: number | null;
    count_min?: number | null;
    date_inventory?: Date | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    nomenclatures?: InventoryNomenclature[] | null;
    owner_id?: number | null;
    owner_name?: string | null;
    place?: Place | null;
    product?: Product | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    type_name?: string | null;
    unit_code?: string | null;

    constructor(data?: IInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.count_current = data["count_current"] !== undefined ? data["count_current"] : <any>null;
            this.count_min = data["count_min"] !== undefined ? data["count_min"] : <any>null;
            this.date_inventory = data["date_inventory"] ? new Date(data["date_inventory"].toString()) : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["nomenclatures"] && data["nomenclatures"].constructor === Array) {
                this.nomenclatures = [];
                for (let item of data["nomenclatures"])
                    this.nomenclatures.push(InventoryNomenclature.fromJS(item));
            }
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.place = data["place"] ? Place.fromJS(data["place"]) : <any>null;
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): Inventory {
        data = typeof data === 'object' ? data : {};
        let result = new Inventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["count_current"] = this.count_current !== undefined ? this.count_current : <any>null;
        data["count_min"] = this.count_min !== undefined ? this.count_min : <any>null;
        data["date_inventory"] = this.date_inventory ? this.date_inventory.toISOString() : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.nomenclatures && this.nomenclatures.constructor === Array) {
            data["nomenclatures"] = [];
            for (let item of this.nomenclatures)
                data["nomenclatures"].push(item.toJSON());
        }
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["place"] = this.place ? this.place.toJSON() : <any>null;
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IInventory {
    code?: string | null;
    count?: number | null;
    count_current?: number | null;
    count_min?: number | null;
    date_inventory?: Date | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    name?: string | null;
    nomenclatures?: InventoryNomenclature[] | null;
    owner_id?: number | null;
    owner_name?: string | null;
    place?: Place | null;
    product?: Product | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: string | null;
    type_name?: string | null;
    unit_code?: string | null;
}

export class MobilePatient implements IMobilePatient {
    age?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    citizenship?: string | null;
    city?: string | null;
    country?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    previous_cards?: MobileCardChronic[] | null;
    sex_id?: number | null;
    social_property_id?: number | null;
    surname?: string | null;
    type?: string | null;

    constructor(data?: IMobilePatient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.age = data["age"] !== undefined ? data["age"] : <any>null;
            this.age_days = data["age_days"] !== undefined ? data["age_days"] : <any>null;
            this.age_months = data["age_months"] !== undefined ? data["age_months"] : <any>null;
            this.age_years = data["age_years"] !== undefined ? data["age_years"] : <any>null;
            this.birth_date = data["birth_date"] !== undefined ? data["birth_date"] : <any>null;
            this.citizenship = data["citizenship"] !== undefined ? data["citizenship"] : <any>null;
            this.city = data["city"] !== undefined ? data["city"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.firstname = data["firstname"] !== undefined ? data["firstname"] : <any>null;
            this.job = data["job"] !== undefined ? data["job"] : <any>null;
            this.job_position = data["job_position"] !== undefined ? data["job_position"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            if (data["previous_cards"] && data["previous_cards"].constructor === Array) {
                this.previous_cards = [];
                for (let item of data["previous_cards"])
                    this.previous_cards.push(MobileCardChronic.fromJS(item));
            }
            this.sex_id = data["sex_id"] !== undefined ? data["sex_id"] : <any>null;
            this.social_property_id = data["social_property_id"] !== undefined ? data["social_property_id"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): MobilePatient {
        data = typeof data === 'object' ? data : {};
        let result = new MobilePatient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["age"] = this.age !== undefined ? this.age : <any>null;
        data["age_days"] = this.age_days !== undefined ? this.age_days : <any>null;
        data["age_months"] = this.age_months !== undefined ? this.age_months : <any>null;
        data["age_years"] = this.age_years !== undefined ? this.age_years : <any>null;
        data["birth_date"] = this.birth_date !== undefined ? this.birth_date : <any>null;
        data["citizenship"] = this.citizenship !== undefined ? this.citizenship : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["firstname"] = this.firstname !== undefined ? this.firstname : <any>null;
        data["job"] = this.job !== undefined ? this.job : <any>null;
        data["job_position"] = this.job_position !== undefined ? this.job_position : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        if (this.previous_cards && this.previous_cards.constructor === Array) {
            data["previous_cards"] = [];
            for (let item of this.previous_cards)
                data["previous_cards"].push(item.toJSON());
        }
        data["sex_id"] = this.sex_id !== undefined ? this.sex_id : <any>null;
        data["social_property_id"] = this.social_property_id !== undefined ? this.social_property_id : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IMobilePatient {
    age?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    citizenship?: string | null;
    city?: string | null;
    country?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    previous_cards?: MobileCardChronic[] | null;
    sex_id?: number | null;
    social_property_id?: number | null;
    surname?: string | null;
    type?: string | null;
}

export class TherapyItemDto implements ITherapyItemDto {
    count?: number | null;
    id?: number | null;
    product_name?: string | null;
    therapy_id?: number | null;

    constructor(data?: ITherapyItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.product_name = data["product_name"] !== undefined ? data["product_name"] : <any>null;
            this.therapy_id = data["therapy_id"] !== undefined ? data["therapy_id"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["product_name"] = this.product_name !== undefined ? this.product_name : <any>null;
        data["therapy_id"] = this.therapy_id !== undefined ? this.therapy_id : <any>null;
        return data; 
    }
}

export interface ITherapyItemDto {
    count?: number | null;
    id?: number | null;
    product_name?: string | null;
    therapy_id?: number | null;
}

export class MobileCardDocument implements IMobileCardDocument {
    date?: string | null;
    name?: string | null;
    number?: string | null;
    organisation?: string | null;
    serie?: string | null;
    type_id?: number | null;

    constructor(data?: IMobileCardDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.organisation = data["organisation"] !== undefined ? data["organisation"] : <any>null;
            this.serie = data["serie"] !== undefined ? data["serie"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardDocument {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["organisation"] = this.organisation !== undefined ? this.organisation : <any>null;
        data["serie"] = this.serie !== undefined ? this.serie : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        return data; 
    }
}

export interface IMobileCardDocument {
    date?: string | null;
    name?: string | null;
    number?: string | null;
    organisation?: string | null;
    serie?: string | null;
    type_id?: number | null;
}

export class BrigadeScheduleDto implements IBrigadeScheduleDto {
    active_calls?: number | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    is_edited?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    performers?: PerformerBrigScheduleDto[] | null;
    period_details?: PeriodDetails | null;
    pharmacy_package_id?: number | null;
    pharmacy_package_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    transports?: TransportBrigScheduleDto[] | null;

    constructor(data?: IBrigadeScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active_calls = data["active_calls"] !== undefined ? data["active_calls"] : <any>null;
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
            this.brigade_name = data["brigade_name"] !== undefined ? data["brigade_name"] : <any>null;
            this.brigade_status_id = data["brigade_status_id"] !== undefined ? data["brigade_status_id"] : <any>null;
            this.brigade_status_name = data["brigade_status_name"] !== undefined ? data["brigade_status_name"] : <any>null;
            this.brigade_type_code = data["brigade_type_code"] !== undefined ? data["brigade_type_code"] : <any>null;
            this.brigade_type_id = data["brigade_type_id"] !== undefined ? data["brigade_type_id"] : <any>null;
            this.brigade_type_name = data["brigade_type_name"] !== undefined ? data["brigade_type_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_edited = data["is_edited"] !== undefined ? data["is_edited"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerBrigScheduleDto.fromJS(item));
            }
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.pharmacy_package_id = data["pharmacy_package_id"] !== undefined ? data["pharmacy_package_id"] : <any>null;
            this.pharmacy_package_name = data["pharmacy_package_name"] !== undefined ? data["pharmacy_package_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            if (data["transports"] && data["transports"].constructor === Array) {
                this.transports = [];
                for (let item of data["transports"])
                    this.transports.push(TransportBrigScheduleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrigadeScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active_calls"] = this.active_calls !== undefined ? this.active_calls : <any>null;
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        data["brigade_name"] = this.brigade_name !== undefined ? this.brigade_name : <any>null;
        data["brigade_status_id"] = this.brigade_status_id !== undefined ? this.brigade_status_id : <any>null;
        data["brigade_status_name"] = this.brigade_status_name !== undefined ? this.brigade_status_name : <any>null;
        data["brigade_type_code"] = this.brigade_type_code !== undefined ? this.brigade_type_code : <any>null;
        data["brigade_type_id"] = this.brigade_type_id !== undefined ? this.brigade_type_id : <any>null;
        data["brigade_type_name"] = this.brigade_type_name !== undefined ? this.brigade_type_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_edited"] = this.is_edited !== undefined ? this.is_edited : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["pharmacy_package_id"] = this.pharmacy_package_id !== undefined ? this.pharmacy_package_id : <any>null;
        data["pharmacy_package_name"] = this.pharmacy_package_name !== undefined ? this.pharmacy_package_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        if (this.transports && this.transports.constructor === Array) {
            data["transports"] = [];
            for (let item of this.transports)
                data["transports"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrigadeScheduleDto {
    active_calls?: number | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    is_edited?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    performers?: PerformerBrigScheduleDto[] | null;
    period_details?: PeriodDetails | null;
    pharmacy_package_id?: number | null;
    pharmacy_package_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    transports?: TransportBrigScheduleDto[] | null;
}

export class ListContainerOfSubdivisionTypeBean implements IListContainerOfSubdivisionTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfSubdivisionTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfSubdivisionTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfSubdivisionTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfSubdivisionTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveOtherPartDto implements ICardObjectiveOtherPartDto {
    ad?: string | null;
    admax?: string | null;
    adn?: string | null;
    bodytemp?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;

    constructor(data?: ICardObjectiveOtherPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ad = data["ad"] !== undefined ? data["ad"] : <any>null;
            this.admax = data["admax"] !== undefined ? data["admax"] : <any>null;
            this.adn = data["adn"] !== undefined ? data["adn"] : <any>null;
            this.bodytemp = data["bodytemp"] !== undefined ? data["bodytemp"] : <any>null;
            this.chd = data["chd"] !== undefined ? data["chd"] : <any>null;
            this.chss = data["chss"] !== undefined ? data["chss"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.ps = data["ps"] !== undefined ? data["ps"] : <any>null;
            this.pulse_oximetry = data["pulse_oximetry"] !== undefined ? data["pulse_oximetry"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveOtherPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveOtherPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ad"] = this.ad !== undefined ? this.ad : <any>null;
        data["admax"] = this.admax !== undefined ? this.admax : <any>null;
        data["adn"] = this.adn !== undefined ? this.adn : <any>null;
        data["bodytemp"] = this.bodytemp !== undefined ? this.bodytemp : <any>null;
        data["chd"] = this.chd !== undefined ? this.chd : <any>null;
        data["chss"] = this.chss !== undefined ? this.chss : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["ps"] = this.ps !== undefined ? this.ps : <any>null;
        data["pulse_oximetry"] = this.pulse_oximetry !== undefined ? this.pulse_oximetry : <any>null;
        return data; 
    }
}

export interface ICardObjectiveOtherPartDto {
    ad?: string | null;
    admax?: string | null;
    adn?: string | null;
    bodytemp?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;
}

export class Timestamp implements ITimestamp {
    date?: number | null;
    day?: number | null;
    hours?: number | null;
    minutes?: number | null;
    month?: number | null;
    nanos?: number | null;
    seconds?: number | null;
    time?: number | null;
    timezoneOffset?: number | null;
    year?: number | null;

    constructor(data?: ITimestamp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.day = data["day"] !== undefined ? data["day"] : <any>null;
            this.hours = data["hours"] !== undefined ? data["hours"] : <any>null;
            this.minutes = data["minutes"] !== undefined ? data["minutes"] : <any>null;
            this.month = data["month"] !== undefined ? data["month"] : <any>null;
            this.nanos = data["nanos"] !== undefined ? data["nanos"] : <any>null;
            this.seconds = data["seconds"] !== undefined ? data["seconds"] : <any>null;
            this.time = data["time"] !== undefined ? data["time"] : <any>null;
            this.timezoneOffset = data["timezoneOffset"] !== undefined ? data["timezoneOffset"] : <any>null;
            this.year = data["year"] !== undefined ? data["year"] : <any>null;
        }
    }

    static fromJS(data: any): Timestamp {
        data = typeof data === 'object' ? data : {};
        let result = new Timestamp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["day"] = this.day !== undefined ? this.day : <any>null;
        data["hours"] = this.hours !== undefined ? this.hours : <any>null;
        data["minutes"] = this.minutes !== undefined ? this.minutes : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["nanos"] = this.nanos !== undefined ? this.nanos : <any>null;
        data["seconds"] = this.seconds !== undefined ? this.seconds : <any>null;
        data["time"] = this.time !== undefined ? this.time : <any>null;
        data["timezoneOffset"] = this.timezoneOffset !== undefined ? this.timezoneOffset : <any>null;
        data["year"] = this.year !== undefined ? this.year : <any>null;
        return data; 
    }
}

export interface ITimestamp {
    date?: number | null;
    day?: number | null;
    hours?: number | null;
    minutes?: number | null;
    month?: number | null;
    nanos?: number | null;
    seconds?: number | null;
    time?: number | null;
    timezoneOffset?: number | null;
    year?: number | null;
}

export class CardObjectivePartDto implements ICardObjectivePartDto {
    addition?: CardObjectiveAdditionPartDto | null;
    alcohol?: CardObjectiveAlcoPartDto | null;
    breath?: CardObjectiveBreathPartDto | null;
    diuresis?: CardObjectiveDiuresisPartDto | null;
    dyspeptic?: CardObjectiveDyspepticPartDto | null;
    edema?: CardObjectiveEdemaPartDto | null;
    excreta?: CardObjectiveExcretaUrinePartDto | null;
    general_state?: CardObjectiveGeneralStatePartDto | null;
    glasgow?: CardObjectiveGlasgowPartDto | null;
    header?: CardObjectiveHeaderDto | null;
    heart?: CardObjectiveHeartPartDto | null;
    hemodynamics?: CardAnamnesisHemodynamicsPartDto | null;
    liver?: CardObjectiveLiverPartDto | null;
    lymph?: CardObjectiveLymphPartDto | null;
    other?: CardObjectiveOtherPartDto | null;
    perc?: CardObjectivePercPartDto | null;
    pupils?: CardObjectivePupilsDto | null;
    reflexes?: CardObjectiveReflexesDto | null;
    skin?: CardObjectiveSkinPartDto | null;
    stomach?: CardObjectiveStomachPartDto | null;
    throat?: CardObjectiveThroatPartDto | null;
    tongue?: CardObjectiveTonguePart | null;
    tonsils?: CardObjectiveTonsilsPartDto | null;
    wheezing?: CardObjectiveWheezingPartDto | null;

    constructor(data?: ICardObjectivePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addition = data["addition"] ? CardObjectiveAdditionPartDto.fromJS(data["addition"]) : <any>null;
            this.alcohol = data["alcohol"] ? CardObjectiveAlcoPartDto.fromJS(data["alcohol"]) : <any>null;
            this.breath = data["breath"] ? CardObjectiveBreathPartDto.fromJS(data["breath"]) : <any>null;
            this.diuresis = data["diuresis"] ? CardObjectiveDiuresisPartDto.fromJS(data["diuresis"]) : <any>null;
            this.dyspeptic = data["dyspeptic"] ? CardObjectiveDyspepticPartDto.fromJS(data["dyspeptic"]) : <any>null;
            this.edema = data["edema"] ? CardObjectiveEdemaPartDto.fromJS(data["edema"]) : <any>null;
            this.excreta = data["excreta"] ? CardObjectiveExcretaUrinePartDto.fromJS(data["excreta"]) : <any>null;
            this.general_state = data["general_state"] ? CardObjectiveGeneralStatePartDto.fromJS(data["general_state"]) : <any>null;
            this.glasgow = data["glasgow"] ? CardObjectiveGlasgowPartDto.fromJS(data["glasgow"]) : <any>null;
            this.header = data["header"] ? CardObjectiveHeaderDto.fromJS(data["header"]) : <any>null;
            this.heart = data["heart"] ? CardObjectiveHeartPartDto.fromJS(data["heart"]) : <any>null;
            this.hemodynamics = data["hemodynamics"] ? CardAnamnesisHemodynamicsPartDto.fromJS(data["hemodynamics"]) : <any>null;
            this.liver = data["liver"] ? CardObjectiveLiverPartDto.fromJS(data["liver"]) : <any>null;
            this.lymph = data["lymph"] ? CardObjectiveLymphPartDto.fromJS(data["lymph"]) : <any>null;
            this.other = data["other"] ? CardObjectiveOtherPartDto.fromJS(data["other"]) : <any>null;
            this.perc = data["perc"] ? CardObjectivePercPartDto.fromJS(data["perc"]) : <any>null;
            this.pupils = data["pupils"] ? CardObjectivePupilsDto.fromJS(data["pupils"]) : <any>null;
            this.reflexes = data["reflexes"] ? CardObjectiveReflexesDto.fromJS(data["reflexes"]) : <any>null;
            this.skin = data["skin"] ? CardObjectiveSkinPartDto.fromJS(data["skin"]) : <any>null;
            this.stomach = data["stomach"] ? CardObjectiveStomachPartDto.fromJS(data["stomach"]) : <any>null;
            this.throat = data["throat"] ? CardObjectiveThroatPartDto.fromJS(data["throat"]) : <any>null;
            this.tongue = data["tongue"] ? CardObjectiveTonguePart.fromJS(data["tongue"]) : <any>null;
            this.tonsils = data["tonsils"] ? CardObjectiveTonsilsPartDto.fromJS(data["tonsils"]) : <any>null;
            this.wheezing = data["wheezing"] ? CardObjectiveWheezingPartDto.fromJS(data["wheezing"]) : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addition"] = this.addition ? this.addition.toJSON() : <any>null;
        data["alcohol"] = this.alcohol ? this.alcohol.toJSON() : <any>null;
        data["breath"] = this.breath ? this.breath.toJSON() : <any>null;
        data["diuresis"] = this.diuresis ? this.diuresis.toJSON() : <any>null;
        data["dyspeptic"] = this.dyspeptic ? this.dyspeptic.toJSON() : <any>null;
        data["edema"] = this.edema ? this.edema.toJSON() : <any>null;
        data["excreta"] = this.excreta ? this.excreta.toJSON() : <any>null;
        data["general_state"] = this.general_state ? this.general_state.toJSON() : <any>null;
        data["glasgow"] = this.glasgow ? this.glasgow.toJSON() : <any>null;
        data["header"] = this.header ? this.header.toJSON() : <any>null;
        data["heart"] = this.heart ? this.heart.toJSON() : <any>null;
        data["hemodynamics"] = this.hemodynamics ? this.hemodynamics.toJSON() : <any>null;
        data["liver"] = this.liver ? this.liver.toJSON() : <any>null;
        data["lymph"] = this.lymph ? this.lymph.toJSON() : <any>null;
        data["other"] = this.other ? this.other.toJSON() : <any>null;
        data["perc"] = this.perc ? this.perc.toJSON() : <any>null;
        data["pupils"] = this.pupils ? this.pupils.toJSON() : <any>null;
        data["reflexes"] = this.reflexes ? this.reflexes.toJSON() : <any>null;
        data["skin"] = this.skin ? this.skin.toJSON() : <any>null;
        data["stomach"] = this.stomach ? this.stomach.toJSON() : <any>null;
        data["throat"] = this.throat ? this.throat.toJSON() : <any>null;
        data["tongue"] = this.tongue ? this.tongue.toJSON() : <any>null;
        data["tonsils"] = this.tonsils ? this.tonsils.toJSON() : <any>null;
        data["wheezing"] = this.wheezing ? this.wheezing.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardObjectivePartDto {
    addition?: CardObjectiveAdditionPartDto | null;
    alcohol?: CardObjectiveAlcoPartDto | null;
    breath?: CardObjectiveBreathPartDto | null;
    diuresis?: CardObjectiveDiuresisPartDto | null;
    dyspeptic?: CardObjectiveDyspepticPartDto | null;
    edema?: CardObjectiveEdemaPartDto | null;
    excreta?: CardObjectiveExcretaUrinePartDto | null;
    general_state?: CardObjectiveGeneralStatePartDto | null;
    glasgow?: CardObjectiveGlasgowPartDto | null;
    header?: CardObjectiveHeaderDto | null;
    heart?: CardObjectiveHeartPartDto | null;
    hemodynamics?: CardAnamnesisHemodynamicsPartDto | null;
    liver?: CardObjectiveLiverPartDto | null;
    lymph?: CardObjectiveLymphPartDto | null;
    other?: CardObjectiveOtherPartDto | null;
    perc?: CardObjectivePercPartDto | null;
    pupils?: CardObjectivePupilsDto | null;
    reflexes?: CardObjectiveReflexesDto | null;
    skin?: CardObjectiveSkinPartDto | null;
    stomach?: CardObjectiveStomachPartDto | null;
    throat?: CardObjectiveThroatPartDto | null;
    tongue?: CardObjectiveTonguePart | null;
    tonsils?: CardObjectiveTonsilsPartDto | null;
    wheezing?: CardObjectiveWheezingPartDto | null;
}

export class MobileCardResult implements IMobileCardResult {
    additional_diagnosis_id?: number | null;
    basic_diagnosis_id?: number | null;
    body_temperature?: string | null;
    comment?: string | null;
    diagnosis_complications_id?: number | null;
    diagnosis_need_visitor_id?: number | null;
    ekg_after?: string | null;
    ekg_before?: string | null;
    glucometry?: string | null;
    medical_events?: string | null;
    medical_events_in_car?: string | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    result_id?: number | null;
    transportation_data?: string | null;
    transportation_method_id?: number | null;
    transportation_place_id?: number | null;
    transportation_problems?: string | null;
    transportation_time?: string | null;
    type_id?: number | null;
    unlaw_actions?: string | null;

    constructor(data?: IMobileCardResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additional_diagnosis_id = data["additional_diagnosis_id"] !== undefined ? data["additional_diagnosis_id"] : <any>null;
            this.basic_diagnosis_id = data["basic_diagnosis_id"] !== undefined ? data["basic_diagnosis_id"] : <any>null;
            this.body_temperature = data["body_temperature"] !== undefined ? data["body_temperature"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.diagnosis_complications_id = data["diagnosis_complications_id"] !== undefined ? data["diagnosis_complications_id"] : <any>null;
            this.diagnosis_need_visitor_id = data["diagnosis_need_visitor_id"] !== undefined ? data["diagnosis_need_visitor_id"] : <any>null;
            this.ekg_after = data["ekg_after"] !== undefined ? data["ekg_after"] : <any>null;
            this.ekg_before = data["ekg_before"] !== undefined ? data["ekg_before"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.medical_events = data["medical_events"] !== undefined ? data["medical_events"] : <any>null;
            this.medical_events_in_car = data["medical_events_in_car"] !== undefined ? data["medical_events_in_car"] : <any>null;
            this.palpitation = data["palpitation"] !== undefined ? data["palpitation"] : <any>null;
            this.palpitation_ad = data["palpitation_ad"] !== undefined ? data["palpitation_ad"] : <any>null;
            this.palpitation_adn = data["palpitation_adn"] !== undefined ? data["palpitation_adn"] : <any>null;
            this.palpitation_cd = data["palpitation_cd"] !== undefined ? data["palpitation_cd"] : <any>null;
            this.palpitation_ps = data["palpitation_ps"] !== undefined ? data["palpitation_ps"] : <any>null;
            this.palpitation_sat_02 = data["palpitation_sat_02"] !== undefined ? data["palpitation_sat_02"] : <any>null;
            this.result_id = data["result_id"] !== undefined ? data["result_id"] : <any>null;
            this.transportation_data = data["transportation_data"] !== undefined ? data["transportation_data"] : <any>null;
            this.transportation_method_id = data["transportation_method_id"] !== undefined ? data["transportation_method_id"] : <any>null;
            this.transportation_place_id = data["transportation_place_id"] !== undefined ? data["transportation_place_id"] : <any>null;
            this.transportation_problems = data["transportation_problems"] !== undefined ? data["transportation_problems"] : <any>null;
            this.transportation_time = data["transportation_time"] !== undefined ? data["transportation_time"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.unlaw_actions = data["unlaw_actions"] !== undefined ? data["unlaw_actions"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardResult {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additional_diagnosis_id"] = this.additional_diagnosis_id !== undefined ? this.additional_diagnosis_id : <any>null;
        data["basic_diagnosis_id"] = this.basic_diagnosis_id !== undefined ? this.basic_diagnosis_id : <any>null;
        data["body_temperature"] = this.body_temperature !== undefined ? this.body_temperature : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["diagnosis_complications_id"] = this.diagnosis_complications_id !== undefined ? this.diagnosis_complications_id : <any>null;
        data["diagnosis_need_visitor_id"] = this.diagnosis_need_visitor_id !== undefined ? this.diagnosis_need_visitor_id : <any>null;
        data["ekg_after"] = this.ekg_after !== undefined ? this.ekg_after : <any>null;
        data["ekg_before"] = this.ekg_before !== undefined ? this.ekg_before : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["medical_events"] = this.medical_events !== undefined ? this.medical_events : <any>null;
        data["medical_events_in_car"] = this.medical_events_in_car !== undefined ? this.medical_events_in_car : <any>null;
        data["palpitation"] = this.palpitation !== undefined ? this.palpitation : <any>null;
        data["palpitation_ad"] = this.palpitation_ad !== undefined ? this.palpitation_ad : <any>null;
        data["palpitation_adn"] = this.palpitation_adn !== undefined ? this.palpitation_adn : <any>null;
        data["palpitation_cd"] = this.palpitation_cd !== undefined ? this.palpitation_cd : <any>null;
        data["palpitation_ps"] = this.palpitation_ps !== undefined ? this.palpitation_ps : <any>null;
        data["palpitation_sat_02"] = this.palpitation_sat_02 !== undefined ? this.palpitation_sat_02 : <any>null;
        data["result_id"] = this.result_id !== undefined ? this.result_id : <any>null;
        data["transportation_data"] = this.transportation_data !== undefined ? this.transportation_data : <any>null;
        data["transportation_method_id"] = this.transportation_method_id !== undefined ? this.transportation_method_id : <any>null;
        data["transportation_place_id"] = this.transportation_place_id !== undefined ? this.transportation_place_id : <any>null;
        data["transportation_problems"] = this.transportation_problems !== undefined ? this.transportation_problems : <any>null;
        data["transportation_time"] = this.transportation_time !== undefined ? this.transportation_time : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["unlaw_actions"] = this.unlaw_actions !== undefined ? this.unlaw_actions : <any>null;
        return data; 
    }
}

export interface IMobileCardResult {
    additional_diagnosis_id?: number | null;
    basic_diagnosis_id?: number | null;
    body_temperature?: string | null;
    comment?: string | null;
    diagnosis_complications_id?: number | null;
    diagnosis_need_visitor_id?: number | null;
    ekg_after?: string | null;
    ekg_before?: string | null;
    glucometry?: string | null;
    medical_events?: string | null;
    medical_events_in_car?: string | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    result_id?: number | null;
    transportation_data?: string | null;
    transportation_method_id?: number | null;
    transportation_place_id?: number | null;
    transportation_problems?: string | null;
    transportation_time?: string | null;
    type_id?: number | null;
    unlaw_actions?: string | null;
}

export class ListDtoOfLogDto implements IListDtoOfLogDto {
    list?: LogDto[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(LogDto.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfLogDto {
    list?: LogDto[] | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveHeartPartDto implements ICardObjectiveHeartPartDto {
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;

    constructor(data?: ICardObjectiveHeartPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.heart_noise_id = data["heart_noise_id"] !== undefined ? data["heart_noise_id"] : <any>null;
            this.heart_noise_name = data["heart_noise_name"] !== undefined ? data["heart_noise_name"] : <any>null;
            this.heart_rate_id = data["heart_rate_id"] !== undefined ? data["heart_rate_id"] : <any>null;
            this.heart_rate_name = data["heart_rate_name"] !== undefined ? data["heart_rate_name"] : <any>null;
            this.heart_tone_id = data["heart_tone_id"] !== undefined ? data["heart_tone_id"] : <any>null;
            this.heart_tone_name = data["heart_tone_name"] !== undefined ? data["heart_tone_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveHeartPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveHeartPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heart_noise_id"] = this.heart_noise_id !== undefined ? this.heart_noise_id : <any>null;
        data["heart_noise_name"] = this.heart_noise_name !== undefined ? this.heart_noise_name : <any>null;
        data["heart_rate_id"] = this.heart_rate_id !== undefined ? this.heart_rate_id : <any>null;
        data["heart_rate_name"] = this.heart_rate_name !== undefined ? this.heart_rate_name : <any>null;
        data["heart_tone_id"] = this.heart_tone_id !== undefined ? this.heart_tone_id : <any>null;
        data["heart_tone_name"] = this.heart_tone_name !== undefined ? this.heart_tone_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveHeartPartDto {
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;
}

export class DistrictDto implements IDistrictDto {
    code?: string | null;
    fias_id?: number | null;
    id?: number | null;
    name?: string | null;
    zone?: string | null;

    constructor(data?: IDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.fias_id = data["fias_id"] !== undefined ? data["fias_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.zone = data["zone"] !== undefined ? data["zone"] : <any>null;
        }
    }

    static fromJS(data: any): DistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["fias_id"] = this.fias_id !== undefined ? this.fias_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["zone"] = this.zone !== undefined ? this.zone : <any>null;
        return data; 
    }
}

export interface IDistrictDto {
    code?: string | null;
    fias_id?: number | null;
    id?: number | null;
    name?: string | null;
    zone?: string | null;
}

export class MobileCardObjective implements IMobileCardObjective {
    adenoid_incrustation?: boolean | null;
    adenoid_size_id?: number | null;
    alcohol_air?: boolean | null;
    body_temperature?: string | null;
    breath_absent?: boolean | null;
    breath_bronchial?: boolean | null;
    breath_hard?: boolean | null;
    breath_puerile?: boolean | null;
    breath_smooth?: boolean | null;
    breath_vesicular?: boolean | null;
    breath_weak?: boolean | null;
    conscious_state_id?: number | null;
    ds_pupil_ratio_id?: number | null;
    ds_reflex_id?: number | null;
    emotional_lability?: boolean | null;
    epidermis_acrocyanosis?: boolean | null;
    epidermis_cyanotic?: boolean | null;
    epidermis_dry?: boolean | null;
    epidermis_earthy?: boolean | null;
    epidermis_hyperemic?: boolean | null;
    epidermis_icteric?: boolean | null;
    epidermis_normal?: boolean | null;
    epidermis_pale?: boolean | null;
    epidermis_profuse_sweat?: boolean | null;
    epidermis_rashes?: boolean | null;
    glucometry?: string | null;
    health_state_id?: number | null;
    inadequate_assessment?: boolean | null;
    instability_romberg?: boolean | null;
    lymph_nodes_localisation?: string | null;
    meningeal?: boolean | null;
    mucous_throat_id?: number | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_ad_max?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_noises?: boolean | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    palpitation_tone_id?: number | null;
    palpitation_type_id?: number | null;
    pathological?: boolean | null;
    pupil_ratio_id?: number | null;
    reaction_to_light?: boolean | null;
    reflex_id?: number | null;
    sensitivity_of_lymph_nodes_id?: number | null;
    shaky_walk?: boolean | null;
    size_of_lymph_nodes_id?: number | null;
    speech_drunk_man?: boolean | null;
    swelling?: boolean | null;
    swelling_localisation?: string | null;

    constructor(data?: IMobileCardObjective) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adenoid_incrustation = data["adenoid_incrustation"] !== undefined ? data["adenoid_incrustation"] : <any>null;
            this.adenoid_size_id = data["adenoid_size_id"] !== undefined ? data["adenoid_size_id"] : <any>null;
            this.alcohol_air = data["alcohol_air"] !== undefined ? data["alcohol_air"] : <any>null;
            this.body_temperature = data["body_temperature"] !== undefined ? data["body_temperature"] : <any>null;
            this.breath_absent = data["breath_absent"] !== undefined ? data["breath_absent"] : <any>null;
            this.breath_bronchial = data["breath_bronchial"] !== undefined ? data["breath_bronchial"] : <any>null;
            this.breath_hard = data["breath_hard"] !== undefined ? data["breath_hard"] : <any>null;
            this.breath_puerile = data["breath_puerile"] !== undefined ? data["breath_puerile"] : <any>null;
            this.breath_smooth = data["breath_smooth"] !== undefined ? data["breath_smooth"] : <any>null;
            this.breath_vesicular = data["breath_vesicular"] !== undefined ? data["breath_vesicular"] : <any>null;
            this.breath_weak = data["breath_weak"] !== undefined ? data["breath_weak"] : <any>null;
            this.conscious_state_id = data["conscious_state_id"] !== undefined ? data["conscious_state_id"] : <any>null;
            this.ds_pupil_ratio_id = data["ds_pupil_ratio_id"] !== undefined ? data["ds_pupil_ratio_id"] : <any>null;
            this.ds_reflex_id = data["ds_reflex_id"] !== undefined ? data["ds_reflex_id"] : <any>null;
            this.emotional_lability = data["emotional_lability"] !== undefined ? data["emotional_lability"] : <any>null;
            this.epidermis_acrocyanosis = data["epidermis_acrocyanosis"] !== undefined ? data["epidermis_acrocyanosis"] : <any>null;
            this.epidermis_cyanotic = data["epidermis_cyanotic"] !== undefined ? data["epidermis_cyanotic"] : <any>null;
            this.epidermis_dry = data["epidermis_dry"] !== undefined ? data["epidermis_dry"] : <any>null;
            this.epidermis_earthy = data["epidermis_earthy"] !== undefined ? data["epidermis_earthy"] : <any>null;
            this.epidermis_hyperemic = data["epidermis_hyperemic"] !== undefined ? data["epidermis_hyperemic"] : <any>null;
            this.epidermis_icteric = data["epidermis_icteric"] !== undefined ? data["epidermis_icteric"] : <any>null;
            this.epidermis_normal = data["epidermis_normal"] !== undefined ? data["epidermis_normal"] : <any>null;
            this.epidermis_pale = data["epidermis_pale"] !== undefined ? data["epidermis_pale"] : <any>null;
            this.epidermis_profuse_sweat = data["epidermis_profuse_sweat"] !== undefined ? data["epidermis_profuse_sweat"] : <any>null;
            this.epidermis_rashes = data["epidermis_rashes"] !== undefined ? data["epidermis_rashes"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.health_state_id = data["health_state_id"] !== undefined ? data["health_state_id"] : <any>null;
            this.inadequate_assessment = data["inadequate_assessment"] !== undefined ? data["inadequate_assessment"] : <any>null;
            this.instability_romberg = data["instability_romberg"] !== undefined ? data["instability_romberg"] : <any>null;
            this.lymph_nodes_localisation = data["lymph_nodes_localisation"] !== undefined ? data["lymph_nodes_localisation"] : <any>null;
            this.meningeal = data["meningeal"] !== undefined ? data["meningeal"] : <any>null;
            this.mucous_throat_id = data["mucous_throat_id"] !== undefined ? data["mucous_throat_id"] : <any>null;
            this.palpitation = data["palpitation"] !== undefined ? data["palpitation"] : <any>null;
            this.palpitation_ad = data["palpitation_ad"] !== undefined ? data["palpitation_ad"] : <any>null;
            this.palpitation_ad_max = data["palpitation_ad_max"] !== undefined ? data["palpitation_ad_max"] : <any>null;
            this.palpitation_adn = data["palpitation_adn"] !== undefined ? data["palpitation_adn"] : <any>null;
            this.palpitation_cd = data["palpitation_cd"] !== undefined ? data["palpitation_cd"] : <any>null;
            this.palpitation_noises = data["palpitation_noises"] !== undefined ? data["palpitation_noises"] : <any>null;
            this.palpitation_ps = data["palpitation_ps"] !== undefined ? data["palpitation_ps"] : <any>null;
            this.palpitation_sat_02 = data["palpitation_sat_02"] !== undefined ? data["palpitation_sat_02"] : <any>null;
            this.palpitation_tone_id = data["palpitation_tone_id"] !== undefined ? data["palpitation_tone_id"] : <any>null;
            this.palpitation_type_id = data["palpitation_type_id"] !== undefined ? data["palpitation_type_id"] : <any>null;
            this.pathological = data["pathological"] !== undefined ? data["pathological"] : <any>null;
            this.pupil_ratio_id = data["pupil_ratio_id"] !== undefined ? data["pupil_ratio_id"] : <any>null;
            this.reaction_to_light = data["reaction_to_light"] !== undefined ? data["reaction_to_light"] : <any>null;
            this.reflex_id = data["reflex_id"] !== undefined ? data["reflex_id"] : <any>null;
            this.sensitivity_of_lymph_nodes_id = data["sensitivity_of_lymph_nodes_id"] !== undefined ? data["sensitivity_of_lymph_nodes_id"] : <any>null;
            this.shaky_walk = data["shaky_walk"] !== undefined ? data["shaky_walk"] : <any>null;
            this.size_of_lymph_nodes_id = data["size_of_lymph_nodes_id"] !== undefined ? data["size_of_lymph_nodes_id"] : <any>null;
            this.speech_drunk_man = data["speech_drunk_man"] !== undefined ? data["speech_drunk_man"] : <any>null;
            this.swelling = data["swelling"] !== undefined ? data["swelling"] : <any>null;
            this.swelling_localisation = data["swelling_localisation"] !== undefined ? data["swelling_localisation"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardObjective {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardObjective();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adenoid_incrustation"] = this.adenoid_incrustation !== undefined ? this.adenoid_incrustation : <any>null;
        data["adenoid_size_id"] = this.adenoid_size_id !== undefined ? this.adenoid_size_id : <any>null;
        data["alcohol_air"] = this.alcohol_air !== undefined ? this.alcohol_air : <any>null;
        data["body_temperature"] = this.body_temperature !== undefined ? this.body_temperature : <any>null;
        data["breath_absent"] = this.breath_absent !== undefined ? this.breath_absent : <any>null;
        data["breath_bronchial"] = this.breath_bronchial !== undefined ? this.breath_bronchial : <any>null;
        data["breath_hard"] = this.breath_hard !== undefined ? this.breath_hard : <any>null;
        data["breath_puerile"] = this.breath_puerile !== undefined ? this.breath_puerile : <any>null;
        data["breath_smooth"] = this.breath_smooth !== undefined ? this.breath_smooth : <any>null;
        data["breath_vesicular"] = this.breath_vesicular !== undefined ? this.breath_vesicular : <any>null;
        data["breath_weak"] = this.breath_weak !== undefined ? this.breath_weak : <any>null;
        data["conscious_state_id"] = this.conscious_state_id !== undefined ? this.conscious_state_id : <any>null;
        data["ds_pupil_ratio_id"] = this.ds_pupil_ratio_id !== undefined ? this.ds_pupil_ratio_id : <any>null;
        data["ds_reflex_id"] = this.ds_reflex_id !== undefined ? this.ds_reflex_id : <any>null;
        data["emotional_lability"] = this.emotional_lability !== undefined ? this.emotional_lability : <any>null;
        data["epidermis_acrocyanosis"] = this.epidermis_acrocyanosis !== undefined ? this.epidermis_acrocyanosis : <any>null;
        data["epidermis_cyanotic"] = this.epidermis_cyanotic !== undefined ? this.epidermis_cyanotic : <any>null;
        data["epidermis_dry"] = this.epidermis_dry !== undefined ? this.epidermis_dry : <any>null;
        data["epidermis_earthy"] = this.epidermis_earthy !== undefined ? this.epidermis_earthy : <any>null;
        data["epidermis_hyperemic"] = this.epidermis_hyperemic !== undefined ? this.epidermis_hyperemic : <any>null;
        data["epidermis_icteric"] = this.epidermis_icteric !== undefined ? this.epidermis_icteric : <any>null;
        data["epidermis_normal"] = this.epidermis_normal !== undefined ? this.epidermis_normal : <any>null;
        data["epidermis_pale"] = this.epidermis_pale !== undefined ? this.epidermis_pale : <any>null;
        data["epidermis_profuse_sweat"] = this.epidermis_profuse_sweat !== undefined ? this.epidermis_profuse_sweat : <any>null;
        data["epidermis_rashes"] = this.epidermis_rashes !== undefined ? this.epidermis_rashes : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["health_state_id"] = this.health_state_id !== undefined ? this.health_state_id : <any>null;
        data["inadequate_assessment"] = this.inadequate_assessment !== undefined ? this.inadequate_assessment : <any>null;
        data["instability_romberg"] = this.instability_romberg !== undefined ? this.instability_romberg : <any>null;
        data["lymph_nodes_localisation"] = this.lymph_nodes_localisation !== undefined ? this.lymph_nodes_localisation : <any>null;
        data["meningeal"] = this.meningeal !== undefined ? this.meningeal : <any>null;
        data["mucous_throat_id"] = this.mucous_throat_id !== undefined ? this.mucous_throat_id : <any>null;
        data["palpitation"] = this.palpitation !== undefined ? this.palpitation : <any>null;
        data["palpitation_ad"] = this.palpitation_ad !== undefined ? this.palpitation_ad : <any>null;
        data["palpitation_ad_max"] = this.palpitation_ad_max !== undefined ? this.palpitation_ad_max : <any>null;
        data["palpitation_adn"] = this.palpitation_adn !== undefined ? this.palpitation_adn : <any>null;
        data["palpitation_cd"] = this.palpitation_cd !== undefined ? this.palpitation_cd : <any>null;
        data["palpitation_noises"] = this.palpitation_noises !== undefined ? this.palpitation_noises : <any>null;
        data["palpitation_ps"] = this.palpitation_ps !== undefined ? this.palpitation_ps : <any>null;
        data["palpitation_sat_02"] = this.palpitation_sat_02 !== undefined ? this.palpitation_sat_02 : <any>null;
        data["palpitation_tone_id"] = this.palpitation_tone_id !== undefined ? this.palpitation_tone_id : <any>null;
        data["palpitation_type_id"] = this.palpitation_type_id !== undefined ? this.palpitation_type_id : <any>null;
        data["pathological"] = this.pathological !== undefined ? this.pathological : <any>null;
        data["pupil_ratio_id"] = this.pupil_ratio_id !== undefined ? this.pupil_ratio_id : <any>null;
        data["reaction_to_light"] = this.reaction_to_light !== undefined ? this.reaction_to_light : <any>null;
        data["reflex_id"] = this.reflex_id !== undefined ? this.reflex_id : <any>null;
        data["sensitivity_of_lymph_nodes_id"] = this.sensitivity_of_lymph_nodes_id !== undefined ? this.sensitivity_of_lymph_nodes_id : <any>null;
        data["shaky_walk"] = this.shaky_walk !== undefined ? this.shaky_walk : <any>null;
        data["size_of_lymph_nodes_id"] = this.size_of_lymph_nodes_id !== undefined ? this.size_of_lymph_nodes_id : <any>null;
        data["speech_drunk_man"] = this.speech_drunk_man !== undefined ? this.speech_drunk_man : <any>null;
        data["swelling"] = this.swelling !== undefined ? this.swelling : <any>null;
        data["swelling_localisation"] = this.swelling_localisation !== undefined ? this.swelling_localisation : <any>null;
        return data; 
    }
}

export interface IMobileCardObjective {
    adenoid_incrustation?: boolean | null;
    adenoid_size_id?: number | null;
    alcohol_air?: boolean | null;
    body_temperature?: string | null;
    breath_absent?: boolean | null;
    breath_bronchial?: boolean | null;
    breath_hard?: boolean | null;
    breath_puerile?: boolean | null;
    breath_smooth?: boolean | null;
    breath_vesicular?: boolean | null;
    breath_weak?: boolean | null;
    conscious_state_id?: number | null;
    ds_pupil_ratio_id?: number | null;
    ds_reflex_id?: number | null;
    emotional_lability?: boolean | null;
    epidermis_acrocyanosis?: boolean | null;
    epidermis_cyanotic?: boolean | null;
    epidermis_dry?: boolean | null;
    epidermis_earthy?: boolean | null;
    epidermis_hyperemic?: boolean | null;
    epidermis_icteric?: boolean | null;
    epidermis_normal?: boolean | null;
    epidermis_pale?: boolean | null;
    epidermis_profuse_sweat?: boolean | null;
    epidermis_rashes?: boolean | null;
    glucometry?: string | null;
    health_state_id?: number | null;
    inadequate_assessment?: boolean | null;
    instability_romberg?: boolean | null;
    lymph_nodes_localisation?: string | null;
    meningeal?: boolean | null;
    mucous_throat_id?: number | null;
    palpitation?: string | null;
    palpitation_ad?: string | null;
    palpitation_ad_max?: string | null;
    palpitation_adn?: string | null;
    palpitation_cd?: string | null;
    palpitation_noises?: boolean | null;
    palpitation_ps?: string | null;
    palpitation_sat_02?: string | null;
    palpitation_tone_id?: number | null;
    palpitation_type_id?: number | null;
    pathological?: boolean | null;
    pupil_ratio_id?: number | null;
    reaction_to_light?: boolean | null;
    reflex_id?: number | null;
    sensitivity_of_lymph_nodes_id?: number | null;
    shaky_walk?: boolean | null;
    size_of_lymph_nodes_id?: number | null;
    speech_drunk_man?: boolean | null;
    swelling?: boolean | null;
    swelling_localisation?: string | null;
}

export class MobileCardAnamnesis implements IMobileCardAnamnesis {
    allergic_anamnesis_id?: number | null;
    born_diseases?: string | null;
    disease_anamnesis?: string | null;
    dont_like?: string | null;
    gynecological?: string | null;
    infect_patient_contact?: string | null;
    problems?: string | null;
    quarantine?: string | null;
    shit_frequency?: string | null;
    shit_id?: number | null;
    urine?: string | null;
    vaccination?: string | null;

    constructor(data?: IMobileCardAnamnesis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic_anamnesis_id = data["allergic_anamnesis_id"] !== undefined ? data["allergic_anamnesis_id"] : <any>null;
            this.born_diseases = data["born_diseases"] !== undefined ? data["born_diseases"] : <any>null;
            this.disease_anamnesis = data["disease_anamnesis"] !== undefined ? data["disease_anamnesis"] : <any>null;
            this.dont_like = data["dont_like"] !== undefined ? data["dont_like"] : <any>null;
            this.gynecological = data["gynecological"] !== undefined ? data["gynecological"] : <any>null;
            this.infect_patient_contact = data["infect_patient_contact"] !== undefined ? data["infect_patient_contact"] : <any>null;
            this.problems = data["problems"] !== undefined ? data["problems"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.shit_frequency = data["shit_frequency"] !== undefined ? data["shit_frequency"] : <any>null;
            this.shit_id = data["shit_id"] !== undefined ? data["shit_id"] : <any>null;
            this.urine = data["urine"] !== undefined ? data["urine"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardAnamnesis {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardAnamnesis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic_anamnesis_id"] = this.allergic_anamnesis_id !== undefined ? this.allergic_anamnesis_id : <any>null;
        data["born_diseases"] = this.born_diseases !== undefined ? this.born_diseases : <any>null;
        data["disease_anamnesis"] = this.disease_anamnesis !== undefined ? this.disease_anamnesis : <any>null;
        data["dont_like"] = this.dont_like !== undefined ? this.dont_like : <any>null;
        data["gynecological"] = this.gynecological !== undefined ? this.gynecological : <any>null;
        data["infect_patient_contact"] = this.infect_patient_contact !== undefined ? this.infect_patient_contact : <any>null;
        data["problems"] = this.problems !== undefined ? this.problems : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["shit_frequency"] = this.shit_frequency !== undefined ? this.shit_frequency : <any>null;
        data["shit_id"] = this.shit_id !== undefined ? this.shit_id : <any>null;
        data["urine"] = this.urine !== undefined ? this.urine : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        return data; 
    }
}

export interface IMobileCardAnamnesis {
    allergic_anamnesis_id?: number | null;
    born_diseases?: string | null;
    disease_anamnesis?: string | null;
    dont_like?: string | null;
    gynecological?: string | null;
    infect_patient_contact?: string | null;
    problems?: string | null;
    quarantine?: string | null;
    shit_frequency?: string | null;
    shit_id?: number | null;
    urine?: string | null;
    vaccination?: string | null;
}

export class PerformerTypeDto implements IPerformerTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IPerformerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IPerformerTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CardResultTransferPatientDto implements ICardResultTransferPatientDto {
    brigade_number?: string | null;
    time?: Date | null;

    constructor(data?: ICardResultTransferPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_number = data["brigade_number"] !== undefined ? data["brigade_number"] : <any>null;
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CardResultTransferPatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTransferPatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_number"] = this.brigade_number !== undefined ? this.brigade_number : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        return data; 
    }
}

export interface ICardResultTransferPatientDto {
    brigade_number?: string | null;
    time?: Date | null;
}

export class CardObjectiveDyspepticPartDto implements ICardObjectiveDyspepticPartDto {
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;

    constructor(data?: ICardObjectiveDyspepticPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dyspeptic_diarrhea = data["dyspeptic_diarrhea"] !== undefined ? data["dyspeptic_diarrhea"] : <any>null;
            this.dyspeptic_nausea = data["dyspeptic_nausea"] !== undefined ? data["dyspeptic_nausea"] : <any>null;
            this.dyspeptic_retch = data["dyspeptic_retch"] !== undefined ? data["dyspeptic_retch"] : <any>null;
            this.dyspeptics_no = data["dyspeptics_no"] !== undefined ? data["dyspeptics_no"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveDyspepticPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveDyspepticPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dyspeptic_diarrhea"] = this.dyspeptic_diarrhea !== undefined ? this.dyspeptic_diarrhea : <any>null;
        data["dyspeptic_nausea"] = this.dyspeptic_nausea !== undefined ? this.dyspeptic_nausea : <any>null;
        data["dyspeptic_retch"] = this.dyspeptic_retch !== undefined ? this.dyspeptic_retch : <any>null;
        data["dyspeptics_no"] = this.dyspeptics_no !== undefined ? this.dyspeptics_no : <any>null;
        return data; 
    }
}

export interface ICardObjectiveDyspepticPartDto {
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;
}

export class CardBean implements ICardBean {
    arriveTimeExceed?: boolean | null;
    brigadeArriveDate?: Date | null;
    brigadeDepartureDate?: Date | null;
    /** Врач бригады, принявшей вызов */
    brigadeDoctorFK?: PerformerBean | null;
    brigadeDoctorIsChecked?: boolean | null;
    brigadeDoneDate?: Date | null;
    /** Бригада */
    brigadeFK?: BrigadeBean | null;
    brigadeHospitalizationDate?: Date | null;
    brigadeInHospitalDate?: Date | null;
    brigadeReceivingDate?: Date | null;
    /** Место, где вызов был принят бригадой */
    brigadeReceivingPlaceFK?: ReferenceTypeBean | null;
    /** Способ получения бригадой вызов */
    brigadeReceivingTypeFK?: ReferenceTypeBean | null;
    brigadeReturnDate?: Date | null;
    /** ID вызова */
    call?: number | null;
    /** Card objective */
    cardObjectiveBean?: CardObjectiveBean | null;
    /** CardResult */
    cardResultBean?: CardResultBean | null;
    /** Статус карты вызова */
    cardStatus?: number | null;
    /** Дата создания карты */
    date?: Date | null;
    /** Врач бригады, принявшей вызов */
    dispatcherReceivedFK?: PerformerBean | null;
    fullTimeInterval?: string | null;
    id?: number | null;
    /** Номер карты */
    number?: string | null;
    /** Пациент */
    patientFK?: PatientBean | null;
    /** ID сотрудника, заполняющего карту */
    performerFK?: PerformerBean | null;
    receivingTimeExceed?: boolean | null;
    /** Тип результа выезда */
    resultTypeFK?: ReferenceTypeBean | null;
    shiftSeniorDoctorComment?: string | null;
    /** Главный врач смены */
    shiftSeniorDoctorFK?: PerformerBean | null;
    shiftSeniorDoctorIsChecked?: boolean | null;
    /** ID подразделения */
    subdivisionFK?: SubdivisionBean | null;
    subdivisionHeadDoctorComment?: string | null;
    /** Главный врач смены */
    subdivisionHeadDoctorFK?: PerformerBean | null;
    subdivisionHeadDoctorIsChecked?: boolean | null;

    constructor(data?: ICardBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.arriveTimeExceed = data["arriveTimeExceed"] !== undefined ? data["arriveTimeExceed"] : <any>null;
            this.brigadeArriveDate = data["brigadeArriveDate"] ? new Date(data["brigadeArriveDate"].toString()) : <any>null;
            this.brigadeDepartureDate = data["brigadeDepartureDate"] ? new Date(data["brigadeDepartureDate"].toString()) : <any>null;
            this.brigadeDoctorFK = data["brigadeDoctorFK"] ? PerformerBean.fromJS(data["brigadeDoctorFK"]) : <any>null;
            this.brigadeDoctorIsChecked = data["brigadeDoctorIsChecked"] !== undefined ? data["brigadeDoctorIsChecked"] : <any>null;
            this.brigadeDoneDate = data["brigadeDoneDate"] ? new Date(data["brigadeDoneDate"].toString()) : <any>null;
            this.brigadeFK = data["brigadeFK"] ? BrigadeBean.fromJS(data["brigadeFK"]) : <any>null;
            this.brigadeHospitalizationDate = data["brigadeHospitalizationDate"] ? new Date(data["brigadeHospitalizationDate"].toString()) : <any>null;
            this.brigadeInHospitalDate = data["brigadeInHospitalDate"] ? new Date(data["brigadeInHospitalDate"].toString()) : <any>null;
            this.brigadeReceivingDate = data["brigadeReceivingDate"] ? new Date(data["brigadeReceivingDate"].toString()) : <any>null;
            this.brigadeReceivingPlaceFK = data["brigadeReceivingPlaceFK"] ? ReferenceTypeBean.fromJS(data["brigadeReceivingPlaceFK"]) : <any>null;
            this.brigadeReceivingTypeFK = data["brigadeReceivingTypeFK"] ? ReferenceTypeBean.fromJS(data["brigadeReceivingTypeFK"]) : <any>null;
            this.brigadeReturnDate = data["brigadeReturnDate"] ? new Date(data["brigadeReturnDate"].toString()) : <any>null;
            this.call = data["call"] !== undefined ? data["call"] : <any>null;
            this.cardObjectiveBean = data["cardObjectiveBean"] ? CardObjectiveBean.fromJS(data["cardObjectiveBean"]) : <any>null;
            this.cardResultBean = data["cardResultBean"] ? CardResultBean.fromJS(data["cardResultBean"]) : <any>null;
            this.cardStatus = data["cardStatus"] !== undefined ? data["cardStatus"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.dispatcherReceivedFK = data["dispatcherReceivedFK"] ? PerformerBean.fromJS(data["dispatcherReceivedFK"]) : <any>null;
            this.fullTimeInterval = data["fullTimeInterval"] !== undefined ? data["fullTimeInterval"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patientFK = data["patientFK"] ? PatientBean.fromJS(data["patientFK"]) : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.receivingTimeExceed = data["receivingTimeExceed"] !== undefined ? data["receivingTimeExceed"] : <any>null;
            this.resultTypeFK = data["resultTypeFK"] ? ReferenceTypeBean.fromJS(data["resultTypeFK"]) : <any>null;
            this.shiftSeniorDoctorComment = data["shiftSeniorDoctorComment"] !== undefined ? data["shiftSeniorDoctorComment"] : <any>null;
            this.shiftSeniorDoctorFK = data["shiftSeniorDoctorFK"] ? PerformerBean.fromJS(data["shiftSeniorDoctorFK"]) : <any>null;
            this.shiftSeniorDoctorIsChecked = data["shiftSeniorDoctorIsChecked"] !== undefined ? data["shiftSeniorDoctorIsChecked"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.subdivisionHeadDoctorComment = data["subdivisionHeadDoctorComment"] !== undefined ? data["subdivisionHeadDoctorComment"] : <any>null;
            this.subdivisionHeadDoctorFK = data["subdivisionHeadDoctorFK"] ? PerformerBean.fromJS(data["subdivisionHeadDoctorFK"]) : <any>null;
            this.subdivisionHeadDoctorIsChecked = data["subdivisionHeadDoctorIsChecked"] !== undefined ? data["subdivisionHeadDoctorIsChecked"] : <any>null;
        }
    }

    static fromJS(data: any): CardBean {
        data = typeof data === 'object' ? data : {};
        let result = new CardBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arriveTimeExceed"] = this.arriveTimeExceed !== undefined ? this.arriveTimeExceed : <any>null;
        data["brigadeArriveDate"] = this.brigadeArriveDate ? this.brigadeArriveDate.toISOString() : <any>null;
        data["brigadeDepartureDate"] = this.brigadeDepartureDate ? this.brigadeDepartureDate.toISOString() : <any>null;
        data["brigadeDoctorFK"] = this.brigadeDoctorFK ? this.brigadeDoctorFK.toJSON() : <any>null;
        data["brigadeDoctorIsChecked"] = this.brigadeDoctorIsChecked !== undefined ? this.brigadeDoctorIsChecked : <any>null;
        data["brigadeDoneDate"] = this.brigadeDoneDate ? this.brigadeDoneDate.toISOString() : <any>null;
        data["brigadeFK"] = this.brigadeFK ? this.brigadeFK.toJSON() : <any>null;
        data["brigadeHospitalizationDate"] = this.brigadeHospitalizationDate ? this.brigadeHospitalizationDate.toISOString() : <any>null;
        data["brigadeInHospitalDate"] = this.brigadeInHospitalDate ? this.brigadeInHospitalDate.toISOString() : <any>null;
        data["brigadeReceivingDate"] = this.brigadeReceivingDate ? this.brigadeReceivingDate.toISOString() : <any>null;
        data["brigadeReceivingPlaceFK"] = this.brigadeReceivingPlaceFK ? this.brigadeReceivingPlaceFK.toJSON() : <any>null;
        data["brigadeReceivingTypeFK"] = this.brigadeReceivingTypeFK ? this.brigadeReceivingTypeFK.toJSON() : <any>null;
        data["brigadeReturnDate"] = this.brigadeReturnDate ? this.brigadeReturnDate.toISOString() : <any>null;
        data["call"] = this.call !== undefined ? this.call : <any>null;
        data["cardObjectiveBean"] = this.cardObjectiveBean ? this.cardObjectiveBean.toJSON() : <any>null;
        data["cardResultBean"] = this.cardResultBean ? this.cardResultBean.toJSON() : <any>null;
        data["cardStatus"] = this.cardStatus !== undefined ? this.cardStatus : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["dispatcherReceivedFK"] = this.dispatcherReceivedFK ? this.dispatcherReceivedFK.toJSON() : <any>null;
        data["fullTimeInterval"] = this.fullTimeInterval !== undefined ? this.fullTimeInterval : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patientFK"] = this.patientFK ? this.patientFK.toJSON() : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["receivingTimeExceed"] = this.receivingTimeExceed !== undefined ? this.receivingTimeExceed : <any>null;
        data["resultTypeFK"] = this.resultTypeFK ? this.resultTypeFK.toJSON() : <any>null;
        data["shiftSeniorDoctorComment"] = this.shiftSeniorDoctorComment !== undefined ? this.shiftSeniorDoctorComment : <any>null;
        data["shiftSeniorDoctorFK"] = this.shiftSeniorDoctorFK ? this.shiftSeniorDoctorFK.toJSON() : <any>null;
        data["shiftSeniorDoctorIsChecked"] = this.shiftSeniorDoctorIsChecked !== undefined ? this.shiftSeniorDoctorIsChecked : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["subdivisionHeadDoctorComment"] = this.subdivisionHeadDoctorComment !== undefined ? this.subdivisionHeadDoctorComment : <any>null;
        data["subdivisionHeadDoctorFK"] = this.subdivisionHeadDoctorFK ? this.subdivisionHeadDoctorFK.toJSON() : <any>null;
        data["subdivisionHeadDoctorIsChecked"] = this.subdivisionHeadDoctorIsChecked !== undefined ? this.subdivisionHeadDoctorIsChecked : <any>null;
        return data; 
    }
}

export interface ICardBean {
    arriveTimeExceed?: boolean | null;
    brigadeArriveDate?: Date | null;
    brigadeDepartureDate?: Date | null;
    /** Врач бригады, принявшей вызов */
    brigadeDoctorFK?: PerformerBean | null;
    brigadeDoctorIsChecked?: boolean | null;
    brigadeDoneDate?: Date | null;
    /** Бригада */
    brigadeFK?: BrigadeBean | null;
    brigadeHospitalizationDate?: Date | null;
    brigadeInHospitalDate?: Date | null;
    brigadeReceivingDate?: Date | null;
    /** Место, где вызов был принят бригадой */
    brigadeReceivingPlaceFK?: ReferenceTypeBean | null;
    /** Способ получения бригадой вызов */
    brigadeReceivingTypeFK?: ReferenceTypeBean | null;
    brigadeReturnDate?: Date | null;
    /** ID вызова */
    call?: number | null;
    /** Card objective */
    cardObjectiveBean?: CardObjectiveBean | null;
    /** CardResult */
    cardResultBean?: CardResultBean | null;
    /** Статус карты вызова */
    cardStatus?: number | null;
    /** Дата создания карты */
    date?: Date | null;
    /** Врач бригады, принявшей вызов */
    dispatcherReceivedFK?: PerformerBean | null;
    fullTimeInterval?: string | null;
    id?: number | null;
    /** Номер карты */
    number?: string | null;
    /** Пациент */
    patientFK?: PatientBean | null;
    /** ID сотрудника, заполняющего карту */
    performerFK?: PerformerBean | null;
    receivingTimeExceed?: boolean | null;
    /** Тип результа выезда */
    resultTypeFK?: ReferenceTypeBean | null;
    shiftSeniorDoctorComment?: string | null;
    /** Главный врач смены */
    shiftSeniorDoctorFK?: PerformerBean | null;
    shiftSeniorDoctorIsChecked?: boolean | null;
    /** ID подразделения */
    subdivisionFK?: SubdivisionBean | null;
    subdivisionHeadDoctorComment?: string | null;
    /** Главный врач смены */
    subdivisionHeadDoctorFK?: PerformerBean | null;
    subdivisionHeadDoctorIsChecked?: boolean | null;
}

export class ListContainerOfPerformerTypeBean implements IListContainerOfPerformerTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPerformerTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPerformerTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPerformerTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPerformerTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfPharmacyGroupBean implements IListContainerOfPharmacyGroupBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPharmacyGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPharmacyGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPharmacyGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPharmacyGroupBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class InquirerTreeNode implements IInquirerTreeNode {
    answer_title?: string | null;
    expanded?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    leaf?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_id?: number | null;
    reason_title?: string | null;

    constructor(data?: IInquirerTreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer_title = data["answer_title"] !== undefined ? data["answer_title"] : <any>null;
            this.expanded = data["expanded"] !== undefined ? data["expanded"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.is_editable = data["is_editable"] !== undefined ? data["is_editable"] : <any>null;
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
            this.query_title = data["query_title"] !== undefined ? data["query_title"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_title = data["reason_title"] !== undefined ? data["reason_title"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerTreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerTreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer_title"] = this.answer_title !== undefined ? this.answer_title : <any>null;
        data["expanded"] = this.expanded !== undefined ? this.expanded : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["is_editable"] = this.is_editable !== undefined ? this.is_editable : <any>null;
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        data["query_title"] = this.query_title !== undefined ? this.query_title : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_title"] = this.reason_title !== undefined ? this.reason_title : <any>null;
        return data; 
    }
}

export interface IInquirerTreeNode {
    answer_title?: string | null;
    expanded?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    leaf?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_id?: number | null;
    reason_title?: string | null;
}

export class BrigadeAppointRequestDto implements IBrigadeAppointRequestDto {
    brigade_schedule_id?: number | null;
    receiving_type_id?: number | null;

    constructor(data?: IBrigadeAppointRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_schedule_id = data["brigade_schedule_id"] !== undefined ? data["brigade_schedule_id"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeAppointRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeAppointRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_schedule_id"] = this.brigade_schedule_id !== undefined ? this.brigade_schedule_id : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        return data; 
    }
}

export interface IBrigadeAppointRequestDto {
    brigade_schedule_id?: number | null;
    receiving_type_id?: number | null;
}

export class SkillDto implements ISkillDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ISkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ISkillDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CallLocationPartDto implements ICallLocationPartDto {
    call_id?: number | null;
    latitude?: number | null;
    longitude?: number | null;

    constructor(data?: ICallLocationPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
        }
    }

    static fromJS(data: any): CallLocationPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallLocationPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        return data; 
    }
}

export interface ICallLocationPartDto {
    call_id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
}

export class Mkb implements IMkb {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    info?: string | null;
    isFinal?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parent?: Mkb | null;
    parentCode?: string | null;

    constructor(data?: IMkb) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.info = data["info"] !== undefined ? data["info"] : <any>null;
            this.isFinal = data["isFinal"] !== undefined ? data["isFinal"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nodeCount = data["nodeCount"] !== undefined ? data["nodeCount"] : <any>null;
            this.parent = data["parent"] ? Mkb.fromJS(data["parent"]) : <any>null;
            this.parentCode = data["parentCode"] !== undefined ? data["parentCode"] : <any>null;
        }
    }

    static fromJS(data: any): Mkb {
        data = typeof data === 'object' ? data : {};
        let result = new Mkb();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["info"] = this.info !== undefined ? this.info : <any>null;
        data["isFinal"] = this.isFinal !== undefined ? this.isFinal : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nodeCount"] = this.nodeCount !== undefined ? this.nodeCount : <any>null;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>null;
        data["parentCode"] = this.parentCode !== undefined ? this.parentCode : <any>null;
        return data; 
    }
}

export interface IMkb {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    info?: string | null;
    isFinal?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parent?: Mkb | null;
    parentCode?: string | null;
}

export class CardObjectiveAdditionPartDto implements ICardObjectiveAdditionPartDto {
    addition_objective?: string | null;

    constructor(data?: ICardObjectiveAdditionPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addition_objective = data["addition_objective"] !== undefined ? data["addition_objective"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveAdditionPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveAdditionPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addition_objective"] = this.addition_objective !== undefined ? this.addition_objective : <any>null;
        return data; 
    }
}

export interface ICardObjectiveAdditionPartDto {
    addition_objective?: string | null;
}

export class MobileCardPatient implements IMobileCardPatient {
    dms?: string | null;
    oms?: string | null;
    omsOrganisation?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    sex_id?: number | null;
    social_status_id?: number | null;
    surname?: string | null;
    type_id?: number | null;

    constructor(data?: IMobileCardPatient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dms = data["Dms"] !== undefined ? data["Dms"] : <any>null;
            this.oms = data["Oms"] !== undefined ? data["Oms"] : <any>null;
            this.omsOrganisation = data["OmsOrganisation"] !== undefined ? data["OmsOrganisation"] : <any>null;
            this.age_days = data["age_days"] !== undefined ? data["age_days"] : <any>null;
            this.age_months = data["age_months"] !== undefined ? data["age_months"] : <any>null;
            this.age_years = data["age_years"] !== undefined ? data["age_years"] : <any>null;
            this.birth_date = data["birth_date"] !== undefined ? data["birth_date"] : <any>null;
            this.firstname = data["firstname"] !== undefined ? data["firstname"] : <any>null;
            this.job = data["job"] !== undefined ? data["job"] : <any>null;
            this.job_position = data["job_position"] !== undefined ? data["job_position"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.sex_id = data["sex_id"] !== undefined ? data["sex_id"] : <any>null;
            this.social_status_id = data["social_status_id"] !== undefined ? data["social_status_id"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardPatient {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardPatient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Dms"] = this.dms !== undefined ? this.dms : <any>null;
        data["Oms"] = this.oms !== undefined ? this.oms : <any>null;
        data["OmsOrganisation"] = this.omsOrganisation !== undefined ? this.omsOrganisation : <any>null;
        data["age_days"] = this.age_days !== undefined ? this.age_days : <any>null;
        data["age_months"] = this.age_months !== undefined ? this.age_months : <any>null;
        data["age_years"] = this.age_years !== undefined ? this.age_years : <any>null;
        data["birth_date"] = this.birth_date !== undefined ? this.birth_date : <any>null;
        data["firstname"] = this.firstname !== undefined ? this.firstname : <any>null;
        data["job"] = this.job !== undefined ? this.job : <any>null;
        data["job_position"] = this.job_position !== undefined ? this.job_position : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["sex_id"] = this.sex_id !== undefined ? this.sex_id : <any>null;
        data["social_status_id"] = this.social_status_id !== undefined ? this.social_status_id : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        return data; 
    }
}

export interface IMobileCardPatient {
    dms?: string | null;
    oms?: string | null;
    omsOrganisation?: string | null;
    age_days?: number | null;
    age_months?: number | null;
    age_years?: number | null;
    birth_date?: string | null;
    firstname?: string | null;
    job?: string | null;
    job_position?: string | null;
    patronymic?: string | null;
    sex_id?: number | null;
    social_status_id?: number | null;
    surname?: string | null;
    type_id?: number | null;
}

export class ListContainerOfPerformerBean implements IListContainerOfPerformerBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfPerformerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfPerformerBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfPerformerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfPerformerBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class InquirerInCallDto implements IInquirerInCallDto {
    basic_reason_id?: number | null;
    brigade_types?: BrigadeTypeDto[] | null;
    extra?: boolean | null;
    id?: number | null;
    items?: InquirerInCallDto[] | null;
    title?: string | null;
    type?: string | null;

    constructor(data?: IInquirerInCallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.basic_reason_id = data["basic_reason_id"] !== undefined ? data["basic_reason_id"] : <any>null;
            if (data["brigade_types"] && data["brigade_types"].constructor === Array) {
                this.brigade_types = [];
                for (let item of data["brigade_types"])
                    this.brigade_types.push(BrigadeTypeDto.fromJS(item));
            }
            this.extra = data["extra"] !== undefined ? data["extra"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(InquirerInCallDto.fromJS(item));
            }
            this.title = data["title"] !== undefined ? data["title"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerInCallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerInCallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basic_reason_id"] = this.basic_reason_id !== undefined ? this.basic_reason_id : <any>null;
        if (this.brigade_types && this.brigade_types.constructor === Array) {
            data["brigade_types"] = [];
            for (let item of this.brigade_types)
                data["brigade_types"].push(item.toJSON());
        }
        data["extra"] = this.extra !== undefined ? this.extra : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IInquirerInCallDto {
    basic_reason_id?: number | null;
    brigade_types?: BrigadeTypeDto[] | null;
    extra?: boolean | null;
    id?: number | null;
    items?: InquirerInCallDto[] | null;
    title?: string | null;
    type?: string | null;
}

export class HospitalDto implements IHospitalDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;

    constructor(data?: IHospitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? FiasAddressDto.fromJS(data["address"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.district_code = data["district_code"] !== undefined ? data["district_code"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
        }
    }

    static fromJS(data: any): HospitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["district_code"] = this.district_code !== undefined ? this.district_code : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        return data; 
    }
}

export interface IHospitalDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
}

export class Medicine implements IMedicine {
    count?: number | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;

    constructor(data?: IMedicine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.uid = data["uid"] !== undefined ? data["uid"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
        }
    }

    static fromJS(data: any): Medicine {
        data = typeof data === 'object' ? data : {};
        let result = new Medicine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["uid"] = this.uid !== undefined ? this.uid : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        return data; 
    }
}

export interface IMedicine {
    count?: number | null;
    name?: string | null;
    uid?: string | null;
    unit_code?: string | null;
}

export class PerformerShortDto implements IPerformerShortDto {
    first_name?: string | null;
    id?: number | null;
    patronymic?: string | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: IPerformerShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.second_name = data["second_name"] !== undefined ? data["second_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["second_name"] = this.second_name !== undefined ? this.second_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface IPerformerShortDto {
    first_name?: string | null;
    id?: number | null;
    patronymic?: string | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class MessageDto implements IMessageDto {
    message?: string | null;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"] !== undefined ? data["message"] : <any>null;
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data; 
    }
}

export interface IMessageDto {
    message?: string | null;
}

export class CardObjectiveDiuresisPartDto implements ICardObjectiveDiuresisPartDto {
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;

    constructor(data?: ICardObjectiveDiuresisPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diuresis_disuria = data["diuresis_disuria"] !== undefined ? data["diuresis_disuria"] : <any>null;
            this.diuresis_hematuria = data["diuresis_hematuria"] !== undefined ? data["diuresis_hematuria"] : <any>null;
            this.diuresis_n = data["diuresis_n"] !== undefined ? data["diuresis_n"] : <any>null;
            this.diuresis_oliguria = data["diuresis_oliguria"] !== undefined ? data["diuresis_oliguria"] : <any>null;
            this.lion_tapping_left = data["lion_tapping_left"] !== undefined ? data["lion_tapping_left"] : <any>null;
            this.lion_tapping_right = data["lion_tapping_right"] !== undefined ? data["lion_tapping_right"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveDiuresisPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveDiuresisPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diuresis_disuria"] = this.diuresis_disuria !== undefined ? this.diuresis_disuria : <any>null;
        data["diuresis_hematuria"] = this.diuresis_hematuria !== undefined ? this.diuresis_hematuria : <any>null;
        data["diuresis_n"] = this.diuresis_n !== undefined ? this.diuresis_n : <any>null;
        data["diuresis_oliguria"] = this.diuresis_oliguria !== undefined ? this.diuresis_oliguria : <any>null;
        data["lion_tapping_left"] = this.lion_tapping_left !== undefined ? this.lion_tapping_left : <any>null;
        data["lion_tapping_right"] = this.lion_tapping_right !== undefined ? this.lion_tapping_right : <any>null;
        return data; 
    }
}

export interface ICardObjectiveDiuresisPartDto {
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;
}

export class BrigadeDto implements IBrigadeDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_receiving_type_id?: number | null;
    brigade_receiving_type_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    can_use?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    full_name?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    on_duty?: boolean | null;
    on_duty_comment?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    status_time?: Date | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_state_mark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;

    constructor(data?: IBrigadeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.br_type_code = data["br_type_code"] !== undefined ? data["br_type_code"] : <any>null;
            this.br_type_id = data["br_type_id"] !== undefined ? data["br_type_id"] : <any>null;
            this.br_type_name = data["br_type_name"] !== undefined ? data["br_type_name"] : <any>null;
            this.brigade_receiving_type_id = data["brigade_receiving_type_id"] !== undefined ? data["brigade_receiving_type_id"] : <any>null;
            this.brigade_receiving_type_name = data["brigade_receiving_type_name"] !== undefined ? data["brigade_receiving_type_name"] : <any>null;
            this.brigade_status_id = data["brigade_status_id"] !== undefined ? data["brigade_status_id"] : <any>null;
            this.brigade_status_name = data["brigade_status_name"] !== undefined ? data["brigade_status_name"] : <any>null;
            this.can_use = data["can_use"] !== undefined ? data["can_use"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.on_duty = data["on_duty"] !== undefined ? data["on_duty"] : <any>null;
            this.on_duty_comment = data["on_duty_comment"] !== undefined ? data["on_duty_comment"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerDto.fromJS(item));
            }
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.status_time = data["status_time"] ? new Date(data["status_time"].toString()) : <any>null;
            this.sub_code = data["sub_code"] !== undefined ? data["sub_code"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
            this.transport_state_mark = data["transport_state_mark"] !== undefined ? data["transport_state_mark"] : <any>null;
            this.workplace_id = data["workplace_id"] !== undefined ? data["workplace_id"] : <any>null;
            this.workplace_name = data["workplace_name"] !== undefined ? data["workplace_name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_type_code"] = this.br_type_code !== undefined ? this.br_type_code : <any>null;
        data["br_type_id"] = this.br_type_id !== undefined ? this.br_type_id : <any>null;
        data["br_type_name"] = this.br_type_name !== undefined ? this.br_type_name : <any>null;
        data["brigade_receiving_type_id"] = this.brigade_receiving_type_id !== undefined ? this.brigade_receiving_type_id : <any>null;
        data["brigade_receiving_type_name"] = this.brigade_receiving_type_name !== undefined ? this.brigade_receiving_type_name : <any>null;
        data["brigade_status_id"] = this.brigade_status_id !== undefined ? this.brigade_status_id : <any>null;
        data["brigade_status_name"] = this.brigade_status_name !== undefined ? this.brigade_status_name : <any>null;
        data["can_use"] = this.can_use !== undefined ? this.can_use : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["on_duty"] = this.on_duty !== undefined ? this.on_duty : <any>null;
        data["on_duty_comment"] = this.on_duty_comment !== undefined ? this.on_duty_comment : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["status_time"] = this.status_time ? this.status_time.toISOString() : <any>null;
        data["sub_code"] = this.sub_code !== undefined ? this.sub_code : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        data["transport_state_mark"] = this.transport_state_mark !== undefined ? this.transport_state_mark : <any>null;
        data["workplace_id"] = this.workplace_id !== undefined ? this.workplace_id : <any>null;
        data["workplace_name"] = this.workplace_name !== undefined ? this.workplace_name : <any>null;
        return data; 
    }
}

export interface IBrigadeDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_receiving_type_id?: number | null;
    brigade_receiving_type_name?: string | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    can_use?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    full_name?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    on_duty?: boolean | null;
    on_duty_comment?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    status_time?: Date | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_state_mark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;
}

export class CardObjectiveEdemaPartDto implements ICardObjectiveEdemaPartDto {
    titles?: boolean | null;
    titles_text?: string | null;

    constructor(data?: ICardObjectiveEdemaPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.titles = data["titles"] !== undefined ? data["titles"] : <any>null;
            this.titles_text = data["titles_text"] !== undefined ? data["titles_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveEdemaPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveEdemaPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titles"] = this.titles !== undefined ? this.titles : <any>null;
        data["titles_text"] = this.titles_text !== undefined ? this.titles_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveEdemaPartDto {
    titles?: boolean | null;
    titles_text?: string | null;
}

export class ListContainerOfSubdivisionBean implements IListContainerOfSubdivisionBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfSubdivisionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfSubdivisionBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfSubdivisionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfSubdivisionBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveGeneralStatePartDto implements ICardObjectiveGeneralStatePartDto {
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    general_state_id?: number | null;
    general_state_name?: string | null;

    constructor(data?: ICardObjectiveGeneralStatePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.behaviour_id = data["behaviour_id"] !== undefined ? data["behaviour_id"] : <any>null;
            this.behaviour_name = data["behaviour_name"] !== undefined ? data["behaviour_name"] : <any>null;
            this.conscious_id = data["conscious_id"] !== undefined ? data["conscious_id"] : <any>null;
            this.conscious_name = data["conscious_name"] !== undefined ? data["conscious_name"] : <any>null;
            this.general_state_id = data["general_state_id"] !== undefined ? data["general_state_id"] : <any>null;
            this.general_state_name = data["general_state_name"] !== undefined ? data["general_state_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveGeneralStatePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveGeneralStatePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["behaviour_id"] = this.behaviour_id !== undefined ? this.behaviour_id : <any>null;
        data["behaviour_name"] = this.behaviour_name !== undefined ? this.behaviour_name : <any>null;
        data["conscious_id"] = this.conscious_id !== undefined ? this.conscious_id : <any>null;
        data["conscious_name"] = this.conscious_name !== undefined ? this.conscious_name : <any>null;
        data["general_state_id"] = this.general_state_id !== undefined ? this.general_state_id : <any>null;
        data["general_state_name"] = this.general_state_name !== undefined ? this.general_state_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveGeneralStatePartDto {
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    general_state_id?: number | null;
    general_state_name?: string | null;
}

export class Place implements IPlace {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: PlaceType | null;
    type_name?: string | null;

    constructor(data?: IPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): Place {
        data = typeof data === 'object' ? data : {};
        let result = new Place();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface IPlace {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    type?: PlaceType | null;
    type_name?: string | null;
}

export class CardResultEfficiencyAssistance implements ICardResultEfficiencyAssistance {
    ad?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    id?: number | null;
    pulse?: string | null;
    pulse_oximetry?: string | null;
    temperature?: string | null;
    work_ad?: string | null;

    constructor(data?: ICardResultEfficiencyAssistance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ad = data["ad"] !== undefined ? data["ad"] : <any>null;
            this.chd = data["chd"] !== undefined ? data["chd"] : <any>null;
            this.chss = data["chss"] !== undefined ? data["chss"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.pulse = data["pulse"] !== undefined ? data["pulse"] : <any>null;
            this.pulse_oximetry = data["pulse_oximetry"] !== undefined ? data["pulse_oximetry"] : <any>null;
            this.temperature = data["temperature"] !== undefined ? data["temperature"] : <any>null;
            this.work_ad = data["work_ad"] !== undefined ? data["work_ad"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultEfficiencyAssistance {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultEfficiencyAssistance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ad"] = this.ad !== undefined ? this.ad : <any>null;
        data["chd"] = this.chd !== undefined ? this.chd : <any>null;
        data["chss"] = this.chss !== undefined ? this.chss : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["pulse"] = this.pulse !== undefined ? this.pulse : <any>null;
        data["pulse_oximetry"] = this.pulse_oximetry !== undefined ? this.pulse_oximetry : <any>null;
        data["temperature"] = this.temperature !== undefined ? this.temperature : <any>null;
        data["work_ad"] = this.work_ad !== undefined ? this.work_ad : <any>null;
        return data; 
    }
}

export interface ICardResultEfficiencyAssistance {
    ad?: string | null;
    chd?: string | null;
    chss?: string | null;
    glucometry?: string | null;
    id?: number | null;
    pulse?: string | null;
    pulse_oximetry?: string | null;
    temperature?: string | null;
    work_ad?: string | null;
}

export class TransportTypeDto implements ITransportTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ITransportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TransportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ITransportTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class PatientBean implements IPatientBean {
    /** Возраст (полных дней) */
    ageDays?: number | null;
    /** Возраст (полных месяцев) */
    ageMonths?: number | null;
    /** Возраст (полных лет) */
    ageYears?: number | null;
    /** Дата рождения */
    birthday?: Date | null;
    callPatient?: number | null;
    /** Гендер (и клал я свой огромный болт на то, что кто-то считает, что гендер и пол - разные вещи!) */
    gender?: boolean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Тип пациента */
    patientTypeFK?: ReferenceTypeBean | null;
    /** Отчетство */
    patronymic?: string | null;
    /** Фамилия */
    surname?: string | null;

    constructor(data?: IPatientBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ageDays = data["ageDays"] !== undefined ? data["ageDays"] : <any>null;
            this.ageMonths = data["ageMonths"] !== undefined ? data["ageMonths"] : <any>null;
            this.ageYears = data["ageYears"] !== undefined ? data["ageYears"] : <any>null;
            this.birthday = data["birthday"] ? new Date(data["birthday"].toString()) : <any>null;
            this.callPatient = data["callPatient"] !== undefined ? data["callPatient"] : <any>null;
            this.gender = data["gender"] !== undefined ? data["gender"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.patientTypeFK = data["patientTypeFK"] ? ReferenceTypeBean.fromJS(data["patientTypeFK"]) : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
        }
    }

    static fromJS(data: any): PatientBean {
        data = typeof data === 'object' ? data : {};
        let result = new PatientBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageDays"] = this.ageDays !== undefined ? this.ageDays : <any>null;
        data["ageMonths"] = this.ageMonths !== undefined ? this.ageMonths : <any>null;
        data["ageYears"] = this.ageYears !== undefined ? this.ageYears : <any>null;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>null;
        data["callPatient"] = this.callPatient !== undefined ? this.callPatient : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["patientTypeFK"] = this.patientTypeFK ? this.patientTypeFK.toJSON() : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        return data; 
    }
}

export interface IPatientBean {
    /** Возраст (полных дней) */
    ageDays?: number | null;
    /** Возраст (полных месяцев) */
    ageMonths?: number | null;
    /** Возраст (полных лет) */
    ageYears?: number | null;
    /** Дата рождения */
    birthday?: Date | null;
    callPatient?: number | null;
    /** Гендер (и клал я свой огромный болт на то, что кто-то считает, что гендер и пол - разные вещи!) */
    gender?: boolean | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Имя */
    name?: string | null;
    /** Тип пациента */
    patientTypeFK?: ReferenceTypeBean | null;
    /** Отчетство */
    patronymic?: string | null;
    /** Фамилия */
    surname?: string | null;
}

export class TransportBrigScheduleUpdateDto implements ITransportBrigScheduleUpdateDto {
    id?: number | null;
    period_details?: PeriodDetails | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleUpdateDto {
    id?: number | null;
    period_details?: PeriodDetails | null;
    transport_id?: number | null;
}

export class RoleBean implements IRoleBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): RoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new RoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IRoleBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfMapOfstringAndobject implements IListContainerOfMapOfstringAndobject {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfMapOfstringAndobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfMapOfstringAndobject {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfMapOfstringAndobject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfMapOfstringAndobject {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class BrigadeTransportScheduleBean implements IBrigadeTransportScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** ID транспорта */
    transport?: number | null;
    /** Транспорт */
    transportFK?: TransportBean | null;

    constructor(data?: IBrigadeTransportScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeSchedule = data["brigadeSchedule"] !== undefined ? data["brigadeSchedule"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.dutyEndDate = data["dutyEndDate"] ? new Date(data["dutyEndDate"].toString()) : <any>null;
            this.dutyStartDate = data["dutyStartDate"] ? new Date(data["dutyStartDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.transport = data["transport"] !== undefined ? data["transport"] : <any>null;
            this.transportFK = data["transportFK"] ? TransportBean.fromJS(data["transportFK"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeTransportScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeTransportScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeSchedule"] = this.brigadeSchedule !== undefined ? this.brigadeSchedule : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["dutyEndDate"] = this.dutyEndDate ? this.dutyEndDate.toISOString() : <any>null;
        data["dutyStartDate"] = this.dutyStartDate ? this.dutyStartDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["transport"] = this.transport !== undefined ? this.transport : <any>null;
        data["transportFK"] = this.transportFK ? this.transportFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeTransportScheduleBean {
    /** ID расписания бригады */
    brigadeSchedule?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** ID транспорта */
    transport?: number | null;
    /** Транспорт */
    transportFK?: TransportBean | null;
}

export class CardAnamnesisAllergicPartDto implements ICardAnamnesisAllergicPartDto {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_name?: string | null;
    allergic_anamnesis_text?: string | null;

    constructor(data?: ICardAnamnesisAllergicPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic_anamnesis = data["allergic_anamnesis"] !== undefined ? data["allergic_anamnesis"] : <any>null;
            this.allergic_anamnesis_name = data["allergic_anamnesis_name"] !== undefined ? data["allergic_anamnesis_name"] : <any>null;
            this.allergic_anamnesis_text = data["allergic_anamnesis_text"] !== undefined ? data["allergic_anamnesis_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisAllergicPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisAllergicPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic_anamnesis"] = this.allergic_anamnesis !== undefined ? this.allergic_anamnesis : <any>null;
        data["allergic_anamnesis_name"] = this.allergic_anamnesis_name !== undefined ? this.allergic_anamnesis_name : <any>null;
        data["allergic_anamnesis_text"] = this.allergic_anamnesis_text !== undefined ? this.allergic_anamnesis_text : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisAllergicPartDto {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_name?: string | null;
    allergic_anamnesis_text?: string | null;
}

export class InventoryNomenclature implements IInventoryNomenclature {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    inventory_id?: number | null;
    name?: string | null;
    packaging_count?: number | null;
    packaging_count_current?: number | null;
    product_count?: number | null;
    product_count_current?: number | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;

    constructor(data?: IInventoryNomenclature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.inventory_id = data["inventory_id"] !== undefined ? data["inventory_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.packaging_count = data["packaging_count"] !== undefined ? data["packaging_count"] : <any>null;
            this.packaging_count_current = data["packaging_count_current"] !== undefined ? data["packaging_count_current"] : <any>null;
            this.product_count = data["product_count"] !== undefined ? data["product_count"] : <any>null;
            this.product_count_current = data["product_count_current"] !== undefined ? data["product_count_current"] : <any>null;
            this.product_id = data["product_id"] !== undefined ? data["product_id"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
            this.unit_count = data["unit_count"] !== undefined ? data["unit_count"] : <any>null;
        }
    }

    static fromJS(data: any): InventoryNomenclature {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryNomenclature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["inventory_id"] = this.inventory_id !== undefined ? this.inventory_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["packaging_count"] = this.packaging_count !== undefined ? this.packaging_count : <any>null;
        data["packaging_count_current"] = this.packaging_count_current !== undefined ? this.packaging_count_current : <any>null;
        data["product_count"] = this.product_count !== undefined ? this.product_count : <any>null;
        data["product_count_current"] = this.product_count_current !== undefined ? this.product_count_current : <any>null;
        data["product_id"] = this.product_id !== undefined ? this.product_id : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        data["unit_count"] = this.unit_count !== undefined ? this.unit_count : <any>null;
        return data; 
    }
}

export interface IInventoryNomenclature {
    code?: string | null;
    deleted?: boolean | null;
    description?: string | null;
    id?: number | null;
    inventory_id?: number | null;
    name?: string | null;
    packaging_count?: number | null;
    packaging_count_current?: number | null;
    product_count?: number | null;
    product_count_current?: number | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;
}

export class AndyTreeNodeOfInquirerBean implements IAndyTreeNodeOfInquirerBean {
    children?: AndyTreeNodeOfInquirerBean[] | null;
    data?: InquirerBean | null;

    constructor(data?: IAndyTreeNodeOfInquirerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(AndyTreeNodeOfInquirerBean.fromJS(item));
            }
            this.data = data["data"] ? InquirerBean.fromJS(data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): AndyTreeNodeOfInquirerBean {
        data = typeof data === 'object' ? data : {};
        let result = new AndyTreeNodeOfInquirerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IAndyTreeNodeOfInquirerBean {
    children?: AndyTreeNodeOfInquirerBean[] | null;
    data?: InquirerBean | null;
}

export class Container implements IContainer {
    columns?: string[] | null;
    list?: any[] | null;

    constructor(data?: IContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["columns"] && data["columns"].constructor === Array) {
                this.columns = [];
                for (let item of data["columns"])
                    this.columns.push(item);
            }
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(item);
            }
        }
    }

    static fromJS(data: any): Container {
        data = typeof data === 'object' ? data : {};
        let result = new Container();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.columns && this.columns.constructor === Array) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item);
        }
        return data; 
    }
}

export interface IContainer {
    columns?: string[] | null;
    list?: any[] | null;
}

export class PeriodDetails implements IPeriodDetails {
    date_from?: Date | null;
    date_to?: Date | null;
    duty_comment?: string | null;
    duty_end_date?: Date | null;
    duty_start_date?: Date | null;

    constructor(data?: IPeriodDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_from = data["date_from"] ? new Date(data["date_from"].toString()) : <any>null;
            this.date_to = data["date_to"] ? new Date(data["date_to"].toString()) : <any>null;
            this.duty_comment = data["duty_comment"] !== undefined ? data["duty_comment"] : <any>null;
            this.duty_end_date = data["duty_end_date"] ? new Date(data["duty_end_date"].toString()) : <any>null;
            this.duty_start_date = data["duty_start_date"] ? new Date(data["duty_start_date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PeriodDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_from"] = this.date_from ? this.date_from.toISOString() : <any>null;
        data["date_to"] = this.date_to ? this.date_to.toISOString() : <any>null;
        data["duty_comment"] = this.duty_comment !== undefined ? this.duty_comment : <any>null;
        data["duty_end_date"] = this.duty_end_date ? this.duty_end_date.toISOString() : <any>null;
        data["duty_start_date"] = this.duty_start_date ? this.duty_start_date.toISOString() : <any>null;
        return data; 
    }
}

export interface IPeriodDetails {
    date_from?: Date | null;
    date_to?: Date | null;
    duty_comment?: string | null;
    duty_end_date?: Date | null;
    duty_start_date?: Date | null;
}

export class ListContainerOfTherapyTemplateItemBean implements IListContainerOfTherapyTemplateItemBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTherapyTemplateItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTherapyTemplateItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTherapyTemplateItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTherapyTemplateItemBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveWheezingPartDto implements ICardObjectiveWheezingPartDto {
    lungs_wheezing_id?: number | null;
    lungs_wheezing_name?: string | null;
    lungs_wheezing_text?: string | null;

    constructor(data?: ICardObjectiveWheezingPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lungs_wheezing_id = data["lungs_wheezing_id"] !== undefined ? data["lungs_wheezing_id"] : <any>null;
            this.lungs_wheezing_name = data["lungs_wheezing_name"] !== undefined ? data["lungs_wheezing_name"] : <any>null;
            this.lungs_wheezing_text = data["lungs_wheezing_text"] !== undefined ? data["lungs_wheezing_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveWheezingPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveWheezingPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lungs_wheezing_id"] = this.lungs_wheezing_id !== undefined ? this.lungs_wheezing_id : <any>null;
        data["lungs_wheezing_name"] = this.lungs_wheezing_name !== undefined ? this.lungs_wheezing_name : <any>null;
        data["lungs_wheezing_text"] = this.lungs_wheezing_text !== undefined ? this.lungs_wheezing_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveWheezingPartDto {
    lungs_wheezing_id?: number | null;
    lungs_wheezing_name?: string | null;
    lungs_wheezing_text?: string | null;
}

export class TreeNode implements ITreeNode {
    count_active?: number | null;
    count_all?: number | null;
    expanded?: boolean | null;
    id?: number | null;
    items?: TreeNode[] | null;
    leaf?: boolean | null;
    loaded?: boolean | null;
    text?: string | null;
    typeId?: number | null;

    constructor(data?: ITreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count_active = data["count_active"] !== undefined ? data["count_active"] : <any>null;
            this.count_all = data["count_all"] !== undefined ? data["count_all"] : <any>null;
            this.expanded = data["expanded"] !== undefined ? data["expanded"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TreeNode.fromJS(item));
            }
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.loaded = data["loaded"] !== undefined ? data["loaded"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.typeId = data["typeId"] !== undefined ? data["typeId"] : <any>null;
        }
    }

    static fromJS(data: any): TreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count_active"] = this.count_active !== undefined ? this.count_active : <any>null;
        data["count_all"] = this.count_all !== undefined ? this.count_all : <any>null;
        data["expanded"] = this.expanded !== undefined ? this.expanded : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["loaded"] = this.loaded !== undefined ? this.loaded : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["typeId"] = this.typeId !== undefined ? this.typeId : <any>null;
        return data; 
    }
}

export interface ITreeNode {
    count_active?: number | null;
    count_all?: number | null;
    expanded?: boolean | null;
    id?: number | null;
    items?: TreeNode[] | null;
    leaf?: boolean | null;
    loaded?: boolean | null;
    text?: string | null;
    typeId?: number | null;
}

export class BrigadeScheduleBean implements IBrigadeScheduleBean {
    /** ID бригады */
    brigade?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Признак вывода бригады на линию */
    isAvailable?: boolean | null;
    name?: string | null;
    performerScheduleList?: BrigadePerformerScheduleBean[] | null;
    transportScheduleList?: BrigadeTransportScheduleBean[] | null;

    constructor(data?: IBrigadeScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade = data["brigade"] !== undefined ? data["brigade"] : <any>null;
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.dutyEndDate = data["dutyEndDate"] ? new Date(data["dutyEndDate"].toString()) : <any>null;
            this.dutyStartDate = data["dutyStartDate"] ? new Date(data["dutyStartDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAvailable = data["isAvailable"] !== undefined ? data["isAvailable"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["performerScheduleList"] && data["performerScheduleList"].constructor === Array) {
                this.performerScheduleList = [];
                for (let item of data["performerScheduleList"])
                    this.performerScheduleList.push(BrigadePerformerScheduleBean.fromJS(item));
            }
            if (data["transportScheduleList"] && data["transportScheduleList"].constructor === Array) {
                this.transportScheduleList = [];
                for (let item of data["transportScheduleList"])
                    this.transportScheduleList.push(BrigadeTransportScheduleBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrigadeScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade"] = this.brigade !== undefined ? this.brigade : <any>null;
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["dutyEndDate"] = this.dutyEndDate ? this.dutyEndDate.toISOString() : <any>null;
        data["dutyStartDate"] = this.dutyStartDate ? this.dutyStartDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.performerScheduleList && this.performerScheduleList.constructor === Array) {
            data["performerScheduleList"] = [];
            for (let item of this.performerScheduleList)
                data["performerScheduleList"].push(item.toJSON());
        }
        if (this.transportScheduleList && this.transportScheduleList.constructor === Array) {
            data["transportScheduleList"] = [];
            for (let item of this.transportScheduleList)
                data["transportScheduleList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrigadeScheduleBean {
    /** ID бригады */
    brigade?: number | null;
    comment?: string | null;
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    /** Конец дежурства */
    dutyEndDate?: Date | null;
    /** Начало дежурства */
    dutyStartDate?: Date | null;
    id?: number | null;
    /** Признак вывода бригады на линию */
    isAvailable?: boolean | null;
    name?: string | null;
    performerScheduleList?: BrigadePerformerScheduleBean[] | null;
    transportScheduleList?: BrigadeTransportScheduleBean[] | null;
}

export class TransportBrigScheduleAvailableDto implements ITransportBrigScheduleAvailableDto {
    brand?: string | null;
    periods?: Period[] | null;
    statemark?: string | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleAvailableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brand = data["brand"] !== undefined ? data["brand"] : <any>null;
            if (data["periods"] && data["periods"].constructor === Array) {
                this.periods = [];
                for (let item of data["periods"])
                    this.periods.push(Period.fromJS(item));
            }
            this.statemark = data["statemark"] !== undefined ? data["statemark"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleAvailableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleAvailableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand !== undefined ? this.brand : <any>null;
        if (this.periods && this.periods.constructor === Array) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item.toJSON());
        }
        data["statemark"] = this.statemark !== undefined ? this.statemark : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleAvailableDto {
    brand?: string | null;
    periods?: Period[] | null;
    statemark?: string | null;
    transport_id?: number | null;
}

export class CardSideTwoDto implements ICardSideTwoDto {
    anamnesis?: CardAnamnesisPartDto | null;
    objective?: CardObjectivePartDto | null;

    constructor(data?: ICardSideTwoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.anamnesis = data["anamnesis"] ? CardAnamnesisPartDto.fromJS(data["anamnesis"]) : <any>null;
            this.objective = data["objective"] ? CardObjectivePartDto.fromJS(data["objective"]) : <any>null;
        }
    }

    static fromJS(data: any): CardSideTwoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardSideTwoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anamnesis"] = this.anamnesis ? this.anamnesis.toJSON() : <any>null;
        data["objective"] = this.objective ? this.objective.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardSideTwoDto {
    anamnesis?: CardAnamnesisPartDto | null;
    objective?: CardObjectivePartDto | null;
}

export class PGgeometry implements IPGgeometry {
    geoType?: number | null;
    geometry?: Geometry | null;
    type?: string | null;
    value?: string | null;

    constructor(data?: IPGgeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.geoType = data["geoType"] !== undefined ? data["geoType"] : <any>null;
            this.geometry = data["geometry"] ? Geometry.fromJS(data["geometry"]) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PGgeometry {
        data = typeof data === 'object' ? data : {};
        let result = new PGgeometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["geoType"] = this.geoType !== undefined ? this.geoType : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IPGgeometry {
    geoType?: number | null;
    geometry?: Geometry | null;
    type?: string | null;
    value?: string | null;
}

export class TransportBrigScheduleDto implements ITransportBrigScheduleDto {
    brand?: string | null;
    id?: number | null;
    period_details?: PeriodDetails | null;
    statemark?: string | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brand = data["brand"] !== undefined ? data["brand"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.statemark = data["statemark"] !== undefined ? data["statemark"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand !== undefined ? this.brand : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["statemark"] = this.statemark !== undefined ? this.statemark : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleDto {
    brand?: string | null;
    id?: number | null;
    period_details?: PeriodDetails | null;
    statemark?: string | null;
    transport_id?: number | null;
}

export class CardObjectiveHeaderDto implements ICardObjectiveHeaderDto {
    is_created?: boolean | null;

    constructor(data?: ICardObjectiveHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        return data; 
    }
}

export interface ICardObjectiveHeaderDto {
    is_created?: boolean | null;
}

export class ArchiveCallContainer implements IArchiveCallContainer {
    brigadeId?: number | null;
    callPriorityList?: number[] | null;
    callStatusList?: number[] | null;
    callTypeId?: number | null;
    dateFrom?: string | null;
    dateTo?: string | null;
    declarantName?: string | null;
    declarantPhone?: string | null;
    declarantTypeId?: number | null;
    number?: string | null;
    patientAgeDays?: number | null;
    patientAgeMonths?: number | null;
    patientAgeYears?: number | null;
    patientName?: string | null;
    patientPatronymic?: string | null;
    patientSurname?: string | null;
    reason?: number | null;
    subdivisionId?: number | null;

    constructor(data?: IArchiveCallContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeId = data["brigadeId"] !== undefined ? data["brigadeId"] : <any>null;
            if (data["callPriorityList"] && data["callPriorityList"].constructor === Array) {
                this.callPriorityList = [];
                for (let item of data["callPriorityList"])
                    this.callPriorityList.push(item);
            }
            if (data["callStatusList"] && data["callStatusList"].constructor === Array) {
                this.callStatusList = [];
                for (let item of data["callStatusList"])
                    this.callStatusList.push(item);
            }
            this.callTypeId = data["callTypeId"] !== undefined ? data["callTypeId"] : <any>null;
            this.dateFrom = data["dateFrom"] !== undefined ? data["dateFrom"] : <any>null;
            this.dateTo = data["dateTo"] !== undefined ? data["dateTo"] : <any>null;
            this.declarantName = data["declarantName"] !== undefined ? data["declarantName"] : <any>null;
            this.declarantPhone = data["declarantPhone"] !== undefined ? data["declarantPhone"] : <any>null;
            this.declarantTypeId = data["declarantTypeId"] !== undefined ? data["declarantTypeId"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patientAgeDays = data["patientAgeDays"] !== undefined ? data["patientAgeDays"] : <any>null;
            this.patientAgeMonths = data["patientAgeMonths"] !== undefined ? data["patientAgeMonths"] : <any>null;
            this.patientAgeYears = data["patientAgeYears"] !== undefined ? data["patientAgeYears"] : <any>null;
            this.patientName = data["patientName"] !== undefined ? data["patientName"] : <any>null;
            this.patientPatronymic = data["patientPatronymic"] !== undefined ? data["patientPatronymic"] : <any>null;
            this.patientSurname = data["patientSurname"] !== undefined ? data["patientSurname"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
        }
    }

    static fromJS(data: any): ArchiveCallContainer {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveCallContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeId"] = this.brigadeId !== undefined ? this.brigadeId : <any>null;
        if (this.callPriorityList && this.callPriorityList.constructor === Array) {
            data["callPriorityList"] = [];
            for (let item of this.callPriorityList)
                data["callPriorityList"].push(item);
        }
        if (this.callStatusList && this.callStatusList.constructor === Array) {
            data["callStatusList"] = [];
            for (let item of this.callStatusList)
                data["callStatusList"].push(item);
        }
        data["callTypeId"] = this.callTypeId !== undefined ? this.callTypeId : <any>null;
        data["dateFrom"] = this.dateFrom !== undefined ? this.dateFrom : <any>null;
        data["dateTo"] = this.dateTo !== undefined ? this.dateTo : <any>null;
        data["declarantName"] = this.declarantName !== undefined ? this.declarantName : <any>null;
        data["declarantPhone"] = this.declarantPhone !== undefined ? this.declarantPhone : <any>null;
        data["declarantTypeId"] = this.declarantTypeId !== undefined ? this.declarantTypeId : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patientAgeDays"] = this.patientAgeDays !== undefined ? this.patientAgeDays : <any>null;
        data["patientAgeMonths"] = this.patientAgeMonths !== undefined ? this.patientAgeMonths : <any>null;
        data["patientAgeYears"] = this.patientAgeYears !== undefined ? this.patientAgeYears : <any>null;
        data["patientName"] = this.patientName !== undefined ? this.patientName : <any>null;
        data["patientPatronymic"] = this.patientPatronymic !== undefined ? this.patientPatronymic : <any>null;
        data["patientSurname"] = this.patientSurname !== undefined ? this.patientSurname : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        return data; 
    }
}

export interface IArchiveCallContainer {
    brigadeId?: number | null;
    callPriorityList?: number[] | null;
    callStatusList?: number[] | null;
    callTypeId?: number | null;
    dateFrom?: string | null;
    dateTo?: string | null;
    declarantName?: string | null;
    declarantPhone?: string | null;
    declarantTypeId?: number | null;
    number?: string | null;
    patientAgeDays?: number | null;
    patientAgeMonths?: number | null;
    patientAgeYears?: number | null;
    patientName?: string | null;
    patientPatronymic?: string | null;
    patientSurname?: string | null;
    reason?: number | null;
    subdivisionId?: number | null;
}

export class PushTokenBean implements IPushTokenBean {
    /** Версия приложения */
    appVersion?: string | null;
    /** ID бригады, использующей устргойство */
    brigadeId?: number | null;
    /** Hashcode */
    hash?: string | null;
    /** Производитель устройства */
    manufacturer?: string | null;
    /** Модель устройства */
    model?: string | null;
    /** Операционная система */
    os?: string | null;
    /** Версия ОС */
    osVersion?: string | null;
    /** Токен */
    token?: string | null;

    constructor(data?: IPushTokenBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appVersion = data["appVersion"] !== undefined ? data["appVersion"] : <any>null;
            this.brigadeId = data["brigadeId"] !== undefined ? data["brigadeId"] : <any>null;
            this.hash = data["hash"] !== undefined ? data["hash"] : <any>null;
            this.manufacturer = data["manufacturer"] !== undefined ? data["manufacturer"] : <any>null;
            this.model = data["model"] !== undefined ? data["model"] : <any>null;
            this.os = data["os"] !== undefined ? data["os"] : <any>null;
            this.osVersion = data["osVersion"] !== undefined ? data["osVersion"] : <any>null;
            this.token = data["token"] !== undefined ? data["token"] : <any>null;
        }
    }

    static fromJS(data: any): PushTokenBean {
        data = typeof data === 'object' ? data : {};
        let result = new PushTokenBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appVersion"] = this.appVersion !== undefined ? this.appVersion : <any>null;
        data["brigadeId"] = this.brigadeId !== undefined ? this.brigadeId : <any>null;
        data["hash"] = this.hash !== undefined ? this.hash : <any>null;
        data["manufacturer"] = this.manufacturer !== undefined ? this.manufacturer : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        data["os"] = this.os !== undefined ? this.os : <any>null;
        data["osVersion"] = this.osVersion !== undefined ? this.osVersion : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface IPushTokenBean {
    /** Версия приложения */
    appVersion?: string | null;
    /** ID бригады, использующей устргойство */
    brigadeId?: number | null;
    /** Hashcode */
    hash?: string | null;
    /** Производитель устройства */
    manufacturer?: string | null;
    /** Модель устройства */
    model?: string | null;
    /** Операционная система */
    os?: string | null;
    /** Версия ОС */
    osVersion?: string | null;
    /** Токен */
    token?: string | null;
}

export class ReportRequestDto implements IReportRequestDto {
    am?: string | null;
    apu?: string | null;
    code?: string | null;
    dateFromAsLocalDateTime?: Date | null;
    dateToAsLocalDateTime?: Date | null;
    date_from?: string | null;
    date_to?: string | null;
    equip_id?: number | null;
    format?: number | null;
    image?: string[] | null;
    interval?: number | null;
    sub_id?: number | null;
    type?: number | null;

    constructor(data?: IReportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.am = data["am"] !== undefined ? data["am"] : <any>null;
            this.apu = data["apu"] !== undefined ? data["apu"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.dateFromAsLocalDateTime = data["dateFromAsLocalDateTime"] ? new Date(data["dateFromAsLocalDateTime"].toString()) : <any>null;
            this.dateToAsLocalDateTime = data["dateToAsLocalDateTime"] ? new Date(data["dateToAsLocalDateTime"].toString()) : <any>null;
            this.date_from = data["date_from"] !== undefined ? data["date_from"] : <any>null;
            this.date_to = data["date_to"] !== undefined ? data["date_to"] : <any>null;
            this.equip_id = data["equip_id"] !== undefined ? data["equip_id"] : <any>null;
            this.format = data["format"] !== undefined ? data["format"] : <any>null;
            if (data["image"] && data["image"].constructor === Array) {
                this.image = [];
                for (let item of data["image"])
                    this.image.push(item);
            }
            this.interval = data["interval"] !== undefined ? data["interval"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): ReportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["am"] = this.am !== undefined ? this.am : <any>null;
        data["apu"] = this.apu !== undefined ? this.apu : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["dateFromAsLocalDateTime"] = this.dateFromAsLocalDateTime ? this.dateFromAsLocalDateTime.toISOString() : <any>null;
        data["dateToAsLocalDateTime"] = this.dateToAsLocalDateTime ? this.dateToAsLocalDateTime.toISOString() : <any>null;
        data["date_from"] = this.date_from !== undefined ? this.date_from : <any>null;
        data["date_to"] = this.date_to !== undefined ? this.date_to : <any>null;
        data["equip_id"] = this.equip_id !== undefined ? this.equip_id : <any>null;
        data["format"] = this.format !== undefined ? this.format : <any>null;
        if (this.image && this.image.constructor === Array) {
            data["image"] = [];
            for (let item of this.image)
                data["image"].push(item);
        }
        data["interval"] = this.interval !== undefined ? this.interval : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReportRequestDto {
    am?: string | null;
    apu?: string | null;
    code?: string | null;
    dateFromAsLocalDateTime?: Date | null;
    dateToAsLocalDateTime?: Date | null;
    date_from?: string | null;
    date_to?: string | null;
    equip_id?: number | null;
    format?: number | null;
    image?: string[] | null;
    interval?: number | null;
    sub_id?: number | null;
    type?: number | null;
}

export class ChatMessage implements IChatMessage {
    blob?: string[] | null;
    chat_id?: number | null;
    date?: Date | null;
    id?: number | null;
    sender_id?: number | null;
    sender_name?: string | null;
    sender_position?: string | null;
    sender_subdivision_name?: string | null;
    text?: string | null;
    type?: ChatMessageType | null;
    was_read?: boolean | null;

    constructor(data?: IChatMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["blob"] && data["blob"].constructor === Array) {
                this.blob = [];
                for (let item of data["blob"])
                    this.blob.push(item);
            }
            this.chat_id = data["chat_id"] !== undefined ? data["chat_id"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.sender_id = data["sender_id"] !== undefined ? data["sender_id"] : <any>null;
            this.sender_name = data["sender_name"] !== undefined ? data["sender_name"] : <any>null;
            this.sender_position = data["sender_position"] !== undefined ? data["sender_position"] : <any>null;
            this.sender_subdivision_name = data["sender_subdivision_name"] !== undefined ? data["sender_subdivision_name"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.was_read = data["was_read"] !== undefined ? data["was_read"] : <any>null;
        }
    }

    static fromJS(data: any): ChatMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.blob && this.blob.constructor === Array) {
            data["blob"] = [];
            for (let item of this.blob)
                data["blob"].push(item);
        }
        data["chat_id"] = this.chat_id !== undefined ? this.chat_id : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["sender_id"] = this.sender_id !== undefined ? this.sender_id : <any>null;
        data["sender_name"] = this.sender_name !== undefined ? this.sender_name : <any>null;
        data["sender_position"] = this.sender_position !== undefined ? this.sender_position : <any>null;
        data["sender_subdivision_name"] = this.sender_subdivision_name !== undefined ? this.sender_subdivision_name : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["was_read"] = this.was_read !== undefined ? this.was_read : <any>null;
        return data; 
    }
}

export interface IChatMessage {
    blob?: string[] | null;
    chat_id?: number | null;
    date?: Date | null;
    id?: number | null;
    sender_id?: number | null;
    sender_name?: string | null;
    sender_position?: string | null;
    sender_subdivision_name?: string | null;
    text?: string | null;
    type?: ChatMessageType | null;
    was_read?: boolean | null;
}

export class TherapyTemplateItemDto implements ITherapyTemplateItemDto {
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    template_id?: number | null;

    constructor(data?: ITherapyTemplateItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.template_id = data["template_id"] !== undefined ? data["template_id"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["template_id"] = this.template_id !== undefined ? this.template_id : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateItemDto {
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    template_id?: number | null;
}

export class Inquirer implements IInquirer {
    answer?: string | null;
    brigadeTypes?: BrigadeType[] | null;
    childs?: Inquirer[] | null;
    codes?: string[] | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    final?: boolean | null;
    id?: number | null;
    isFinal?: boolean | null;
    parent?: Inquirer | null;
    query?: string | null;
    reasonBasic?: boolean | null;
    reasonComment?: string | null;
    reasonExtra?: boolean | null;
    reasonName?: string | null;
    type?: string | null;

    constructor(data?: IInquirer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer = data["answer"] !== undefined ? data["answer"] : <any>null;
            if (data["brigadeTypes"] && data["brigadeTypes"].constructor === Array) {
                this.brigadeTypes = [];
                for (let item of data["brigadeTypes"])
                    this.brigadeTypes.push(BrigadeType.fromJS(item));
            }
            if (data["childs"] && data["childs"].constructor === Array) {
                this.childs = [];
                for (let item of data["childs"])
                    this.childs.push(Inquirer.fromJS(item));
            }
            if (data["codes"] && data["codes"].constructor === Array) {
                this.codes = [];
                for (let item of data["codes"])
                    this.codes.push(item);
            }
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.final = data["final"] !== undefined ? data["final"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isFinal = data["isFinal"] !== undefined ? data["isFinal"] : <any>null;
            this.parent = data["parent"] ? Inquirer.fromJS(data["parent"]) : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.reasonBasic = data["reasonBasic"] !== undefined ? data["reasonBasic"] : <any>null;
            this.reasonComment = data["reasonComment"] !== undefined ? data["reasonComment"] : <any>null;
            this.reasonExtra = data["reasonExtra"] !== undefined ? data["reasonExtra"] : <any>null;
            this.reasonName = data["reasonName"] !== undefined ? data["reasonName"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Inquirer {
        data = typeof data === 'object' ? data : {};
        let result = new Inquirer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer !== undefined ? this.answer : <any>null;
        if (this.brigadeTypes && this.brigadeTypes.constructor === Array) {
            data["brigadeTypes"] = [];
            for (let item of this.brigadeTypes)
                data["brigadeTypes"].push(item.toJSON());
        }
        if (this.childs && this.childs.constructor === Array) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        if (this.codes && this.codes.constructor === Array) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["final"] = this.final !== undefined ? this.final : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isFinal"] = this.isFinal !== undefined ? this.isFinal : <any>null;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["reasonBasic"] = this.reasonBasic !== undefined ? this.reasonBasic : <any>null;
        data["reasonComment"] = this.reasonComment !== undefined ? this.reasonComment : <any>null;
        data["reasonExtra"] = this.reasonExtra !== undefined ? this.reasonExtra : <any>null;
        data["reasonName"] = this.reasonName !== undefined ? this.reasonName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IInquirer {
    answer?: string | null;
    brigadeTypes?: BrigadeType[] | null;
    childs?: Inquirer[] | null;
    codes?: string[] | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    final?: boolean | null;
    id?: number | null;
    isFinal?: boolean | null;
    parent?: Inquirer | null;
    query?: string | null;
    reasonBasic?: boolean | null;
    reasonComment?: string | null;
    reasonExtra?: boolean | null;
    reasonName?: string | null;
    type?: string | null;
}

export class CallContainer implements ICallContainer {
    brigadeList?: BrigadeContainer[] | null;
    call?: CallBean | null;
    patientList?: PatientBean[] | null;

    constructor(data?: ICallContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["brigadeList"] && data["brigadeList"].constructor === Array) {
                this.brigadeList = [];
                for (let item of data["brigadeList"])
                    this.brigadeList.push(BrigadeContainer.fromJS(item));
            }
            this.call = data["call"] ? CallBean.fromJS(data["call"]) : <any>null;
            if (data["patientList"] && data["patientList"].constructor === Array) {
                this.patientList = [];
                for (let item of data["patientList"])
                    this.patientList.push(PatientBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CallContainer {
        data = typeof data === 'object' ? data : {};
        let result = new CallContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.brigadeList && this.brigadeList.constructor === Array) {
            data["brigadeList"] = [];
            for (let item of this.brigadeList)
                data["brigadeList"].push(item.toJSON());
        }
        data["call"] = this.call ? this.call.toJSON() : <any>null;
        if (this.patientList && this.patientList.constructor === Array) {
            data["patientList"] = [];
            for (let item of this.patientList)
                data["patientList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICallContainer {
    brigadeList?: BrigadeContainer[] | null;
    call?: CallBean | null;
    patientList?: PatientBean[] | null;
}

export class ListContainerOfTherapyItemBean implements IListContainerOfTherapyItemBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTherapyItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTherapyItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTherapyItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTherapyItemBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class TherapyTemplateItemBean implements ITherapyTemplateItemBean {
    code?: string | null;
    /** Группа */
    groupFK?: PharmacyGroupBean | null;
    /** Id группы */
    groupId?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Id шаблона */
    templateId?: number | null;
    /** Шаблон */
    therapyTemplateFK?: TherapyTemplateBean | null;

    constructor(data?: ITherapyTemplateItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.groupFK = data["groupFK"] ? PharmacyGroupBean.fromJS(data["groupFK"]) : <any>null;
            this.groupId = data["groupId"] !== undefined ? data["groupId"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.templateId = data["templateId"] !== undefined ? data["templateId"] : <any>null;
            this.therapyTemplateFK = data["therapyTemplateFK"] ? TherapyTemplateBean.fromJS(data["therapyTemplateFK"]) : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["groupFK"] = this.groupFK ? this.groupFK.toJSON() : <any>null;
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["templateId"] = this.templateId !== undefined ? this.templateId : <any>null;
        data["therapyTemplateFK"] = this.therapyTemplateFK ? this.therapyTemplateFK.toJSON() : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateItemBean {
    code?: string | null;
    /** Группа */
    groupFK?: PharmacyGroupBean | null;
    /** Id группы */
    groupId?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Id шаблона */
    templateId?: number | null;
    /** Шаблон */
    therapyTemplateFK?: TherapyTemplateBean | null;
}

export class CardResultActiveVisitDto implements ICardResultActiveVisitDto {
    active_visit_date?: Date | null;
    active_visit_hours?: number | null;
    active_visit_type_code?: string | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;

    constructor(data?: ICardResultActiveVisitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active_visit_date = data["active_visit_date"] ? new Date(data["active_visit_date"].toString()) : <any>null;
            this.active_visit_hours = data["active_visit_hours"] !== undefined ? data["active_visit_hours"] : <any>null;
            this.active_visit_type_code = data["active_visit_type_code"] !== undefined ? data["active_visit_type_code"] : <any>null;
            this.active_visit_type_id = data["active_visit_type_id"] !== undefined ? data["active_visit_type_id"] : <any>null;
            this.active_visit_type_name = data["active_visit_type_name"] !== undefined ? data["active_visit_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultActiveVisitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultActiveVisitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active_visit_date"] = this.active_visit_date ? this.active_visit_date.toISOString() : <any>null;
        data["active_visit_hours"] = this.active_visit_hours !== undefined ? this.active_visit_hours : <any>null;
        data["active_visit_type_code"] = this.active_visit_type_code !== undefined ? this.active_visit_type_code : <any>null;
        data["active_visit_type_id"] = this.active_visit_type_id !== undefined ? this.active_visit_type_id : <any>null;
        data["active_visit_type_name"] = this.active_visit_type_name !== undefined ? this.active_visit_type_name : <any>null;
        return data; 
    }
}

export interface ICardResultActiveVisitDto {
    active_visit_date?: Date | null;
    active_visit_hours?: number | null;
    active_visit_type_code?: string | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;
}

export class CardObjectiveLiverPartDto implements ICardObjectiveLiverPartDto {
    liver_normal_large?: number | null;
    liver_normal_large_name?: string | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;

    constructor(data?: ICardObjectiveLiverPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.liver_normal_large = data["liver_normal_large"] !== undefined ? data["liver_normal_large"] : <any>null;
            this.liver_normal_large_name = data["liver_normal_large_name"] !== undefined ? data["liver_normal_large_name"] : <any>null;
            this.liver_ortner = data["liver_ortner"] !== undefined ? data["liver_ortner"] : <any>null;
            this.liver_size_text = data["liver_size_text"] !== undefined ? data["liver_size_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveLiverPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveLiverPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["liver_normal_large"] = this.liver_normal_large !== undefined ? this.liver_normal_large : <any>null;
        data["liver_normal_large_name"] = this.liver_normal_large_name !== undefined ? this.liver_normal_large_name : <any>null;
        data["liver_ortner"] = this.liver_ortner !== undefined ? this.liver_ortner : <any>null;
        data["liver_size_text"] = this.liver_size_text !== undefined ? this.liver_size_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveLiverPartDto {
    liver_normal_large?: number | null;
    liver_normal_large_name?: string | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;
}

export class ListContainerOfLogBean implements IListContainerOfLogBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfLogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfLogBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfLogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfLogBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class MobileCard implements IMobileCard {
    address?: MobileCardAddress | null;
    anamnesis?: MobileCardAnamnesis | null;
    document?: MobileCardDocument | null;
    drugs?: MobileCardDrug[] | null;
    objective_data?: MobileCardObjective | null;
    patient?: MobileCardPatient | null;
    result?: MobileCardResult | null;

    constructor(data?: IMobileCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? MobileCardAddress.fromJS(data["address"]) : <any>null;
            this.anamnesis = data["anamnesis"] ? MobileCardAnamnesis.fromJS(data["anamnesis"]) : <any>null;
            this.document = data["document"] ? MobileCardDocument.fromJS(data["document"]) : <any>null;
            if (data["drugs"] && data["drugs"].constructor === Array) {
                this.drugs = [];
                for (let item of data["drugs"])
                    this.drugs.push(MobileCardDrug.fromJS(item));
            }
            this.objective_data = data["objective_data"] ? MobileCardObjective.fromJS(data["objective_data"]) : <any>null;
            this.patient = data["patient"] ? MobileCardPatient.fromJS(data["patient"]) : <any>null;
            this.result = data["result"] ? MobileCardResult.fromJS(data["result"]) : <any>null;
        }
    }

    static fromJS(data: any): MobileCard {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["anamnesis"] = this.anamnesis ? this.anamnesis.toJSON() : <any>null;
        data["document"] = this.document ? this.document.toJSON() : <any>null;
        if (this.drugs && this.drugs.constructor === Array) {
            data["drugs"] = [];
            for (let item of this.drugs)
                data["drugs"].push(item.toJSON());
        }
        data["objective_data"] = this.objective_data ? this.objective_data.toJSON() : <any>null;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>null;
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        return data; 
    }
}

export interface IMobileCard {
    address?: MobileCardAddress | null;
    anamnesis?: MobileCardAnamnesis | null;
    document?: MobileCardDocument | null;
    drugs?: MobileCardDrug[] | null;
    objective_data?: MobileCardObjective | null;
    patient?: MobileCardPatient | null;
    result?: MobileCardResult | null;
}

export class CardResultReasonDto implements ICardResultReasonDto {
    accident_type_code?: string | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: Date | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    reason_type_code?: string | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;

    constructor(data?: ICardResultReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accident_type_code = data["accident_type_code"] !== undefined ? data["accident_type_code"] : <any>null;
            this.accident_type_id = data["accident_type_id"] !== undefined ? data["accident_type_id"] : <any>null;
            this.accident_type_name = data["accident_type_name"] !== undefined ? data["accident_type_name"] : <any>null;
            this.death_condition_id = data["death_condition_id"] !== undefined ? data["death_condition_id"] : <any>null;
            this.death_condition_name = data["death_condition_name"] !== undefined ? data["death_condition_name"] : <any>null;
            this.death_time = data["death_time"] ? new Date(data["death_time"].toString()) : <any>null;
            this.intoxication_type_id = data["intoxication_type_id"] !== undefined ? data["intoxication_type_id"] : <any>null;
            this.intoxication_type_name = data["intoxication_type_name"] !== undefined ? data["intoxication_type_name"] : <any>null;
            this.reason_type_code = data["reason_type_code"] !== undefined ? data["reason_type_code"] : <any>null;
            this.reason_type_id = data["reason_type_id"] !== undefined ? data["reason_type_id"] : <any>null;
            this.reason_type_name = data["reason_type_name"] !== undefined ? data["reason_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accident_type_code"] = this.accident_type_code !== undefined ? this.accident_type_code : <any>null;
        data["accident_type_id"] = this.accident_type_id !== undefined ? this.accident_type_id : <any>null;
        data["accident_type_name"] = this.accident_type_name !== undefined ? this.accident_type_name : <any>null;
        data["death_condition_id"] = this.death_condition_id !== undefined ? this.death_condition_id : <any>null;
        data["death_condition_name"] = this.death_condition_name !== undefined ? this.death_condition_name : <any>null;
        data["death_time"] = this.death_time ? this.death_time.toISOString() : <any>null;
        data["intoxication_type_id"] = this.intoxication_type_id !== undefined ? this.intoxication_type_id : <any>null;
        data["intoxication_type_name"] = this.intoxication_type_name !== undefined ? this.intoxication_type_name : <any>null;
        data["reason_type_code"] = this.reason_type_code !== undefined ? this.reason_type_code : <any>null;
        data["reason_type_id"] = this.reason_type_id !== undefined ? this.reason_type_id : <any>null;
        data["reason_type_name"] = this.reason_type_name !== undefined ? this.reason_type_name : <any>null;
        return data; 
    }
}

export interface ICardResultReasonDto {
    accident_type_code?: string | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: Date | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    reason_type_code?: string | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;
}

export class RoutingPointDto implements IRoutingPointDto {
    x1?: number | null;
    x2?: number | null;
    y1?: number | null;
    y2?: number | null;

    constructor(data?: IRoutingPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x1 = data["x1"] !== undefined ? data["x1"] : <any>null;
            this.x2 = data["x2"] !== undefined ? data["x2"] : <any>null;
            this.y1 = data["y1"] !== undefined ? data["y1"] : <any>null;
            this.y2 = data["y2"] !== undefined ? data["y2"] : <any>null;
        }
    }

    static fromJS(data: any): RoutingPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoutingPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x1"] = this.x1 !== undefined ? this.x1 : <any>null;
        data["x2"] = this.x2 !== undefined ? this.x2 : <any>null;
        data["y1"] = this.y1 !== undefined ? this.y1 : <any>null;
        data["y2"] = this.y2 !== undefined ? this.y2 : <any>null;
        return data; 
    }
}

export interface IRoutingPointDto {
    x1?: number | null;
    x2?: number | null;
    y1?: number | null;
    y2?: number | null;
}

export class Role implements IRole {
    active?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IRole {
    active?: boolean | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class ListContainerOfTherapyTemplateBean implements IListContainerOfTherapyTemplateBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTherapyTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTherapyTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTherapyTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTherapyTemplateBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardDto implements ICardDto {
    result?: CardResultDto | null;
    side_one?: CardSideOneDto | null;
    side_two?: CardSideTwoDto | null;
    similars?: string[] | null;

    constructor(data?: ICardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"] ? CardResultDto.fromJS(data["result"]) : <any>null;
            this.side_one = data["side_one"] ? CardSideOneDto.fromJS(data["side_one"]) : <any>null;
            this.side_two = data["side_two"] ? CardSideTwoDto.fromJS(data["side_two"]) : <any>null;
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
        }
    }

    static fromJS(data: any): CardDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>null;
        data["side_one"] = this.side_one ? this.side_one.toJSON() : <any>null;
        data["side_two"] = this.side_two ? this.side_two.toJSON() : <any>null;
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        return data; 
    }
}

export interface ICardDto {
    result?: CardResultDto | null;
    side_one?: CardSideOneDto | null;
    side_two?: CardSideTwoDto | null;
    similars?: string[] | null;
}

export class ListDtoOfPermission implements IListDtoOfPermission {
    list?: Permission[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(Permission.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfPermission {
    list?: Permission[] | null;
    size?: number | null;
    total?: number | null;
}

export class TransferAddresseeDto implements ITransferAddresseeDto {
    reconended_brigade_id?: number | null;
    subdivision_id?: number | null;

    constructor(data?: ITransferAddresseeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reconended_brigade_id = data["reconended_brigade_id"] !== undefined ? data["reconended_brigade_id"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransferAddresseeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferAddresseeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reconended_brigade_id"] = this.reconended_brigade_id !== undefined ? this.reconended_brigade_id : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        return data; 
    }
}

export interface ITransferAddresseeDto {
    reconended_brigade_id?: number | null;
    subdivision_id?: number | null;
}

export class PharmacyDto implements IPharmacyDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    items?: GroupBagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IPharmacyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.document_id = data["document_id"] !== undefined ? data["document_id"] : <any>null;
            this.document_name = data["document_name"] !== undefined ? data["document_name"] : <any>null;
            this.drug_id = data["drug_id"] !== undefined ? data["drug_id"] : <any>null;
            this.expiry_date = data["expiry_date"] ? new Date(data["expiry_date"].toString()) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.inner_amount = data["inner_amount"] !== undefined ? data["inner_amount"] : <any>null;
            this.is_reusable = data["is_reusable"] !== undefined ? data["is_reusable"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GroupBagItemDto.fromJS(item));
            }
            this.matrix_code = data["matrix_code"] !== undefined ? data["matrix_code"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.matrix_name = data["matrix_name"] !== undefined ? data["matrix_name"] : <any>null;
            this.minimum = data["minimum"] !== undefined ? data["minimum"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["document_id"] = this.document_id !== undefined ? this.document_id : <any>null;
        data["document_name"] = this.document_name !== undefined ? this.document_name : <any>null;
        data["drug_id"] = this.drug_id !== undefined ? this.drug_id : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toISOString() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["inner_amount"] = this.inner_amount !== undefined ? this.inner_amount : <any>null;
        data["is_reusable"] = this.is_reusable !== undefined ? this.is_reusable : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["matrix_code"] = this.matrix_code !== undefined ? this.matrix_code : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["matrix_name"] = this.matrix_name !== undefined ? this.matrix_name : <any>null;
        data["minimum"] = this.minimum !== undefined ? this.minimum : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    items?: GroupBagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    series_number?: number | null;
    type?: number | null;
}

export class PharmacyGroupBean implements IPharmacyGroupBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IPharmacyGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IPharmacyGroupBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfTherapyBean implements IListContainerOfTherapyBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTherapyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTherapyBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTherapyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTherapyBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ScheduleTypeBean implements IScheduleTypeBean {
    code?: string | null;
    /** Количество рабочих дней */
    daysOff?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Начало смены */
    timeFrom?: string | null;
    /** Окончание смены */
    timeTo?: string | null;
    /** Количество рабочих дней */
    workingDays?: number | null;
    /** Количество рабочих минут */
    workingMinutes?: number | null;

    constructor(data?: IScheduleTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.daysOff = data["daysOff"] !== undefined ? data["daysOff"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.timeFrom = data["timeFrom"] !== undefined ? data["timeFrom"] : <any>null;
            this.timeTo = data["timeTo"] !== undefined ? data["timeTo"] : <any>null;
            this.workingDays = data["workingDays"] !== undefined ? data["workingDays"] : <any>null;
            this.workingMinutes = data["workingMinutes"] !== undefined ? data["workingMinutes"] : <any>null;
        }
    }

    static fromJS(data: any): ScheduleTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["daysOff"] = this.daysOff !== undefined ? this.daysOff : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["timeFrom"] = this.timeFrom !== undefined ? this.timeFrom : <any>null;
        data["timeTo"] = this.timeTo !== undefined ? this.timeTo : <any>null;
        data["workingDays"] = this.workingDays !== undefined ? this.workingDays : <any>null;
        data["workingMinutes"] = this.workingMinutes !== undefined ? this.workingMinutes : <any>null;
        return data; 
    }
}

export interface IScheduleTypeBean {
    code?: string | null;
    /** Количество рабочих дней */
    daysOff?: number | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Начало смены */
    timeFrom?: string | null;
    /** Окончание смены */
    timeTo?: string | null;
    /** Количество рабочих дней */
    workingDays?: number | null;
    /** Количество рабочих минут */
    workingMinutes?: number | null;
}

export class CallSimilarRequestDto implements ICallSimilarRequestDto {
    ao_full_name?: string | null;
    declarant_phone?: string | null;
    district_guid?: string | null;
    house?: string | null;
    patient?: CallPatientPartDto[] | null;

    constructor(data?: ICallSimilarRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ao_full_name = data["ao_full_name"] !== undefined ? data["ao_full_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.district_guid = data["district_guid"] !== undefined ? data["district_guid"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            if (data["patient"] && data["patient"].constructor === Array) {
                this.patient = [];
                for (let item of data["patient"])
                    this.patient.push(CallPatientPartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CallSimilarRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallSimilarRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ao_full_name"] = this.ao_full_name !== undefined ? this.ao_full_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["district_guid"] = this.district_guid !== undefined ? this.district_guid : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        if (this.patient && this.patient.constructor === Array) {
            data["patient"] = [];
            for (let item of this.patient)
                data["patient"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICallSimilarRequestDto {
    ao_full_name?: string | null;
    declarant_phone?: string | null;
    district_guid?: string | null;
    house?: string | null;
    patient?: CallPatientPartDto[] | null;
}

export class StreetBean implements IStreetBean {
    cityAddress?: string | null;
    fullName?: string | null;
    highway?: boolean | null;
    name?: string | null;

    constructor(data?: IStreetBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityAddress = data["cityAddress"] !== undefined ? data["cityAddress"] : <any>null;
            this.fullName = data["fullName"] !== undefined ? data["fullName"] : <any>null;
            this.highway = data["highway"] !== undefined ? data["highway"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): StreetBean {
        data = typeof data === 'object' ? data : {};
        let result = new StreetBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityAddress"] = this.cityAddress !== undefined ? this.cityAddress : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["highway"] = this.highway !== undefined ? this.highway : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IStreetBean {
    cityAddress?: string | null;
    fullName?: string | null;
    highway?: boolean | null;
    name?: string | null;
}

export class District implements IDistrict {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    fiasId?: number | null;
    geometry?: PGgeometry | null;
    id?: number | null;
    name?: string | null;
    osmGid?: number | null;
    osmId?: number | null;
    zone?: string | null;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.fiasId = data["fiasId"] !== undefined ? data["fiasId"] : <any>null;
            this.geometry = data["geometry"] ? PGgeometry.fromJS(data["geometry"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.osmGid = data["osmGid"] !== undefined ? data["osmGid"] : <any>null;
            this.osmId = data["osmId"] !== undefined ? data["osmId"] : <any>null;
            this.zone = data["zone"] !== undefined ? data["zone"] : <any>null;
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["fiasId"] = this.fiasId !== undefined ? this.fiasId : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["osmGid"] = this.osmGid !== undefined ? this.osmGid : <any>null;
        data["osmId"] = this.osmId !== undefined ? this.osmId : <any>null;
        data["zone"] = this.zone !== undefined ? this.zone : <any>null;
        return data; 
    }
}

export interface IDistrict {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    fiasId?: number | null;
    geometry?: PGgeometry | null;
    id?: number | null;
    name?: string | null;
    osmGid?: number | null;
    osmId?: number | null;
    zone?: string | null;
}

export class ListContainerOfRoleBean implements IListContainerOfRoleBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfRoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfRoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfRoleBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class BrigadeBean implements IBrigadeBean {
    /** Статус бригады */
    brigadeStatus?: number | null;
    /** Статус бригады */
    brigadeStatusFK?: BrigadeStatusBean | null;
    /** Тип бригады */
    brigadeType?: number | null;
    /** Тип бригады */
    brigadeTypeFK?: BrigadeTypeBean | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    /** ID подразделения */
    subdivision?: number | null;
    /** ID рабочего подразделения */
    workplaceSubdivision?: number | null;

    constructor(data?: IBrigadeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeStatus = data["brigadeStatus"] !== undefined ? data["brigadeStatus"] : <any>null;
            this.brigadeStatusFK = data["brigadeStatusFK"] ? BrigadeStatusBean.fromJS(data["brigadeStatusFK"]) : <any>null;
            this.brigadeType = data["brigadeType"] !== undefined ? data["brigadeType"] : <any>null;
            this.brigadeTypeFK = data["brigadeTypeFK"] ? BrigadeTypeBean.fromJS(data["brigadeTypeFK"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivision = data["subdivision"] !== undefined ? data["subdivision"] : <any>null;
            this.workplaceSubdivision = data["workplaceSubdivision"] !== undefined ? data["workplaceSubdivision"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeStatus"] = this.brigadeStatus !== undefined ? this.brigadeStatus : <any>null;
        data["brigadeStatusFK"] = this.brigadeStatusFK ? this.brigadeStatusFK.toJSON() : <any>null;
        data["brigadeType"] = this.brigadeType !== undefined ? this.brigadeType : <any>null;
        data["brigadeTypeFK"] = this.brigadeTypeFK ? this.brigadeTypeFK.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivision"] = this.subdivision !== undefined ? this.subdivision : <any>null;
        data["workplaceSubdivision"] = this.workplaceSubdivision !== undefined ? this.workplaceSubdivision : <any>null;
        return data; 
    }
}

export interface IBrigadeBean {
    /** Статус бригады */
    brigadeStatus?: number | null;
    /** Статус бригады */
    brigadeStatusFK?: BrigadeStatusBean | null;
    /** Тип бригады */
    brigadeType?: number | null;
    /** Тип бригады */
    brigadeTypeFK?: BrigadeTypeBean | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    /** ID подразделения */
    subdivision?: number | null;
    /** ID рабочего подразделения */
    workplaceSubdivision?: number | null;
}

export class RegionBean implements IRegionBean {
    /** Родительский район */
    district?: string | null;
    /** Полное наименование региона */
    fullName?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование региона */
    name?: string | null;
    /** Родительский регион */
    region?: string | null;

    constructor(data?: IRegionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.fullName = data["fullName"] !== undefined ? data["fullName"] : <any>null;
            this.geometry = data["geometry"] ? PGgeometry.fromJS(data["geometry"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.idOSM = data["idOSM"] !== undefined ? data["idOSM"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.region = data["region"] !== undefined ? data["region"] : <any>null;
        }
    }

    static fromJS(data: any): RegionBean {
        data = typeof data === 'object' ? data : {};
        let result = new RegionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["geometry"] = this.geometry ? this.geometry.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["idOSM"] = this.idOSM !== undefined ? this.idOSM : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["region"] = this.region !== undefined ? this.region : <any>null;
        return data; 
    }
}

export interface IRegionBean {
    /** Родительский район */
    district?: string | null;
    /** Полное наименование региона */
    fullName?: string | null;
    /** Геометрия */
    geometry?: PGgeometry | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование региона */
    name?: string | null;
    /** Родительский регион */
    region?: string | null;
}

export class BagMatrixItemDto implements IBagMatrixItemDto {
    amount?: number | null;
    bag_id?: number | null;
    code?: string | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    nomenclature_id?: number | null;

    constructor(data?: IBagMatrixItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BagItemDto.fromJS(item));
            }
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
        }
    }

    static fromJS(data: any): BagMatrixItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BagMatrixItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        return data; 
    }
}

export interface IBagMatrixItemDto {
    amount?: number | null;
    bag_id?: number | null;
    code?: string | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    nomenclature_id?: number | null;
}

export class TherapyItemBean implements ITherapyItemBean {
    /** Количество */
    count?: number | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Название продукта */
    productName?: string | null;
    /** Терапия */
    therapyFK?: TherapyBean | null;
    /** Id терапии */
    therapyId?: number | null;

    constructor(data?: ITherapyItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.productName = data["productName"] !== undefined ? data["productName"] : <any>null;
            this.therapyFK = data["therapyFK"] ? TherapyBean.fromJS(data["therapyFK"]) : <any>null;
            this.therapyId = data["therapyId"] !== undefined ? data["therapyId"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["therapyFK"] = this.therapyFK ? this.therapyFK.toJSON() : <any>null;
        data["therapyId"] = this.therapyId !== undefined ? this.therapyId : <any>null;
        return data; 
    }
}

export interface ITherapyItemBean {
    /** Количество */
    count?: number | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Название продукта */
    productName?: string | null;
    /** Терапия */
    therapyFK?: TherapyBean | null;
    /** Id терапии */
    therapyId?: number | null;
}

export class CallBean implements ICallBean {
    /** Адрес вызова (город, улица и пр.) */
    address?: string | null;
    /** Дата/время вызова */
    date?: Date | null;
    /** Ф.И.О. заявителя */
    declarantName?: string | null;
    /** Номер телефона заявителя */
    declarantPhone?: string | null;
    /** Тип заявителя */
    declarantTypeFK?: ReferenceTypeBean | null;
    /** Код домофона */
    entranceCode?: string | null;
    /** Номер подъезда */
    entranceNum?: string | null;
    /** Адрес вызова (номер квартиры) */
    flatNum?: string | null;
    /** Адрес вызова (номер дома) */
    houseNum?: string | null;
    id?: number | null;
    /** Местоположение */
    location?: string | null;
    /** № вызова */
    number?: string | null;
    /** Сотрудник, принявший вызов */
    performer?: number | null;
    /** Сотрудник, принимающий вызов */
    performerFK?: PerformerBean | null;
    /** Тип места вызова */
    placeTypeFK?: ReferenceTypeBean | null;
    /** Приоритет */
    priority?: number | null;
    /** Комментарий к причине вызова */
    reasonComment?: string | null;
    /** Причина вызова */
    reasonFK?: InquirerBean | null;
    /** Статус */
    status?: number | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Тип вызова */
    typeFK?: ReferenceTypeBean | null;

    constructor(data?: ICallBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.declarantName = data["declarantName"] !== undefined ? data["declarantName"] : <any>null;
            this.declarantPhone = data["declarantPhone"] !== undefined ? data["declarantPhone"] : <any>null;
            this.declarantTypeFK = data["declarantTypeFK"] ? ReferenceTypeBean.fromJS(data["declarantTypeFK"]) : <any>null;
            this.entranceCode = data["entranceCode"] !== undefined ? data["entranceCode"] : <any>null;
            this.entranceNum = data["entranceNum"] !== undefined ? data["entranceNum"] : <any>null;
            this.flatNum = data["flatNum"] !== undefined ? data["flatNum"] : <any>null;
            this.houseNum = data["houseNum"] !== undefined ? data["houseNum"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.performer = data["performer"] !== undefined ? data["performer"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.placeTypeFK = data["placeTypeFK"] ? ReferenceTypeBean.fromJS(data["placeTypeFK"]) : <any>null;
            this.priority = data["priority"] !== undefined ? data["priority"] : <any>null;
            this.reasonComment = data["reasonComment"] !== undefined ? data["reasonComment"] : <any>null;
            this.reasonFK = data["reasonFK"] ? InquirerBean.fromJS(data["reasonFK"]) : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.typeFK = data["typeFK"] ? ReferenceTypeBean.fromJS(data["typeFK"]) : <any>null;
        }
    }

    static fromJS(data: any): CallBean {
        data = typeof data === 'object' ? data : {};
        let result = new CallBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["declarantName"] = this.declarantName !== undefined ? this.declarantName : <any>null;
        data["declarantPhone"] = this.declarantPhone !== undefined ? this.declarantPhone : <any>null;
        data["declarantTypeFK"] = this.declarantTypeFK ? this.declarantTypeFK.toJSON() : <any>null;
        data["entranceCode"] = this.entranceCode !== undefined ? this.entranceCode : <any>null;
        data["entranceNum"] = this.entranceNum !== undefined ? this.entranceNum : <any>null;
        data["flatNum"] = this.flatNum !== undefined ? this.flatNum : <any>null;
        data["houseNum"] = this.houseNum !== undefined ? this.houseNum : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["performer"] = this.performer !== undefined ? this.performer : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["placeTypeFK"] = this.placeTypeFK ? this.placeTypeFK.toJSON() : <any>null;
        data["priority"] = this.priority !== undefined ? this.priority : <any>null;
        data["reasonComment"] = this.reasonComment !== undefined ? this.reasonComment : <any>null;
        data["reasonFK"] = this.reasonFK ? this.reasonFK.toJSON() : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        return data; 
    }
}

export interface ICallBean {
    /** Адрес вызова (город, улица и пр.) */
    address?: string | null;
    /** Дата/время вызова */
    date?: Date | null;
    /** Ф.И.О. заявителя */
    declarantName?: string | null;
    /** Номер телефона заявителя */
    declarantPhone?: string | null;
    /** Тип заявителя */
    declarantTypeFK?: ReferenceTypeBean | null;
    /** Код домофона */
    entranceCode?: string | null;
    /** Номер подъезда */
    entranceNum?: string | null;
    /** Адрес вызова (номер квартиры) */
    flatNum?: string | null;
    /** Адрес вызова (номер дома) */
    houseNum?: string | null;
    id?: number | null;
    /** Местоположение */
    location?: string | null;
    /** № вызова */
    number?: string | null;
    /** Сотрудник, принявший вызов */
    performer?: number | null;
    /** Сотрудник, принимающий вызов */
    performerFK?: PerformerBean | null;
    /** Тип места вызова */
    placeTypeFK?: ReferenceTypeBean | null;
    /** Приоритет */
    priority?: number | null;
    /** Комментарий к причине вызова */
    reasonComment?: string | null;
    /** Причина вызова */
    reasonFK?: InquirerBean | null;
    /** Статус */
    status?: number | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Тип вызова */
    typeFK?: ReferenceTypeBean | null;
}

export class SubdivisionTypeBean implements ISubdivisionTypeBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    parentId?: number | null;

    constructor(data?: ISubdivisionTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        return data; 
    }
}

export interface ISubdivisionTypeBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    parentId?: number | null;
}

export class PerformerBrigScheduleDto implements IPerformerBrigScheduleDto {
    id?: number | null;
    is_major?: boolean | null;
    performer_first_name?: string | null;
    performer_id?: number | null;
    performer_patronymic?: string | null;
    performer_second_name?: string | null;
    performer_type_id?: number | null;
    performer_type_name?: string | null;
    period_details?: PeriodDetails | null;
    short_name?: string | null;

    constructor(data?: IPerformerBrigScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_major = data["is_major"] !== undefined ? data["is_major"] : <any>null;
            this.performer_first_name = data["performer_first_name"] !== undefined ? data["performer_first_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_patronymic = data["performer_patronymic"] !== undefined ? data["performer_patronymic"] : <any>null;
            this.performer_second_name = data["performer_second_name"] !== undefined ? data["performer_second_name"] : <any>null;
            this.performer_type_id = data["performer_type_id"] !== undefined ? data["performer_type_id"] : <any>null;
            this.performer_type_name = data["performer_type_name"] !== undefined ? data["performer_type_name"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_major"] = this.is_major !== undefined ? this.is_major : <any>null;
        data["performer_first_name"] = this.performer_first_name !== undefined ? this.performer_first_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_patronymic"] = this.performer_patronymic !== undefined ? this.performer_patronymic : <any>null;
        data["performer_second_name"] = this.performer_second_name !== undefined ? this.performer_second_name : <any>null;
        data["performer_type_id"] = this.performer_type_id !== undefined ? this.performer_type_id : <any>null;
        data["performer_type_name"] = this.performer_type_name !== undefined ? this.performer_type_name : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleDto {
    id?: number | null;
    is_major?: boolean | null;
    performer_first_name?: string | null;
    performer_id?: number | null;
    performer_patronymic?: string | null;
    performer_second_name?: string | null;
    performer_type_id?: number | null;
    performer_type_name?: string | null;
    period_details?: PeriodDetails | null;
    short_name?: string | null;
}

export class Field implements IField {
    text?: string | null;
    type?: number | null;
    value?: string | null;

    constructor(data?: IField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Field {
        data = typeof data === 'object' ? data : {};
        let result = new Field();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IField {
    text?: string | null;
    type?: number | null;
    value?: string | null;
}

export class TherapyBean implements ITherapyBean {
    /** Дата */
    date?: Date | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** На месте/при транспортировке (t/f) */
    isLocal?: boolean | null;
    /** Результат */
    resultFK?: CardResultBean | null;
    /** Id результата */
    resultId?: number | null;
    /** Шаблон */
    templateFK?: TherapyTemplateBean | null;
    /** Id шаблона */
    templateId?: number | null;
    /** Описание */
    text?: string | null;

    constructor(data?: ITherapyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.isLocal = data["isLocal"] !== undefined ? data["isLocal"] : <any>null;
            this.resultFK = data["resultFK"] ? CardResultBean.fromJS(data["resultFK"]) : <any>null;
            this.resultId = data["resultId"] !== undefined ? data["resultId"] : <any>null;
            this.templateFK = data["templateFK"] ? TherapyTemplateBean.fromJS(data["templateFK"]) : <any>null;
            this.templateId = data["templateId"] !== undefined ? data["templateId"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["isLocal"] = this.isLocal !== undefined ? this.isLocal : <any>null;
        data["resultFK"] = this.resultFK ? this.resultFK.toJSON() : <any>null;
        data["resultId"] = this.resultId !== undefined ? this.resultId : <any>null;
        data["templateFK"] = this.templateFK ? this.templateFK.toJSON() : <any>null;
        data["templateId"] = this.templateId !== undefined ? this.templateId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyBean {
    /** Дата */
    date?: Date | null;
    id?: number | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** На месте/при транспортировке (t/f) */
    isLocal?: boolean | null;
    /** Результат */
    resultFK?: CardResultBean | null;
    /** Id результата */
    resultId?: number | null;
    /** Шаблон */
    templateFK?: TherapyTemplateBean | null;
    /** Id шаблона */
    templateId?: number | null;
    /** Описание */
    text?: string | null;
}

export class CardObjectiveThroatPartDto implements ICardObjectiveThroatPartDto {
    multiple_zeva_clean_hyper?: number | null;
    multiple_zeva_clean_hyper_name?: string | null;

    constructor(data?: ICardObjectiveThroatPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.multiple_zeva_clean_hyper = data["multiple_zeva_clean_hyper"] !== undefined ? data["multiple_zeva_clean_hyper"] : <any>null;
            this.multiple_zeva_clean_hyper_name = data["multiple_zeva_clean_hyper_name"] !== undefined ? data["multiple_zeva_clean_hyper_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveThroatPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveThroatPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiple_zeva_clean_hyper"] = this.multiple_zeva_clean_hyper !== undefined ? this.multiple_zeva_clean_hyper : <any>null;
        data["multiple_zeva_clean_hyper_name"] = this.multiple_zeva_clean_hyper_name !== undefined ? this.multiple_zeva_clean_hyper_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveThroatPartDto {
    multiple_zeva_clean_hyper?: number | null;
    multiple_zeva_clean_hyper_name?: string | null;
}

export class SubdivisionFlatDto implements ISubdivisionFlatDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    email?: string | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;
    zone_exist?: boolean | null;

    constructor(data?: ISubdivisionFlatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? FiasAddressDto.fromJS(data["address"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
            if (data["zone"] && data["zone"].constructor === Array) {
                this.zone = [];
                for (let item of data["zone"])
                    this.zone.push(item);
            }
            this.zone_exist = data["zone_exist"] !== undefined ? data["zone_exist"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionFlatDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionFlatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        if (this.zone && this.zone.constructor === Array) {
            data["zone"] = [];
            for (let item of this.zone)
                data["zone"].push(item);
        }
        data["zone_exist"] = this.zone_exist !== undefined ? this.zone_exist : <any>null;
        return data; 
    }
}

export interface ISubdivisionFlatDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    email?: string | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;
    zone_exist?: boolean | null;
}

export class ListContainer implements IListContainer {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainer {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainer {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class MonPoint implements IMonPoint {
    date?: string | null;
    externalId?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    row?: number | null;
    stateMark?: string | null;

    constructor(data?: IMonPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.externalId = data["externalId"] !== undefined ? data["externalId"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.row = data["row"] !== undefined ? data["row"] : <any>null;
            this.stateMark = data["stateMark"] !== undefined ? data["stateMark"] : <any>null;
        }
    }

    static fromJS(data: any): MonPoint {
        data = typeof data === 'object' ? data : {};
        let result = new MonPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["row"] = this.row !== undefined ? this.row : <any>null;
        data["stateMark"] = this.stateMark !== undefined ? this.stateMark : <any>null;
        return data; 
    }
}

export interface IMonPoint {
    date?: string | null;
    externalId?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    row?: number | null;
    stateMark?: string | null;
}

export class NotificationObject implements INotificationObject {
    current_time?: Date | null;
    incomings?: number | null;

    constructor(data?: INotificationObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.current_time = data["current_time"] ? new Date(data["current_time"].toString()) : <any>null;
            this.incomings = data["incomings"] !== undefined ? data["incomings"] : <any>null;
        }
    }

    static fromJS(data: any): NotificationObject {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current_time"] = this.current_time ? this.current_time.toISOString() : <any>null;
        data["incomings"] = this.incomings !== undefined ? this.incomings : <any>null;
        return data; 
    }
}

export interface INotificationObject {
    current_time?: Date | null;
    incomings?: number | null;
}

export class Pair implements IPair {
    first?: any | null;
    second?: any | null;

    constructor(data?: IPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] !== undefined ? data["first"] : <any>null;
            this.second = data["second"] !== undefined ? data["second"] : <any>null;
        }
    }

    static fromJS(data: any): Pair {
        data = typeof data === 'object' ? data : {};
        let result = new Pair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first !== undefined ? this.first : <any>null;
        data["second"] = this.second !== undefined ? this.second : <any>null;
        return data; 
    }
}

export interface IPair {
    first?: any | null;
    second?: any | null;
}

export class CardAnamnesisPartDtoFLAT implements ICardAnamnesisPartDtoFLAT {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_text?: string | null;
    complaints_anamnesis?: string | null;
    gynecologic_anamnesis?: string | null;
    illnes_anamnesis?: string | null;
    infect_contacts?: string | null;
    is_created?: boolean | null;
    past_illneses?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;

    constructor(data?: ICardAnamnesisPartDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allergic_anamnesis = data["allergic_anamnesis"] !== undefined ? data["allergic_anamnesis"] : <any>null;
            this.allergic_anamnesis_text = data["allergic_anamnesis_text"] !== undefined ? data["allergic_anamnesis_text"] : <any>null;
            this.complaints_anamnesis = data["complaints_anamnesis"] !== undefined ? data["complaints_anamnesis"] : <any>null;
            this.gynecologic_anamnesis = data["gynecologic_anamnesis"] !== undefined ? data["gynecologic_anamnesis"] : <any>null;
            this.illnes_anamnesis = data["illnes_anamnesis"] !== undefined ? data["illnes_anamnesis"] : <any>null;
            this.infect_contacts = data["infect_contacts"] !== undefined ? data["infect_contacts"] : <any>null;
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
            this.past_illneses = data["past_illneses"] !== undefined ? data["past_illneses"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisPartDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisPartDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allergic_anamnesis"] = this.allergic_anamnesis !== undefined ? this.allergic_anamnesis : <any>null;
        data["allergic_anamnesis_text"] = this.allergic_anamnesis_text !== undefined ? this.allergic_anamnesis_text : <any>null;
        data["complaints_anamnesis"] = this.complaints_anamnesis !== undefined ? this.complaints_anamnesis : <any>null;
        data["gynecologic_anamnesis"] = this.gynecologic_anamnesis !== undefined ? this.gynecologic_anamnesis : <any>null;
        data["illnes_anamnesis"] = this.illnes_anamnesis !== undefined ? this.illnes_anamnesis : <any>null;
        data["infect_contacts"] = this.infect_contacts !== undefined ? this.infect_contacts : <any>null;
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        data["past_illneses"] = this.past_illneses !== undefined ? this.past_illneses : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisPartDtoFLAT {
    allergic_anamnesis?: number | null;
    allergic_anamnesis_text?: string | null;
    complaints_anamnesis?: string | null;
    gynecologic_anamnesis?: string | null;
    illnes_anamnesis?: string | null;
    infect_contacts?: string | null;
    is_created?: boolean | null;
    past_illneses?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;
}

export class ChatUser implements IChatUser {
    active?: boolean | null;
    author?: boolean | null;
    chatMessages?: ChatMessage[] | null;
    id?: number | null;
    performer?: Performer | null;
    unreadCount?: number | null;

    constructor(data?: IChatUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.author = data["author"] !== undefined ? data["author"] : <any>null;
            if (data["chatMessages"] && data["chatMessages"].constructor === Array) {
                this.chatMessages = [];
                for (let item of data["chatMessages"])
                    this.chatMessages.push(ChatMessage.fromJS(item));
            }
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.performer = data["performer"] ? Performer.fromJS(data["performer"]) : <any>null;
            this.unreadCount = data["unreadCount"] !== undefined ? data["unreadCount"] : <any>null;
        }
    }

    static fromJS(data: any): ChatUser {
        data = typeof data === 'object' ? data : {};
        let result = new ChatUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        if (this.chatMessages && this.chatMessages.constructor === Array) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>null;
        data["unreadCount"] = this.unreadCount !== undefined ? this.unreadCount : <any>null;
        return data; 
    }
}

export interface IChatUser {
    active?: boolean | null;
    author?: boolean | null;
    chatMessages?: ChatMessage[] | null;
    id?: number | null;
    performer?: Performer | null;
    unreadCount?: number | null;
}

export class SubdivisionTypeDto implements ISubdivisionTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ISubdivisionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ISubdivisionTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class Report implements IReport {
    code?: string | null;
    deleted?: boolean | null;
    file_name?: string | null;
    format?: ReportFormat | null;
    group_code?: string | null;
    group_name?: string | null;
    id?: number | null;
    lastUpdate?: Date | null;
    name?: string | null;
    nn?: number | null;
    performer?: string | null;
    script?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    template?: string[] | null;
    type?: ReportType | null;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.file_name = data["file_name"] !== undefined ? data["file_name"] : <any>null;
            this.format = data["format"] !== undefined ? data["format"] : <any>null;
            this.group_code = data["group_code"] !== undefined ? data["group_code"] : <any>null;
            this.group_name = data["group_name"] !== undefined ? data["group_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.lastUpdate = data["lastUpdate"] ? new Date(data["lastUpdate"].toString()) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nn = data["nn"] !== undefined ? data["nn"] : <any>null;
            this.performer = data["performer"] !== undefined ? data["performer"] : <any>null;
            this.script = data["script"] !== undefined ? data["script"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
            if (data["template"] && data["template"].constructor === Array) {
                this.template = [];
                for (let item of data["template"])
                    this.template.push(item);
            }
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["file_name"] = this.file_name !== undefined ? this.file_name : <any>null;
        data["format"] = this.format !== undefined ? this.format : <any>null;
        data["group_code"] = this.group_code !== undefined ? this.group_code : <any>null;
        data["group_name"] = this.group_name !== undefined ? this.group_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nn"] = this.nn !== undefined ? this.nn : <any>null;
        data["performer"] = this.performer !== undefined ? this.performer : <any>null;
        data["script"] = this.script !== undefined ? this.script : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        if (this.template && this.template.constructor === Array) {
            data["template"] = [];
            for (let item of this.template)
                data["template"].push(item);
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReport {
    code?: string | null;
    deleted?: boolean | null;
    file_name?: string | null;
    format?: ReportFormat | null;
    group_code?: string | null;
    group_name?: string | null;
    id?: number | null;
    lastUpdate?: Date | null;
    name?: string | null;
    nn?: number | null;
    performer?: string | null;
    script?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    template?: string[] | null;
    type?: ReportType | null;
}

export class BrigadeStatusBean implements IBrigadeStatusBean {
    code?: string | null;
    id?: number | null;
    /** Признак возможности использования бригады */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IBrigadeStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isAvailable = data["isAvailable"] !== undefined ? data["isAvailable"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeStatusBean {
    code?: string | null;
    id?: number | null;
    /** Признак возможности использования бригады */
    isAvailable?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class ListContainerOfBrigadeBean implements IListContainerOfBrigadeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBrigadeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBrigadeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBrigadeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBrigadeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class PharmacyNomenclatureDto implements IPharmacyNomenclatureDto {
    amount?: number | null;
    company?: string | null;
    drug_id?: number | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IPharmacyNomenclatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.drug_id = data["drug_id"] !== undefined ? data["drug_id"] : <any>null;
            this.expiry_date = data["expiry_date"] ? new Date(data["expiry_date"].toString()) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyNomenclatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyNomenclatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["drug_id"] = this.drug_id !== undefined ? this.drug_id : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toISOString() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyNomenclatureDto {
    amount?: number | null;
    company?: string | null;
    drug_id?: number | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    series_number?: number | null;
    type?: number | null;
}

export class CardSubdivisionHeadDoctorPartDto implements ICardSubdivisionHeadDoctorPartDto {
    subdivision_head_doctor_checked?: boolean | null;
    subdivision_head_doctor_comment?: string | null;
    subdivision_head_doctor_date?: Date | null;
    subdivision_head_doctor_id?: number | null;
    subdivision_head_doctor_name?: string | null;

    constructor(data?: ICardSubdivisionHeadDoctorPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subdivision_head_doctor_checked = data["subdivision_head_doctor_checked"] !== undefined ? data["subdivision_head_doctor_checked"] : <any>null;
            this.subdivision_head_doctor_comment = data["subdivision_head_doctor_comment"] !== undefined ? data["subdivision_head_doctor_comment"] : <any>null;
            this.subdivision_head_doctor_date = data["subdivision_head_doctor_date"] ? new Date(data["subdivision_head_doctor_date"].toString()) : <any>null;
            this.subdivision_head_doctor_id = data["subdivision_head_doctor_id"] !== undefined ? data["subdivision_head_doctor_id"] : <any>null;
            this.subdivision_head_doctor_name = data["subdivision_head_doctor_name"] !== undefined ? data["subdivision_head_doctor_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardSubdivisionHeadDoctorPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardSubdivisionHeadDoctorPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subdivision_head_doctor_checked"] = this.subdivision_head_doctor_checked !== undefined ? this.subdivision_head_doctor_checked : <any>null;
        data["subdivision_head_doctor_comment"] = this.subdivision_head_doctor_comment !== undefined ? this.subdivision_head_doctor_comment : <any>null;
        data["subdivision_head_doctor_date"] = this.subdivision_head_doctor_date ? this.subdivision_head_doctor_date.toISOString() : <any>null;
        data["subdivision_head_doctor_id"] = this.subdivision_head_doctor_id !== undefined ? this.subdivision_head_doctor_id : <any>null;
        data["subdivision_head_doctor_name"] = this.subdivision_head_doctor_name !== undefined ? this.subdivision_head_doctor_name : <any>null;
        return data; 
    }
}

export interface ICardSubdivisionHeadDoctorPartDto {
    subdivision_head_doctor_checked?: boolean | null;
    subdivision_head_doctor_comment?: string | null;
    subdivision_head_doctor_date?: Date | null;
    subdivision_head_doctor_id?: number | null;
    subdivision_head_doctor_name?: string | null;
}

export class View implements IView {
    contentType?: string | null;

    constructor(data?: IView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["contentType"] !== undefined ? data["contentType"] : <any>null;
        }
    }

    static fromJS(data: any): View {
        data = typeof data === 'object' ? data : {};
        let result = new View();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        return data; 
    }
}

export interface IView {
    contentType?: string | null;
}

export class ListContainerOfScheduleTypeBean implements IListContainerOfScheduleTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfScheduleTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfScheduleTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfScheduleTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfScheduleTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class ReportGroup implements IReportGroup {
    children?: ReportGroup[] | null;
    code?: string | null;
    id?: string | null;
    leaf?: boolean | null;
    name?: string | null;

    constructor(data?: IReportGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(ReportGroup.fromJS(item));
            }
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ReportGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ReportGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IReportGroup {
    children?: ReportGroup[] | null;
    code?: string | null;
    id?: string | null;
    leaf?: boolean | null;
    name?: string | null;
}

export class BagDto implements IBagDto {
    date?: Date | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    owner_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IBagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BagItemDto.fromJS(item));
            }
            this.matrix_code = data["matrix_code"] !== undefined ? data["matrix_code"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.matrix_name = data["matrix_name"] !== undefined ? data["matrix_name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): BagDto {
        data = typeof data === 'object' ? data : {};
        let result = new BagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["matrix_code"] = this.matrix_code !== undefined ? this.matrix_code : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["matrix_name"] = this.matrix_name !== undefined ? this.matrix_name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IBagDto {
    date?: Date | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    matrix_code?: string | null;
    matrix_id?: number | null;
    matrix_name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    owner_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    series_number?: number | null;
    type?: number | null;
}

export class Skill implements ISkill {
    code?: string | null;
    commonName?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.commonName = data["commonName"] !== undefined ? data["commonName"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["commonName"] = this.commonName !== undefined ? this.commonName : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ISkill {
    code?: string | null;
    commonName?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class CardResultHeaderDto implements ICardResultHeaderDto {
    is_created?: boolean | null;

    constructor(data?: ICardResultHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        return data; 
    }
}

export interface ICardResultHeaderDto {
    is_created?: boolean | null;
}

export class CardObjectiveSkinPartDto implements ICardObjectiveSkinPartDto {
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;

    constructor(data?: ICardObjectiveSkinPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skin_integ_acrosian = data["skin_integ_acrosian"] !== undefined ? data["skin_integ_acrosian"] : <any>null;
            this.skin_integ_cyanotic = data["skin_integ_cyanotic"] !== undefined ? data["skin_integ_cyanotic"] : <any>null;
            this.skin_integ_dry = data["skin_integ_dry"] !== undefined ? data["skin_integ_dry"] : <any>null;
            this.skin_integ_earthy = data["skin_integ_earthy"] !== undefined ? data["skin_integ_earthy"] : <any>null;
            this.skin_integ_hyperemetic = data["skin_integ_hyperemetic"] !== undefined ? data["skin_integ_hyperemetic"] : <any>null;
            this.skin_integ_icteric = data["skin_integ_icteric"] !== undefined ? data["skin_integ_icteric"] : <any>null;
            this.skin_integ_marbleness = data["skin_integ_marbleness"] !== undefined ? data["skin_integ_marbleness"] : <any>null;
            this.skin_integ_normal = data["skin_integ_normal"] !== undefined ? data["skin_integ_normal"] : <any>null;
            this.skin_integ_pale = data["skin_integ_pale"] !== undefined ? data["skin_integ_pale"] : <any>null;
            this.skin_integ_profuse = data["skin_integ_profuse"] !== undefined ? data["skin_integ_profuse"] : <any>null;
            this.skin_integ_rashes = data["skin_integ_rashes"] !== undefined ? data["skin_integ_rashes"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveSkinPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveSkinPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skin_integ_acrosian"] = this.skin_integ_acrosian !== undefined ? this.skin_integ_acrosian : <any>null;
        data["skin_integ_cyanotic"] = this.skin_integ_cyanotic !== undefined ? this.skin_integ_cyanotic : <any>null;
        data["skin_integ_dry"] = this.skin_integ_dry !== undefined ? this.skin_integ_dry : <any>null;
        data["skin_integ_earthy"] = this.skin_integ_earthy !== undefined ? this.skin_integ_earthy : <any>null;
        data["skin_integ_hyperemetic"] = this.skin_integ_hyperemetic !== undefined ? this.skin_integ_hyperemetic : <any>null;
        data["skin_integ_icteric"] = this.skin_integ_icteric !== undefined ? this.skin_integ_icteric : <any>null;
        data["skin_integ_marbleness"] = this.skin_integ_marbleness !== undefined ? this.skin_integ_marbleness : <any>null;
        data["skin_integ_normal"] = this.skin_integ_normal !== undefined ? this.skin_integ_normal : <any>null;
        data["skin_integ_pale"] = this.skin_integ_pale !== undefined ? this.skin_integ_pale : <any>null;
        data["skin_integ_profuse"] = this.skin_integ_profuse !== undefined ? this.skin_integ_profuse : <any>null;
        data["skin_integ_rashes"] = this.skin_integ_rashes !== undefined ? this.skin_integ_rashes : <any>null;
        return data; 
    }
}

export interface ICardObjectiveSkinPartDto {
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;
}

export class TherapyDto implements ITherapyDto {
    date?: Date | null;
    id?: number | null;
    is_local?: boolean | null;
    items?: TherapyItemDto[] | null;
    result_id?: number | null;
    template_id?: number | null;
    text?: string | null;

    constructor(data?: ITherapyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_local = data["is_local"] !== undefined ? data["is_local"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TherapyItemDto.fromJS(item));
            }
            this.result_id = data["result_id"] !== undefined ? data["result_id"] : <any>null;
            this.template_id = data["template_id"] !== undefined ? data["template_id"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_local"] = this.is_local !== undefined ? this.is_local : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["result_id"] = this.result_id !== undefined ? this.result_id : <any>null;
        data["template_id"] = this.template_id !== undefined ? this.template_id : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyDto {
    date?: Date | null;
    id?: number | null;
    is_local?: boolean | null;
    items?: TherapyItemDto[] | null;
    result_id?: number | null;
    template_id?: number | null;
    text?: string | null;
}

export class CardResultDtoFLAT implements ICardResultDtoFLAT {
    accident_type?: number | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    active_visit_date?: Date | null;
    active_visit_hours?: number | null;
    active_visit_type?: number | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;
    assistance_result_id?: number | null;
    bandages?: number | null;
    catheters?: number | null;
    comments?: string | null;
    complication_id?: number | null;
    concomitant_diagnosis?: MkbDto | null;
    death_condition?: number | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: Date | null;
    ekg_ch_s_s?: number | null;
    ekg_ch_s_s_after?: number | null;
    ekg_comments?: string | null;
    ekg_comments_after?: string | null;
    ekg_rhythm?: string | null;
    ekg_rhythm_after?: string | null;
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_reason?: number | null;
    hosp_reason_name?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation?: number | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;
    intoxication_type?: number | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    is_created?: boolean | null;
    local_CHD?: string | null;
    local_CHSS?: string | null;
    local_ad?: string | null;
    local_glucometry?: string | null;
    local_pulse?: string | null;
    local_pulse_oximetry?: string | null;
    local_temperature?: string | null;
    local_therapies?: TherapyDto[] | null;
    local_therapy?: string | null;
    local_work_ad?: string | null;
    main_diagnosis?: MkbDto | null;
    other_materials?: string | null;
    reason_type?: number | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;
    syringes?: number | null;
    transfer_patient_brigade?: string | null;
    transfer_patient_time?: Date | null;
    transfusion_systems?: number | null;
    transport_CHD?: string | null;
    transport_CHSS?: string | null;
    transport_ad?: string | null;
    transport_glucometry?: string | null;
    transport_pulse?: string | null;
    transport_pulse_oximetry?: string | null;
    transport_temperature?: string | null;
    transport_therapies?: TherapyDto[] | null;
    transport_therapy?: string | null;
    transport_work_ad?: string | null;
    transporting_date?: Date | null;
    transporting_type?: number | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;
    type?: number | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ICardResultDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accident_type = data["accident_type"] !== undefined ? data["accident_type"] : <any>null;
            this.accident_type_id = data["accident_type_id"] !== undefined ? data["accident_type_id"] : <any>null;
            this.accident_type_name = data["accident_type_name"] !== undefined ? data["accident_type_name"] : <any>null;
            this.active_visit_date = data["active_visit_date"] ? new Date(data["active_visit_date"].toString()) : <any>null;
            this.active_visit_hours = data["active_visit_hours"] !== undefined ? data["active_visit_hours"] : <any>null;
            this.active_visit_type = data["active_visit_type"] !== undefined ? data["active_visit_type"] : <any>null;
            this.active_visit_type_id = data["active_visit_type_id"] !== undefined ? data["active_visit_type_id"] : <any>null;
            this.active_visit_type_name = data["active_visit_type_name"] !== undefined ? data["active_visit_type_name"] : <any>null;
            this.assistance_result_id = data["assistance_result_id"] !== undefined ? data["assistance_result_id"] : <any>null;
            this.bandages = data["bandages"] !== undefined ? data["bandages"] : <any>null;
            this.catheters = data["catheters"] !== undefined ? data["catheters"] : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.complication_id = data["complication_id"] !== undefined ? data["complication_id"] : <any>null;
            this.concomitant_diagnosis = data["concomitant_diagnosis"] ? MkbDto.fromJS(data["concomitant_diagnosis"]) : <any>null;
            this.death_condition = data["death_condition"] !== undefined ? data["death_condition"] : <any>null;
            this.death_condition_id = data["death_condition_id"] !== undefined ? data["death_condition_id"] : <any>null;
            this.death_condition_name = data["death_condition_name"] !== undefined ? data["death_condition_name"] : <any>null;
            this.death_time = data["death_time"] ? new Date(data["death_time"].toString()) : <any>null;
            this.ekg_ch_s_s = data["ekg_ch_s_s"] !== undefined ? data["ekg_ch_s_s"] : <any>null;
            this.ekg_ch_s_s_after = data["ekg_ch_s_s_after"] !== undefined ? data["ekg_ch_s_s_after"] : <any>null;
            this.ekg_comments = data["ekg_comments"] !== undefined ? data["ekg_comments"] : <any>null;
            this.ekg_comments_after = data["ekg_comments_after"] !== undefined ? data["ekg_comments_after"] : <any>null;
            this.ekg_rhythm = data["ekg_rhythm"] !== undefined ? data["ekg_rhythm"] : <any>null;
            this.ekg_rhythm_after = data["ekg_rhythm_after"] !== undefined ? data["ekg_rhythm_after"] : <any>null;
            this.hosp_complications = data["hosp_complications"] !== undefined ? data["hosp_complications"] : <any>null;
            this.hosp_complications_text = data["hosp_complications_text"] !== undefined ? data["hosp_complications_text"] : <any>null;
            this.hosp_reason = data["hosp_reason"] !== undefined ? data["hosp_reason"] : <any>null;
            this.hosp_reason_name = data["hosp_reason_name"] !== undefined ? data["hosp_reason_name"] : <any>null;
            this.hosp_to_id = data["hosp_to_id"] !== undefined ? data["hosp_to_id"] : <any>null;
            this.hosp_to_name = data["hosp_to_name"] !== undefined ? data["hosp_to_name"] : <any>null;
            this.hosp_transportation = data["hosp_transportation"] !== undefined ? data["hosp_transportation"] : <any>null;
            this.hosp_transportation_id = data["hosp_transportation_id"] !== undefined ? data["hosp_transportation_id"] : <any>null;
            this.hosp_transportation_name = data["hosp_transportation_name"] !== undefined ? data["hosp_transportation_name"] : <any>null;
            this.illegal_actions = data["illegal_actions"] !== undefined ? data["illegal_actions"] : <any>null;
            this.illegal_actions_text = data["illegal_actions_text"] !== undefined ? data["illegal_actions_text"] : <any>null;
            this.intoxication_type = data["intoxication_type"] !== undefined ? data["intoxication_type"] : <any>null;
            this.intoxication_type_id = data["intoxication_type_id"] !== undefined ? data["intoxication_type_id"] : <any>null;
            this.intoxication_type_name = data["intoxication_type_name"] !== undefined ? data["intoxication_type_name"] : <any>null;
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
            this.local_CHD = data["local_CHD"] !== undefined ? data["local_CHD"] : <any>null;
            this.local_CHSS = data["local_CHSS"] !== undefined ? data["local_CHSS"] : <any>null;
            this.local_ad = data["local_ad"] !== undefined ? data["local_ad"] : <any>null;
            this.local_glucometry = data["local_glucometry"] !== undefined ? data["local_glucometry"] : <any>null;
            this.local_pulse = data["local_pulse"] !== undefined ? data["local_pulse"] : <any>null;
            this.local_pulse_oximetry = data["local_pulse_oximetry"] !== undefined ? data["local_pulse_oximetry"] : <any>null;
            this.local_temperature = data["local_temperature"] !== undefined ? data["local_temperature"] : <any>null;
            if (data["local_therapies"] && data["local_therapies"].constructor === Array) {
                this.local_therapies = [];
                for (let item of data["local_therapies"])
                    this.local_therapies.push(TherapyDto.fromJS(item));
            }
            this.local_therapy = data["local_therapy"] !== undefined ? data["local_therapy"] : <any>null;
            this.local_work_ad = data["local_work_ad"] !== undefined ? data["local_work_ad"] : <any>null;
            this.main_diagnosis = data["main_diagnosis"] ? MkbDto.fromJS(data["main_diagnosis"]) : <any>null;
            this.other_materials = data["other_materials"] !== undefined ? data["other_materials"] : <any>null;
            this.reason_type = data["reason_type"] !== undefined ? data["reason_type"] : <any>null;
            this.reason_type_id = data["reason_type_id"] !== undefined ? data["reason_type_id"] : <any>null;
            this.reason_type_name = data["reason_type_name"] !== undefined ? data["reason_type_name"] : <any>null;
            this.syringes = data["syringes"] !== undefined ? data["syringes"] : <any>null;
            this.transfer_patient_brigade = data["transfer_patient_brigade"] !== undefined ? data["transfer_patient_brigade"] : <any>null;
            this.transfer_patient_time = data["transfer_patient_time"] ? new Date(data["transfer_patient_time"].toString()) : <any>null;
            this.transfusion_systems = data["transfusion_systems"] !== undefined ? data["transfusion_systems"] : <any>null;
            this.transport_CHD = data["transport_CHD"] !== undefined ? data["transport_CHD"] : <any>null;
            this.transport_CHSS = data["transport_CHSS"] !== undefined ? data["transport_CHSS"] : <any>null;
            this.transport_ad = data["transport_ad"] !== undefined ? data["transport_ad"] : <any>null;
            this.transport_glucometry = data["transport_glucometry"] !== undefined ? data["transport_glucometry"] : <any>null;
            this.transport_pulse = data["transport_pulse"] !== undefined ? data["transport_pulse"] : <any>null;
            this.transport_pulse_oximetry = data["transport_pulse_oximetry"] !== undefined ? data["transport_pulse_oximetry"] : <any>null;
            this.transport_temperature = data["transport_temperature"] !== undefined ? data["transport_temperature"] : <any>null;
            if (data["transport_therapies"] && data["transport_therapies"].constructor === Array) {
                this.transport_therapies = [];
                for (let item of data["transport_therapies"])
                    this.transport_therapies.push(TherapyDto.fromJS(item));
            }
            this.transport_therapy = data["transport_therapy"] !== undefined ? data["transport_therapy"] : <any>null;
            this.transport_work_ad = data["transport_work_ad"] !== undefined ? data["transport_work_ad"] : <any>null;
            this.transporting_date = data["transporting_date"] ? new Date(data["transporting_date"].toString()) : <any>null;
            this.transporting_type = data["transporting_type"] !== undefined ? data["transporting_type"] : <any>null;
            this.transporting_type_id = data["transporting_type_id"] !== undefined ? data["transporting_type_id"] : <any>null;
            this.transporting_type_name = data["transporting_type_name"] !== undefined ? data["transporting_type_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_comment = data["type_comment"] !== undefined ? data["type_comment"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accident_type"] = this.accident_type !== undefined ? this.accident_type : <any>null;
        data["accident_type_id"] = this.accident_type_id !== undefined ? this.accident_type_id : <any>null;
        data["accident_type_name"] = this.accident_type_name !== undefined ? this.accident_type_name : <any>null;
        data["active_visit_date"] = this.active_visit_date ? this.active_visit_date.toISOString() : <any>null;
        data["active_visit_hours"] = this.active_visit_hours !== undefined ? this.active_visit_hours : <any>null;
        data["active_visit_type"] = this.active_visit_type !== undefined ? this.active_visit_type : <any>null;
        data["active_visit_type_id"] = this.active_visit_type_id !== undefined ? this.active_visit_type_id : <any>null;
        data["active_visit_type_name"] = this.active_visit_type_name !== undefined ? this.active_visit_type_name : <any>null;
        data["assistance_result_id"] = this.assistance_result_id !== undefined ? this.assistance_result_id : <any>null;
        data["bandages"] = this.bandages !== undefined ? this.bandages : <any>null;
        data["catheters"] = this.catheters !== undefined ? this.catheters : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["complication_id"] = this.complication_id !== undefined ? this.complication_id : <any>null;
        data["concomitant_diagnosis"] = this.concomitant_diagnosis ? this.concomitant_diagnosis.toJSON() : <any>null;
        data["death_condition"] = this.death_condition !== undefined ? this.death_condition : <any>null;
        data["death_condition_id"] = this.death_condition_id !== undefined ? this.death_condition_id : <any>null;
        data["death_condition_name"] = this.death_condition_name !== undefined ? this.death_condition_name : <any>null;
        data["death_time"] = this.death_time ? this.death_time.toISOString() : <any>null;
        data["ekg_ch_s_s"] = this.ekg_ch_s_s !== undefined ? this.ekg_ch_s_s : <any>null;
        data["ekg_ch_s_s_after"] = this.ekg_ch_s_s_after !== undefined ? this.ekg_ch_s_s_after : <any>null;
        data["ekg_comments"] = this.ekg_comments !== undefined ? this.ekg_comments : <any>null;
        data["ekg_comments_after"] = this.ekg_comments_after !== undefined ? this.ekg_comments_after : <any>null;
        data["ekg_rhythm"] = this.ekg_rhythm !== undefined ? this.ekg_rhythm : <any>null;
        data["ekg_rhythm_after"] = this.ekg_rhythm_after !== undefined ? this.ekg_rhythm_after : <any>null;
        data["hosp_complications"] = this.hosp_complications !== undefined ? this.hosp_complications : <any>null;
        data["hosp_complications_text"] = this.hosp_complications_text !== undefined ? this.hosp_complications_text : <any>null;
        data["hosp_reason"] = this.hosp_reason !== undefined ? this.hosp_reason : <any>null;
        data["hosp_reason_name"] = this.hosp_reason_name !== undefined ? this.hosp_reason_name : <any>null;
        data["hosp_to_id"] = this.hosp_to_id !== undefined ? this.hosp_to_id : <any>null;
        data["hosp_to_name"] = this.hosp_to_name !== undefined ? this.hosp_to_name : <any>null;
        data["hosp_transportation"] = this.hosp_transportation !== undefined ? this.hosp_transportation : <any>null;
        data["hosp_transportation_id"] = this.hosp_transportation_id !== undefined ? this.hosp_transportation_id : <any>null;
        data["hosp_transportation_name"] = this.hosp_transportation_name !== undefined ? this.hosp_transportation_name : <any>null;
        data["illegal_actions"] = this.illegal_actions !== undefined ? this.illegal_actions : <any>null;
        data["illegal_actions_text"] = this.illegal_actions_text !== undefined ? this.illegal_actions_text : <any>null;
        data["intoxication_type"] = this.intoxication_type !== undefined ? this.intoxication_type : <any>null;
        data["intoxication_type_id"] = this.intoxication_type_id !== undefined ? this.intoxication_type_id : <any>null;
        data["intoxication_type_name"] = this.intoxication_type_name !== undefined ? this.intoxication_type_name : <any>null;
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        data["local_CHD"] = this.local_CHD !== undefined ? this.local_CHD : <any>null;
        data["local_CHSS"] = this.local_CHSS !== undefined ? this.local_CHSS : <any>null;
        data["local_ad"] = this.local_ad !== undefined ? this.local_ad : <any>null;
        data["local_glucometry"] = this.local_glucometry !== undefined ? this.local_glucometry : <any>null;
        data["local_pulse"] = this.local_pulse !== undefined ? this.local_pulse : <any>null;
        data["local_pulse_oximetry"] = this.local_pulse_oximetry !== undefined ? this.local_pulse_oximetry : <any>null;
        data["local_temperature"] = this.local_temperature !== undefined ? this.local_temperature : <any>null;
        if (this.local_therapies && this.local_therapies.constructor === Array) {
            data["local_therapies"] = [];
            for (let item of this.local_therapies)
                data["local_therapies"].push(item.toJSON());
        }
        data["local_therapy"] = this.local_therapy !== undefined ? this.local_therapy : <any>null;
        data["local_work_ad"] = this.local_work_ad !== undefined ? this.local_work_ad : <any>null;
        data["main_diagnosis"] = this.main_diagnosis ? this.main_diagnosis.toJSON() : <any>null;
        data["other_materials"] = this.other_materials !== undefined ? this.other_materials : <any>null;
        data["reason_type"] = this.reason_type !== undefined ? this.reason_type : <any>null;
        data["reason_type_id"] = this.reason_type_id !== undefined ? this.reason_type_id : <any>null;
        data["reason_type_name"] = this.reason_type_name !== undefined ? this.reason_type_name : <any>null;
        data["syringes"] = this.syringes !== undefined ? this.syringes : <any>null;
        data["transfer_patient_brigade"] = this.transfer_patient_brigade !== undefined ? this.transfer_patient_brigade : <any>null;
        data["transfer_patient_time"] = this.transfer_patient_time ? this.transfer_patient_time.toISOString() : <any>null;
        data["transfusion_systems"] = this.transfusion_systems !== undefined ? this.transfusion_systems : <any>null;
        data["transport_CHD"] = this.transport_CHD !== undefined ? this.transport_CHD : <any>null;
        data["transport_CHSS"] = this.transport_CHSS !== undefined ? this.transport_CHSS : <any>null;
        data["transport_ad"] = this.transport_ad !== undefined ? this.transport_ad : <any>null;
        data["transport_glucometry"] = this.transport_glucometry !== undefined ? this.transport_glucometry : <any>null;
        data["transport_pulse"] = this.transport_pulse !== undefined ? this.transport_pulse : <any>null;
        data["transport_pulse_oximetry"] = this.transport_pulse_oximetry !== undefined ? this.transport_pulse_oximetry : <any>null;
        data["transport_temperature"] = this.transport_temperature !== undefined ? this.transport_temperature : <any>null;
        if (this.transport_therapies && this.transport_therapies.constructor === Array) {
            data["transport_therapies"] = [];
            for (let item of this.transport_therapies)
                data["transport_therapies"].push(item.toJSON());
        }
        data["transport_therapy"] = this.transport_therapy !== undefined ? this.transport_therapy : <any>null;
        data["transport_work_ad"] = this.transport_work_ad !== undefined ? this.transport_work_ad : <any>null;
        data["transporting_date"] = this.transporting_date ? this.transporting_date.toISOString() : <any>null;
        data["transporting_type"] = this.transporting_type !== undefined ? this.transporting_type : <any>null;
        data["transporting_type_id"] = this.transporting_type_id !== undefined ? this.transporting_type_id : <any>null;
        data["transporting_type_name"] = this.transporting_type_name !== undefined ? this.transporting_type_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_comment"] = this.type_comment !== undefined ? this.type_comment : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ICardResultDtoFLAT {
    accident_type?: number | null;
    accident_type_id?: number | null;
    accident_type_name?: string | null;
    active_visit_date?: Date | null;
    active_visit_hours?: number | null;
    active_visit_type?: number | null;
    active_visit_type_id?: number | null;
    active_visit_type_name?: string | null;
    assistance_result_id?: number | null;
    bandages?: number | null;
    catheters?: number | null;
    comments?: string | null;
    complication_id?: number | null;
    concomitant_diagnosis?: MkbDto | null;
    death_condition?: number | null;
    death_condition_id?: number | null;
    death_condition_name?: string | null;
    death_time?: Date | null;
    ekg_ch_s_s?: number | null;
    ekg_ch_s_s_after?: number | null;
    ekg_comments?: string | null;
    ekg_comments_after?: string | null;
    ekg_rhythm?: string | null;
    ekg_rhythm_after?: string | null;
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_reason?: number | null;
    hosp_reason_name?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation?: number | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    illegal_actions?: boolean | null;
    illegal_actions_text?: string | null;
    intoxication_type?: number | null;
    intoxication_type_id?: number | null;
    intoxication_type_name?: string | null;
    is_created?: boolean | null;
    local_CHD?: string | null;
    local_CHSS?: string | null;
    local_ad?: string | null;
    local_glucometry?: string | null;
    local_pulse?: string | null;
    local_pulse_oximetry?: string | null;
    local_temperature?: string | null;
    local_therapies?: TherapyDto[] | null;
    local_therapy?: string | null;
    local_work_ad?: string | null;
    main_diagnosis?: MkbDto | null;
    other_materials?: string | null;
    reason_type?: number | null;
    reason_type_id?: number | null;
    reason_type_name?: string | null;
    syringes?: number | null;
    transfer_patient_brigade?: string | null;
    transfer_patient_time?: Date | null;
    transfusion_systems?: number | null;
    transport_CHD?: string | null;
    transport_CHSS?: string | null;
    transport_ad?: string | null;
    transport_glucometry?: string | null;
    transport_pulse?: string | null;
    transport_pulse_oximetry?: string | null;
    transport_temperature?: string | null;
    transport_therapies?: TherapyDto[] | null;
    transport_therapy?: string | null;
    transport_work_ad?: string | null;
    transporting_date?: Date | null;
    transporting_type?: number | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;
    type?: number | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class CardAnamnesisIllnesPartDto implements ICardAnamnesisIllnesPartDto {
    illnes_anamnesis?: string | null;
    past_illneses?: string | null;

    constructor(data?: ICardAnamnesisIllnesPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.illnes_anamnesis = data["illnes_anamnesis"] !== undefined ? data["illnes_anamnesis"] : <any>null;
            this.past_illneses = data["past_illneses"] !== undefined ? data["past_illneses"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisIllnesPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisIllnesPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["illnes_anamnesis"] = this.illnes_anamnesis !== undefined ? this.illnes_anamnesis : <any>null;
        data["past_illneses"] = this.past_illneses !== undefined ? this.past_illneses : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisIllnesPartDto {
    illnes_anamnesis?: string | null;
    past_illneses?: string | null;
}

export class CardDeclarantPartDto implements ICardDeclarantPartDto {
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;

    constructor(data?: ICardDeclarantPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.declarant_type_id = data["declarant_type_id"] !== undefined ? data["declarant_type_id"] : <any>null;
            this.declarant_type_name = data["declarant_type_name"] !== undefined ? data["declarant_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardDeclarantPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardDeclarantPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["declarant_type_id"] = this.declarant_type_id !== undefined ? this.declarant_type_id : <any>null;
        data["declarant_type_name"] = this.declarant_type_name !== undefined ? this.declarant_type_name : <any>null;
        return data; 
    }
}

export interface ICardDeclarantPartDto {
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
}

export class CardAddressHouseDto implements ICardAddressHouseDto {
    building?: string | null;
    fias_id?: number | null;
    full_name?: string | null;
    house?: string | null;
    structure?: string | null;

    constructor(data?: ICardAddressHouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.fias_id = data["fias_id"] !== undefined ? data["fias_id"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.house = data["house"] !== undefined ? data["house"] : <any>null;
            this.structure = data["structure"] !== undefined ? data["structure"] : <any>null;
        }
    }

    static fromJS(data: any): CardAddressHouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAddressHouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["fias_id"] = this.fias_id !== undefined ? this.fias_id : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["house"] = this.house !== undefined ? this.house : <any>null;
        data["structure"] = this.structure !== undefined ? this.structure : <any>null;
        return data; 
    }
}

export interface ICardAddressHouseDto {
    building?: string | null;
    fias_id?: number | null;
    full_name?: string | null;
    house?: string | null;
    structure?: string | null;
}

export class PerformerBrigScheduleUpdateDto implements IPerformerBrigScheduleUpdateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;

    constructor(data?: IPerformerBrigScheduleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleUpdateDto {
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
}

export class CardBasicDatesPartDto implements ICardBasicDatesPartDto {
    arrive_time_exceed?: boolean | null;
    brigade_arrive_date?: Date | null;
    brigade_complete_date?: Date | null;
    brigade_departure_date?: Date | null;
    brigade_receiving_date?: Date | null;
    brigade_return_date?: Date | null;
    brigade_transport_begin_date?: Date | null;
    brigade_transport_end_date?: Date | null;
    call_create_date?: Date | null;
    call_date?: Date | null;
    card_date?: Date | null;
    full_time_interval?: string | null;
    receiving_time_exceed?: boolean | null;

    constructor(data?: ICardBasicDatesPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.arrive_time_exceed = data["arrive_time_exceed"] !== undefined ? data["arrive_time_exceed"] : <any>null;
            this.brigade_arrive_date = data["brigade_arrive_date"] ? new Date(data["brigade_arrive_date"].toString()) : <any>null;
            this.brigade_complete_date = data["brigade_complete_date"] ? new Date(data["brigade_complete_date"].toString()) : <any>null;
            this.brigade_departure_date = data["brigade_departure_date"] ? new Date(data["brigade_departure_date"].toString()) : <any>null;
            this.brigade_receiving_date = data["brigade_receiving_date"] ? new Date(data["brigade_receiving_date"].toString()) : <any>null;
            this.brigade_return_date = data["brigade_return_date"] ? new Date(data["brigade_return_date"].toString()) : <any>null;
            this.brigade_transport_begin_date = data["brigade_transport_begin_date"] ? new Date(data["brigade_transport_begin_date"].toString()) : <any>null;
            this.brigade_transport_end_date = data["brigade_transport_end_date"] ? new Date(data["brigade_transport_end_date"].toString()) : <any>null;
            this.call_create_date = data["call_create_date"] ? new Date(data["call_create_date"].toString()) : <any>null;
            this.call_date = data["call_date"] ? new Date(data["call_date"].toString()) : <any>null;
            this.card_date = data["card_date"] ? new Date(data["card_date"].toString()) : <any>null;
            this.full_time_interval = data["full_time_interval"] !== undefined ? data["full_time_interval"] : <any>null;
            this.receiving_time_exceed = data["receiving_time_exceed"] !== undefined ? data["receiving_time_exceed"] : <any>null;
        }
    }

    static fromJS(data: any): CardBasicDatesPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardBasicDatesPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrive_time_exceed"] = this.arrive_time_exceed !== undefined ? this.arrive_time_exceed : <any>null;
        data["brigade_arrive_date"] = this.brigade_arrive_date ? this.brigade_arrive_date.toISOString() : <any>null;
        data["brigade_complete_date"] = this.brigade_complete_date ? this.brigade_complete_date.toISOString() : <any>null;
        data["brigade_departure_date"] = this.brigade_departure_date ? this.brigade_departure_date.toISOString() : <any>null;
        data["brigade_receiving_date"] = this.brigade_receiving_date ? this.brigade_receiving_date.toISOString() : <any>null;
        data["brigade_return_date"] = this.brigade_return_date ? this.brigade_return_date.toISOString() : <any>null;
        data["brigade_transport_begin_date"] = this.brigade_transport_begin_date ? this.brigade_transport_begin_date.toISOString() : <any>null;
        data["brigade_transport_end_date"] = this.brigade_transport_end_date ? this.brigade_transport_end_date.toISOString() : <any>null;
        data["call_create_date"] = this.call_create_date ? this.call_create_date.toISOString() : <any>null;
        data["call_date"] = this.call_date ? this.call_date.toISOString() : <any>null;
        data["card_date"] = this.card_date ? this.card_date.toISOString() : <any>null;
        data["full_time_interval"] = this.full_time_interval !== undefined ? this.full_time_interval : <any>null;
        data["receiving_time_exceed"] = this.receiving_time_exceed !== undefined ? this.receiving_time_exceed : <any>null;
        return data; 
    }
}

export interface ICardBasicDatesPartDto {
    arrive_time_exceed?: boolean | null;
    brigade_arrive_date?: Date | null;
    brigade_complete_date?: Date | null;
    brigade_departure_date?: Date | null;
    brigade_receiving_date?: Date | null;
    brigade_return_date?: Date | null;
    brigade_transport_begin_date?: Date | null;
    brigade_transport_end_date?: Date | null;
    call_create_date?: Date | null;
    call_date?: Date | null;
    card_date?: Date | null;
    full_time_interval?: string | null;
    receiving_time_exceed?: boolean | null;
}

export class CallShortDto implements ICallShortDto {
    address?: string | null;
    call_id?: number | null;
    call_reason?: string | null;
    date?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    is_unfounded?: boolean | null;
    number?: string | null;
    patient_age?: string | null;
    patient_firstname?: string | null;
    patient_patronymic?: string | null;
    patient_second_name?: string | null;
    patients?: string[] | null;
    similars?: string[] | null;
    status?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICallShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_reason = data["call_reason"] !== undefined ? data["call_reason"] : <any>null;
            this.date = data["date"] !== undefined ? data["date"] : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patient_age = data["patient_age"] !== undefined ? data["patient_age"] : <any>null;
            this.patient_firstname = data["patient_firstname"] !== undefined ? data["patient_firstname"] : <any>null;
            this.patient_patronymic = data["patient_patronymic"] !== undefined ? data["patient_patronymic"] : <any>null;
            this.patient_second_name = data["patient_second_name"] !== undefined ? data["patient_second_name"] : <any>null;
            if (data["patients"] && data["patients"].constructor === Array) {
                this.patients = [];
                for (let item of data["patients"])
                    this.patients.push(item);
            }
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_reason"] = this.call_reason !== undefined ? this.call_reason : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patient_age"] = this.patient_age !== undefined ? this.patient_age : <any>null;
        data["patient_firstname"] = this.patient_firstname !== undefined ? this.patient_firstname : <any>null;
        data["patient_patronymic"] = this.patient_patronymic !== undefined ? this.patient_patronymic : <any>null;
        data["patient_second_name"] = this.patient_second_name !== undefined ? this.patient_second_name : <any>null;
        if (this.patients && this.patients.constructor === Array) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item);
        }
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICallShortDto {
    address?: string | null;
    call_id?: number | null;
    call_reason?: string | null;
    date?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    is_unfounded?: boolean | null;
    number?: string | null;
    patient_age?: string | null;
    patient_firstname?: string | null;
    patient_patronymic?: string | null;
    patient_second_name?: string | null;
    patients?: string[] | null;
    similars?: string[] | null;
    status?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class CardObjectiveComplicationsPartDto implements ICardObjectiveComplicationsPartDto {
    complications_id?: number | null;
    complications_name?: string | null;
    complications_text?: string | null;

    constructor(data?: ICardObjectiveComplicationsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.complications_id = data["complications_id"] !== undefined ? data["complications_id"] : <any>null;
            this.complications_name = data["complications_name"] !== undefined ? data["complications_name"] : <any>null;
            this.complications_text = data["complications_text"] !== undefined ? data["complications_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveComplicationsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveComplicationsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complications_id"] = this.complications_id !== undefined ? this.complications_id : <any>null;
        data["complications_name"] = this.complications_name !== undefined ? this.complications_name : <any>null;
        data["complications_text"] = this.complications_text !== undefined ? this.complications_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveComplicationsPartDto {
    complications_id?: number | null;
    complications_name?: string | null;
    complications_text?: string | null;
}

export class MobileMessage implements IMobileMessage {
    code?: string | null;
    date?: Date | null;
    guid?: string | null;
    on_off?: boolean | null;

    constructor(data?: IMobileMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
            this.on_off = data["on_off"] !== undefined ? data["on_off"] : <any>null;
        }
    }

    static fromJS(data: any): MobileMessage {
        data = typeof data === 'object' ? data : {};
        let result = new MobileMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        data["on_off"] = this.on_off !== undefined ? this.on_off : <any>null;
        return data; 
    }
}

export interface IMobileMessage {
    code?: string | null;
    date?: Date | null;
    guid?: string | null;
    on_off?: boolean | null;
}

export class UnitBean implements IUnitBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IUnitBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): UnitBean {
        data = typeof data === 'object' ? data : {};
        let result = new UnitBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IUnitBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class BagItemDto implements IBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    bag_nomenclature_id?: number | null;
    bag_series_number?: number | null;
    company?: string | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IBagItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.bag_nomenclature_id = data["bag_nomenclature_id"] !== undefined ? data["bag_nomenclature_id"] : <any>null;
            this.bag_series_number = data["bag_series_number"] !== undefined ? data["bag_series_number"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.expiry_date = data["expiry_date"] ? new Date(data["expiry_date"].toString()) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_reusable = data["is_reusable"] !== undefined ? data["is_reusable"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): BagItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BagItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["bag_nomenclature_id"] = this.bag_nomenclature_id !== undefined ? this.bag_nomenclature_id : <any>null;
        data["bag_series_number"] = this.bag_series_number !== undefined ? this.bag_series_number : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toISOString() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_reusable"] = this.is_reusable !== undefined ? this.is_reusable : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    bag_nomenclature_id?: number | null;
    bag_series_number?: number | null;
    company?: string | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    series_number?: number | null;
    type?: number | null;
}

export class ListContainerOfBrigadeTypeBean implements IListContainerOfBrigadeTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBrigadeTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBrigadeTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBrigadeTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBrigadeTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveAlcoPartDto implements ICardObjectiveAlcoPartDto {
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;

    constructor(data?: ICardObjectiveAlcoPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.alco_breath = data["alco_breath"] !== undefined ? data["alco_breath"] : <any>null;
            this.alco_emotion_lability = data["alco_emotion_lability"] !== undefined ? data["alco_emotion_lability"] : <any>null;
            this.alco_inadequate = data["alco_inadequate"] !== undefined ? data["alco_inadequate"] : <any>null;
            this.alco_romberg_pose = data["alco_romberg_pose"] !== undefined ? data["alco_romberg_pose"] : <any>null;
            this.alco_shaky_walk = data["alco_shaky_walk"] !== undefined ? data["alco_shaky_walk"] : <any>null;
            this.alco_speach_behavior = data["alco_speach_behavior"] !== undefined ? data["alco_speach_behavior"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveAlcoPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveAlcoPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alco_breath"] = this.alco_breath !== undefined ? this.alco_breath : <any>null;
        data["alco_emotion_lability"] = this.alco_emotion_lability !== undefined ? this.alco_emotion_lability : <any>null;
        data["alco_inadequate"] = this.alco_inadequate !== undefined ? this.alco_inadequate : <any>null;
        data["alco_romberg_pose"] = this.alco_romberg_pose !== undefined ? this.alco_romberg_pose : <any>null;
        data["alco_shaky_walk"] = this.alco_shaky_walk !== undefined ? this.alco_shaky_walk : <any>null;
        data["alco_speach_behavior"] = this.alco_speach_behavior !== undefined ? this.alco_speach_behavior : <any>null;
        return data; 
    }
}

export interface ICardObjectiveAlcoPartDto {
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;
}

export class BrigadeTypeBean implements IBrigadeTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IBrigadeTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class GroupBagItemDto implements IGroupBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    group_id?: number | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    name?: string | null;
    nomenclature_id?: number | null;

    constructor(data?: IGroupBagItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BagItemDto.fromJS(item));
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
        }
    }

    static fromJS(data: any): GroupBagItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupBagItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        return data; 
    }
}

export interface IGroupBagItemDto {
    amount?: number | null;
    bag_id?: number | null;
    group_id?: number | null;
    id?: number | null;
    items?: BagItemDto[] | null;
    name?: string | null;
    nomenclature_id?: number | null;
}

export class ListContainerOfTransportBean implements IListContainerOfTransportBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfTransportBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfTransportBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfTransportBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfTransportBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class BrigadeContainer implements IBrigadeContainer {
    brigade?: BrigadeBean | null;
    performerList?: PerformerBean[] | null;
    transportBean?: TransportBean | null;

    constructor(data?: IBrigadeContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade = data["brigade"] ? BrigadeBean.fromJS(data["brigade"]) : <any>null;
            if (data["performerList"] && data["performerList"].constructor === Array) {
                this.performerList = [];
                for (let item of data["performerList"])
                    this.performerList.push(PerformerBean.fromJS(item));
            }
            this.transportBean = data["transportBean"] ? TransportBean.fromJS(data["transportBean"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeContainer {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade"] = this.brigade ? this.brigade.toJSON() : <any>null;
        if (this.performerList && this.performerList.constructor === Array) {
            data["performerList"] = [];
            for (let item of this.performerList)
                data["performerList"].push(item.toJSON());
        }
        data["transportBean"] = this.transportBean ? this.transportBean.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeContainer {
    brigade?: BrigadeBean | null;
    performerList?: PerformerBean[] | null;
    transportBean?: TransportBean | null;
}

export class CardGridDto implements ICardGridDto {
    address?: string | null;
    brigade_arrive_date?: Date | null;
    brigade_departure_date?: Date | null;
    brigade_help_date?: Date | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_receiving_date?: Date | null;
    brigade_return_date?: Date | null;
    call_id?: number | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    date?: Date | null;
    declarant_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: Date | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    district?: string | null;
    district_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    main_diagnosis_id?: number | null;
    main_diagnosis_name?: string | null;
    number?: string | null;
    patient?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    result_id?: number | null;
    result_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICardGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.brigade_arrive_date = data["brigade_arrive_date"] ? new Date(data["brigade_arrive_date"].toString()) : <any>null;
            this.brigade_departure_date = data["brigade_departure_date"] ? new Date(data["brigade_departure_date"].toString()) : <any>null;
            this.brigade_help_date = data["brigade_help_date"] ? new Date(data["brigade_help_date"].toString()) : <any>null;
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
            this.brigade_name = data["brigade_name"] !== undefined ? data["brigade_name"] : <any>null;
            this.brigade_receiving_date = data["brigade_receiving_date"] ? new Date(data["brigade_receiving_date"].toString()) : <any>null;
            this.brigade_return_date = data["brigade_return_date"] ? new Date(data["brigade_return_date"].toString()) : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.card_id = data["card_id"] !== undefined ? data["card_id"] : <any>null;
            this.card_status = data["card_status"] !== undefined ? data["card_status"] : <any>null;
            this.card_status_name = data["card_status_name"] !== undefined ? data["card_status_name"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.deleted_date = data["deleted_date"] ? new Date(data["deleted_date"].toString()) : <any>null;
            this.deleted_message = data["deleted_message"] !== undefined ? data["deleted_message"] : <any>null;
            this.deleted_performer_id = data["deleted_performer_id"] !== undefined ? data["deleted_performer_id"] : <any>null;
            this.deleted_performer_name = data["deleted_performer_name"] !== undefined ? data["deleted_performer_name"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.district_name = data["district_name"] !== undefined ? data["district_name"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.main_diagnosis_id = data["main_diagnosis_id"] !== undefined ? data["main_diagnosis_id"] : <any>null;
            this.main_diagnosis_name = data["main_diagnosis_name"] !== undefined ? data["main_diagnosis_name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patient = data["patient"] !== undefined ? data["patient"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.result_id = data["result_id"] !== undefined ? data["result_id"] : <any>null;
            this.result_name = data["result_name"] !== undefined ? data["result_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["brigade_arrive_date"] = this.brigade_arrive_date ? this.brigade_arrive_date.toISOString() : <any>null;
        data["brigade_departure_date"] = this.brigade_departure_date ? this.brigade_departure_date.toISOString() : <any>null;
        data["brigade_help_date"] = this.brigade_help_date ? this.brigade_help_date.toISOString() : <any>null;
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        data["brigade_name"] = this.brigade_name !== undefined ? this.brigade_name : <any>null;
        data["brigade_receiving_date"] = this.brigade_receiving_date ? this.brigade_receiving_date.toISOString() : <any>null;
        data["brigade_return_date"] = this.brigade_return_date ? this.brigade_return_date.toISOString() : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["card_id"] = this.card_id !== undefined ? this.card_id : <any>null;
        data["card_status"] = this.card_status !== undefined ? this.card_status : <any>null;
        data["card_status_name"] = this.card_status_name !== undefined ? this.card_status_name : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["deleted_date"] = this.deleted_date ? this.deleted_date.toISOString() : <any>null;
        data["deleted_message"] = this.deleted_message !== undefined ? this.deleted_message : <any>null;
        data["deleted_performer_id"] = this.deleted_performer_id !== undefined ? this.deleted_performer_id : <any>null;
        data["deleted_performer_name"] = this.deleted_performer_name !== undefined ? this.deleted_performer_name : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["district_name"] = this.district_name !== undefined ? this.district_name : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["main_diagnosis_id"] = this.main_diagnosis_id !== undefined ? this.main_diagnosis_id : <any>null;
        data["main_diagnosis_name"] = this.main_diagnosis_name !== undefined ? this.main_diagnosis_name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patient"] = this.patient !== undefined ? this.patient : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["result_id"] = this.result_id !== undefined ? this.result_id : <any>null;
        data["result_name"] = this.result_name !== undefined ? this.result_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICardGridDto {
    address?: string | null;
    brigade_arrive_date?: Date | null;
    brigade_departure_date?: Date | null;
    brigade_help_date?: Date | null;
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_receiving_date?: Date | null;
    brigade_return_date?: Date | null;
    call_id?: number | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    date?: Date | null;
    declarant_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: Date | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    district?: string | null;
    district_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    main_diagnosis_id?: number | null;
    main_diagnosis_name?: string | null;
    number?: string | null;
    patient?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    result_id?: number | null;
    result_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class CardObjectiveLymphPartDto implements ICardObjectiveLymphPartDto {
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_normal_large_name?: string | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_painful_unpainful_name?: string | null;
    lymph_nodes_text?: string | null;

    constructor(data?: ICardObjectiveLymphPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lymph_nodes_normal_large = data["lymph_nodes_normal_large"] !== undefined ? data["lymph_nodes_normal_large"] : <any>null;
            this.lymph_nodes_normal_large_name = data["lymph_nodes_normal_large_name"] !== undefined ? data["lymph_nodes_normal_large_name"] : <any>null;
            this.lymph_nodes_painful_unpainful = data["lymph_nodes_painful_unpainful"] !== undefined ? data["lymph_nodes_painful_unpainful"] : <any>null;
            this.lymph_nodes_painful_unpainful_name = data["lymph_nodes_painful_unpainful_name"] !== undefined ? data["lymph_nodes_painful_unpainful_name"] : <any>null;
            this.lymph_nodes_text = data["lymph_nodes_text"] !== undefined ? data["lymph_nodes_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveLymphPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveLymphPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lymph_nodes_normal_large"] = this.lymph_nodes_normal_large !== undefined ? this.lymph_nodes_normal_large : <any>null;
        data["lymph_nodes_normal_large_name"] = this.lymph_nodes_normal_large_name !== undefined ? this.lymph_nodes_normal_large_name : <any>null;
        data["lymph_nodes_painful_unpainful"] = this.lymph_nodes_painful_unpainful !== undefined ? this.lymph_nodes_painful_unpainful : <any>null;
        data["lymph_nodes_painful_unpainful_name"] = this.lymph_nodes_painful_unpainful_name !== undefined ? this.lymph_nodes_painful_unpainful_name : <any>null;
        data["lymph_nodes_text"] = this.lymph_nodes_text !== undefined ? this.lymph_nodes_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveLymphPartDto {
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_normal_large_name?: string | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_painful_unpainful_name?: string | null;
    lymph_nodes_text?: string | null;
}

export class CardAnamnesisComplaintsPartDto implements ICardAnamnesisComplaintsPartDto {
    complaints_anamnesis?: string | null;

    constructor(data?: ICardAnamnesisComplaintsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.complaints_anamnesis = data["complaints_anamnesis"] !== undefined ? data["complaints_anamnesis"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisComplaintsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisComplaintsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complaints_anamnesis"] = this.complaints_anamnesis !== undefined ? this.complaints_anamnesis : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisComplaintsPartDto {
    complaints_anamnesis?: string | null;
}

export class MessageEventDto implements IMessageEventDto {
    code?: string | null;
    date?: Date | null;
    date_filled?: Date | null;
    id?: number | null;
    message_id?: number | null;
    name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    transmitted?: boolean | null;

    constructor(data?: IMessageEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.date_filled = data["date_filled"] ? new Date(data["date_filled"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.message_id = data["message_id"] !== undefined ? data["message_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.transmitted = data["transmitted"] !== undefined ? data["transmitted"] : <any>null;
        }
    }

    static fromJS(data: any): MessageEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["date_filled"] = this.date_filled ? this.date_filled.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["message_id"] = this.message_id !== undefined ? this.message_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["transmitted"] = this.transmitted !== undefined ? this.transmitted : <any>null;
        return data; 
    }
}

export interface IMessageEventDto {
    code?: string | null;
    date?: Date | null;
    date_filled?: Date | null;
    id?: number | null;
    message_id?: number | null;
    name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    transmitted?: boolean | null;
}

export class CardResultCommentsDto implements ICardResultCommentsDto {
    comments?: string | null;

    constructor(data?: ICardResultCommentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultCommentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultCommentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        return data; 
    }
}

export interface ICardResultCommentsDto {
    comments?: string | null;
}

export class BrigadeScheduleCreateDto implements IBrigadeScheduleCreateDto {
    cars?: TransportBrigScheduleCreateDto[] | null;
    performers?: PerformerBrigScheduleCreateDto[] | null;
    period_details?: PeriodDetails | null;

    constructor(data?: IBrigadeScheduleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cars"] && data["cars"].constructor === Array) {
                this.cars = [];
                for (let item of data["cars"])
                    this.cars.push(TransportBrigScheduleCreateDto.fromJS(item));
            }
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerBrigScheduleCreateDto.fromJS(item));
            }
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeScheduleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeScheduleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cars && this.cars.constructor === Array) {
            data["cars"] = [];
            for (let item of this.cars)
                data["cars"].push(item.toJSON());
        }
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeScheduleCreateDto {
    cars?: TransportBrigScheduleCreateDto[] | null;
    performers?: PerformerBrigScheduleCreateDto[] | null;
    period_details?: PeriodDetails | null;
}

export class ReferenceTypeBean implements IReferenceTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
    type?: string | null;

    constructor(data?: IReferenceTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): ReferenceTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReferenceTypeBean {
    code?: string | null;
    id?: number | null;
    isDefault?: boolean | null;
    isDeleted?: boolean | null;
    name?: string | null;
    type?: string | null;
}

export class CardObjectiveExcretaUrinePartDto implements ICardObjectiveExcretaUrinePartDto {
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    urine_text?: string | null;

    constructor(data?: ICardObjectiveExcretaUrinePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.excreta = data["excreta"] !== undefined ? data["excreta"] : <any>null;
            this.excreta_name = data["excreta_name"] !== undefined ? data["excreta_name"] : <any>null;
            this.excreta_text = data["excreta_text"] !== undefined ? data["excreta_text"] : <any>null;
            this.urine_text = data["urine_text"] !== undefined ? data["urine_text"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveExcretaUrinePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveExcretaUrinePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["excreta"] = this.excreta !== undefined ? this.excreta : <any>null;
        data["excreta_name"] = this.excreta_name !== undefined ? this.excreta_name : <any>null;
        data["excreta_text"] = this.excreta_text !== undefined ? this.excreta_text : <any>null;
        data["urine_text"] = this.urine_text !== undefined ? this.urine_text : <any>null;
        return data; 
    }
}

export interface ICardObjectiveExcretaUrinePartDto {
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    urine_text?: string | null;
}

export class CardResultDto implements ICardResultDto {
    active_visit?: CardResultActiveVisitDto | null;
    assistance_result?: CardResultAssistanceResultDto | null;
    comments?: string | null;
    death?: CardResultDeathDto | null;
    diagnosis?: CardResultDiagnosisDto | null;
    ekg?: CardResultEkg | null;
    ekg_after?: CardResultEkg | null;
    header?: CardResultHeaderDto | null;
    illegal_actions?: CardResultIllegalActionsDto | null;
    local_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    local_therapies?: TherapyDto[] | null;
    materials?: CardResultMaterialsDto | null;
    transfer_patient?: CardResultTransferPatientDto | null;
    transport_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    transport_therapies?: TherapyDto[] | null;
    transporting?: CardResultTransportingDto | null;
    type?: CardResultTypeDto | null;

    constructor(data?: ICardResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active_visit = data["active_visit"] ? CardResultActiveVisitDto.fromJS(data["active_visit"]) : <any>null;
            this.assistance_result = data["assistance_result"] ? CardResultAssistanceResultDto.fromJS(data["assistance_result"]) : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.death = data["death"] ? CardResultDeathDto.fromJS(data["death"]) : <any>null;
            this.diagnosis = data["diagnosis"] ? CardResultDiagnosisDto.fromJS(data["diagnosis"]) : <any>null;
            this.ekg = data["ekg"] ? CardResultEkg.fromJS(data["ekg"]) : <any>null;
            this.ekg_after = data["ekg_after"] ? CardResultEkg.fromJS(data["ekg_after"]) : <any>null;
            this.header = data["header"] ? CardResultHeaderDto.fromJS(data["header"]) : <any>null;
            this.illegal_actions = data["illegal_actions"] ? CardResultIllegalActionsDto.fromJS(data["illegal_actions"]) : <any>null;
            this.local_efficiency_assistance = data["local_efficiency_assistance"] ? CardResultEfficiencyAssistance.fromJS(data["local_efficiency_assistance"]) : <any>null;
            if (data["local_therapies"] && data["local_therapies"].constructor === Array) {
                this.local_therapies = [];
                for (let item of data["local_therapies"])
                    this.local_therapies.push(TherapyDto.fromJS(item));
            }
            this.materials = data["materials"] ? CardResultMaterialsDto.fromJS(data["materials"]) : <any>null;
            this.transfer_patient = data["transfer_patient"] ? CardResultTransferPatientDto.fromJS(data["transfer_patient"]) : <any>null;
            this.transport_efficiency_assistance = data["transport_efficiency_assistance"] ? CardResultEfficiencyAssistance.fromJS(data["transport_efficiency_assistance"]) : <any>null;
            if (data["transport_therapies"] && data["transport_therapies"].constructor === Array) {
                this.transport_therapies = [];
                for (let item of data["transport_therapies"])
                    this.transport_therapies.push(TherapyDto.fromJS(item));
            }
            this.transporting = data["transporting"] ? CardResultTransportingDto.fromJS(data["transporting"]) : <any>null;
            this.type = data["type"] ? CardResultTypeDto.fromJS(data["type"]) : <any>null;
        }
    }

    static fromJS(data: any): CardResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active_visit"] = this.active_visit ? this.active_visit.toJSON() : <any>null;
        data["assistance_result"] = this.assistance_result ? this.assistance_result.toJSON() : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["death"] = this.death ? this.death.toJSON() : <any>null;
        data["diagnosis"] = this.diagnosis ? this.diagnosis.toJSON() : <any>null;
        data["ekg"] = this.ekg ? this.ekg.toJSON() : <any>null;
        data["ekg_after"] = this.ekg_after ? this.ekg_after.toJSON() : <any>null;
        data["header"] = this.header ? this.header.toJSON() : <any>null;
        data["illegal_actions"] = this.illegal_actions ? this.illegal_actions.toJSON() : <any>null;
        data["local_efficiency_assistance"] = this.local_efficiency_assistance ? this.local_efficiency_assistance.toJSON() : <any>null;
        if (this.local_therapies && this.local_therapies.constructor === Array) {
            data["local_therapies"] = [];
            for (let item of this.local_therapies)
                data["local_therapies"].push(item.toJSON());
        }
        data["materials"] = this.materials ? this.materials.toJSON() : <any>null;
        data["transfer_patient"] = this.transfer_patient ? this.transfer_patient.toJSON() : <any>null;
        data["transport_efficiency_assistance"] = this.transport_efficiency_assistance ? this.transport_efficiency_assistance.toJSON() : <any>null;
        if (this.transport_therapies && this.transport_therapies.constructor === Array) {
            data["transport_therapies"] = [];
            for (let item of this.transport_therapies)
                data["transport_therapies"].push(item.toJSON());
        }
        data["transporting"] = this.transporting ? this.transporting.toJSON() : <any>null;
        data["type"] = this.type ? this.type.toJSON() : <any>null;
        return data; 
    }
}

export interface ICardResultDto {
    active_visit?: CardResultActiveVisitDto | null;
    assistance_result?: CardResultAssistanceResultDto | null;
    comments?: string | null;
    death?: CardResultDeathDto | null;
    diagnosis?: CardResultDiagnosisDto | null;
    ekg?: CardResultEkg | null;
    ekg_after?: CardResultEkg | null;
    header?: CardResultHeaderDto | null;
    illegal_actions?: CardResultIllegalActionsDto | null;
    local_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    local_therapies?: TherapyDto[] | null;
    materials?: CardResultMaterialsDto | null;
    transfer_patient?: CardResultTransferPatientDto | null;
    transport_efficiency_assistance?: CardResultEfficiencyAssistance | null;
    transport_therapies?: TherapyDto[] | null;
    transporting?: CardResultTransportingDto | null;
    type?: CardResultTypeDto | null;
}

export class LoginPair implements ILoginPair {
    name?: string | null;
    password?: string | null;

    constructor(data?: ILoginPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginPair {
        data = typeof data === 'object' ? data : {};
        let result = new LoginPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface ILoginPair {
    name?: string | null;
    password?: string | null;
}

export class PharmacyGroupReferenceDto implements IPharmacyGroupReferenceDto {
    code?: string | null;
    company?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    reference_id?: number | null;

    constructor(data?: IPharmacyGroupReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.reference_id = data["reference_id"] !== undefined ? data["reference_id"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyGroupReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyGroupReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["reference_id"] = this.reference_id !== undefined ? this.reference_id : <any>null;
        return data; 
    }
}

export interface IPharmacyGroupReferenceDto {
    code?: string | null;
    company?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    name?: string | null;
    reference_id?: number | null;
}

export class CardShiftSeniorDoctorPartDto implements ICardShiftSeniorDoctorPartDto {
    shift_senior_doctor_checked?: boolean | null;
    shift_senior_doctor_comment?: string | null;
    shift_senior_doctor_date?: Date | null;
    shift_senior_doctor_id?: number | null;
    shift_senior_doctor_name?: string | null;

    constructor(data?: ICardShiftSeniorDoctorPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shift_senior_doctor_checked = data["shift_senior_doctor_checked"] !== undefined ? data["shift_senior_doctor_checked"] : <any>null;
            this.shift_senior_doctor_comment = data["shift_senior_doctor_comment"] !== undefined ? data["shift_senior_doctor_comment"] : <any>null;
            this.shift_senior_doctor_date = data["shift_senior_doctor_date"] ? new Date(data["shift_senior_doctor_date"].toString()) : <any>null;
            this.shift_senior_doctor_id = data["shift_senior_doctor_id"] !== undefined ? data["shift_senior_doctor_id"] : <any>null;
            this.shift_senior_doctor_name = data["shift_senior_doctor_name"] !== undefined ? data["shift_senior_doctor_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardShiftSeniorDoctorPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardShiftSeniorDoctorPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shift_senior_doctor_checked"] = this.shift_senior_doctor_checked !== undefined ? this.shift_senior_doctor_checked : <any>null;
        data["shift_senior_doctor_comment"] = this.shift_senior_doctor_comment !== undefined ? this.shift_senior_doctor_comment : <any>null;
        data["shift_senior_doctor_date"] = this.shift_senior_doctor_date ? this.shift_senior_doctor_date.toISOString() : <any>null;
        data["shift_senior_doctor_id"] = this.shift_senior_doctor_id !== undefined ? this.shift_senior_doctor_id : <any>null;
        data["shift_senior_doctor_name"] = this.shift_senior_doctor_name !== undefined ? this.shift_senior_doctor_name : <any>null;
        return data; 
    }
}

export interface ICardShiftSeniorDoctorPartDto {
    shift_senior_doctor_checked?: boolean | null;
    shift_senior_doctor_comment?: string | null;
    shift_senior_doctor_date?: Date | null;
    shift_senior_doctor_id?: number | null;
    shift_senior_doctor_name?: string | null;
}

export class CardObjectiveGlasgowPartDto implements ICardObjectiveGlasgowPartDto {
    eye?: number | null;
    motor?: number | null;
    verbal?: number | null;

    constructor(data?: ICardObjectiveGlasgowPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eye = data["eye"] !== undefined ? data["eye"] : <any>null;
            this.motor = data["motor"] !== undefined ? data["motor"] : <any>null;
            this.verbal = data["verbal"] !== undefined ? data["verbal"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveGlasgowPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveGlasgowPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eye"] = this.eye !== undefined ? this.eye : <any>null;
        data["motor"] = this.motor !== undefined ? this.motor : <any>null;
        data["verbal"] = this.verbal !== undefined ? this.verbal : <any>null;
        return data; 
    }
}

export interface ICardObjectiveGlasgowPartDto {
    eye?: number | null;
    motor?: number | null;
    verbal?: number | null;
}

export class ProductMove implements IProductMove {
    count?: number | null;
    count_consumption?: number | null;
    count_receiving?: number | null;
    date?: Date | null;
    description?: string | null;
    document_id?: number | null;

    constructor(data?: IProductMove) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"] !== undefined ? data["count"] : <any>null;
            this.count_consumption = data["count_consumption"] !== undefined ? data["count_consumption"] : <any>null;
            this.count_receiving = data["count_receiving"] !== undefined ? data["count_receiving"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.document_id = data["document_id"] !== undefined ? data["document_id"] : <any>null;
        }
    }

    static fromJS(data: any): ProductMove {
        data = typeof data === 'object' ? data : {};
        let result = new ProductMove();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count !== undefined ? this.count : <any>null;
        data["count_consumption"] = this.count_consumption !== undefined ? this.count_consumption : <any>null;
        data["count_receiving"] = this.count_receiving !== undefined ? this.count_receiving : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["document_id"] = this.document_id !== undefined ? this.document_id : <any>null;
        return data; 
    }
}

export interface IProductMove {
    count?: number | null;
    count_consumption?: number | null;
    count_receiving?: number | null;
    date?: Date | null;
    description?: string | null;
    document_id?: number | null;
}

export class ListDtoOfstring implements IListDtoOfstring {
    list?: string[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfstring) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(item);
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfstring {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfstring();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item);
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfstring {
    list?: string[] | null;
    size?: number | null;
    total?: number | null;
}

export class ListContainerOfUnitBean implements IListContainerOfUnitBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfUnitBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfUnitBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfUnitBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfUnitBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardBrigadeDoctorPartDto implements ICardBrigadeDoctorPartDto {
    brigade_doctor_date?: Date | null;
    brigade_doctor_id?: number | null;
    brigade_doctor_name?: string | null;
    brigade_doctor_signed?: boolean | null;

    constructor(data?: ICardBrigadeDoctorPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_doctor_date = data["brigade_doctor_date"] ? new Date(data["brigade_doctor_date"].toString()) : <any>null;
            this.brigade_doctor_id = data["brigade_doctor_id"] !== undefined ? data["brigade_doctor_id"] : <any>null;
            this.brigade_doctor_name = data["brigade_doctor_name"] !== undefined ? data["brigade_doctor_name"] : <any>null;
            this.brigade_doctor_signed = data["brigade_doctor_signed"] !== undefined ? data["brigade_doctor_signed"] : <any>null;
        }
    }

    static fromJS(data: any): CardBrigadeDoctorPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardBrigadeDoctorPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_doctor_date"] = this.brigade_doctor_date ? this.brigade_doctor_date.toISOString() : <any>null;
        data["brigade_doctor_id"] = this.brigade_doctor_id !== undefined ? this.brigade_doctor_id : <any>null;
        data["brigade_doctor_name"] = this.brigade_doctor_name !== undefined ? this.brigade_doctor_name : <any>null;
        data["brigade_doctor_signed"] = this.brigade_doctor_signed !== undefined ? this.brigade_doctor_signed : <any>null;
        return data; 
    }
}

export interface ICardBrigadeDoctorPartDto {
    brigade_doctor_date?: Date | null;
    brigade_doctor_id?: number | null;
    brigade_doctor_name?: string | null;
    brigade_doctor_signed?: boolean | null;
}

export class CardObjectivePartDtoFLAT implements ICardObjectivePartDtoFLAT {
    ad?: string | null;
    addition_objective?: string | null;
    admax?: string | null;
    adn?: string | null;
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;
    almonds_normal_large?: number | null;
    almonds_plaque?: boolean | null;
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    bodytemp?: string | null;
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    card_delivery_id?: number | null;
    chd?: string | null;
    chss?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    eye?: number | null;
    general_state_id?: number | null;
    general_state_name?: string | null;
    glucometry?: string | null;
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_pulse_id?: number | null;
    heart_pulse_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;
    heart_tone_noise?: boolean | null;
    is_created?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;
    liver_normal_large?: number | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;
    lungs_wheezing_id?: number | null;
    lungs_wheezing_text?: string | null;
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_text?: string | null;
    meningeal_reflexes?: boolean | null;
    motor?: number | null;
    multiple_zeva_clean_hyper?: number | null;
    pathological_reflexes?: boolean | null;
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;
    post_therapy_hemodynamics?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;
    titles?: boolean | null;
    titles_text?: string | null;
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;
    urine_text?: string | null;
    verbal?: number | null;

    constructor(data?: ICardObjectivePartDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ad = data["ad"] !== undefined ? data["ad"] : <any>null;
            this.addition_objective = data["addition_objective"] !== undefined ? data["addition_objective"] : <any>null;
            this.admax = data["admax"] !== undefined ? data["admax"] : <any>null;
            this.adn = data["adn"] !== undefined ? data["adn"] : <any>null;
            this.alco_breath = data["alco_breath"] !== undefined ? data["alco_breath"] : <any>null;
            this.alco_emotion_lability = data["alco_emotion_lability"] !== undefined ? data["alco_emotion_lability"] : <any>null;
            this.alco_inadequate = data["alco_inadequate"] !== undefined ? data["alco_inadequate"] : <any>null;
            this.alco_romberg_pose = data["alco_romberg_pose"] !== undefined ? data["alco_romberg_pose"] : <any>null;
            this.alco_shaky_walk = data["alco_shaky_walk"] !== undefined ? data["alco_shaky_walk"] : <any>null;
            this.alco_speach_behavior = data["alco_speach_behavior"] !== undefined ? data["alco_speach_behavior"] : <any>null;
            this.almonds_normal_large = data["almonds_normal_large"] !== undefined ? data["almonds_normal_large"] : <any>null;
            this.almonds_plaque = data["almonds_plaque"] !== undefined ? data["almonds_plaque"] : <any>null;
            this.behaviour_id = data["behaviour_id"] !== undefined ? data["behaviour_id"] : <any>null;
            this.behaviour_name = data["behaviour_name"] !== undefined ? data["behaviour_name"] : <any>null;
            this.bodytemp = data["bodytemp"] !== undefined ? data["bodytemp"] : <any>null;
            this.breath_absent = data["breath_absent"] !== undefined ? data["breath_absent"] : <any>null;
            this.breath_bronch = data["breath_bronch"] !== undefined ? data["breath_bronch"] : <any>null;
            this.breath_evenly = data["breath_evenly"] !== undefined ? data["breath_evenly"] : <any>null;
            this.breath_hard = data["breath_hard"] !== undefined ? data["breath_hard"] : <any>null;
            this.breath_puer = data["breath_puer"] !== undefined ? data["breath_puer"] : <any>null;
            this.breath_text = data["breath_text"] !== undefined ? data["breath_text"] : <any>null;
            this.breath_vesicul = data["breath_vesicul"] !== undefined ? data["breath_vesicul"] : <any>null;
            this.breath_weak = data["breath_weak"] !== undefined ? data["breath_weak"] : <any>null;
            this.card_delivery_id = data["card_delivery_id"] !== undefined ? data["card_delivery_id"] : <any>null;
            this.chd = data["chd"] !== undefined ? data["chd"] : <any>null;
            this.chss = data["chss"] !== undefined ? data["chss"] : <any>null;
            this.conscious_id = data["conscious_id"] !== undefined ? data["conscious_id"] : <any>null;
            this.conscious_name = data["conscious_name"] !== undefined ? data["conscious_name"] : <any>null;
            this.diuresis_disuria = data["diuresis_disuria"] !== undefined ? data["diuresis_disuria"] : <any>null;
            this.diuresis_hematuria = data["diuresis_hematuria"] !== undefined ? data["diuresis_hematuria"] : <any>null;
            this.diuresis_n = data["diuresis_n"] !== undefined ? data["diuresis_n"] : <any>null;
            this.diuresis_oliguria = data["diuresis_oliguria"] !== undefined ? data["diuresis_oliguria"] : <any>null;
            this.dyspeptic_diarrhea = data["dyspeptic_diarrhea"] !== undefined ? data["dyspeptic_diarrhea"] : <any>null;
            this.dyspeptic_nausea = data["dyspeptic_nausea"] !== undefined ? data["dyspeptic_nausea"] : <any>null;
            this.dyspeptic_retch = data["dyspeptic_retch"] !== undefined ? data["dyspeptic_retch"] : <any>null;
            this.dyspeptics_no = data["dyspeptics_no"] !== undefined ? data["dyspeptics_no"] : <any>null;
            this.dyspnea_id = data["dyspnea_id"] !== undefined ? data["dyspnea_id"] : <any>null;
            this.dyspnea_name = data["dyspnea_name"] !== undefined ? data["dyspnea_name"] : <any>null;
            this.excreta = data["excreta"] !== undefined ? data["excreta"] : <any>null;
            this.excreta_name = data["excreta_name"] !== undefined ? data["excreta_name"] : <any>null;
            this.excreta_text = data["excreta_text"] !== undefined ? data["excreta_text"] : <any>null;
            this.eye = data["eye"] !== undefined ? data["eye"] : <any>null;
            this.general_state_id = data["general_state_id"] !== undefined ? data["general_state_id"] : <any>null;
            this.general_state_name = data["general_state_name"] !== undefined ? data["general_state_name"] : <any>null;
            this.glucometry = data["glucometry"] !== undefined ? data["glucometry"] : <any>null;
            this.heart_noise_id = data["heart_noise_id"] !== undefined ? data["heart_noise_id"] : <any>null;
            this.heart_noise_name = data["heart_noise_name"] !== undefined ? data["heart_noise_name"] : <any>null;
            this.heart_pulse_id = data["heart_pulse_id"] !== undefined ? data["heart_pulse_id"] : <any>null;
            this.heart_pulse_name = data["heart_pulse_name"] !== undefined ? data["heart_pulse_name"] : <any>null;
            this.heart_rate_id = data["heart_rate_id"] !== undefined ? data["heart_rate_id"] : <any>null;
            this.heart_rate_name = data["heart_rate_name"] !== undefined ? data["heart_rate_name"] : <any>null;
            this.heart_tone_id = data["heart_tone_id"] !== undefined ? data["heart_tone_id"] : <any>null;
            this.heart_tone_name = data["heart_tone_name"] !== undefined ? data["heart_tone_name"] : <any>null;
            this.heart_tone_noise = data["heart_tone_noise"] !== undefined ? data["heart_tone_noise"] : <any>null;
            this.is_created = data["is_created"] !== undefined ? data["is_created"] : <any>null;
            this.lion_tapping_left = data["lion_tapping_left"] !== undefined ? data["lion_tapping_left"] : <any>null;
            this.lion_tapping_right = data["lion_tapping_right"] !== undefined ? data["lion_tapping_right"] : <any>null;
            this.liver_normal_large = data["liver_normal_large"] !== undefined ? data["liver_normal_large"] : <any>null;
            this.liver_ortner = data["liver_ortner"] !== undefined ? data["liver_ortner"] : <any>null;
            this.liver_size_text = data["liver_size_text"] !== undefined ? data["liver_size_text"] : <any>null;
            this.lungs_wheezing_id = data["lungs_wheezing_id"] !== undefined ? data["lungs_wheezing_id"] : <any>null;
            this.lungs_wheezing_text = data["lungs_wheezing_text"] !== undefined ? data["lungs_wheezing_text"] : <any>null;
            this.lymph_nodes_normal_large = data["lymph_nodes_normal_large"] !== undefined ? data["lymph_nodes_normal_large"] : <any>null;
            this.lymph_nodes_painful_unpainful = data["lymph_nodes_painful_unpainful"] !== undefined ? data["lymph_nodes_painful_unpainful"] : <any>null;
            this.lymph_nodes_text = data["lymph_nodes_text"] !== undefined ? data["lymph_nodes_text"] : <any>null;
            this.meningeal_reflexes = data["meningeal_reflexes"] !== undefined ? data["meningeal_reflexes"] : <any>null;
            this.motor = data["motor"] !== undefined ? data["motor"] : <any>null;
            this.multiple_zeva_clean_hyper = data["multiple_zeva_clean_hyper"] !== undefined ? data["multiple_zeva_clean_hyper"] : <any>null;
            this.pathological_reflexes = data["pathological_reflexes"] !== undefined ? data["pathological_reflexes"] : <any>null;
            this.penalties_anisocoria = data["penalties_anisocoria"] !== undefined ? data["penalties_anisocoria"] : <any>null;
            this.penalties_anisocoria_name = data["penalties_anisocoria_name"] !== undefined ? data["penalties_anisocoria_name"] : <any>null;
            this.penalties_d_s_id = data["penalties_d_s_id"] !== undefined ? data["penalties_d_s_id"] : <any>null;
            this.penalties_d_s_name = data["penalties_d_s_name"] !== undefined ? data["penalties_d_s_name"] : <any>null;
            this.penalties_id = data["penalties_id"] !== undefined ? data["penalties_id"] : <any>null;
            this.penalties_light = data["penalties_light"] !== undefined ? data["penalties_light"] : <any>null;
            this.penalties_light_name = data["penalties_light_name"] !== undefined ? data["penalties_light_name"] : <any>null;
            this.penalties_name = data["penalties_name"] !== undefined ? data["penalties_name"] : <any>null;
            this.penalties_nystagmus = data["penalties_nystagmus"] !== undefined ? data["penalties_nystagmus"] : <any>null;
            this.penalties_nystagmus_name = data["penalties_nystagmus_name"] !== undefined ? data["penalties_nystagmus_name"] : <any>null;
            this.perc_lungs_sound_id = data["perc_lungs_sound_id"] !== undefined ? data["perc_lungs_sound_id"] : <any>null;
            this.perc_lungs_sound_name = data["perc_lungs_sound_name"] !== undefined ? data["perc_lungs_sound_name"] : <any>null;
            this.perc_lungs_sound_text = data["perc_lungs_sound_text"] !== undefined ? data["perc_lungs_sound_text"] : <any>null;
            this.post_therapy_hemodynamics = data["post_therapy_hemodynamics"] !== undefined ? data["post_therapy_hemodynamics"] : <any>null;
            this.ps = data["ps"] !== undefined ? data["ps"] : <any>null;
            this.pulse_oximetry = data["pulse_oximetry"] !== undefined ? data["pulse_oximetry"] : <any>null;
            this.reflexes_d_s_id = data["reflexes_d_s_id"] !== undefined ? data["reflexes_d_s_id"] : <any>null;
            this.reflexes_d_s_name = data["reflexes_d_s_name"] !== undefined ? data["reflexes_d_s_name"] : <any>null;
            this.reflexes_name = data["reflexes_name"] !== undefined ? data["reflexes_name"] : <any>null;
            this.skin_integ_acrosian = data["skin_integ_acrosian"] !== undefined ? data["skin_integ_acrosian"] : <any>null;
            this.skin_integ_cyanotic = data["skin_integ_cyanotic"] !== undefined ? data["skin_integ_cyanotic"] : <any>null;
            this.skin_integ_dry = data["skin_integ_dry"] !== undefined ? data["skin_integ_dry"] : <any>null;
            this.skin_integ_earthy = data["skin_integ_earthy"] !== undefined ? data["skin_integ_earthy"] : <any>null;
            this.skin_integ_hyperemetic = data["skin_integ_hyperemetic"] !== undefined ? data["skin_integ_hyperemetic"] : <any>null;
            this.skin_integ_icteric = data["skin_integ_icteric"] !== undefined ? data["skin_integ_icteric"] : <any>null;
            this.skin_integ_marbleness = data["skin_integ_marbleness"] !== undefined ? data["skin_integ_marbleness"] : <any>null;
            this.skin_integ_normal = data["skin_integ_normal"] !== undefined ? data["skin_integ_normal"] : <any>null;
            this.skin_integ_pale = data["skin_integ_pale"] !== undefined ? data["skin_integ_pale"] : <any>null;
            this.skin_integ_profuse = data["skin_integ_profuse"] !== undefined ? data["skin_integ_profuse"] : <any>null;
            this.skin_integ_rashes = data["skin_integ_rashes"] !== undefined ? data["skin_integ_rashes"] : <any>null;
            this.stomach_ascites = data["stomach_ascites"] !== undefined ? data["stomach_ascites"] : <any>null;
            this.stomach_breathing_involved = data["stomach_breathing_involved"] !== undefined ? data["stomach_breathing_involved"] : <any>null;
            this.stomach_breathing_involved_name = data["stomach_breathing_involved_name"] !== undefined ? data["stomach_breathing_involved_name"] : <any>null;
            this.stomach_disklike = data["stomach_disklike"] !== undefined ? data["stomach_disklike"] : <any>null;
            this.stomach_hard = data["stomach_hard"] !== undefined ? data["stomach_hard"] : <any>null;
            this.stomach_infliat = data["stomach_infliat"] !== undefined ? data["stomach_infliat"] : <any>null;
            this.stomach_normal = data["stomach_normal"] !== undefined ? data["stomach_normal"] : <any>null;
            this.stomach_painful = data["stomach_painful"] !== undefined ? data["stomach_painful"] : <any>null;
            this.stomach_peritonit = data["stomach_peritonit"] !== undefined ? data["stomach_peritonit"] : <any>null;
            this.stomach_peritonit_name = data["stomach_peritonit_name"] !== undefined ? data["stomach_peritonit_name"] : <any>null;
            this.stomach_soft = data["stomach_soft"] !== undefined ? data["stomach_soft"] : <any>null;
            this.stomach_text = data["stomach_text"] !== undefined ? data["stomach_text"] : <any>null;
            this.stomach_unpainful = data["stomach_unpainful"] !== undefined ? data["stomach_unpainful"] : <any>null;
            this.tendon_reflexes_id = data["tendon_reflexes_id"] !== undefined ? data["tendon_reflexes_id"] : <any>null;
            this.tendon_reflexes_name = data["tendon_reflexes_name"] !== undefined ? data["tendon_reflexes_name"] : <any>null;
            this.titles = data["titles"] !== undefined ? data["titles"] : <any>null;
            this.titles_text = data["titles_text"] !== undefined ? data["titles_text"] : <any>null;
            this.tongue_clean_furred = data["tongue_clean_furred"] !== undefined ? data["tongue_clean_furred"] : <any>null;
            this.tongue_clean_furred_name = data["tongue_clean_furred_name"] !== undefined ? data["tongue_clean_furred_name"] : <any>null;
            this.tongue_weat_dry = data["tongue_weat_dry"] !== undefined ? data["tongue_weat_dry"] : <any>null;
            this.tongue_weat_dry_name = data["tongue_weat_dry_name"] !== undefined ? data["tongue_weat_dry_name"] : <any>null;
            this.urine_text = data["urine_text"] !== undefined ? data["urine_text"] : <any>null;
            this.verbal = data["verbal"] !== undefined ? data["verbal"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePartDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePartDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ad"] = this.ad !== undefined ? this.ad : <any>null;
        data["addition_objective"] = this.addition_objective !== undefined ? this.addition_objective : <any>null;
        data["admax"] = this.admax !== undefined ? this.admax : <any>null;
        data["adn"] = this.adn !== undefined ? this.adn : <any>null;
        data["alco_breath"] = this.alco_breath !== undefined ? this.alco_breath : <any>null;
        data["alco_emotion_lability"] = this.alco_emotion_lability !== undefined ? this.alco_emotion_lability : <any>null;
        data["alco_inadequate"] = this.alco_inadequate !== undefined ? this.alco_inadequate : <any>null;
        data["alco_romberg_pose"] = this.alco_romberg_pose !== undefined ? this.alco_romberg_pose : <any>null;
        data["alco_shaky_walk"] = this.alco_shaky_walk !== undefined ? this.alco_shaky_walk : <any>null;
        data["alco_speach_behavior"] = this.alco_speach_behavior !== undefined ? this.alco_speach_behavior : <any>null;
        data["almonds_normal_large"] = this.almonds_normal_large !== undefined ? this.almonds_normal_large : <any>null;
        data["almonds_plaque"] = this.almonds_plaque !== undefined ? this.almonds_plaque : <any>null;
        data["behaviour_id"] = this.behaviour_id !== undefined ? this.behaviour_id : <any>null;
        data["behaviour_name"] = this.behaviour_name !== undefined ? this.behaviour_name : <any>null;
        data["bodytemp"] = this.bodytemp !== undefined ? this.bodytemp : <any>null;
        data["breath_absent"] = this.breath_absent !== undefined ? this.breath_absent : <any>null;
        data["breath_bronch"] = this.breath_bronch !== undefined ? this.breath_bronch : <any>null;
        data["breath_evenly"] = this.breath_evenly !== undefined ? this.breath_evenly : <any>null;
        data["breath_hard"] = this.breath_hard !== undefined ? this.breath_hard : <any>null;
        data["breath_puer"] = this.breath_puer !== undefined ? this.breath_puer : <any>null;
        data["breath_text"] = this.breath_text !== undefined ? this.breath_text : <any>null;
        data["breath_vesicul"] = this.breath_vesicul !== undefined ? this.breath_vesicul : <any>null;
        data["breath_weak"] = this.breath_weak !== undefined ? this.breath_weak : <any>null;
        data["card_delivery_id"] = this.card_delivery_id !== undefined ? this.card_delivery_id : <any>null;
        data["chd"] = this.chd !== undefined ? this.chd : <any>null;
        data["chss"] = this.chss !== undefined ? this.chss : <any>null;
        data["conscious_id"] = this.conscious_id !== undefined ? this.conscious_id : <any>null;
        data["conscious_name"] = this.conscious_name !== undefined ? this.conscious_name : <any>null;
        data["diuresis_disuria"] = this.diuresis_disuria !== undefined ? this.diuresis_disuria : <any>null;
        data["diuresis_hematuria"] = this.diuresis_hematuria !== undefined ? this.diuresis_hematuria : <any>null;
        data["diuresis_n"] = this.diuresis_n !== undefined ? this.diuresis_n : <any>null;
        data["diuresis_oliguria"] = this.diuresis_oliguria !== undefined ? this.diuresis_oliguria : <any>null;
        data["dyspeptic_diarrhea"] = this.dyspeptic_diarrhea !== undefined ? this.dyspeptic_diarrhea : <any>null;
        data["dyspeptic_nausea"] = this.dyspeptic_nausea !== undefined ? this.dyspeptic_nausea : <any>null;
        data["dyspeptic_retch"] = this.dyspeptic_retch !== undefined ? this.dyspeptic_retch : <any>null;
        data["dyspeptics_no"] = this.dyspeptics_no !== undefined ? this.dyspeptics_no : <any>null;
        data["dyspnea_id"] = this.dyspnea_id !== undefined ? this.dyspnea_id : <any>null;
        data["dyspnea_name"] = this.dyspnea_name !== undefined ? this.dyspnea_name : <any>null;
        data["excreta"] = this.excreta !== undefined ? this.excreta : <any>null;
        data["excreta_name"] = this.excreta_name !== undefined ? this.excreta_name : <any>null;
        data["excreta_text"] = this.excreta_text !== undefined ? this.excreta_text : <any>null;
        data["eye"] = this.eye !== undefined ? this.eye : <any>null;
        data["general_state_id"] = this.general_state_id !== undefined ? this.general_state_id : <any>null;
        data["general_state_name"] = this.general_state_name !== undefined ? this.general_state_name : <any>null;
        data["glucometry"] = this.glucometry !== undefined ? this.glucometry : <any>null;
        data["heart_noise_id"] = this.heart_noise_id !== undefined ? this.heart_noise_id : <any>null;
        data["heart_noise_name"] = this.heart_noise_name !== undefined ? this.heart_noise_name : <any>null;
        data["heart_pulse_id"] = this.heart_pulse_id !== undefined ? this.heart_pulse_id : <any>null;
        data["heart_pulse_name"] = this.heart_pulse_name !== undefined ? this.heart_pulse_name : <any>null;
        data["heart_rate_id"] = this.heart_rate_id !== undefined ? this.heart_rate_id : <any>null;
        data["heart_rate_name"] = this.heart_rate_name !== undefined ? this.heart_rate_name : <any>null;
        data["heart_tone_id"] = this.heart_tone_id !== undefined ? this.heart_tone_id : <any>null;
        data["heart_tone_name"] = this.heart_tone_name !== undefined ? this.heart_tone_name : <any>null;
        data["heart_tone_noise"] = this.heart_tone_noise !== undefined ? this.heart_tone_noise : <any>null;
        data["is_created"] = this.is_created !== undefined ? this.is_created : <any>null;
        data["lion_tapping_left"] = this.lion_tapping_left !== undefined ? this.lion_tapping_left : <any>null;
        data["lion_tapping_right"] = this.lion_tapping_right !== undefined ? this.lion_tapping_right : <any>null;
        data["liver_normal_large"] = this.liver_normal_large !== undefined ? this.liver_normal_large : <any>null;
        data["liver_ortner"] = this.liver_ortner !== undefined ? this.liver_ortner : <any>null;
        data["liver_size_text"] = this.liver_size_text !== undefined ? this.liver_size_text : <any>null;
        data["lungs_wheezing_id"] = this.lungs_wheezing_id !== undefined ? this.lungs_wheezing_id : <any>null;
        data["lungs_wheezing_text"] = this.lungs_wheezing_text !== undefined ? this.lungs_wheezing_text : <any>null;
        data["lymph_nodes_normal_large"] = this.lymph_nodes_normal_large !== undefined ? this.lymph_nodes_normal_large : <any>null;
        data["lymph_nodes_painful_unpainful"] = this.lymph_nodes_painful_unpainful !== undefined ? this.lymph_nodes_painful_unpainful : <any>null;
        data["lymph_nodes_text"] = this.lymph_nodes_text !== undefined ? this.lymph_nodes_text : <any>null;
        data["meningeal_reflexes"] = this.meningeal_reflexes !== undefined ? this.meningeal_reflexes : <any>null;
        data["motor"] = this.motor !== undefined ? this.motor : <any>null;
        data["multiple_zeva_clean_hyper"] = this.multiple_zeva_clean_hyper !== undefined ? this.multiple_zeva_clean_hyper : <any>null;
        data["pathological_reflexes"] = this.pathological_reflexes !== undefined ? this.pathological_reflexes : <any>null;
        data["penalties_anisocoria"] = this.penalties_anisocoria !== undefined ? this.penalties_anisocoria : <any>null;
        data["penalties_anisocoria_name"] = this.penalties_anisocoria_name !== undefined ? this.penalties_anisocoria_name : <any>null;
        data["penalties_d_s_id"] = this.penalties_d_s_id !== undefined ? this.penalties_d_s_id : <any>null;
        data["penalties_d_s_name"] = this.penalties_d_s_name !== undefined ? this.penalties_d_s_name : <any>null;
        data["penalties_id"] = this.penalties_id !== undefined ? this.penalties_id : <any>null;
        data["penalties_light"] = this.penalties_light !== undefined ? this.penalties_light : <any>null;
        data["penalties_light_name"] = this.penalties_light_name !== undefined ? this.penalties_light_name : <any>null;
        data["penalties_name"] = this.penalties_name !== undefined ? this.penalties_name : <any>null;
        data["penalties_nystagmus"] = this.penalties_nystagmus !== undefined ? this.penalties_nystagmus : <any>null;
        data["penalties_nystagmus_name"] = this.penalties_nystagmus_name !== undefined ? this.penalties_nystagmus_name : <any>null;
        data["perc_lungs_sound_id"] = this.perc_lungs_sound_id !== undefined ? this.perc_lungs_sound_id : <any>null;
        data["perc_lungs_sound_name"] = this.perc_lungs_sound_name !== undefined ? this.perc_lungs_sound_name : <any>null;
        data["perc_lungs_sound_text"] = this.perc_lungs_sound_text !== undefined ? this.perc_lungs_sound_text : <any>null;
        data["post_therapy_hemodynamics"] = this.post_therapy_hemodynamics !== undefined ? this.post_therapy_hemodynamics : <any>null;
        data["ps"] = this.ps !== undefined ? this.ps : <any>null;
        data["pulse_oximetry"] = this.pulse_oximetry !== undefined ? this.pulse_oximetry : <any>null;
        data["reflexes_d_s_id"] = this.reflexes_d_s_id !== undefined ? this.reflexes_d_s_id : <any>null;
        data["reflexes_d_s_name"] = this.reflexes_d_s_name !== undefined ? this.reflexes_d_s_name : <any>null;
        data["reflexes_name"] = this.reflexes_name !== undefined ? this.reflexes_name : <any>null;
        data["skin_integ_acrosian"] = this.skin_integ_acrosian !== undefined ? this.skin_integ_acrosian : <any>null;
        data["skin_integ_cyanotic"] = this.skin_integ_cyanotic !== undefined ? this.skin_integ_cyanotic : <any>null;
        data["skin_integ_dry"] = this.skin_integ_dry !== undefined ? this.skin_integ_dry : <any>null;
        data["skin_integ_earthy"] = this.skin_integ_earthy !== undefined ? this.skin_integ_earthy : <any>null;
        data["skin_integ_hyperemetic"] = this.skin_integ_hyperemetic !== undefined ? this.skin_integ_hyperemetic : <any>null;
        data["skin_integ_icteric"] = this.skin_integ_icteric !== undefined ? this.skin_integ_icteric : <any>null;
        data["skin_integ_marbleness"] = this.skin_integ_marbleness !== undefined ? this.skin_integ_marbleness : <any>null;
        data["skin_integ_normal"] = this.skin_integ_normal !== undefined ? this.skin_integ_normal : <any>null;
        data["skin_integ_pale"] = this.skin_integ_pale !== undefined ? this.skin_integ_pale : <any>null;
        data["skin_integ_profuse"] = this.skin_integ_profuse !== undefined ? this.skin_integ_profuse : <any>null;
        data["skin_integ_rashes"] = this.skin_integ_rashes !== undefined ? this.skin_integ_rashes : <any>null;
        data["stomach_ascites"] = this.stomach_ascites !== undefined ? this.stomach_ascites : <any>null;
        data["stomach_breathing_involved"] = this.stomach_breathing_involved !== undefined ? this.stomach_breathing_involved : <any>null;
        data["stomach_breathing_involved_name"] = this.stomach_breathing_involved_name !== undefined ? this.stomach_breathing_involved_name : <any>null;
        data["stomach_disklike"] = this.stomach_disklike !== undefined ? this.stomach_disklike : <any>null;
        data["stomach_hard"] = this.stomach_hard !== undefined ? this.stomach_hard : <any>null;
        data["stomach_infliat"] = this.stomach_infliat !== undefined ? this.stomach_infliat : <any>null;
        data["stomach_normal"] = this.stomach_normal !== undefined ? this.stomach_normal : <any>null;
        data["stomach_painful"] = this.stomach_painful !== undefined ? this.stomach_painful : <any>null;
        data["stomach_peritonit"] = this.stomach_peritonit !== undefined ? this.stomach_peritonit : <any>null;
        data["stomach_peritonit_name"] = this.stomach_peritonit_name !== undefined ? this.stomach_peritonit_name : <any>null;
        data["stomach_soft"] = this.stomach_soft !== undefined ? this.stomach_soft : <any>null;
        data["stomach_text"] = this.stomach_text !== undefined ? this.stomach_text : <any>null;
        data["stomach_unpainful"] = this.stomach_unpainful !== undefined ? this.stomach_unpainful : <any>null;
        data["tendon_reflexes_id"] = this.tendon_reflexes_id !== undefined ? this.tendon_reflexes_id : <any>null;
        data["tendon_reflexes_name"] = this.tendon_reflexes_name !== undefined ? this.tendon_reflexes_name : <any>null;
        data["titles"] = this.titles !== undefined ? this.titles : <any>null;
        data["titles_text"] = this.titles_text !== undefined ? this.titles_text : <any>null;
        data["tongue_clean_furred"] = this.tongue_clean_furred !== undefined ? this.tongue_clean_furred : <any>null;
        data["tongue_clean_furred_name"] = this.tongue_clean_furred_name !== undefined ? this.tongue_clean_furred_name : <any>null;
        data["tongue_weat_dry"] = this.tongue_weat_dry !== undefined ? this.tongue_weat_dry : <any>null;
        data["tongue_weat_dry_name"] = this.tongue_weat_dry_name !== undefined ? this.tongue_weat_dry_name : <any>null;
        data["urine_text"] = this.urine_text !== undefined ? this.urine_text : <any>null;
        data["verbal"] = this.verbal !== undefined ? this.verbal : <any>null;
        return data; 
    }
}

export interface ICardObjectivePartDtoFLAT {
    ad?: string | null;
    addition_objective?: string | null;
    admax?: string | null;
    adn?: string | null;
    alco_breath?: boolean | null;
    alco_emotion_lability?: boolean | null;
    alco_inadequate?: boolean | null;
    alco_romberg_pose?: boolean | null;
    alco_shaky_walk?: boolean | null;
    alco_speach_behavior?: boolean | null;
    almonds_normal_large?: number | null;
    almonds_plaque?: boolean | null;
    behaviour_id?: number | null;
    behaviour_name?: string | null;
    bodytemp?: string | null;
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    card_delivery_id?: number | null;
    chd?: string | null;
    chss?: string | null;
    conscious_id?: number | null;
    conscious_name?: string | null;
    diuresis_disuria?: boolean | null;
    diuresis_hematuria?: boolean | null;
    diuresis_n?: boolean | null;
    diuresis_oliguria?: boolean | null;
    dyspeptic_diarrhea?: boolean | null;
    dyspeptic_nausea?: boolean | null;
    dyspeptic_retch?: boolean | null;
    dyspeptics_no?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;
    excreta?: number | null;
    excreta_name?: string | null;
    excreta_text?: string | null;
    eye?: number | null;
    general_state_id?: number | null;
    general_state_name?: string | null;
    glucometry?: string | null;
    heart_noise_id?: number | null;
    heart_noise_name?: string | null;
    heart_pulse_id?: number | null;
    heart_pulse_name?: string | null;
    heart_rate_id?: number | null;
    heart_rate_name?: string | null;
    heart_tone_id?: number | null;
    heart_tone_name?: string | null;
    heart_tone_noise?: boolean | null;
    is_created?: boolean | null;
    lion_tapping_left?: boolean | null;
    lion_tapping_right?: boolean | null;
    liver_normal_large?: number | null;
    liver_ortner?: boolean | null;
    liver_size_text?: string | null;
    lungs_wheezing_id?: number | null;
    lungs_wheezing_text?: string | null;
    lymph_nodes_normal_large?: number | null;
    lymph_nodes_painful_unpainful?: number | null;
    lymph_nodes_text?: string | null;
    meningeal_reflexes?: boolean | null;
    motor?: number | null;
    multiple_zeva_clean_hyper?: number | null;
    pathological_reflexes?: boolean | null;
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;
    perc_lungs_sound_id?: number | null;
    perc_lungs_sound_name?: string | null;
    perc_lungs_sound_text?: string | null;
    post_therapy_hemodynamics?: string | null;
    ps?: string | null;
    pulse_oximetry?: string | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    skin_integ_acrosian?: boolean | null;
    skin_integ_cyanotic?: boolean | null;
    skin_integ_dry?: boolean | null;
    skin_integ_earthy?: boolean | null;
    skin_integ_hyperemetic?: boolean | null;
    skin_integ_icteric?: boolean | null;
    skin_integ_marbleness?: boolean | null;
    skin_integ_normal?: boolean | null;
    skin_integ_pale?: boolean | null;
    skin_integ_profuse?: boolean | null;
    skin_integ_rashes?: boolean | null;
    stomach_ascites?: boolean | null;
    stomach_breathing_involved?: number | null;
    stomach_breathing_involved_name?: string | null;
    stomach_disklike?: boolean | null;
    stomach_hard?: boolean | null;
    stomach_infliat?: boolean | null;
    stomach_normal?: boolean | null;
    stomach_painful?: boolean | null;
    stomach_peritonit?: number | null;
    stomach_peritonit_name?: string | null;
    stomach_soft?: boolean | null;
    stomach_text?: string | null;
    stomach_unpainful?: boolean | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;
    titles?: boolean | null;
    titles_text?: string | null;
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;
    urine_text?: string | null;
    verbal?: number | null;
}

export class UploadFileForm implements IUploadFileForm {
    code?: string | null;
    file?: any | null;
    format?: number | null;
    group_code?: string | null;
    id?: number | null;
    name?: string | null;
    nn?: number | null;
    script?: string | null;
    sub_id?: number | null;
    type?: number | null;

    constructor(data?: IUploadFileForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.format = data["format"] !== undefined ? data["format"] : <any>null;
            this.group_code = data["group_code"] !== undefined ? data["group_code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nn = data["nn"] !== undefined ? data["nn"] : <any>null;
            this.script = data["script"] !== undefined ? data["script"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): UploadFileForm {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["format"] = this.format !== undefined ? this.format : <any>null;
        data["group_code"] = this.group_code !== undefined ? this.group_code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nn"] = this.nn !== undefined ? this.nn : <any>null;
        data["script"] = this.script !== undefined ? this.script : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IUploadFileForm {
    code?: string | null;
    file?: any | null;
    format?: number | null;
    group_code?: string | null;
    id?: number | null;
    name?: string | null;
    nn?: number | null;
    script?: string | null;
    sub_id?: number | null;
    type?: number | null;
}

export class CardObjectiveReflexesDto implements ICardObjectiveReflexesDto {
    meningeal_reflexes?: boolean | null;
    pathological_reflexes?: boolean | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;

    constructor(data?: ICardObjectiveReflexesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.meningeal_reflexes = data["meningeal_reflexes"] !== undefined ? data["meningeal_reflexes"] : <any>null;
            this.pathological_reflexes = data["pathological_reflexes"] !== undefined ? data["pathological_reflexes"] : <any>null;
            this.reflexes_d_s_id = data["reflexes_d_s_id"] !== undefined ? data["reflexes_d_s_id"] : <any>null;
            this.reflexes_d_s_name = data["reflexes_d_s_name"] !== undefined ? data["reflexes_d_s_name"] : <any>null;
            this.reflexes_name = data["reflexes_name"] !== undefined ? data["reflexes_name"] : <any>null;
            this.tendon_reflexes_id = data["tendon_reflexes_id"] !== undefined ? data["tendon_reflexes_id"] : <any>null;
            this.tendon_reflexes_name = data["tendon_reflexes_name"] !== undefined ? data["tendon_reflexes_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveReflexesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveReflexesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meningeal_reflexes"] = this.meningeal_reflexes !== undefined ? this.meningeal_reflexes : <any>null;
        data["pathological_reflexes"] = this.pathological_reflexes !== undefined ? this.pathological_reflexes : <any>null;
        data["reflexes_d_s_id"] = this.reflexes_d_s_id !== undefined ? this.reflexes_d_s_id : <any>null;
        data["reflexes_d_s_name"] = this.reflexes_d_s_name !== undefined ? this.reflexes_d_s_name : <any>null;
        data["reflexes_name"] = this.reflexes_name !== undefined ? this.reflexes_name : <any>null;
        data["tendon_reflexes_id"] = this.tendon_reflexes_id !== undefined ? this.tendon_reflexes_id : <any>null;
        data["tendon_reflexes_name"] = this.tendon_reflexes_name !== undefined ? this.tendon_reflexes_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveReflexesDto {
    meningeal_reflexes?: boolean | null;
    pathological_reflexes?: boolean | null;
    reflexes_d_s_id?: number | null;
    reflexes_d_s_name?: string | null;
    reflexes_name?: string | null;
    tendon_reflexes_id?: number | null;
    tendon_reflexes_name?: string | null;
}

export class BrigadeType implements IBrigadeType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IBrigadeType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeType {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class ListContainerOfSkillBean implements IListContainerOfSkillBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfSkillBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfSkillBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfSkillBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfSkillBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class URI implements IURI {
    absolute?: boolean | null;
    authority?: string | null;
    fragment?: string | null;
    host?: string | null;
    opaque?: boolean | null;
    path?: string | null;
    port?: number | null;
    query?: string | null;
    rawAuthority?: string | null;
    rawFragment?: string | null;
    rawPath?: string | null;
    rawQuery?: string | null;
    rawSchemeSpecificPart?: string | null;
    rawUserInfo?: string | null;
    scheme?: string | null;
    schemeSpecificPart?: string | null;
    userInfo?: string | null;

    constructor(data?: IURI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.absolute = data["absolute"] !== undefined ? data["absolute"] : <any>null;
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
            this.fragment = data["fragment"] !== undefined ? data["fragment"] : <any>null;
            this.host = data["host"] !== undefined ? data["host"] : <any>null;
            this.opaque = data["opaque"] !== undefined ? data["opaque"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.port = data["port"] !== undefined ? data["port"] : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.rawAuthority = data["rawAuthority"] !== undefined ? data["rawAuthority"] : <any>null;
            this.rawFragment = data["rawFragment"] !== undefined ? data["rawFragment"] : <any>null;
            this.rawPath = data["rawPath"] !== undefined ? data["rawPath"] : <any>null;
            this.rawQuery = data["rawQuery"] !== undefined ? data["rawQuery"] : <any>null;
            this.rawSchemeSpecificPart = data["rawSchemeSpecificPart"] !== undefined ? data["rawSchemeSpecificPart"] : <any>null;
            this.rawUserInfo = data["rawUserInfo"] !== undefined ? data["rawUserInfo"] : <any>null;
            this.scheme = data["scheme"] !== undefined ? data["scheme"] : <any>null;
            this.schemeSpecificPart = data["schemeSpecificPart"] !== undefined ? data["schemeSpecificPart"] : <any>null;
            this.userInfo = data["userInfo"] !== undefined ? data["userInfo"] : <any>null;
        }
    }

    static fromJS(data: any): URI {
        data = typeof data === 'object' ? data : {};
        let result = new URI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absolute"] = this.absolute !== undefined ? this.absolute : <any>null;
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        data["fragment"] = this.fragment !== undefined ? this.fragment : <any>null;
        data["host"] = this.host !== undefined ? this.host : <any>null;
        data["opaque"] = this.opaque !== undefined ? this.opaque : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["port"] = this.port !== undefined ? this.port : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["rawAuthority"] = this.rawAuthority !== undefined ? this.rawAuthority : <any>null;
        data["rawFragment"] = this.rawFragment !== undefined ? this.rawFragment : <any>null;
        data["rawPath"] = this.rawPath !== undefined ? this.rawPath : <any>null;
        data["rawQuery"] = this.rawQuery !== undefined ? this.rawQuery : <any>null;
        data["rawSchemeSpecificPart"] = this.rawSchemeSpecificPart !== undefined ? this.rawSchemeSpecificPart : <any>null;
        data["rawUserInfo"] = this.rawUserInfo !== undefined ? this.rawUserInfo : <any>null;
        data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
        data["schemeSpecificPart"] = this.schemeSpecificPart !== undefined ? this.schemeSpecificPart : <any>null;
        data["userInfo"] = this.userInfo !== undefined ? this.userInfo : <any>null;
        return data; 
    }
}

export interface IURI {
    absolute?: boolean | null;
    authority?: string | null;
    fragment?: string | null;
    host?: string | null;
    opaque?: boolean | null;
    path?: string | null;
    port?: number | null;
    query?: string | null;
    rawAuthority?: string | null;
    rawFragment?: string | null;
    rawPath?: string | null;
    rawQuery?: string | null;
    rawSchemeSpecificPart?: string | null;
    rawUserInfo?: string | null;
    scheme?: string | null;
    schemeSpecificPart?: string | null;
    userInfo?: string | null;
}

export class URL implements IURL {
    authority?: string | null;
    content?: any | null;
    defaultPort?: number | null;
    file?: string | null;
    host?: string | null;
    path?: string | null;
    port?: number | null;
    protocol?: string | null;
    query?: string | null;
    ref?: string | null;
    userInfo?: string | null;

    constructor(data?: IURL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
            this.content = data["content"] !== undefined ? data["content"] : <any>null;
            this.defaultPort = data["defaultPort"] !== undefined ? data["defaultPort"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.host = data["host"] !== undefined ? data["host"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.port = data["port"] !== undefined ? data["port"] : <any>null;
            this.protocol = data["protocol"] !== undefined ? data["protocol"] : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.ref = data["ref"] !== undefined ? data["ref"] : <any>null;
            this.userInfo = data["userInfo"] !== undefined ? data["userInfo"] : <any>null;
        }
    }

    static fromJS(data: any): URL {
        data = typeof data === 'object' ? data : {};
        let result = new URL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        data["content"] = this.content !== undefined ? this.content : <any>null;
        data["defaultPort"] = this.defaultPort !== undefined ? this.defaultPort : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["host"] = this.host !== undefined ? this.host : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["port"] = this.port !== undefined ? this.port : <any>null;
        data["protocol"] = this.protocol !== undefined ? this.protocol : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["ref"] = this.ref !== undefined ? this.ref : <any>null;
        data["userInfo"] = this.userInfo !== undefined ? this.userInfo : <any>null;
        return data; 
    }
}

export interface IURL {
    authority?: string | null;
    content?: any | null;
    defaultPort?: number | null;
    file?: string | null;
    host?: string | null;
    path?: string | null;
    port?: number | null;
    protocol?: string | null;
    query?: string | null;
    ref?: string | null;
    userInfo?: string | null;
}

export class ListContainerOfReferenceTypeBean implements IListContainerOfReferenceTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfReferenceTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfReferenceTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfReferenceTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfReferenceTypeBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class Chat implements IChat {
    archive?: boolean | null;
    chatMessage?: ChatMessage | null;
    creator?: ChatUser | null;
    date?: Date | null;
    id?: number | null;
    name?: string | null;
    online?: boolean | null;
    position?: string | null;
    subdivision_name?: string | null;
    type?: ChatType | null;
    unread_count?: number | null;
    users?: ChatUser[] | null;

    constructor(data?: IChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archive = data["archive"] !== undefined ? data["archive"] : <any>null;
            this.chatMessage = data["chatMessage"] ? ChatMessage.fromJS(data["chatMessage"]) : <any>null;
            this.creator = data["creator"] ? ChatUser.fromJS(data["creator"]) : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.position = data["position"] !== undefined ? data["position"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.unread_count = data["unread_count"] !== undefined ? data["unread_count"] : <any>null;
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(ChatUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Chat {
        data = typeof data === 'object' ? data : {};
        let result = new Chat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archive"] = this.archive !== undefined ? this.archive : <any>null;
        data["chatMessage"] = this.chatMessage ? this.chatMessage.toJSON() : <any>null;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["position"] = this.position !== undefined ? this.position : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["unread_count"] = this.unread_count !== undefined ? this.unread_count : <any>null;
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChat {
    archive?: boolean | null;
    chatMessage?: ChatMessage | null;
    creator?: ChatUser | null;
    date?: Date | null;
    id?: number | null;
    name?: string | null;
    online?: boolean | null;
    position?: string | null;
    subdivision_name?: string | null;
    type?: ChatType | null;
    unread_count?: number | null;
    users?: ChatUser[] | null;
}

export class CardResultDeathDto implements ICardResultDeathDto {
    time?: Date | null;

    constructor(data?: ICardResultDeathDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CardResultDeathDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultDeathDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        return data; 
    }
}

export interface ICardResultDeathDto {
    time?: Date | null;
}

export class ListDtoOfPerformerDto implements IListDtoOfPerformerDto {
    list?: PerformerDto[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfPerformerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(PerformerDto.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfPerformerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfPerformerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfPerformerDto {
    list?: PerformerDto[] | null;
    size?: number | null;
    total?: number | null;
}

export class DistrictBean implements IDistrictBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: IDistrictBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): DistrictBean {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IDistrictBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class AndyTreeNode implements IAndyTreeNode {
    children?: AndyTreeNode[] | null;
    data?: any | null;

    constructor(data?: IAndyTreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(AndyTreeNode.fromJS(item));
            }
            this.data = data["data"] !== undefined ? data["data"] : <any>null;
        }
    }

    static fromJS(data: any): AndyTreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new AndyTreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["data"] = this.data !== undefined ? this.data : <any>null;
        return data; 
    }
}

export interface IAndyTreeNode {
    children?: AndyTreeNode[] | null;
    data?: any | null;
}

export class ReferenceDto implements IReferenceDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IReferenceDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class DocumentItemDto implements IDocumentItemDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    performer_id?: number | null;
    series_number?: number | null;
    type?: number | null;

    constructor(data?: IDocumentItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.document_id = data["document_id"] !== undefined ? data["document_id"] : <any>null;
            this.document_name = data["document_name"] !== undefined ? data["document_name"] : <any>null;
            this.drug_id = data["drug_id"] !== undefined ? data["drug_id"] : <any>null;
            this.expiry_date = data["expiry_date"] ? new Date(data["expiry_date"].toString()) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.inner_amount = data["inner_amount"] !== undefined ? data["inner_amount"] : <any>null;
            this.is_reusable = data["is_reusable"] !== undefined ? data["is_reusable"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.minimum = data["minimum"] !== undefined ? data["minimum"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nomenclature_id = data["nomenclature_id"] !== undefined ? data["nomenclature_id"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.series_number = data["series_number"] !== undefined ? data["series_number"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["document_id"] = this.document_id !== undefined ? this.document_id : <any>null;
        data["document_name"] = this.document_name !== undefined ? this.document_name : <any>null;
        data["drug_id"] = this.drug_id !== undefined ? this.drug_id : <any>null;
        data["expiry_date"] = this.expiry_date ? this.expiry_date.toISOString() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["inner_amount"] = this.inner_amount !== undefined ? this.inner_amount : <any>null;
        data["is_reusable"] = this.is_reusable !== undefined ? this.is_reusable : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["minimum"] = this.minimum !== undefined ? this.minimum : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nomenclature_id"] = this.nomenclature_id !== undefined ? this.nomenclature_id : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["series_number"] = this.series_number !== undefined ? this.series_number : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IDocumentItemDto {
    amount?: number | null;
    code?: string | null;
    company?: string | null;
    document_id?: number | null;
    document_name?: string | null;
    drug_id?: number | null;
    expiry_date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    inner_amount?: number | null;
    is_reusable?: boolean | null;
    matrix_id?: number | null;
    minimum?: number | null;
    name?: string | null;
    nomenclature_id?: number | null;
    owner_id?: number | null;
    performer_id?: number | null;
    series_number?: number | null;
    type?: number | null;
}

export class Table implements ITable {
    code?: string | null;
    items?: Field[] | null;
    text?: string | null;
    type?: TableType | null;

    constructor(data?: ITable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Field.fromJS(item));
            }
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Table {
        data = typeof data === 'object' ? data : {};
        let result = new Table();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface ITable {
    code?: string | null;
    items?: Field[] | null;
    text?: string | null;
    type?: TableType | null;
}

export class LoginInfo implements ILoginInfo {
    authorities?: any | null;
    name?: string | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    token?: string | null;

    constructor(data?: ILoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authorities = data["authorities"] !== undefined ? data["authorities"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.subdivisionName = data["subdivisionName"] !== undefined ? data["subdivisionName"] : <any>null;
            this.token = data["token"] !== undefined ? data["token"] : <any>null;
        }
    }

    static fromJS(data: any): LoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorities"] = this.authorities !== undefined ? this.authorities : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["subdivisionName"] = this.subdivisionName !== undefined ? this.subdivisionName : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface ILoginInfo {
    authorities?: any | null;
    name?: string | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    token?: string | null;
}

export class PairOfPerformerBeanAndListOfMapOfstringAndobject implements IPairOfPerformerBeanAndListOfMapOfstringAndobject {
    first?: PerformerBean | null;
    second?: { [key: string] : any; }[] | null;

    constructor(data?: IPairOfPerformerBeanAndListOfMapOfstringAndobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? PerformerBean.fromJS(data["first"]) : <any>null;
            if (data["second"] && data["second"].constructor === Array) {
                this.second = [];
                for (let item of data["second"])
                    this.second.push(item);
            }
        }
    }

    static fromJS(data: any): PairOfPerformerBeanAndListOfMapOfstringAndobject {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfPerformerBeanAndListOfMapOfstringAndobject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        if (this.second && this.second.constructor === Array) {
            data["second"] = [];
            for (let item of this.second)
                data["second"].push(item);
        }
        return data; 
    }
}

export interface IPairOfPerformerBeanAndListOfMapOfstringAndobject {
    first?: PerformerBean | null;
    second?: { [key: string] : any; }[] | null;
}

export class CallDto implements ICallDto {
    address?: CallFiasAddressDto | null;
    declarant?: CallDeclarantPartDto | null;
    general?: CallGeneralPartDto | null;
    patients?: CallPatientPartDto[] | null;
    similars?: string[] | null;

    constructor(data?: ICallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? CallFiasAddressDto.fromJS(data["address"]) : <any>null;
            this.declarant = data["declarant"] ? CallDeclarantPartDto.fromJS(data["declarant"]) : <any>null;
            this.general = data["general"] ? CallGeneralPartDto.fromJS(data["general"]) : <any>null;
            if (data["patients"] && data["patients"].constructor === Array) {
                this.patients = [];
                for (let item of data["patients"])
                    this.patients.push(CallPatientPartDto.fromJS(item));
            }
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
        }
    }

    static fromJS(data: any): CallDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["declarant"] = this.declarant ? this.declarant.toJSON() : <any>null;
        data["general"] = this.general ? this.general.toJSON() : <any>null;
        if (this.patients && this.patients.constructor === Array) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        return data; 
    }
}

export interface ICallDto {
    address?: CallFiasAddressDto | null;
    declarant?: CallDeclarantPartDto | null;
    general?: CallGeneralPartDto | null;
    patients?: CallPatientPartDto[] | null;
    similars?: string[] | null;
}

export class CardResultBean implements ICardResultBean {
    /** Тип несчастного случая */
    accidentType?: number | null;
    /** Дата визита */
    activeVisitDate?: Date | null;
    /** Визит */
    activeVisitFK?: ReferenceTypeBean | null;
    /** Продолжительность визита */
    activeVisitHours?: number | null;
    /** Тип визита */
    activeVisitType?: number | null;
    /** Id результата помощи */
    assistanceResultId?: number | null;
    /** Бинты */
    bandages?: number | null;
    /** Задержка бригады */
    brigadeDelay?: boolean | null;
    /** Задержка бригады: комментарий */
    brigadeDelayText?: string | null;
    /** Тип задержки бригады */
    brigadeDelayType?: number | null;
    /** Катетеры */
    catheters?: number | null;
    /** Комментарии */
    comments?: string | null;
    /** Осложнения */
    complicationFK?: ClassMkbBean | null;
    /** Сопутствующий диагноз */
    concomitantDiagnosisFK?: ClassMkbBean | null;
    /** Название сопутствующего диагноза */
    concomitantDiagnosisName?: string | null;
    /** Состояние */
    condition?: number | null;
    /** Смерть */
    deathFK?: ClassMkbBean | null;
    /** Время смерти */
    deathTime?: Date | null;
    /** ЭКГ: ЧСС */
    ekgChSS?: number | null;
    /** ЭКГ: ЧСС после оказания МП */
    ekgChSSAfter?: number | null;
    /** ЭКГ: комментарий */
    ekgComments?: string | null;
    /** ЭКГ: комментарий после оказания МП */
    ekgCommentsAfter?: string | null;
    /** ЭКГ: ритм */
    ekgRhytm?: string | null;
    /** ЭКГ: ритм после оказания МП */
    ekgRhytmAfter?: string | null;
    /** Причина неудачи */
    failReasonText?: string | null;
    /** Осложнения при госпитализации */
    hospComplications?: boolean | null;
    /** Осложнения при госпитализации: комментарий */
    hospComplicationsText?: string | null;
    /** Больница отправления */
    hospFromFK?: SubdivisionBean | null;
    /** Причина госпитализации */
    hospReason?: number | null;
    /** Больница прибытия */
    hospToFK?: SubdivisionBean | null;
    id?: number | null;
    /** Нелегальные действия: комментарий */
    illegalActionText?: string | null;
    /** Нелегальные действия */
    illegalActions?: boolean | null;
    illegalActionsType?: number | null;
    /** Инцидент */
    incidentFK?: ReferenceTypeBean | null;
    /** Интоксикация */
    intoxicationFK?: ReferenceTypeBean | null;
    /** Тип интоксикации */
    intoxicationType?: number | null;
    /** Признак создания */
    isCreated?: boolean | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Артериальное давление на месте */
    localAd?: string | null;
    /** Частота дыхания на месте */
    localChd?: string | null;
    /** ЧСС на месте */
    localChss?: string | null;
    /** Глюкометрия на месте */
    localGlucometry?: string | null;
    /** Пульс на месте */
    localPulse?: string | null;
    /** Пульсоксиметрия на месту */
    localPulseOximetry?: string | null;
    /** Температура на месте */
    localTemperature?: string | null;
    /** Рабочее артериальное давление на месте */
    localWorkAd?: string | null;
    /** Id основного диагноза */
    mainDiagnosisId?: number | null;
    /** Название сновного диагноза */
    mainDiagnosisName?: string | null;
    /** Классификация МКБ */
    mkbFK?: ClassMkbBean | null;
    /** Причина неоказания помощи */
    notHelpReasonType?: number | null;
    /** Другие материалы */
    otherMaterials?: string | null;
    /** Тип причины */
    reasonType?: number | null;
    /** Причина результата */
    resultCauseFK?: ReferenceTypeBean | null;
    /** Результат */
    resultFK?: ReferenceTypeBean | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Шприцы */
    syringes?: number | null;
    /** Бригада трансфера пациента */
    transferPatientBrigade?: string | null;
    /** Дата трансфера пациента */
    transferPatientDate?: Date | null;
    /** Системы переливания */
    transfusionSystem?: number | null;
    /** Артериальное давление при транспортировке */
    transportAd?: string | null;
    /** Частота дыхания при транспортировке */
    transportChd?: string | null;
    /** ЧСС при транспортировке */
    transportChss?: string | null;
    /** Глюкометрия при транспортировке */
    transportGlucometry?: string | null;
    /** Оксиметрия пульса при транспортировке */
    transportOximetry?: string | null;
    /** Пульс при транспортировке */
    transportPulse?: string | null;
    /** Температура при транспортировке */
    transportTemperature?: string | null;
    /** Рабочее артериальное давление при транспортировке */
    transportWorkAd?: string | null;
    /** Транспортировка */
    transportationFK?: ReferenceTypeBean | null;
    /** Метод транспортировки */
    transportationMethodFK?: ReferenceTypeBean | null;
    /** Дата транспортировки */
    transportingDate?: Date | null;
    /** Тип транспортировки */
    transportingType?: number | null;

    constructor(data?: ICardResultBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accidentType = data["accidentType"] !== undefined ? data["accidentType"] : <any>null;
            this.activeVisitDate = data["activeVisitDate"] ? new Date(data["activeVisitDate"].toString()) : <any>null;
            this.activeVisitFK = data["activeVisitFK"] ? ReferenceTypeBean.fromJS(data["activeVisitFK"]) : <any>null;
            this.activeVisitHours = data["activeVisitHours"] !== undefined ? data["activeVisitHours"] : <any>null;
            this.activeVisitType = data["activeVisitType"] !== undefined ? data["activeVisitType"] : <any>null;
            this.assistanceResultId = data["assistanceResultId"] !== undefined ? data["assistanceResultId"] : <any>null;
            this.bandages = data["bandages"] !== undefined ? data["bandages"] : <any>null;
            this.brigadeDelay = data["brigadeDelay"] !== undefined ? data["brigadeDelay"] : <any>null;
            this.brigadeDelayText = data["brigadeDelayText"] !== undefined ? data["brigadeDelayText"] : <any>null;
            this.brigadeDelayType = data["brigadeDelayType"] !== undefined ? data["brigadeDelayType"] : <any>null;
            this.catheters = data["catheters"] !== undefined ? data["catheters"] : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.complicationFK = data["complicationFK"] ? ClassMkbBean.fromJS(data["complicationFK"]) : <any>null;
            this.concomitantDiagnosisFK = data["concomitantDiagnosisFK"] ? ClassMkbBean.fromJS(data["concomitantDiagnosisFK"]) : <any>null;
            this.concomitantDiagnosisName = data["concomitantDiagnosisName"] !== undefined ? data["concomitantDiagnosisName"] : <any>null;
            this.condition = data["condition"] !== undefined ? data["condition"] : <any>null;
            this.deathFK = data["deathFK"] ? ClassMkbBean.fromJS(data["deathFK"]) : <any>null;
            this.deathTime = data["deathTime"] ? new Date(data["deathTime"].toString()) : <any>null;
            this.ekgChSS = data["ekgChSS"] !== undefined ? data["ekgChSS"] : <any>null;
            this.ekgChSSAfter = data["ekgChSSAfter"] !== undefined ? data["ekgChSSAfter"] : <any>null;
            this.ekgComments = data["ekgComments"] !== undefined ? data["ekgComments"] : <any>null;
            this.ekgCommentsAfter = data["ekgCommentsAfter"] !== undefined ? data["ekgCommentsAfter"] : <any>null;
            this.ekgRhytm = data["ekgRhytm"] !== undefined ? data["ekgRhytm"] : <any>null;
            this.ekgRhytmAfter = data["ekgRhytmAfter"] !== undefined ? data["ekgRhytmAfter"] : <any>null;
            this.failReasonText = data["failReasonText"] !== undefined ? data["failReasonText"] : <any>null;
            this.hospComplications = data["hospComplications"] !== undefined ? data["hospComplications"] : <any>null;
            this.hospComplicationsText = data["hospComplicationsText"] !== undefined ? data["hospComplicationsText"] : <any>null;
            this.hospFromFK = data["hospFromFK"] ? SubdivisionBean.fromJS(data["hospFromFK"]) : <any>null;
            this.hospReason = data["hospReason"] !== undefined ? data["hospReason"] : <any>null;
            this.hospToFK = data["hospToFK"] ? SubdivisionBean.fromJS(data["hospToFK"]) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.illegalActionText = data["illegalActionText"] !== undefined ? data["illegalActionText"] : <any>null;
            this.illegalActions = data["illegalActions"] !== undefined ? data["illegalActions"] : <any>null;
            this.illegalActionsType = data["illegalActionsType"] !== undefined ? data["illegalActionsType"] : <any>null;
            this.incidentFK = data["incidentFK"] ? ReferenceTypeBean.fromJS(data["incidentFK"]) : <any>null;
            this.intoxicationFK = data["intoxicationFK"] ? ReferenceTypeBean.fromJS(data["intoxicationFK"]) : <any>null;
            this.intoxicationType = data["intoxicationType"] !== undefined ? data["intoxicationType"] : <any>null;
            this.isCreated = data["isCreated"] !== undefined ? data["isCreated"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.localAd = data["localAd"] !== undefined ? data["localAd"] : <any>null;
            this.localChd = data["localChd"] !== undefined ? data["localChd"] : <any>null;
            this.localChss = data["localChss"] !== undefined ? data["localChss"] : <any>null;
            this.localGlucometry = data["localGlucometry"] !== undefined ? data["localGlucometry"] : <any>null;
            this.localPulse = data["localPulse"] !== undefined ? data["localPulse"] : <any>null;
            this.localPulseOximetry = data["localPulseOximetry"] !== undefined ? data["localPulseOximetry"] : <any>null;
            this.localTemperature = data["localTemperature"] !== undefined ? data["localTemperature"] : <any>null;
            this.localWorkAd = data["localWorkAd"] !== undefined ? data["localWorkAd"] : <any>null;
            this.mainDiagnosisId = data["mainDiagnosisId"] !== undefined ? data["mainDiagnosisId"] : <any>null;
            this.mainDiagnosisName = data["mainDiagnosisName"] !== undefined ? data["mainDiagnosisName"] : <any>null;
            this.mkbFK = data["mkbFK"] ? ClassMkbBean.fromJS(data["mkbFK"]) : <any>null;
            this.notHelpReasonType = data["notHelpReasonType"] !== undefined ? data["notHelpReasonType"] : <any>null;
            this.otherMaterials = data["otherMaterials"] !== undefined ? data["otherMaterials"] : <any>null;
            this.reasonType = data["reasonType"] !== undefined ? data["reasonType"] : <any>null;
            this.resultCauseFK = data["resultCauseFK"] ? ReferenceTypeBean.fromJS(data["resultCauseFK"]) : <any>null;
            this.resultFK = data["resultFK"] ? ReferenceTypeBean.fromJS(data["resultFK"]) : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.syringes = data["syringes"] !== undefined ? data["syringes"] : <any>null;
            this.transferPatientBrigade = data["transferPatientBrigade"] !== undefined ? data["transferPatientBrigade"] : <any>null;
            this.transferPatientDate = data["transferPatientDate"] ? new Date(data["transferPatientDate"].toString()) : <any>null;
            this.transfusionSystem = data["transfusionSystem"] !== undefined ? data["transfusionSystem"] : <any>null;
            this.transportAd = data["transportAd"] !== undefined ? data["transportAd"] : <any>null;
            this.transportChd = data["transportChd"] !== undefined ? data["transportChd"] : <any>null;
            this.transportChss = data["transportChss"] !== undefined ? data["transportChss"] : <any>null;
            this.transportGlucometry = data["transportGlucometry"] !== undefined ? data["transportGlucometry"] : <any>null;
            this.transportOximetry = data["transportOximetry"] !== undefined ? data["transportOximetry"] : <any>null;
            this.transportPulse = data["transportPulse"] !== undefined ? data["transportPulse"] : <any>null;
            this.transportTemperature = data["transportTemperature"] !== undefined ? data["transportTemperature"] : <any>null;
            this.transportWorkAd = data["transportWorkAd"] !== undefined ? data["transportWorkAd"] : <any>null;
            this.transportationFK = data["transportationFK"] ? ReferenceTypeBean.fromJS(data["transportationFK"]) : <any>null;
            this.transportationMethodFK = data["transportationMethodFK"] ? ReferenceTypeBean.fromJS(data["transportationMethodFK"]) : <any>null;
            this.transportingDate = data["transportingDate"] ? new Date(data["transportingDate"].toString()) : <any>null;
            this.transportingType = data["transportingType"] !== undefined ? data["transportingType"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultBean {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accidentType"] = this.accidentType !== undefined ? this.accidentType : <any>null;
        data["activeVisitDate"] = this.activeVisitDate ? this.activeVisitDate.toISOString() : <any>null;
        data["activeVisitFK"] = this.activeVisitFK ? this.activeVisitFK.toJSON() : <any>null;
        data["activeVisitHours"] = this.activeVisitHours !== undefined ? this.activeVisitHours : <any>null;
        data["activeVisitType"] = this.activeVisitType !== undefined ? this.activeVisitType : <any>null;
        data["assistanceResultId"] = this.assistanceResultId !== undefined ? this.assistanceResultId : <any>null;
        data["bandages"] = this.bandages !== undefined ? this.bandages : <any>null;
        data["brigadeDelay"] = this.brigadeDelay !== undefined ? this.brigadeDelay : <any>null;
        data["brigadeDelayText"] = this.brigadeDelayText !== undefined ? this.brigadeDelayText : <any>null;
        data["brigadeDelayType"] = this.brigadeDelayType !== undefined ? this.brigadeDelayType : <any>null;
        data["catheters"] = this.catheters !== undefined ? this.catheters : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["complicationFK"] = this.complicationFK ? this.complicationFK.toJSON() : <any>null;
        data["concomitantDiagnosisFK"] = this.concomitantDiagnosisFK ? this.concomitantDiagnosisFK.toJSON() : <any>null;
        data["concomitantDiagnosisName"] = this.concomitantDiagnosisName !== undefined ? this.concomitantDiagnosisName : <any>null;
        data["condition"] = this.condition !== undefined ? this.condition : <any>null;
        data["deathFK"] = this.deathFK ? this.deathFK.toJSON() : <any>null;
        data["deathTime"] = this.deathTime ? this.deathTime.toISOString() : <any>null;
        data["ekgChSS"] = this.ekgChSS !== undefined ? this.ekgChSS : <any>null;
        data["ekgChSSAfter"] = this.ekgChSSAfter !== undefined ? this.ekgChSSAfter : <any>null;
        data["ekgComments"] = this.ekgComments !== undefined ? this.ekgComments : <any>null;
        data["ekgCommentsAfter"] = this.ekgCommentsAfter !== undefined ? this.ekgCommentsAfter : <any>null;
        data["ekgRhytm"] = this.ekgRhytm !== undefined ? this.ekgRhytm : <any>null;
        data["ekgRhytmAfter"] = this.ekgRhytmAfter !== undefined ? this.ekgRhytmAfter : <any>null;
        data["failReasonText"] = this.failReasonText !== undefined ? this.failReasonText : <any>null;
        data["hospComplications"] = this.hospComplications !== undefined ? this.hospComplications : <any>null;
        data["hospComplicationsText"] = this.hospComplicationsText !== undefined ? this.hospComplicationsText : <any>null;
        data["hospFromFK"] = this.hospFromFK ? this.hospFromFK.toJSON() : <any>null;
        data["hospReason"] = this.hospReason !== undefined ? this.hospReason : <any>null;
        data["hospToFK"] = this.hospToFK ? this.hospToFK.toJSON() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["illegalActionText"] = this.illegalActionText !== undefined ? this.illegalActionText : <any>null;
        data["illegalActions"] = this.illegalActions !== undefined ? this.illegalActions : <any>null;
        data["illegalActionsType"] = this.illegalActionsType !== undefined ? this.illegalActionsType : <any>null;
        data["incidentFK"] = this.incidentFK ? this.incidentFK.toJSON() : <any>null;
        data["intoxicationFK"] = this.intoxicationFK ? this.intoxicationFK.toJSON() : <any>null;
        data["intoxicationType"] = this.intoxicationType !== undefined ? this.intoxicationType : <any>null;
        data["isCreated"] = this.isCreated !== undefined ? this.isCreated : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["localAd"] = this.localAd !== undefined ? this.localAd : <any>null;
        data["localChd"] = this.localChd !== undefined ? this.localChd : <any>null;
        data["localChss"] = this.localChss !== undefined ? this.localChss : <any>null;
        data["localGlucometry"] = this.localGlucometry !== undefined ? this.localGlucometry : <any>null;
        data["localPulse"] = this.localPulse !== undefined ? this.localPulse : <any>null;
        data["localPulseOximetry"] = this.localPulseOximetry !== undefined ? this.localPulseOximetry : <any>null;
        data["localTemperature"] = this.localTemperature !== undefined ? this.localTemperature : <any>null;
        data["localWorkAd"] = this.localWorkAd !== undefined ? this.localWorkAd : <any>null;
        data["mainDiagnosisId"] = this.mainDiagnosisId !== undefined ? this.mainDiagnosisId : <any>null;
        data["mainDiagnosisName"] = this.mainDiagnosisName !== undefined ? this.mainDiagnosisName : <any>null;
        data["mkbFK"] = this.mkbFK ? this.mkbFK.toJSON() : <any>null;
        data["notHelpReasonType"] = this.notHelpReasonType !== undefined ? this.notHelpReasonType : <any>null;
        data["otherMaterials"] = this.otherMaterials !== undefined ? this.otherMaterials : <any>null;
        data["reasonType"] = this.reasonType !== undefined ? this.reasonType : <any>null;
        data["resultCauseFK"] = this.resultCauseFK ? this.resultCauseFK.toJSON() : <any>null;
        data["resultFK"] = this.resultFK ? this.resultFK.toJSON() : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["syringes"] = this.syringes !== undefined ? this.syringes : <any>null;
        data["transferPatientBrigade"] = this.transferPatientBrigade !== undefined ? this.transferPatientBrigade : <any>null;
        data["transferPatientDate"] = this.transferPatientDate ? this.transferPatientDate.toISOString() : <any>null;
        data["transfusionSystem"] = this.transfusionSystem !== undefined ? this.transfusionSystem : <any>null;
        data["transportAd"] = this.transportAd !== undefined ? this.transportAd : <any>null;
        data["transportChd"] = this.transportChd !== undefined ? this.transportChd : <any>null;
        data["transportChss"] = this.transportChss !== undefined ? this.transportChss : <any>null;
        data["transportGlucometry"] = this.transportGlucometry !== undefined ? this.transportGlucometry : <any>null;
        data["transportOximetry"] = this.transportOximetry !== undefined ? this.transportOximetry : <any>null;
        data["transportPulse"] = this.transportPulse !== undefined ? this.transportPulse : <any>null;
        data["transportTemperature"] = this.transportTemperature !== undefined ? this.transportTemperature : <any>null;
        data["transportWorkAd"] = this.transportWorkAd !== undefined ? this.transportWorkAd : <any>null;
        data["transportationFK"] = this.transportationFK ? this.transportationFK.toJSON() : <any>null;
        data["transportationMethodFK"] = this.transportationMethodFK ? this.transportationMethodFK.toJSON() : <any>null;
        data["transportingDate"] = this.transportingDate ? this.transportingDate.toISOString() : <any>null;
        data["transportingType"] = this.transportingType !== undefined ? this.transportingType : <any>null;
        return data; 
    }
}

export interface ICardResultBean {
    /** Тип несчастного случая */
    accidentType?: number | null;
    /** Дата визита */
    activeVisitDate?: Date | null;
    /** Визит */
    activeVisitFK?: ReferenceTypeBean | null;
    /** Продолжительность визита */
    activeVisitHours?: number | null;
    /** Тип визита */
    activeVisitType?: number | null;
    /** Id результата помощи */
    assistanceResultId?: number | null;
    /** Бинты */
    bandages?: number | null;
    /** Задержка бригады */
    brigadeDelay?: boolean | null;
    /** Задержка бригады: комментарий */
    brigadeDelayText?: string | null;
    /** Тип задержки бригады */
    brigadeDelayType?: number | null;
    /** Катетеры */
    catheters?: number | null;
    /** Комментарии */
    comments?: string | null;
    /** Осложнения */
    complicationFK?: ClassMkbBean | null;
    /** Сопутствующий диагноз */
    concomitantDiagnosisFK?: ClassMkbBean | null;
    /** Название сопутствующего диагноза */
    concomitantDiagnosisName?: string | null;
    /** Состояние */
    condition?: number | null;
    /** Смерть */
    deathFK?: ClassMkbBean | null;
    /** Время смерти */
    deathTime?: Date | null;
    /** ЭКГ: ЧСС */
    ekgChSS?: number | null;
    /** ЭКГ: ЧСС после оказания МП */
    ekgChSSAfter?: number | null;
    /** ЭКГ: комментарий */
    ekgComments?: string | null;
    /** ЭКГ: комментарий после оказания МП */
    ekgCommentsAfter?: string | null;
    /** ЭКГ: ритм */
    ekgRhytm?: string | null;
    /** ЭКГ: ритм после оказания МП */
    ekgRhytmAfter?: string | null;
    /** Причина неудачи */
    failReasonText?: string | null;
    /** Осложнения при госпитализации */
    hospComplications?: boolean | null;
    /** Осложнения при госпитализации: комментарий */
    hospComplicationsText?: string | null;
    /** Больница отправления */
    hospFromFK?: SubdivisionBean | null;
    /** Причина госпитализации */
    hospReason?: number | null;
    /** Больница прибытия */
    hospToFK?: SubdivisionBean | null;
    id?: number | null;
    /** Нелегальные действия: комментарий */
    illegalActionText?: string | null;
    /** Нелегальные действия */
    illegalActions?: boolean | null;
    illegalActionsType?: number | null;
    /** Инцидент */
    incidentFK?: ReferenceTypeBean | null;
    /** Интоксикация */
    intoxicationFK?: ReferenceTypeBean | null;
    /** Тип интоксикации */
    intoxicationType?: number | null;
    /** Признак создания */
    isCreated?: boolean | null;
    /** Признак удаления записи */
    isDeleted?: boolean | null;
    /** Артериальное давление на месте */
    localAd?: string | null;
    /** Частота дыхания на месте */
    localChd?: string | null;
    /** ЧСС на месте */
    localChss?: string | null;
    /** Глюкометрия на месте */
    localGlucometry?: string | null;
    /** Пульс на месте */
    localPulse?: string | null;
    /** Пульсоксиметрия на месту */
    localPulseOximetry?: string | null;
    /** Температура на месте */
    localTemperature?: string | null;
    /** Рабочее артериальное давление на месте */
    localWorkAd?: string | null;
    /** Id основного диагноза */
    mainDiagnosisId?: number | null;
    /** Название сновного диагноза */
    mainDiagnosisName?: string | null;
    /** Классификация МКБ */
    mkbFK?: ClassMkbBean | null;
    /** Причина неоказания помощи */
    notHelpReasonType?: number | null;
    /** Другие материалы */
    otherMaterials?: string | null;
    /** Тип причины */
    reasonType?: number | null;
    /** Причина результата */
    resultCauseFK?: ReferenceTypeBean | null;
    /** Результат */
    resultFK?: ReferenceTypeBean | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Шприцы */
    syringes?: number | null;
    /** Бригада трансфера пациента */
    transferPatientBrigade?: string | null;
    /** Дата трансфера пациента */
    transferPatientDate?: Date | null;
    /** Системы переливания */
    transfusionSystem?: number | null;
    /** Артериальное давление при транспортировке */
    transportAd?: string | null;
    /** Частота дыхания при транспортировке */
    transportChd?: string | null;
    /** ЧСС при транспортировке */
    transportChss?: string | null;
    /** Глюкометрия при транспортировке */
    transportGlucometry?: string | null;
    /** Оксиметрия пульса при транспортировке */
    transportOximetry?: string | null;
    /** Пульс при транспортировке */
    transportPulse?: string | null;
    /** Температура при транспортировке */
    transportTemperature?: string | null;
    /** Рабочее артериальное давление при транспортировке */
    transportWorkAd?: string | null;
    /** Транспортировка */
    transportationFK?: ReferenceTypeBean | null;
    /** Метод транспортировки */
    transportationMethodFK?: ReferenceTypeBean | null;
    /** Дата транспортировки */
    transportingDate?: Date | null;
    /** Тип транспортировки */
    transportingType?: number | null;
}

export class Geometry implements IGeometry {
    dimension?: number | null;
    firstPoint?: any | null;
    haveMeasure?: boolean | null;
    lastPoint?: any | null;
    measured?: boolean | null;
    srid?: number | null;
    type?: number | null;
    typeString?: string | null;
    value?: string | null;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dimension = data["dimension"] !== undefined ? data["dimension"] : <any>null;
            this.firstPoint = data["firstPoint"] !== undefined ? data["firstPoint"] : <any>null;
            this.haveMeasure = data["haveMeasure"] !== undefined ? data["haveMeasure"] : <any>null;
            this.lastPoint = data["lastPoint"] !== undefined ? data["lastPoint"] : <any>null;
            this.measured = data["measured"] !== undefined ? data["measured"] : <any>null;
            this.srid = data["srid"] !== undefined ? data["srid"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeString = data["typeString"] !== undefined ? data["typeString"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension !== undefined ? this.dimension : <any>null;
        data["firstPoint"] = this.firstPoint !== undefined ? this.firstPoint : <any>null;
        data["haveMeasure"] = this.haveMeasure !== undefined ? this.haveMeasure : <any>null;
        data["lastPoint"] = this.lastPoint !== undefined ? this.lastPoint : <any>null;
        data["measured"] = this.measured !== undefined ? this.measured : <any>null;
        data["srid"] = this.srid !== undefined ? this.srid : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeString"] = this.typeString !== undefined ? this.typeString : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IGeometry {
    dimension?: number | null;
    firstPoint?: any | null;
    haveMeasure?: boolean | null;
    lastPoint?: any | null;
    measured?: boolean | null;
    srid?: number | null;
    type?: number | null;
    typeString?: string | null;
    value?: string | null;
}

export class CardResultTransportingDto implements ICardResultTransportingDto {
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    transporting_date?: Date | null;
    transporting_type_code?: string | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;

    constructor(data?: ICardResultTransportingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hosp_complications = data["hosp_complications"] !== undefined ? data["hosp_complications"] : <any>null;
            this.hosp_complications_text = data["hosp_complications_text"] !== undefined ? data["hosp_complications_text"] : <any>null;
            this.hosp_to_id = data["hosp_to_id"] !== undefined ? data["hosp_to_id"] : <any>null;
            this.hosp_to_name = data["hosp_to_name"] !== undefined ? data["hosp_to_name"] : <any>null;
            this.hosp_transportation_id = data["hosp_transportation_id"] !== undefined ? data["hosp_transportation_id"] : <any>null;
            this.hosp_transportation_name = data["hosp_transportation_name"] !== undefined ? data["hosp_transportation_name"] : <any>null;
            this.transporting_date = data["transporting_date"] ? new Date(data["transporting_date"].toString()) : <any>null;
            this.transporting_type_code = data["transporting_type_code"] !== undefined ? data["transporting_type_code"] : <any>null;
            this.transporting_type_id = data["transporting_type_id"] !== undefined ? data["transporting_type_id"] : <any>null;
            this.transporting_type_name = data["transporting_type_name"] !== undefined ? data["transporting_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultTransportingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTransportingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hosp_complications"] = this.hosp_complications !== undefined ? this.hosp_complications : <any>null;
        data["hosp_complications_text"] = this.hosp_complications_text !== undefined ? this.hosp_complications_text : <any>null;
        data["hosp_to_id"] = this.hosp_to_id !== undefined ? this.hosp_to_id : <any>null;
        data["hosp_to_name"] = this.hosp_to_name !== undefined ? this.hosp_to_name : <any>null;
        data["hosp_transportation_id"] = this.hosp_transportation_id !== undefined ? this.hosp_transportation_id : <any>null;
        data["hosp_transportation_name"] = this.hosp_transportation_name !== undefined ? this.hosp_transportation_name : <any>null;
        data["transporting_date"] = this.transporting_date ? this.transporting_date.toISOString() : <any>null;
        data["transporting_type_code"] = this.transporting_type_code !== undefined ? this.transporting_type_code : <any>null;
        data["transporting_type_id"] = this.transporting_type_id !== undefined ? this.transporting_type_id : <any>null;
        data["transporting_type_name"] = this.transporting_type_name !== undefined ? this.transporting_type_name : <any>null;
        return data; 
    }
}

export interface ICardResultTransportingDto {
    hosp_complications?: boolean | null;
    hosp_complications_text?: string | null;
    hosp_to_id?: number | null;
    hosp_to_name?: string | null;
    hosp_transportation_id?: number | null;
    hosp_transportation_name?: string | null;
    transporting_date?: Date | null;
    transporting_type_code?: string | null;
    transporting_type_id?: number | null;
    transporting_type_name?: string | null;
}

export class ReferenceTypeDto implements IReferenceTypeDto {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    system_value?: number | null;
    type?: string | null;

    constructor(data?: IReferenceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.default = data["default"] !== undefined ? data["default"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.system_value = data["system_value"] !== undefined ? data["system_value"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): ReferenceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["default"] = this.default !== undefined ? this.default : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["system_value"] = this.system_value !== undefined ? this.system_value : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IReferenceTypeDto {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    system_value?: number | null;
    type?: string | null;
}

export class MobileCardRequest implements IMobileCardRequest {
    call_items?: MobileCall[] | null;
    guid?: string | null;

    constructor(data?: IMobileCardRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["call_items"] && data["call_items"].constructor === Array) {
                this.call_items = [];
                for (let item of data["call_items"])
                    this.call_items.push(MobileCall.fromJS(item));
            }
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.call_items && this.call_items.constructor === Array) {
            data["call_items"] = [];
            for (let item of this.call_items)
                data["call_items"].push(item.toJSON());
        }
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        return data; 
    }
}

export interface IMobileCardRequest {
    call_items?: MobileCall[] | null;
    guid?: string | null;
}

export class CardObjectiveTonsilsPartDto implements ICardObjectiveTonsilsPartDto {
    almonds_normal_large?: number | null;
    almonds_normal_large_name?: string | null;
    almonds_plaque?: boolean | null;

    constructor(data?: ICardObjectiveTonsilsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.almonds_normal_large = data["almonds_normal_large"] !== undefined ? data["almonds_normal_large"] : <any>null;
            this.almonds_normal_large_name = data["almonds_normal_large_name"] !== undefined ? data["almonds_normal_large_name"] : <any>null;
            this.almonds_plaque = data["almonds_plaque"] !== undefined ? data["almonds_plaque"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveTonsilsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveTonsilsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["almonds_normal_large"] = this.almonds_normal_large !== undefined ? this.almonds_normal_large : <any>null;
        data["almonds_normal_large_name"] = this.almonds_normal_large_name !== undefined ? this.almonds_normal_large_name : <any>null;
        data["almonds_plaque"] = this.almonds_plaque !== undefined ? this.almonds_plaque : <any>null;
        return data; 
    }
}

export interface ICardObjectiveTonsilsPartDto {
    almonds_normal_large?: number | null;
    almonds_normal_large_name?: string | null;
    almonds_plaque?: boolean | null;
}

export class PerformerContainer implements IPerformerContainer {
    brigadeBean?: BrigadeBean | null;
    brigadeSchedule?: BrigadeScheduleBean | null;
    performer?: PerformerBean | null;
    roleList?: ListContainerOfRoleBean | null;

    constructor(data?: IPerformerContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigadeBean = data["brigadeBean"] ? BrigadeBean.fromJS(data["brigadeBean"]) : <any>null;
            this.brigadeSchedule = data["brigadeSchedule"] ? BrigadeScheduleBean.fromJS(data["brigadeSchedule"]) : <any>null;
            this.performer = data["performer"] ? PerformerBean.fromJS(data["performer"]) : <any>null;
            this.roleList = data["roleList"] ? ListContainerOfRoleBean.fromJS(data["roleList"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerContainer {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigadeBean"] = this.brigadeBean ? this.brigadeBean.toJSON() : <any>null;
        data["brigadeSchedule"] = this.brigadeSchedule ? this.brigadeSchedule.toJSON() : <any>null;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>null;
        data["roleList"] = this.roleList ? this.roleList.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerContainer {
    brigadeBean?: BrigadeBean | null;
    brigadeSchedule?: BrigadeScheduleBean | null;
    performer?: PerformerBean | null;
    roleList?: ListContainerOfRoleBean | null;
}

export class CardAnamnesisHemodynamicsPartDto implements ICardAnamnesisHemodynamicsPartDto {
    post_therapy_hemodynamics?: string | null;

    constructor(data?: ICardAnamnesisHemodynamicsPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.post_therapy_hemodynamics = data["post_therapy_hemodynamics"] !== undefined ? data["post_therapy_hemodynamics"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisHemodynamicsPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisHemodynamicsPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["post_therapy_hemodynamics"] = this.post_therapy_hemodynamics !== undefined ? this.post_therapy_hemodynamics : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisHemodynamicsPartDto {
    post_therapy_hemodynamics?: string | null;
}

export class PharmacyDocumentDto implements IPharmacyDocumentDto {
    card_id?: number | null;
    card_number?: string | null;
    counterparty_id?: number | null;
    counterparty_name?: string | null;
    date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    is_has_changes?: boolean | null;
    is_processed?: boolean | null;
    is_system?: boolean | null;
    items?: DocumentItemDto[] | null;
    number?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    process_date?: Date | null;
    reason_id?: number | null;
    reason_text?: string | null;
    reason_type?: number | null;
    type?: number | null;
    type_text?: string | null;

    constructor(data?: IPharmacyDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.card_id = data["card_id"] !== undefined ? data["card_id"] : <any>null;
            this.card_number = data["card_number"] !== undefined ? data["card_number"] : <any>null;
            this.counterparty_id = data["counterparty_id"] !== undefined ? data["counterparty_id"] : <any>null;
            this.counterparty_name = data["counterparty_name"] !== undefined ? data["counterparty_name"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_has_changes = data["is_has_changes"] !== undefined ? data["is_has_changes"] : <any>null;
            this.is_processed = data["is_processed"] !== undefined ? data["is_processed"] : <any>null;
            this.is_system = data["is_system"] !== undefined ? data["is_system"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentItemDto.fromJS(item));
            }
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.owner_id = data["owner_id"] !== undefined ? data["owner_id"] : <any>null;
            this.owner_name = data["owner_name"] !== undefined ? data["owner_name"] : <any>null;
            this.process_date = data["process_date"] ? new Date(data["process_date"].toString()) : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_text = data["reason_text"] !== undefined ? data["reason_text"] : <any>null;
            this.reason_type = data["reason_type"] !== undefined ? data["reason_type"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.type_text = data["type_text"] !== undefined ? data["type_text"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["card_id"] = this.card_id !== undefined ? this.card_id : <any>null;
        data["card_number"] = this.card_number !== undefined ? this.card_number : <any>null;
        data["counterparty_id"] = this.counterparty_id !== undefined ? this.counterparty_id : <any>null;
        data["counterparty_name"] = this.counterparty_name !== undefined ? this.counterparty_name : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_has_changes"] = this.is_has_changes !== undefined ? this.is_has_changes : <any>null;
        data["is_processed"] = this.is_processed !== undefined ? this.is_processed : <any>null;
        data["is_system"] = this.is_system !== undefined ? this.is_system : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["owner_id"] = this.owner_id !== undefined ? this.owner_id : <any>null;
        data["owner_name"] = this.owner_name !== undefined ? this.owner_name : <any>null;
        data["process_date"] = this.process_date ? this.process_date.toISOString() : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_text"] = this.reason_text !== undefined ? this.reason_text : <any>null;
        data["reason_type"] = this.reason_type !== undefined ? this.reason_type : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["type_text"] = this.type_text !== undefined ? this.type_text : <any>null;
        return data; 
    }
}

export interface IPharmacyDocumentDto {
    card_id?: number | null;
    card_number?: string | null;
    counterparty_id?: number | null;
    counterparty_name?: string | null;
    date?: Date | null;
    full_name?: string | null;
    id?: number | null;
    is_has_changes?: boolean | null;
    is_processed?: boolean | null;
    is_system?: boolean | null;
    items?: DocumentItemDto[] | null;
    number?: string | null;
    owner_id?: number | null;
    owner_name?: string | null;
    process_date?: Date | null;
    reason_id?: number | null;
    reason_text?: string | null;
    reason_type?: number | null;
    type?: number | null;
    type_text?: string | null;
}

export class LogBean implements ILogBean {
    actionType?: number | null;
    date?: Timestamp | null;
    description?: string | null;
    id?: number | null;
    logType?: number | null;
    parentRecordId?: number | null;
    parentRecordType?: number | null;
    performerFK?: PerformerBean | null;
    performerId?: number | null;
    recordId?: number | null;
    subdivisionFK?: SubdivisionBean | null;
    subdivisionId?: number | null;

    constructor(data?: ILogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionType = data["actionType"] !== undefined ? data["actionType"] : <any>null;
            this.date = data["date"] ? Timestamp.fromJS(data["date"]) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.logType = data["logType"] !== undefined ? data["logType"] : <any>null;
            this.parentRecordId = data["parentRecordId"] !== undefined ? data["parentRecordId"] : <any>null;
            this.parentRecordType = data["parentRecordType"] !== undefined ? data["parentRecordType"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.performerId = data["performerId"] !== undefined ? data["performerId"] : <any>null;
            this.recordId = data["recordId"] !== undefined ? data["recordId"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
        }
    }

    static fromJS(data: any): LogBean {
        data = typeof data === 'object' ? data : {};
        let result = new LogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType !== undefined ? this.actionType : <any>null;
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["logType"] = this.logType !== undefined ? this.logType : <any>null;
        data["parentRecordId"] = this.parentRecordId !== undefined ? this.parentRecordId : <any>null;
        data["parentRecordType"] = this.parentRecordType !== undefined ? this.parentRecordType : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["performerId"] = this.performerId !== undefined ? this.performerId : <any>null;
        data["recordId"] = this.recordId !== undefined ? this.recordId : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        return data; 
    }
}

export interface ILogBean {
    actionType?: number | null;
    date?: Timestamp | null;
    description?: string | null;
    id?: number | null;
    logType?: number | null;
    parentRecordId?: number | null;
    parentRecordType?: number | null;
    performerFK?: PerformerBean | null;
    performerId?: number | null;
    recordId?: number | null;
    subdivisionFK?: SubdivisionBean | null;
    subdivisionId?: number | null;
}

export class BrigadeTypeDto implements IBrigadeTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IBrigadeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IBrigadeTypeDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class RoutingDto implements IRoutingDto {
    hours?: string | null;
    km?: string | null;
    points?: RoutingPointDto[] | null;

    constructor(data?: IRoutingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hours = data["hours"] !== undefined ? data["hours"] : <any>null;
            this.km = data["km"] !== undefined ? data["km"] : <any>null;
            if (data["points"] && data["points"].constructor === Array) {
                this.points = [];
                for (let item of data["points"])
                    this.points.push(RoutingPointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoutingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoutingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hours"] = this.hours !== undefined ? this.hours : <any>null;
        data["km"] = this.km !== undefined ? this.km : <any>null;
        if (this.points && this.points.constructor === Array) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoutingDto {
    hours?: string | null;
    km?: string | null;
    points?: RoutingPointDto[] | null;
}

export class ScheduleType implements IScheduleType {
    days_off?: number | null;
    days_working?: number | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    name?: string | null;
    subdivision_id?: number | null;
    time_from?: string | null;
    time_working?: string | null;

    constructor(data?: IScheduleType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.days_off = data["days_off"] !== undefined ? data["days_off"] : <any>null;
            this.days_working = data["days_working"] !== undefined ? data["days_working"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.is_editable = data["is_editable"] !== undefined ? data["is_editable"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.time_from = data["time_from"] !== undefined ? data["time_from"] : <any>null;
            this.time_working = data["time_working"] !== undefined ? data["time_working"] : <any>null;
        }
    }

    static fromJS(data: any): ScheduleType {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["days_off"] = this.days_off !== undefined ? this.days_off : <any>null;
        data["days_working"] = this.days_working !== undefined ? this.days_working : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["is_editable"] = this.is_editable !== undefined ? this.is_editable : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["time_from"] = this.time_from !== undefined ? this.time_from : <any>null;
        data["time_working"] = this.time_working !== undefined ? this.time_working : <any>null;
        return data; 
    }
}

export interface IScheduleType {
    days_off?: number | null;
    days_working?: number | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    name?: string | null;
    subdivision_id?: number | null;
    time_from?: string | null;
    time_working?: string | null;
}

export class ListDtoOfPerformer implements IListDtoOfPerformer {
    list?: Performer[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfPerformer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(Performer.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfPerformer {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfPerformer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfPerformer {
    list?: Performer[] | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveBreathPartDto implements ICardObjectiveBreathPartDto {
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;

    constructor(data?: ICardObjectiveBreathPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.breath_absent = data["breath_absent"] !== undefined ? data["breath_absent"] : <any>null;
            this.breath_bronch = data["breath_bronch"] !== undefined ? data["breath_bronch"] : <any>null;
            this.breath_evenly = data["breath_evenly"] !== undefined ? data["breath_evenly"] : <any>null;
            this.breath_hard = data["breath_hard"] !== undefined ? data["breath_hard"] : <any>null;
            this.breath_puer = data["breath_puer"] !== undefined ? data["breath_puer"] : <any>null;
            this.breath_text = data["breath_text"] !== undefined ? data["breath_text"] : <any>null;
            this.breath_vesicul = data["breath_vesicul"] !== undefined ? data["breath_vesicul"] : <any>null;
            this.breath_weak = data["breath_weak"] !== undefined ? data["breath_weak"] : <any>null;
            this.dyspnea_id = data["dyspnea_id"] !== undefined ? data["dyspnea_id"] : <any>null;
            this.dyspnea_name = data["dyspnea_name"] !== undefined ? data["dyspnea_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveBreathPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveBreathPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["breath_absent"] = this.breath_absent !== undefined ? this.breath_absent : <any>null;
        data["breath_bronch"] = this.breath_bronch !== undefined ? this.breath_bronch : <any>null;
        data["breath_evenly"] = this.breath_evenly !== undefined ? this.breath_evenly : <any>null;
        data["breath_hard"] = this.breath_hard !== undefined ? this.breath_hard : <any>null;
        data["breath_puer"] = this.breath_puer !== undefined ? this.breath_puer : <any>null;
        data["breath_text"] = this.breath_text !== undefined ? this.breath_text : <any>null;
        data["breath_vesicul"] = this.breath_vesicul !== undefined ? this.breath_vesicul : <any>null;
        data["breath_weak"] = this.breath_weak !== undefined ? this.breath_weak : <any>null;
        data["dyspnea_id"] = this.dyspnea_id !== undefined ? this.dyspnea_id : <any>null;
        data["dyspnea_name"] = this.dyspnea_name !== undefined ? this.dyspnea_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveBreathPartDto {
    breath_absent?: boolean | null;
    breath_bronch?: boolean | null;
    breath_evenly?: boolean | null;
    breath_hard?: boolean | null;
    breath_puer?: boolean | null;
    breath_text?: string | null;
    breath_vesicul?: boolean | null;
    breath_weak?: boolean | null;
    dyspnea_id?: number | null;
    dyspnea_name?: string | null;
}

export class Unit implements IUnit {
    code?: string | null;
    name?: string | null;

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IUnit {
    code?: string | null;
    name?: string | null;
}

export class ListContainerOfClassMkbBean implements IListContainerOfClassMkbBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfClassMkbBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfClassMkbBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfClassMkbBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfClassMkbBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class BuildingBean implements IBuildingBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Геометрия */
    geometry?: string | null;
    /** Наименование постройки */
    houseName?: string | null;
    /** Номер дома */
    houseNumber?: string | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование улицы */
    streetName?: string | null;

    constructor(data?: IBuildingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityAddress = data["cityAddress"] !== undefined ? data["cityAddress"] : <any>null;
            this.geometry = data["geometry"] !== undefined ? data["geometry"] : <any>null;
            this.houseName = data["houseName"] !== undefined ? data["houseName"] : <any>null;
            this.houseNumber = data["houseNumber"] !== undefined ? data["houseNumber"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.idOSM = data["idOSM"] !== undefined ? data["idOSM"] : <any>null;
            this.streetName = data["streetName"] !== undefined ? data["streetName"] : <any>null;
        }
    }

    static fromJS(data: any): BuildingBean {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityAddress"] = this.cityAddress !== undefined ? this.cityAddress : <any>null;
        data["geometry"] = this.geometry !== undefined ? this.geometry : <any>null;
        data["houseName"] = this.houseName !== undefined ? this.houseName : <any>null;
        data["houseNumber"] = this.houseNumber !== undefined ? this.houseNumber : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["idOSM"] = this.idOSM !== undefined ? this.idOSM : <any>null;
        data["streetName"] = this.streetName !== undefined ? this.streetName : <any>null;
        return data; 
    }
}

export interface IBuildingBean {
    /** Полный адрес населенного пункта */
    cityAddress?: string | null;
    /** Геометрия */
    geometry?: string | null;
    /** Наименование постройки */
    houseName?: string | null;
    /** Номер дома */
    houseNumber?: string | null;
    id?: number | null;
    idOSM?: number | null;
    /** Наименование улицы */
    streetName?: string | null;
}

export class TransportBrigScheduleCreateDto implements ITransportBrigScheduleCreateDto {
    period_details?: PeriodDetails | null;
    transport_id?: number | null;

    constructor(data?: ITransportBrigScheduleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
        }
    }

    static fromJS(data: any): TransportBrigScheduleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportBrigScheduleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        return data; 
    }
}

export interface ITransportBrigScheduleCreateDto {
    period_details?: PeriodDetails | null;
    transport_id?: number | null;
}

export class SkillBean implements ISkillBean {
    code?: string | null;
    commonName?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;

    constructor(data?: ISkillBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.commonName = data["commonName"] !== undefined ? data["commonName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SkillBean {
        data = typeof data === 'object' ? data : {};
        let result = new SkillBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["commonName"] = this.commonName !== undefined ? this.commonName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ISkillBean {
    code?: string | null;
    commonName?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
}

export class CallDtoFLAT implements ICallDtoFLAT {
    action?: string | null;
    address?: CallFiasAddressDto | null;
    addressee?: number[] | null;
    audio_file_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: Date | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
    is_unfounded?: boolean | null;
    patient?: CallPatientPartDto[] | null;
    performer_id?: number | null;
    performer_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    reason_id?: number | null;
    reason_name?: string | null;
    similars?: string[] | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICallDtoFLAT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"] !== undefined ? data["action"] : <any>null;
            this.address = data["address"] ? CallFiasAddressDto.fromJS(data["address"]) : <any>null;
            if (data["addressee"] && data["addressee"].constructor === Array) {
                this.addressee = [];
                for (let item of data["addressee"])
                    this.addressee.push(item);
            }
            this.audio_file_name = data["audio_file_name"] !== undefined ? data["audio_file_name"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_priority = data["call_priority"] !== undefined ? data["call_priority"] : <any>null;
            this.call_priority_name = data["call_priority_name"] !== undefined ? data["call_priority_name"] : <any>null;
            this.call_type_id = data["call_type_id"] !== undefined ? data["call_type_id"] : <any>null;
            this.call_type_name = data["call_type_name"] !== undefined ? data["call_type_name"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.declarant_type_id = data["declarant_type_id"] !== undefined ? data["declarant_type_id"] : <any>null;
            this.declarant_type_name = data["declarant_type_name"] !== undefined ? data["declarant_type_name"] : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            if (data["patient"] && data["patient"].constructor === Array) {
                this.patient = [];
                for (let item of data["patient"])
                    this.patient.push(CallPatientPartDto.fromJS(item));
            }
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.primary_call_id = data["primary_call_id"] !== undefined ? data["primary_call_id"] : <any>null;
            this.primary_call_number = data["primary_call_number"] !== undefined ? data["primary_call_number"] : <any>null;
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_extra = data["reason_extra"] !== undefined ? data["reason_extra"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            if (data["similars"] && data["similars"].constructor === Array) {
                this.similars = [];
                for (let item of data["similars"])
                    this.similars.push(item);
            }
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallDtoFLAT {
        data = typeof data === 'object' ? data : {};
        let result = new CallDtoFLAT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action !== undefined ? this.action : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        if (this.addressee && this.addressee.constructor === Array) {
            data["addressee"] = [];
            for (let item of this.addressee)
                data["addressee"].push(item);
        }
        data["audio_file_name"] = this.audio_file_name !== undefined ? this.audio_file_name : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_priority"] = this.call_priority !== undefined ? this.call_priority : <any>null;
        data["call_priority_name"] = this.call_priority_name !== undefined ? this.call_priority_name : <any>null;
        data["call_type_id"] = this.call_type_id !== undefined ? this.call_type_id : <any>null;
        data["call_type_name"] = this.call_type_name !== undefined ? this.call_type_name : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["declarant_type_id"] = this.declarant_type_id !== undefined ? this.declarant_type_id : <any>null;
        data["declarant_type_name"] = this.declarant_type_name !== undefined ? this.declarant_type_name : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        if (this.patient && this.patient.constructor === Array) {
            data["patient"] = [];
            for (let item of this.patient)
                data["patient"].push(item.toJSON());
        }
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["primary_call_id"] = this.primary_call_id !== undefined ? this.primary_call_id : <any>null;
        data["primary_call_number"] = this.primary_call_number !== undefined ? this.primary_call_number : <any>null;
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_extra"] = this.reason_extra !== undefined ? this.reason_extra : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        if (this.similars && this.similars.constructor === Array) {
            data["similars"] = [];
            for (let item of this.similars)
                data["similars"].push(item);
        }
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICallDtoFLAT {
    action?: string | null;
    address?: CallFiasAddressDto | null;
    addressee?: number[] | null;
    audio_file_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    date?: Date | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
    is_unfounded?: boolean | null;
    patient?: CallPatientPartDto[] | null;
    performer_id?: number | null;
    performer_name?: string | null;
    primary_call_id?: number | null;
    primary_call_number?: string | null;
    reason_comment?: string | null;
    reason_extra?: boolean | null;
    reason_id?: number | null;
    reason_name?: string | null;
    similars?: string[] | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class PerformerBrigScheduleAvailableDto implements IPerformerBrigScheduleAvailableDto {
    first_name?: string | null;
    patronymic?: string | null;
    performer_id?: number | null;
    periods?: Period[] | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: IPerformerBrigScheduleAvailableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            if (data["periods"] && data["periods"].constructor === Array) {
                this.periods = [];
                for (let item of data["periods"])
                    this.periods.push(Period.fromJS(item));
            }
            this.second_name = data["second_name"] !== undefined ? data["second_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerBrigScheduleAvailableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBrigScheduleAvailableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        if (this.periods && this.periods.constructor === Array) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item.toJSON());
        }
        data["second_name"] = this.second_name !== undefined ? this.second_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface IPerformerBrigScheduleAvailableDto {
    first_name?: string | null;
    patronymic?: string | null;
    performer_id?: number | null;
    periods?: Period[] | null;
    second_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class CallBrigadePartDto implements ICallBrigadePartDto {
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_subdivision_id?: number | null;
    brigade_subdivision_name?: string | null;
    brigade_subdivision_short_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    performers?: PerformerShortDto[] | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    state?: string | null;
    state_date?: Date | null;
    transport_brand?: string | null;
    transport_class_name?: string | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    transport_type_name?: string | null;

    constructor(data?: ICallBrigadePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
            this.brigade_name = data["brigade_name"] !== undefined ? data["brigade_name"] : <any>null;
            this.brigade_schedule_id = data["brigade_schedule_id"] !== undefined ? data["brigade_schedule_id"] : <any>null;
            this.brigade_subdivision_id = data["brigade_subdivision_id"] !== undefined ? data["brigade_subdivision_id"] : <any>null;
            this.brigade_subdivision_name = data["brigade_subdivision_name"] !== undefined ? data["brigade_subdivision_name"] : <any>null;
            this.brigade_subdivision_short_name = data["brigade_subdivision_short_name"] !== undefined ? data["brigade_subdivision_short_name"] : <any>null;
            this.brigade_type_code = data["brigade_type_code"] !== undefined ? data["brigade_type_code"] : <any>null;
            this.brigade_type_id = data["brigade_type_id"] !== undefined ? data["brigade_type_id"] : <any>null;
            this.brigade_type_name = data["brigade_type_name"] !== undefined ? data["brigade_type_name"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_reason_id = data["call_reason_id"] !== undefined ? data["call_reason_id"] : <any>null;
            this.call_reason_name = data["call_reason_name"] !== undefined ? data["call_reason_name"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["messages"] && data["messages"].constructor === Array) {
                this.messages = [];
                for (let item of data["messages"])
                    this.messages.push(MessageEventDto.fromJS(item));
            }
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerShortDto.fromJS(item));
            }
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.state = data["state"] !== undefined ? data["state"] : <any>null;
            this.state_date = data["state_date"] ? new Date(data["state_date"].toString()) : <any>null;
            this.transport_brand = data["transport_brand"] !== undefined ? data["transport_brand"] : <any>null;
            this.transport_class_name = data["transport_class_name"] !== undefined ? data["transport_class_name"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
            this.transport_statemark = data["transport_statemark"] !== undefined ? data["transport_statemark"] : <any>null;
            this.transport_type_name = data["transport_type_name"] !== undefined ? data["transport_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallBrigadePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallBrigadePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        data["brigade_name"] = this.brigade_name !== undefined ? this.brigade_name : <any>null;
        data["brigade_schedule_id"] = this.brigade_schedule_id !== undefined ? this.brigade_schedule_id : <any>null;
        data["brigade_subdivision_id"] = this.brigade_subdivision_id !== undefined ? this.brigade_subdivision_id : <any>null;
        data["brigade_subdivision_name"] = this.brigade_subdivision_name !== undefined ? this.brigade_subdivision_name : <any>null;
        data["brigade_subdivision_short_name"] = this.brigade_subdivision_short_name !== undefined ? this.brigade_subdivision_short_name : <any>null;
        data["brigade_type_code"] = this.brigade_type_code !== undefined ? this.brigade_type_code : <any>null;
        data["brigade_type_id"] = this.brigade_type_id !== undefined ? this.brigade_type_id : <any>null;
        data["brigade_type_name"] = this.brigade_type_name !== undefined ? this.brigade_type_name : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_reason_id"] = this.call_reason_id !== undefined ? this.call_reason_id : <any>null;
        data["call_reason_name"] = this.call_reason_name !== undefined ? this.call_reason_name : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.messages && this.messages.constructor === Array) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["state_date"] = this.state_date ? this.state_date.toISOString() : <any>null;
        data["transport_brand"] = this.transport_brand !== undefined ? this.transport_brand : <any>null;
        data["transport_class_name"] = this.transport_class_name !== undefined ? this.transport_class_name : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        data["transport_statemark"] = this.transport_statemark !== undefined ? this.transport_statemark : <any>null;
        data["transport_type_name"] = this.transport_type_name !== undefined ? this.transport_type_name : <any>null;
        return data; 
    }
}

export interface ICallBrigadePartDto {
    brigade_id?: number | null;
    brigade_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_subdivision_id?: number | null;
    brigade_subdivision_name?: string | null;
    brigade_subdivision_short_name?: string | null;
    brigade_type_code?: string | null;
    brigade_type_id?: number | null;
    brigade_type_name?: string | null;
    call_id?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    performers?: PerformerShortDto[] | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    state?: string | null;
    state_date?: Date | null;
    transport_brand?: string | null;
    transport_class_name?: string | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    transport_type_name?: string | null;
}

export class AddressObject implements IAddressObject {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    full_name?: string | null;
    gc_key?: string | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: IAddressObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.gc_key = data["gc_key"] !== undefined ? data["gc_key"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): AddressObject {
        data = typeof data === 'object' ? data : {};
        let result = new AddressObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["gc_key"] = this.gc_key !== undefined ? this.gc_key : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IAddressObject {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    full_name?: string | null;
    gc_key?: string | null;
    id?: number | null;
    name?: string | null;
}

export class FiasAddressHouseDto implements IFiasAddressHouseDto {
    building?: string | null;
    code?: string | null;
    full_name?: string | null;
    number?: string | null;
    structure?: string | null;

    constructor(data?: IFiasAddressHouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"] !== undefined ? data["building"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.structure = data["structure"] !== undefined ? data["structure"] : <any>null;
        }
    }

    static fromJS(data: any): FiasAddressHouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiasAddressHouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building !== undefined ? this.building : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["structure"] = this.structure !== undefined ? this.structure : <any>null;
        return data; 
    }
}

export interface IFiasAddressHouseDto {
    building?: string | null;
    code?: string | null;
    full_name?: string | null;
    number?: string | null;
    structure?: string | null;
}

export class LongDto implements ILongDto {
    call_id?: number | null;

    constructor(data?: ILongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
        }
    }

    static fromJS(data: any): LongDto {
        data = typeof data === 'object' ? data : {};
        let result = new LongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        return data; 
    }
}

export interface ILongDto {
    call_id?: number | null;
}

export class PharmacyOwner implements IPharmacyOwner {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    isDefault?: boolean | null;
    name?: string | null;
    systemValue?: number | null;
    type?: string | null;

    constructor(data?: IPharmacyOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.default = data["default"] !== undefined ? data["default"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDefault = data["isDefault"] !== undefined ? data["isDefault"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.systemValue = data["systemValue"] !== undefined ? data["systemValue"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyOwner {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["default"] = this.default !== undefined ? this.default : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["systemValue"] = this.systemValue !== undefined ? this.systemValue : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyOwner {
    code?: string | null;
    default?: boolean | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    id?: number | null;
    isDefault?: boolean | null;
    name?: string | null;
    systemValue?: number | null;
    type?: string | null;
}

export class CardPatientPartDto implements ICardPatientPartDto {
    alien_birthplace?: string | null;
    birthday?: Date | null;
    document_date?: Date | null;
    document_name?: string | null;
    document_number?: string | null;
    document_serial?: string | null;
    insurance_DMS_SMO?: string | null;
    insurance_OMS?: string | null;
    insurance_SMO?: string | null;
    is_dead?: boolean | null;
    job_place?: string | null;
    job_position?: string | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;
    registry_building?: string | null;
    registry_city?: string | null;
    registry_country?: string | null;
    registry_district?: string | null;
    registry_flat?: string | null;
    registry_house?: string | null;
    registry_region?: string | null;
    registry_street?: string | null;
    social_type_id?: number | null;
    social_type_name?: string | null;
    source_type_id?: number | null;
    source_type_name?: string | null;

    constructor(data?: ICardPatientPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.alien_birthplace = data["alien_birthplace"] !== undefined ? data["alien_birthplace"] : <any>null;
            this.birthday = data["birthday"] ? new Date(data["birthday"].toString()) : <any>null;
            this.document_date = data["document_date"] ? new Date(data["document_date"].toString()) : <any>null;
            this.document_name = data["document_name"] !== undefined ? data["document_name"] : <any>null;
            this.document_number = data["document_number"] !== undefined ? data["document_number"] : <any>null;
            this.document_serial = data["document_serial"] !== undefined ? data["document_serial"] : <any>null;
            this.insurance_DMS_SMO = data["insurance_DMS_SMO"] !== undefined ? data["insurance_DMS_SMO"] : <any>null;
            this.insurance_OMS = data["insurance_OMS"] !== undefined ? data["insurance_OMS"] : <any>null;
            this.insurance_SMO = data["insurance_SMO"] !== undefined ? data["insurance_SMO"] : <any>null;
            this.is_dead = data["is_dead"] !== undefined ? data["is_dead"] : <any>null;
            this.job_place = data["job_place"] !== undefined ? data["job_place"] : <any>null;
            this.job_position = data["job_position"] !== undefined ? data["job_position"] : <any>null;
            this.patient_age_days = data["patient_age_days"] !== undefined ? data["patient_age_days"] : <any>null;
            this.patient_age_months = data["patient_age_months"] !== undefined ? data["patient_age_months"] : <any>null;
            this.patient_age_years = data["patient_age_years"] !== undefined ? data["patient_age_years"] : <any>null;
            this.patient_firstname = data["patient_firstname"] !== undefined ? data["patient_firstname"] : <any>null;
            this.patient_id = data["patient_id"] !== undefined ? data["patient_id"] : <any>null;
            this.patient_patronymic = data["patient_patronymic"] !== undefined ? data["patient_patronymic"] : <any>null;
            this.patient_secondname = data["patient_secondname"] !== undefined ? data["patient_secondname"] : <any>null;
            this.patient_sex = data["patient_sex"] !== undefined ? data["patient_sex"] : <any>null;
            this.patient_sex_name = data["patient_sex_name"] !== undefined ? data["patient_sex_name"] : <any>null;
            this.patient_type_id = data["patient_type_id"] !== undefined ? data["patient_type_id"] : <any>null;
            this.patient_type_name = data["patient_type_name"] !== undefined ? data["patient_type_name"] : <any>null;
            this.registry_building = data["registry_building"] !== undefined ? data["registry_building"] : <any>null;
            this.registry_city = data["registry_city"] !== undefined ? data["registry_city"] : <any>null;
            this.registry_country = data["registry_country"] !== undefined ? data["registry_country"] : <any>null;
            this.registry_district = data["registry_district"] !== undefined ? data["registry_district"] : <any>null;
            this.registry_flat = data["registry_flat"] !== undefined ? data["registry_flat"] : <any>null;
            this.registry_house = data["registry_house"] !== undefined ? data["registry_house"] : <any>null;
            this.registry_region = data["registry_region"] !== undefined ? data["registry_region"] : <any>null;
            this.registry_street = data["registry_street"] !== undefined ? data["registry_street"] : <any>null;
            this.social_type_id = data["social_type_id"] !== undefined ? data["social_type_id"] : <any>null;
            this.social_type_name = data["social_type_name"] !== undefined ? data["social_type_name"] : <any>null;
            this.source_type_id = data["source_type_id"] !== undefined ? data["source_type_id"] : <any>null;
            this.source_type_name = data["source_type_name"] !== undefined ? data["source_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardPatientPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardPatientPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alien_birthplace"] = this.alien_birthplace !== undefined ? this.alien_birthplace : <any>null;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>null;
        data["document_date"] = this.document_date ? this.document_date.toISOString() : <any>null;
        data["document_name"] = this.document_name !== undefined ? this.document_name : <any>null;
        data["document_number"] = this.document_number !== undefined ? this.document_number : <any>null;
        data["document_serial"] = this.document_serial !== undefined ? this.document_serial : <any>null;
        data["insurance_DMS_SMO"] = this.insurance_DMS_SMO !== undefined ? this.insurance_DMS_SMO : <any>null;
        data["insurance_OMS"] = this.insurance_OMS !== undefined ? this.insurance_OMS : <any>null;
        data["insurance_SMO"] = this.insurance_SMO !== undefined ? this.insurance_SMO : <any>null;
        data["is_dead"] = this.is_dead !== undefined ? this.is_dead : <any>null;
        data["job_place"] = this.job_place !== undefined ? this.job_place : <any>null;
        data["job_position"] = this.job_position !== undefined ? this.job_position : <any>null;
        data["patient_age_days"] = this.patient_age_days !== undefined ? this.patient_age_days : <any>null;
        data["patient_age_months"] = this.patient_age_months !== undefined ? this.patient_age_months : <any>null;
        data["patient_age_years"] = this.patient_age_years !== undefined ? this.patient_age_years : <any>null;
        data["patient_firstname"] = this.patient_firstname !== undefined ? this.patient_firstname : <any>null;
        data["patient_id"] = this.patient_id !== undefined ? this.patient_id : <any>null;
        data["patient_patronymic"] = this.patient_patronymic !== undefined ? this.patient_patronymic : <any>null;
        data["patient_secondname"] = this.patient_secondname !== undefined ? this.patient_secondname : <any>null;
        data["patient_sex"] = this.patient_sex !== undefined ? this.patient_sex : <any>null;
        data["patient_sex_name"] = this.patient_sex_name !== undefined ? this.patient_sex_name : <any>null;
        data["patient_type_id"] = this.patient_type_id !== undefined ? this.patient_type_id : <any>null;
        data["patient_type_name"] = this.patient_type_name !== undefined ? this.patient_type_name : <any>null;
        data["registry_building"] = this.registry_building !== undefined ? this.registry_building : <any>null;
        data["registry_city"] = this.registry_city !== undefined ? this.registry_city : <any>null;
        data["registry_country"] = this.registry_country !== undefined ? this.registry_country : <any>null;
        data["registry_district"] = this.registry_district !== undefined ? this.registry_district : <any>null;
        data["registry_flat"] = this.registry_flat !== undefined ? this.registry_flat : <any>null;
        data["registry_house"] = this.registry_house !== undefined ? this.registry_house : <any>null;
        data["registry_region"] = this.registry_region !== undefined ? this.registry_region : <any>null;
        data["registry_street"] = this.registry_street !== undefined ? this.registry_street : <any>null;
        data["social_type_id"] = this.social_type_id !== undefined ? this.social_type_id : <any>null;
        data["social_type_name"] = this.social_type_name !== undefined ? this.social_type_name : <any>null;
        data["source_type_id"] = this.source_type_id !== undefined ? this.source_type_id : <any>null;
        data["source_type_name"] = this.source_type_name !== undefined ? this.source_type_name : <any>null;
        return data; 
    }
}

export interface ICardPatientPartDto {
    alien_birthplace?: string | null;
    birthday?: Date | null;
    document_date?: Date | null;
    document_name?: string | null;
    document_number?: string | null;
    document_serial?: string | null;
    insurance_DMS_SMO?: string | null;
    insurance_OMS?: string | null;
    insurance_SMO?: string | null;
    is_dead?: boolean | null;
    job_place?: string | null;
    job_position?: string | null;
    patient_age_days?: number | null;
    patient_age_months?: number | null;
    patient_age_years?: number | null;
    patient_firstname?: string | null;
    patient_id?: number | null;
    patient_patronymic?: string | null;
    patient_secondname?: string | null;
    patient_sex?: number | null;
    patient_sex_name?: string | null;
    patient_type_id?: number | null;
    patient_type_name?: string | null;
    registry_building?: string | null;
    registry_city?: string | null;
    registry_country?: string | null;
    registry_district?: string | null;
    registry_flat?: string | null;
    registry_house?: string | null;
    registry_region?: string | null;
    registry_street?: string | null;
    social_type_id?: number | null;
    social_type_name?: string | null;
    source_type_id?: number | null;
    source_type_name?: string | null;
}

export class PerformerBean implements IPerformerBean {
    /** Пароль */
    clearPassword?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Логин */
    login?: string | null;
    /** Имя */
    name?: string | null;
    /** Отчество */
    patronymic?: string | null;
    /** Телефон */
    phone?: string | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Фамилия */
    surname?: string | null;
    /** Тип сотрудника */
    typeFK?: PerformerTypeBean | null;
    /** Рабочее подразделение */
    workplaceSubdivisionFK?: SubdivisionBean | null;

    constructor(data?: IPerformerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clearPassword = data["clearPassword"] !== undefined ? data["clearPassword"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.subdivisionFK = data["subdivisionFK"] ? SubdivisionBean.fromJS(data["subdivisionFK"]) : <any>null;
            this.surname = data["surname"] !== undefined ? data["surname"] : <any>null;
            this.typeFK = data["typeFK"] ? PerformerTypeBean.fromJS(data["typeFK"]) : <any>null;
            this.workplaceSubdivisionFK = data["workplaceSubdivisionFK"] ? SubdivisionBean.fromJS(data["workplaceSubdivisionFK"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerBean {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clearPassword"] = this.clearPassword !== undefined ? this.clearPassword : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["subdivisionFK"] = this.subdivisionFK ? this.subdivisionFK.toJSON() : <any>null;
        data["surname"] = this.surname !== undefined ? this.surname : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        data["workplaceSubdivisionFK"] = this.workplaceSubdivisionFK ? this.workplaceSubdivisionFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerBean {
    /** Пароль */
    clearPassword?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Логин */
    login?: string | null;
    /** Имя */
    name?: string | null;
    /** Отчество */
    patronymic?: string | null;
    /** Телефон */
    phone?: string | null;
    /** Подразделение */
    subdivisionFK?: SubdivisionBean | null;
    /** Фамилия */
    surname?: string | null;
    /** Тип сотрудника */
    typeFK?: PerformerTypeBean | null;
    /** Рабочее подразделение */
    workplaceSubdivisionFK?: SubdivisionBean | null;
}

export class TherapyTemplateDto implements ITherapyTemplateDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    text?: string | null;

    constructor(data?: ITherapyTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    text?: string | null;
}

export class CardObjectivePupilsDto implements ICardObjectivePupilsDto {
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;

    constructor(data?: ICardObjectivePupilsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.penalties_anisocoria = data["penalties_anisocoria"] !== undefined ? data["penalties_anisocoria"] : <any>null;
            this.penalties_anisocoria_name = data["penalties_anisocoria_name"] !== undefined ? data["penalties_anisocoria_name"] : <any>null;
            this.penalties_d_s_id = data["penalties_d_s_id"] !== undefined ? data["penalties_d_s_id"] : <any>null;
            this.penalties_d_s_name = data["penalties_d_s_name"] !== undefined ? data["penalties_d_s_name"] : <any>null;
            this.penalties_id = data["penalties_id"] !== undefined ? data["penalties_id"] : <any>null;
            this.penalties_light = data["penalties_light"] !== undefined ? data["penalties_light"] : <any>null;
            this.penalties_light_name = data["penalties_light_name"] !== undefined ? data["penalties_light_name"] : <any>null;
            this.penalties_name = data["penalties_name"] !== undefined ? data["penalties_name"] : <any>null;
            this.penalties_nystagmus = data["penalties_nystagmus"] !== undefined ? data["penalties_nystagmus"] : <any>null;
            this.penalties_nystagmus_name = data["penalties_nystagmus_name"] !== undefined ? data["penalties_nystagmus_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectivePupilsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectivePupilsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["penalties_anisocoria"] = this.penalties_anisocoria !== undefined ? this.penalties_anisocoria : <any>null;
        data["penalties_anisocoria_name"] = this.penalties_anisocoria_name !== undefined ? this.penalties_anisocoria_name : <any>null;
        data["penalties_d_s_id"] = this.penalties_d_s_id !== undefined ? this.penalties_d_s_id : <any>null;
        data["penalties_d_s_name"] = this.penalties_d_s_name !== undefined ? this.penalties_d_s_name : <any>null;
        data["penalties_id"] = this.penalties_id !== undefined ? this.penalties_id : <any>null;
        data["penalties_light"] = this.penalties_light !== undefined ? this.penalties_light : <any>null;
        data["penalties_light_name"] = this.penalties_light_name !== undefined ? this.penalties_light_name : <any>null;
        data["penalties_name"] = this.penalties_name !== undefined ? this.penalties_name : <any>null;
        data["penalties_nystagmus"] = this.penalties_nystagmus !== undefined ? this.penalties_nystagmus : <any>null;
        data["penalties_nystagmus_name"] = this.penalties_nystagmus_name !== undefined ? this.penalties_nystagmus_name : <any>null;
        return data; 
    }
}

export interface ICardObjectivePupilsDto {
    penalties_anisocoria?: number | null;
    penalties_anisocoria_name?: string | null;
    penalties_d_s_id?: number | null;
    penalties_d_s_name?: string | null;
    penalties_id?: number | null;
    penalties_light?: number | null;
    penalties_light_name?: string | null;
    penalties_name?: string | null;
    penalties_nystagmus?: number | null;
    penalties_nystagmus_name?: string | null;
}

export class GrantedAuthority implements IGrantedAuthority {
    authority?: string | null;

    constructor(data?: IGrantedAuthority) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authority = data["authority"] !== undefined ? data["authority"] : <any>null;
        }
    }

    static fromJS(data: any): GrantedAuthority {
        data = typeof data === 'object' ? data : {};
        let result = new GrantedAuthority();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority !== undefined ? this.authority : <any>null;
        return data; 
    }
}

export interface IGrantedAuthority {
    authority?: string | null;
}

export class Resource implements IResource {
    description?: string | null;
    file?: any | null;
    filename?: string | null;
    inputStream?: any | null;
    open?: boolean | null;
    readable?: boolean | null;
    uri?: URI | null;
    url?: URL | null;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.filename = data["filename"] !== undefined ? data["filename"] : <any>null;
            this.inputStream = data["inputStream"] !== undefined ? data["inputStream"] : <any>null;
            this.open = data["open"] !== undefined ? data["open"] : <any>null;
            this.readable = data["readable"] !== undefined ? data["readable"] : <any>null;
            this.uri = data["uri"] ? URI.fromJS(data["uri"]) : <any>null;
            this.url = data["url"] ? URL.fromJS(data["url"]) : <any>null;
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["filename"] = this.filename !== undefined ? this.filename : <any>null;
        data["inputStream"] = this.inputStream !== undefined ? this.inputStream : <any>null;
        data["open"] = this.open !== undefined ? this.open : <any>null;
        data["readable"] = this.readable !== undefined ? this.readable : <any>null;
        data["uri"] = this.uri ? this.uri.toJSON() : <any>null;
        data["url"] = this.url ? this.url.toJSON() : <any>null;
        return data; 
    }
}

export interface IResource {
    description?: string | null;
    file?: any | null;
    filename?: string | null;
    inputStream?: any | null;
    open?: boolean | null;
    readable?: boolean | null;
    uri?: URI | null;
    url?: URL | null;
}

export class Period implements IPeriod {
    date_from?: Date | null;
    date_to?: Date | null;
    id?: number | null;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date_from = data["date_from"] ? new Date(data["date_from"].toString()) : <any>null;
            this.date_to = data["date_to"] ? new Date(data["date_to"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date_from"] = this.date_from ? this.date_from.toISOString() : <any>null;
        data["date_to"] = this.date_to ? this.date_to.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IPeriod {
    date_from?: Date | null;
    date_to?: Date | null;
    id?: number | null;
}

export class PerformerScheduleDto2 implements IPerformerScheduleDto2 {
    deleted?: boolean | null;
    errors?: string[] | null;
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
    period_id?: number | null;
    period_type?: ScheduleType | null;
    scheduller_info?: PerformerScheduller | null;

    constructor(data?: IPerformerScheduleDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(item);
            }
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.period_details = data["period_details"] ? PeriodDetails.fromJS(data["period_details"]) : <any>null;
            this.period_id = data["period_id"] !== undefined ? data["period_id"] : <any>null;
            this.period_type = data["period_type"] ? ScheduleType.fromJS(data["period_type"]) : <any>null;
            this.scheduller_info = data["scheduller_info"] ? PerformerScheduller.fromJS(data["scheduller_info"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerScheduleDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerScheduleDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["period_details"] = this.period_details ? this.period_details.toJSON() : <any>null;
        data["period_id"] = this.period_id !== undefined ? this.period_id : <any>null;
        data["period_type"] = this.period_type ? this.period_type.toJSON() : <any>null;
        data["scheduller_info"] = this.scheduller_info ? this.scheduller_info.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerScheduleDto2 {
    deleted?: boolean | null;
    errors?: string[] | null;
    performer_id?: number | null;
    period_details?: PeriodDetails | null;
    period_id?: number | null;
    period_type?: ScheduleType | null;
    scheduller_info?: PerformerScheduller | null;
}

export class CardResultAssistanceResultDto implements ICardResultAssistanceResultDto {
    assistance_result_id?: number | null;
    card_result_id?: number | null;
    name?: string | null;

    constructor(data?: ICardResultAssistanceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assistance_result_id = data["assistance_result_id"] !== undefined ? data["assistance_result_id"] : <any>null;
            this.card_result_id = data["card_result_id"] !== undefined ? data["card_result_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultAssistanceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultAssistanceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assistance_result_id"] = this.assistance_result_id !== undefined ? this.assistance_result_id : <any>null;
        data["card_result_id"] = this.card_result_id !== undefined ? this.card_result_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICardResultAssistanceResultDto {
    assistance_result_id?: number | null;
    card_result_id?: number | null;
    name?: string | null;
}

export class CallFiasAddressDto implements ICallFiasAddressDto {
    call_place_id?: number | null;
    call_place_name?: string | null;
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;

    constructor(data?: ICallFiasAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_place_id = data["call_place_id"] !== undefined ? data["call_place_id"] : <any>null;
            this.call_place_name = data["call_place_name"] !== undefined ? data["call_place_name"] : <any>null;
            this.country = data["country"] ? FiasAddressObjectDto.fromJS(data["country"]) : <any>null;
            this.district = data["district"] ? FiasAddressObjectDto.fromJS(data["district"]) : <any>null;
            this.entrance = data["entrance"] !== undefined ? data["entrance"] : <any>null;
            this.entrance_code = data["entrance_code"] !== undefined ? data["entrance_code"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.floor = data["floor"] !== undefined ? data["floor"] : <any>null;
            this.fullname = data["fullname"] !== undefined ? data["fullname"] : <any>null;
            this.geometry = data["geometry"] !== undefined ? data["geometry"] : <any>null;
            this.house = data["house"] ? FiasAddressHouseDto.fromJS(data["house"]) : <any>null;
            this.region = data["region"] ? FiasAddressObjectDto.fromJS(data["region"]) : <any>null;
            this.room = data["room"] !== undefined ? data["room"] : <any>null;
            this.settlement = data["settlement"] ? FiasAddressObjectDto.fromJS(data["settlement"]) : <any>null;
            this.street = data["street"] ? FiasAddressObjectDto.fromJS(data["street"]) : <any>null;
        }
    }

    static fromJS(data: any): CallFiasAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallFiasAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_place_id"] = this.call_place_id !== undefined ? this.call_place_id : <any>null;
        data["call_place_name"] = this.call_place_name !== undefined ? this.call_place_name : <any>null;
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        data["district"] = this.district ? this.district.toJSON() : <any>null;
        data["entrance"] = this.entrance !== undefined ? this.entrance : <any>null;
        data["entrance_code"] = this.entrance_code !== undefined ? this.entrance_code : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["fullname"] = this.fullname !== undefined ? this.fullname : <any>null;
        data["geometry"] = this.geometry !== undefined ? this.geometry : <any>null;
        data["house"] = this.house ? this.house.toJSON() : <any>null;
        data["region"] = this.region ? this.region.toJSON() : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["settlement"] = this.settlement ? this.settlement.toJSON() : <any>null;
        data["street"] = this.street ? this.street.toJSON() : <any>null;
        return data; 
    }
}

export interface ICallFiasAddressDto {
    call_place_id?: number | null;
    call_place_name?: string | null;
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;
}

export class CardResultTypeDto implements ICardResultTypeDto {
    system_value?: number | null;
    type_code?: string | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;

    constructor(data?: ICardResultTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.system_value = data["system_value"] !== undefined ? data["system_value"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_comment = data["type_comment"] !== undefined ? data["type_comment"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["system_value"] = this.system_value !== undefined ? this.system_value : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_comment"] = this.type_comment !== undefined ? this.type_comment : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        return data; 
    }
}

export interface ICardResultTypeDto {
    system_value?: number | null;
    type_code?: string | null;
    type_comment?: string | null;
    type_id?: number | null;
    type_name?: string | null;
}

export class NomenclatureItem implements INomenclatureItem {
    expiryDate?: Date | null;
    id?: number | null;
    owner?: PharmacyOwner | null;
    referenceItem?: PharmacyReferenceItem | null;
    reusable?: boolean | null;
    seriesNumber?: number | null;
    type?: NomenclatureItemType | null;

    constructor(data?: INomenclatureItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.owner = data["owner"] ? PharmacyOwner.fromJS(data["owner"]) : <any>null;
            this.referenceItem = data["referenceItem"] ? PharmacyReferenceItem.fromJS(data["referenceItem"]) : <any>null;
            this.reusable = data["reusable"] !== undefined ? data["reusable"] : <any>null;
            this.seriesNumber = data["seriesNumber"] !== undefined ? data["seriesNumber"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): NomenclatureItem {
        data = typeof data === 'object' ? data : {};
        let result = new NomenclatureItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>null;
        data["referenceItem"] = this.referenceItem ? this.referenceItem.toJSON() : <any>null;
        data["reusable"] = this.reusable !== undefined ? this.reusable : <any>null;
        data["seriesNumber"] = this.seriesNumber !== undefined ? this.seriesNumber : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface INomenclatureItem {
    expiryDate?: Date | null;
    id?: number | null;
    owner?: PharmacyOwner | null;
    referenceItem?: PharmacyReferenceItem | null;
    reusable?: boolean | null;
    seriesNumber?: number | null;
    type?: NomenclatureItemType | null;
}

export class MkbDto implements IMkbDto {
    id?: number | null;
    info?: string | null;
    leaf?: boolean | null;
    name?: string | null;
    parent_id?: number | null;

    constructor(data?: IMkbDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.info = data["info"] !== undefined ? data["info"] : <any>null;
            this.leaf = data["leaf"] !== undefined ? data["leaf"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
        }
    }

    static fromJS(data: any): MkbDto {
        data = typeof data === 'object' ? data : {};
        let result = new MkbDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["info"] = this.info !== undefined ? this.info : <any>null;
        data["leaf"] = this.leaf !== undefined ? this.leaf : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        return data; 
    }
}

export interface IMkbDto {
    id?: number | null;
    info?: string | null;
    leaf?: boolean | null;
    name?: string | null;
    parent_id?: number | null;
}

export class FiasAddressDto implements IFiasAddressDto {
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;

    constructor(data?: IFiasAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.country = data["country"] ? FiasAddressObjectDto.fromJS(data["country"]) : <any>null;
            this.district = data["district"] ? FiasAddressObjectDto.fromJS(data["district"]) : <any>null;
            this.entrance = data["entrance"] !== undefined ? data["entrance"] : <any>null;
            this.entrance_code = data["entrance_code"] !== undefined ? data["entrance_code"] : <any>null;
            this.flat = data["flat"] !== undefined ? data["flat"] : <any>null;
            this.floor = data["floor"] !== undefined ? data["floor"] : <any>null;
            this.fullname = data["fullname"] !== undefined ? data["fullname"] : <any>null;
            this.geometry = data["geometry"] !== undefined ? data["geometry"] : <any>null;
            this.house = data["house"] ? FiasAddressHouseDto.fromJS(data["house"]) : <any>null;
            this.region = data["region"] ? FiasAddressObjectDto.fromJS(data["region"]) : <any>null;
            this.room = data["room"] !== undefined ? data["room"] : <any>null;
            this.settlement = data["settlement"] ? FiasAddressObjectDto.fromJS(data["settlement"]) : <any>null;
            this.street = data["street"] ? FiasAddressObjectDto.fromJS(data["street"]) : <any>null;
        }
    }

    static fromJS(data: any): FiasAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiasAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        data["district"] = this.district ? this.district.toJSON() : <any>null;
        data["entrance"] = this.entrance !== undefined ? this.entrance : <any>null;
        data["entrance_code"] = this.entrance_code !== undefined ? this.entrance_code : <any>null;
        data["flat"] = this.flat !== undefined ? this.flat : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["fullname"] = this.fullname !== undefined ? this.fullname : <any>null;
        data["geometry"] = this.geometry !== undefined ? this.geometry : <any>null;
        data["house"] = this.house ? this.house.toJSON() : <any>null;
        data["region"] = this.region ? this.region.toJSON() : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["settlement"] = this.settlement ? this.settlement.toJSON() : <any>null;
        data["street"] = this.street ? this.street.toJSON() : <any>null;
        return data; 
    }
}

export interface IFiasAddressDto {
    country?: FiasAddressObjectDto | null;
    district?: FiasAddressObjectDto | null;
    entrance?: string | null;
    entrance_code?: string | null;
    flat?: string | null;
    floor?: string | null;
    fullname?: string | null;
    geometry?: string | null;
    house?: FiasAddressHouseDto | null;
    region?: FiasAddressObjectDto | null;
    room?: string | null;
    settlement?: FiasAddressObjectDto | null;
    street?: FiasAddressObjectDto | null;
}

export class DrugDto implements IDrugDto {
    code?: string | null;
    company?: string | null;
    container?: string | null;
    container_item?: string | null;
    container_item_count?: number | null;
    country?: string | null;
    full_name?: string | null;
    group?: string | null;
    id?: number | null;
    name?: string | null;
    type?: number | null;

    constructor(data?: IDrugDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.container = data["container"] !== undefined ? data["container"] : <any>null;
            this.container_item = data["container_item"] !== undefined ? data["container_item"] : <any>null;
            this.container_item_count = data["container_item_count"] !== undefined ? data["container_item_count"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.group = data["group"] !== undefined ? data["group"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): DrugDto {
        data = typeof data === 'object' ? data : {};
        let result = new DrugDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["container"] = this.container !== undefined ? this.container : <any>null;
        data["container_item"] = this.container_item !== undefined ? this.container_item : <any>null;
        data["container_item_count"] = this.container_item_count !== undefined ? this.container_item_count : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["group"] = this.group !== undefined ? this.group : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IDrugDto {
    code?: string | null;
    company?: string | null;
    container?: string | null;
    container_item?: string | null;
    container_item_count?: number | null;
    country?: string | null;
    full_name?: string | null;
    group?: string | null;
    id?: number | null;
    name?: string | null;
    type?: number | null;
}

export class InquirerBean implements IInquirerBean {
    answer?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    parentId?: number | null;
    query?: string | null;
    reason?: string | null;

    constructor(data?: IInquirerBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer = data["answer"] !== undefined ? data["answer"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
            this.query = data["query"] !== undefined ? data["query"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerBean {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer !== undefined ? this.answer : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        data["query"] = this.query !== undefined ? this.query : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        return data; 
    }
}

export interface IInquirerBean {
    answer?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    parentId?: number | null;
    query?: string | null;
    reason?: string | null;
}

export class Performer implements IPerformer {
    adminConfig?: string | null;
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    online?: boolean | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    type?: PerformerType | null;
    typeId?: number | null;
    typeName?: string | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;

    constructor(data?: IPerformer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminConfig = data["adminConfig"] !== undefined ? data["adminConfig"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(Role.fromJS(item));
            }
            this.secondName = data["secondName"] !== undefined ? data["secondName"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            if (data["skills"] && data["skills"].constructor === Array) {
                this.skills = [];
                for (let item of data["skills"])
                    this.skills.push(Skill.fromJS(item));
            }
            this.subdivisionId = data["subdivisionId"] !== undefined ? data["subdivisionId"] : <any>null;
            this.subdivisionName = data["subdivisionName"] !== undefined ? data["subdivisionName"] : <any>null;
            this.type = data["type"] ? PerformerType.fromJS(data["type"]) : <any>null;
            this.typeId = data["typeId"] !== undefined ? data["typeId"] : <any>null;
            this.typeName = data["typeName"] !== undefined ? data["typeName"] : <any>null;
            this.userConfig = data["userConfig"] !== undefined ? data["userConfig"] : <any>null;
            this.workplaceSubdivisionId = data["workplaceSubdivisionId"] !== undefined ? data["workplaceSubdivisionId"] : <any>null;
            this.workplaceSubdivisionName = data["workplaceSubdivisionName"] !== undefined ? data["workplaceSubdivisionName"] : <any>null;
        }
    }

    static fromJS(data: any): Performer {
        data = typeof data === 'object' ? data : {};
        let result = new Performer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminConfig"] = this.adminConfig !== undefined ? this.adminConfig : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["secondName"] = this.secondName !== undefined ? this.secondName : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        if (this.skills && this.skills.constructor === Array) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        data["subdivisionId"] = this.subdivisionId !== undefined ? this.subdivisionId : <any>null;
        data["subdivisionName"] = this.subdivisionName !== undefined ? this.subdivisionName : <any>null;
        data["type"] = this.type ? this.type.toJSON() : <any>null;
        data["typeId"] = this.typeId !== undefined ? this.typeId : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["userConfig"] = this.userConfig !== undefined ? this.userConfig : <any>null;
        data["workplaceSubdivisionId"] = this.workplaceSubdivisionId !== undefined ? this.workplaceSubdivisionId : <any>null;
        data["workplaceSubdivisionName"] = this.workplaceSubdivisionName !== undefined ? this.workplaceSubdivisionName : <any>null;
        return data; 
    }
}

export interface IPerformer {
    adminConfig?: string | null;
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    firstName?: string | null;
    id?: number | null;
    login?: string | null;
    online?: boolean | null;
    password?: string | null;
    patronymic?: string | null;
    phone?: string | null;
    roles?: Role[] | null;
    secondName?: string | null;
    shortName?: string | null;
    skills?: Skill[] | null;
    subdivisionId?: number | null;
    subdivisionName?: string | null;
    type?: PerformerType | null;
    typeId?: number | null;
    typeName?: string | null;
    userConfig?: string | null;
    workplaceSubdivisionId?: number | null;
    workplaceSubdivisionName?: string | null;
}

export class PharmacyReferenceItem implements IPharmacyReferenceItem {
    barcode?: number | null;
    code?: string | null;
    company?: string | null;
    container?: string | null;
    containerItem?: string | null;
    containerItemCount?: number | null;
    country?: string | null;
    group?: string | null;
    id?: number | null;
    legalEntity?: string | null;
    name?: string | null;
    normativeDocuments?: string | null;
    productInfo?: string | null;
    regCertCancellationDate?: Date | null;
    regCertExpiryDate?: Date | null;
    regCertNumber?: string | null;
    regDate?: Date | null;
    type?: PharmacyReferenceItemType | null;

    constructor(data?: IPharmacyReferenceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barcode = data["barcode"] !== undefined ? data["barcode"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.company = data["company"] !== undefined ? data["company"] : <any>null;
            this.container = data["container"] !== undefined ? data["container"] : <any>null;
            this.containerItem = data["containerItem"] !== undefined ? data["containerItem"] : <any>null;
            this.containerItemCount = data["containerItemCount"] !== undefined ? data["containerItemCount"] : <any>null;
            this.country = data["country"] !== undefined ? data["country"] : <any>null;
            this.group = data["group"] !== undefined ? data["group"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.legalEntity = data["legalEntity"] !== undefined ? data["legalEntity"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.normativeDocuments = data["normativeDocuments"] !== undefined ? data["normativeDocuments"] : <any>null;
            this.productInfo = data["productInfo"] !== undefined ? data["productInfo"] : <any>null;
            this.regCertCancellationDate = data["regCertCancellationDate"] ? new Date(data["regCertCancellationDate"].toString()) : <any>null;
            this.regCertExpiryDate = data["regCertExpiryDate"] ? new Date(data["regCertExpiryDate"].toString()) : <any>null;
            this.regCertNumber = data["regCertNumber"] !== undefined ? data["regCertNumber"] : <any>null;
            this.regDate = data["regDate"] ? new Date(data["regDate"].toString()) : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyReferenceItem {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyReferenceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode !== undefined ? this.barcode : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["container"] = this.container !== undefined ? this.container : <any>null;
        data["containerItem"] = this.containerItem !== undefined ? this.containerItem : <any>null;
        data["containerItemCount"] = this.containerItemCount !== undefined ? this.containerItemCount : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["group"] = this.group !== undefined ? this.group : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["legalEntity"] = this.legalEntity !== undefined ? this.legalEntity : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["normativeDocuments"] = this.normativeDocuments !== undefined ? this.normativeDocuments : <any>null;
        data["productInfo"] = this.productInfo !== undefined ? this.productInfo : <any>null;
        data["regCertCancellationDate"] = this.regCertCancellationDate ? this.regCertCancellationDate.toISOString() : <any>null;
        data["regCertExpiryDate"] = this.regCertExpiryDate ? this.regCertExpiryDate.toISOString() : <any>null;
        data["regCertNumber"] = this.regCertNumber !== undefined ? this.regCertNumber : <any>null;
        data["regDate"] = this.regDate ? this.regDate.toISOString() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyReferenceItem {
    barcode?: number | null;
    code?: string | null;
    company?: string | null;
    container?: string | null;
    containerItem?: string | null;
    containerItemCount?: number | null;
    country?: string | null;
    group?: string | null;
    id?: number | null;
    legalEntity?: string | null;
    name?: string | null;
    normativeDocuments?: string | null;
    productInfo?: string | null;
    regCertCancellationDate?: Date | null;
    regCertExpiryDate?: Date | null;
    regCertNumber?: string | null;
    regDate?: Date | null;
    type?: PharmacyReferenceItemType | null;
}

export class BrigadeFindListDto implements IBrigadeFindListDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    call_id?: number | null;
    call_latitude?: number | null;
    call_longitude?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    can_use?: boolean | null;
    distanse?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    name?: string | null;
    performers?: PerformerBrigScheduleDto[] | null;
    prior?: boolean | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    recommended?: boolean | null;
    sub_id?: number | null;
    sub_short_name?: string | null;
    time?: string | null;
    transport?: TransportBrigScheduleDto | null;

    constructor(data?: IBrigadeFindListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.br_type_code = data["br_type_code"] !== undefined ? data["br_type_code"] : <any>null;
            this.br_type_id = data["br_type_id"] !== undefined ? data["br_type_id"] : <any>null;
            this.br_type_name = data["br_type_name"] !== undefined ? data["br_type_name"] : <any>null;
            this.brigade_schedule_id = data["brigade_schedule_id"] !== undefined ? data["brigade_schedule_id"] : <any>null;
            this.brigade_status_id = data["brigade_status_id"] !== undefined ? data["brigade_status_id"] : <any>null;
            this.brigade_status_name = data["brigade_status_name"] !== undefined ? data["brigade_status_name"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_latitude = data["call_latitude"] !== undefined ? data["call_latitude"] : <any>null;
            this.call_longitude = data["call_longitude"] !== undefined ? data["call_longitude"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_reason_id = data["call_reason_id"] !== undefined ? data["call_reason_id"] : <any>null;
            this.call_reason_name = data["call_reason_name"] !== undefined ? data["call_reason_name"] : <any>null;
            this.can_use = data["can_use"] !== undefined ? data["can_use"] : <any>null;
            this.distanse = data["distanse"] !== undefined ? data["distanse"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            if (data["messages"] && data["messages"].constructor === Array) {
                this.messages = [];
                for (let item of data["messages"])
                    this.messages.push(MessageEventDto.fromJS(item));
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerBrigScheduleDto.fromJS(item));
            }
            this.prior = data["prior"] !== undefined ? data["prior"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.recommended = data["recommended"] !== undefined ? data["recommended"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_short_name = data["sub_short_name"] !== undefined ? data["sub_short_name"] : <any>null;
            this.time = data["time"] !== undefined ? data["time"] : <any>null;
            this.transport = data["transport"] ? TransportBrigScheduleDto.fromJS(data["transport"]) : <any>null;
        }
    }

    static fromJS(data: any): BrigadeFindListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeFindListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_type_code"] = this.br_type_code !== undefined ? this.br_type_code : <any>null;
        data["br_type_id"] = this.br_type_id !== undefined ? this.br_type_id : <any>null;
        data["br_type_name"] = this.br_type_name !== undefined ? this.br_type_name : <any>null;
        data["brigade_schedule_id"] = this.brigade_schedule_id !== undefined ? this.brigade_schedule_id : <any>null;
        data["brigade_status_id"] = this.brigade_status_id !== undefined ? this.brigade_status_id : <any>null;
        data["brigade_status_name"] = this.brigade_status_name !== undefined ? this.brigade_status_name : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_latitude"] = this.call_latitude !== undefined ? this.call_latitude : <any>null;
        data["call_longitude"] = this.call_longitude !== undefined ? this.call_longitude : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_reason_id"] = this.call_reason_id !== undefined ? this.call_reason_id : <any>null;
        data["call_reason_name"] = this.call_reason_name !== undefined ? this.call_reason_name : <any>null;
        data["can_use"] = this.can_use !== undefined ? this.can_use : <any>null;
        data["distanse"] = this.distanse !== undefined ? this.distanse : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        if (this.messages && this.messages.constructor === Array) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["prior"] = this.prior !== undefined ? this.prior : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["recommended"] = this.recommended !== undefined ? this.recommended : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_short_name"] = this.sub_short_name !== undefined ? this.sub_short_name : <any>null;
        data["time"] = this.time !== undefined ? this.time : <any>null;
        data["transport"] = this.transport ? this.transport.toJSON() : <any>null;
        return data; 
    }
}

export interface IBrigadeFindListDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    brigade_schedule_id?: number | null;
    brigade_status_id?: number | null;
    brigade_status_name?: string | null;
    call_id?: number | null;
    call_latitude?: number | null;
    call_longitude?: number | null;
    call_number?: string | null;
    call_reason_id?: number | null;
    call_reason_name?: string | null;
    can_use?: boolean | null;
    distanse?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    messages?: MessageEventDto[] | null;
    name?: string | null;
    performers?: PerformerBrigScheduleDto[] | null;
    prior?: boolean | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    recommended?: boolean | null;
    sub_id?: number | null;
    sub_short_name?: string | null;
    time?: string | null;
    transport?: TransportBrigScheduleDto | null;
}

export class Packaging implements IPackaging {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;

    constructor(data?: IPackaging) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.product_id = data["product_id"] !== undefined ? data["product_id"] : <any>null;
            this.unit_code = data["unit_code"] !== undefined ? data["unit_code"] : <any>null;
            this.unit_count = data["unit_count"] !== undefined ? data["unit_count"] : <any>null;
        }
    }

    static fromJS(data: any): Packaging {
        data = typeof data === 'object' ? data : {};
        let result = new Packaging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["product_id"] = this.product_id !== undefined ? this.product_id : <any>null;
        data["unit_code"] = this.unit_code !== undefined ? this.unit_code : <any>null;
        data["unit_count"] = this.unit_count !== undefined ? this.unit_count : <any>null;
        return data; 
    }
}

export interface IPackaging {
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
    product_id?: number | null;
    unit_code?: string | null;
    unit_count?: number | null;
}

export class CardGeneralPartDto implements ICardGeneralPartDto {
    basic_dates?: CardBasicDatesPartDto | null;
    brigade_doctor?: CardBrigadeDoctorPartDto | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: Date | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    dispatcher_accept_id?: number | null;
    dispatcher_accept_name?: string | null;
    dispatcher_received_id?: number | null;
    dispatcher_received_name?: string | null;
    number?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    shift_senior_doctor?: CardShiftSeniorDoctorPartDto | null;
    subdivision_head_doctor?: CardSubdivisionHeadDoctorPartDto | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;

    constructor(data?: ICardGeneralPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.basic_dates = data["basic_dates"] ? CardBasicDatesPartDto.fromJS(data["basic_dates"]) : <any>null;
            this.brigade_doctor = data["brigade_doctor"] ? CardBrigadeDoctorPartDto.fromJS(data["brigade_doctor"]) : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_number = data["call_number"] !== undefined ? data["call_number"] : <any>null;
            this.call_priority = data["call_priority"] !== undefined ? data["call_priority"] : <any>null;
            this.call_priority_name = data["call_priority_name"] !== undefined ? data["call_priority_name"] : <any>null;
            this.call_type_id = data["call_type_id"] !== undefined ? data["call_type_id"] : <any>null;
            this.call_type_name = data["call_type_name"] !== undefined ? data["call_type_name"] : <any>null;
            this.card_id = data["card_id"] !== undefined ? data["card_id"] : <any>null;
            this.card_status = data["card_status"] !== undefined ? data["card_status"] : <any>null;
            this.card_status_name = data["card_status_name"] !== undefined ? data["card_status_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.deleted_date = data["deleted_date"] ? new Date(data["deleted_date"].toString()) : <any>null;
            this.deleted_message = data["deleted_message"] !== undefined ? data["deleted_message"] : <any>null;
            this.deleted_performer_id = data["deleted_performer_id"] !== undefined ? data["deleted_performer_id"] : <any>null;
            this.deleted_performer_name = data["deleted_performer_name"] !== undefined ? data["deleted_performer_name"] : <any>null;
            this.dispatcher_accept_id = data["dispatcher_accept_id"] !== undefined ? data["dispatcher_accept_id"] : <any>null;
            this.dispatcher_accept_name = data["dispatcher_accept_name"] !== undefined ? data["dispatcher_accept_name"] : <any>null;
            this.dispatcher_received_id = data["dispatcher_received_id"] !== undefined ? data["dispatcher_received_id"] : <any>null;
            this.dispatcher_received_name = data["dispatcher_received_name"] !== undefined ? data["dispatcher_received_name"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.reason_comment = data["reason_comment"] !== undefined ? data["reason_comment"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.receiving_type_id = data["receiving_type_id"] !== undefined ? data["receiving_type_id"] : <any>null;
            this.receiving_type_name = data["receiving_type_name"] !== undefined ? data["receiving_type_name"] : <any>null;
            this.shift_senior_doctor = data["shift_senior_doctor"] ? CardShiftSeniorDoctorPartDto.fromJS(data["shift_senior_doctor"]) : <any>null;
            this.subdivision_head_doctor = data["subdivision_head_doctor"] ? CardSubdivisionHeadDoctorPartDto.fromJS(data["subdivision_head_doctor"]) : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardGeneralPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardGeneralPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basic_dates"] = this.basic_dates ? this.basic_dates.toJSON() : <any>null;
        data["brigade_doctor"] = this.brigade_doctor ? this.brigade_doctor.toJSON() : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_number"] = this.call_number !== undefined ? this.call_number : <any>null;
        data["call_priority"] = this.call_priority !== undefined ? this.call_priority : <any>null;
        data["call_priority_name"] = this.call_priority_name !== undefined ? this.call_priority_name : <any>null;
        data["call_type_id"] = this.call_type_id !== undefined ? this.call_type_id : <any>null;
        data["call_type_name"] = this.call_type_name !== undefined ? this.call_type_name : <any>null;
        data["card_id"] = this.card_id !== undefined ? this.card_id : <any>null;
        data["card_status"] = this.card_status !== undefined ? this.card_status : <any>null;
        data["card_status_name"] = this.card_status_name !== undefined ? this.card_status_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["deleted_date"] = this.deleted_date ? this.deleted_date.toISOString() : <any>null;
        data["deleted_message"] = this.deleted_message !== undefined ? this.deleted_message : <any>null;
        data["deleted_performer_id"] = this.deleted_performer_id !== undefined ? this.deleted_performer_id : <any>null;
        data["deleted_performer_name"] = this.deleted_performer_name !== undefined ? this.deleted_performer_name : <any>null;
        data["dispatcher_accept_id"] = this.dispatcher_accept_id !== undefined ? this.dispatcher_accept_id : <any>null;
        data["dispatcher_accept_name"] = this.dispatcher_accept_name !== undefined ? this.dispatcher_accept_name : <any>null;
        data["dispatcher_received_id"] = this.dispatcher_received_id !== undefined ? this.dispatcher_received_id : <any>null;
        data["dispatcher_received_name"] = this.dispatcher_received_name !== undefined ? this.dispatcher_received_name : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["reason_comment"] = this.reason_comment !== undefined ? this.reason_comment : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["receiving_type_id"] = this.receiving_type_id !== undefined ? this.receiving_type_id : <any>null;
        data["receiving_type_name"] = this.receiving_type_name !== undefined ? this.receiving_type_name : <any>null;
        data["shift_senior_doctor"] = this.shift_senior_doctor ? this.shift_senior_doctor.toJSON() : <any>null;
        data["subdivision_head_doctor"] = this.subdivision_head_doctor ? this.subdivision_head_doctor.toJSON() : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        return data; 
    }
}

export interface ICardGeneralPartDto {
    basic_dates?: CardBasicDatesPartDto | null;
    brigade_doctor?: CardBrigadeDoctorPartDto | null;
    call_id?: number | null;
    call_number?: string | null;
    call_priority?: number | null;
    call_priority_name?: string | null;
    call_type_id?: number | null;
    call_type_name?: string | null;
    card_id?: number | null;
    card_status?: number | null;
    card_status_name?: string | null;
    deleted?: boolean | null;
    deleted_date?: Date | null;
    deleted_message?: string | null;
    deleted_performer_id?: number | null;
    deleted_performer_name?: string | null;
    dispatcher_accept_id?: number | null;
    dispatcher_accept_name?: string | null;
    dispatcher_received_id?: number | null;
    dispatcher_received_name?: string | null;
    number?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    reason_comment?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    receiving_type_id?: number | null;
    receiving_type_name?: string | null;
    shift_senior_doctor?: CardShiftSeniorDoctorPartDto | null;
    subdivision_head_doctor?: CardSubdivisionHeadDoctorPartDto | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
}

export class File implements IFile {
    absolute?: boolean | null;
    absoluteFile?: any | null;
    absolutePath?: string | null;
    canonicalFile?: any | null;
    canonicalPath?: string | null;
    directory?: boolean | null;
    file?: boolean | null;
    freeSpace?: number | null;
    hidden?: boolean | null;
    name?: string | null;
    parent?: string | null;
    parentFile?: any | null;
    path?: string | null;
    totalSpace?: number | null;
    usableSpace?: number | null;

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.absolute = data["absolute"] !== undefined ? data["absolute"] : <any>null;
            this.absoluteFile = data["absoluteFile"] !== undefined ? data["absoluteFile"] : <any>null;
            this.absolutePath = data["absolutePath"] !== undefined ? data["absolutePath"] : <any>null;
            this.canonicalFile = data["canonicalFile"] !== undefined ? data["canonicalFile"] : <any>null;
            this.canonicalPath = data["canonicalPath"] !== undefined ? data["canonicalPath"] : <any>null;
            this.directory = data["directory"] !== undefined ? data["directory"] : <any>null;
            this.file = data["file"] !== undefined ? data["file"] : <any>null;
            this.freeSpace = data["freeSpace"] !== undefined ? data["freeSpace"] : <any>null;
            this.hidden = data["hidden"] !== undefined ? data["hidden"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parent = data["parent"] !== undefined ? data["parent"] : <any>null;
            this.parentFile = data["parentFile"] !== undefined ? data["parentFile"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.totalSpace = data["totalSpace"] !== undefined ? data["totalSpace"] : <any>null;
            this.usableSpace = data["usableSpace"] !== undefined ? data["usableSpace"] : <any>null;
        }
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absolute"] = this.absolute !== undefined ? this.absolute : <any>null;
        data["absoluteFile"] = this.absoluteFile !== undefined ? this.absoluteFile : <any>null;
        data["absolutePath"] = this.absolutePath !== undefined ? this.absolutePath : <any>null;
        data["canonicalFile"] = this.canonicalFile !== undefined ? this.canonicalFile : <any>null;
        data["canonicalPath"] = this.canonicalPath !== undefined ? this.canonicalPath : <any>null;
        data["directory"] = this.directory !== undefined ? this.directory : <any>null;
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["freeSpace"] = this.freeSpace !== undefined ? this.freeSpace : <any>null;
        data["hidden"] = this.hidden !== undefined ? this.hidden : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parent"] = this.parent !== undefined ? this.parent : <any>null;
        data["parentFile"] = this.parentFile !== undefined ? this.parentFile : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["totalSpace"] = this.totalSpace !== undefined ? this.totalSpace : <any>null;
        data["usableSpace"] = this.usableSpace !== undefined ? this.usableSpace : <any>null;
        return data; 
    }
}

export interface IFile {
    absolute?: boolean | null;
    absoluteFile?: any | null;
    absolutePath?: string | null;
    canonicalFile?: any | null;
    canonicalPath?: string | null;
    directory?: boolean | null;
    file?: boolean | null;
    freeSpace?: number | null;
    hidden?: boolean | null;
    name?: string | null;
    parent?: string | null;
    parentFile?: any | null;
    path?: string | null;
    totalSpace?: number | null;
    usableSpace?: number | null;
}

export class CardAnamnesisEpidemicPartDto implements ICardAnamnesisEpidemicPartDto {
    infect_contacts?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;

    constructor(data?: ICardAnamnesisEpidemicPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.infect_contacts = data["infect_contacts"] !== undefined ? data["infect_contacts"] : <any>null;
            this.quarantine = data["quarantine"] !== undefined ? data["quarantine"] : <any>null;
            this.vaccination = data["vaccination"] !== undefined ? data["vaccination"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisEpidemicPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisEpidemicPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["infect_contacts"] = this.infect_contacts !== undefined ? this.infect_contacts : <any>null;
        data["quarantine"] = this.quarantine !== undefined ? this.quarantine : <any>null;
        data["vaccination"] = this.vaccination !== undefined ? this.vaccination : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisEpidemicPartDto {
    infect_contacts?: string | null;
    quarantine?: string | null;
    vaccination?: string | null;
}

export class CallGridDto implements ICallGridDto {
    address?: string | null;
    brigades?: string | null;
    call_id?: number | null;
    call_status?: number | null;
    call_status_name?: string | null;
    date?: Date | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    district_name?: string | null;
    id?: number | null;
    is_unfounded?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    number?: string | null;
    patients?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;

    constructor(data?: ICallGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.brigades = data["brigades"] !== undefined ? data["brigades"] : <any>null;
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.call_status = data["call_status"] !== undefined ? data["call_status"] : <any>null;
            this.call_status_name = data["call_status_name"] !== undefined ? data["call_status_name"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.district_name = data["district_name"] !== undefined ? data["district_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_unfounded = data["is_unfounded"] !== undefined ? data["is_unfounded"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.patients = data["patients"] !== undefined ? data["patients"] : <any>null;
            this.performer_accept_id = data["performer_accept_id"] !== undefined ? data["performer_accept_id"] : <any>null;
            this.performer_accept_name = data["performer_accept_name"] !== undefined ? data["performer_accept_name"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            this.performer_send_id = data["performer_send_id"] !== undefined ? data["performer_send_id"] : <any>null;
            this.performer_send_name = data["performer_send_name"] !== undefined ? data["performer_send_name"] : <any>null;
            this.reason_id = data["reason_id"] !== undefined ? data["reason_id"] : <any>null;
            this.reason_name = data["reason_name"] !== undefined ? data["reason_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_name = data["subdivision_name"] !== undefined ? data["subdivision_name"] : <any>null;
            this.subdivision_send_id = data["subdivision_send_id"] !== undefined ? data["subdivision_send_id"] : <any>null;
            this.subdivision_send_name = data["subdivision_send_name"] !== undefined ? data["subdivision_send_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["brigades"] = this.brigades !== undefined ? this.brigades : <any>null;
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["call_status"] = this.call_status !== undefined ? this.call_status : <any>null;
        data["call_status_name"] = this.call_status_name !== undefined ? this.call_status_name : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["district_name"] = this.district_name !== undefined ? this.district_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_unfounded"] = this.is_unfounded !== undefined ? this.is_unfounded : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["patients"] = this.patients !== undefined ? this.patients : <any>null;
        data["performer_accept_id"] = this.performer_accept_id !== undefined ? this.performer_accept_id : <any>null;
        data["performer_accept_name"] = this.performer_accept_name !== undefined ? this.performer_accept_name : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        data["performer_send_id"] = this.performer_send_id !== undefined ? this.performer_send_id : <any>null;
        data["performer_send_name"] = this.performer_send_name !== undefined ? this.performer_send_name : <any>null;
        data["reason_id"] = this.reason_id !== undefined ? this.reason_id : <any>null;
        data["reason_name"] = this.reason_name !== undefined ? this.reason_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_name"] = this.subdivision_name !== undefined ? this.subdivision_name : <any>null;
        data["subdivision_send_id"] = this.subdivision_send_id !== undefined ? this.subdivision_send_id : <any>null;
        data["subdivision_send_name"] = this.subdivision_send_name !== undefined ? this.subdivision_send_name : <any>null;
        return data; 
    }
}

export interface ICallGridDto {
    address?: string | null;
    brigades?: string | null;
    call_id?: number | null;
    call_status?: number | null;
    call_status_name?: string | null;
    date?: Date | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    district_name?: string | null;
    id?: number | null;
    is_unfounded?: boolean | null;
    latitude?: number | null;
    longitude?: number | null;
    number?: string | null;
    patients?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    reason_id?: number | null;
    reason_name?: string | null;
    subdivision_id?: number | null;
    subdivision_name?: string | null;
    subdivision_send_id?: number | null;
    subdivision_send_name?: string | null;
}

export class InquirerDto implements IInquirerDto {
    answer_title?: string | null;
    brigade_types?: number[] | null;
    extra?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_title?: string | null;

    constructor(data?: IInquirerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.answer_title = data["answer_title"] !== undefined ? data["answer_title"] : <any>null;
            if (data["brigade_types"] && data["brigade_types"].constructor === Array) {
                this.brigade_types = [];
                for (let item of data["brigade_types"])
                    this.brigade_types.push(item);
            }
            this.extra = data["extra"] !== undefined ? data["extra"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.is_editable = data["is_editable"] !== undefined ? data["is_editable"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
            this.query_title = data["query_title"] !== undefined ? data["query_title"] : <any>null;
            this.reason_title = data["reason_title"] !== undefined ? data["reason_title"] : <any>null;
        }
    }

    static fromJS(data: any): InquirerDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquirerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer_title"] = this.answer_title !== undefined ? this.answer_title : <any>null;
        if (this.brigade_types && this.brigade_types.constructor === Array) {
            data["brigade_types"] = [];
            for (let item of this.brigade_types)
                data["brigade_types"].push(item);
        }
        data["extra"] = this.extra !== undefined ? this.extra : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["is_editable"] = this.is_editable !== undefined ? this.is_editable : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        data["query_title"] = this.query_title !== undefined ? this.query_title : <any>null;
        data["reason_title"] = this.reason_title !== undefined ? this.reason_title : <any>null;
        return data; 
    }
}

export interface IInquirerDto {
    answer_title?: string | null;
    brigade_types?: number[] | null;
    extra?: boolean | null;
    id?: number | null;
    is_deleted?: boolean | null;
    is_editable?: boolean | null;
    parent_id?: number | null;
    query_title?: string | null;
    reason_title?: string | null;
}

export class SubdivisionDto implements ISubdivisionDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;

    constructor(data?: ISubdivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? FiasAddressDto.fromJS(data["address"]) : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.district_code = data["district_code"] !== undefined ? data["district_code"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.par_code = data["par_code"] !== undefined ? data["par_code"] : <any>null;
            this.par_id = data["par_id"] !== undefined ? data["par_id"] : <any>null;
            this.par_name = data["par_name"] !== undefined ? data["par_name"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
            this.type_code = data["type_code"] !== undefined ? data["type_code"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
            if (data["zone"] && data["zone"].constructor === Array) {
                this.zone = [];
                for (let item of data["zone"])
                    this.zone.push(item);
            }
        }
    }

    static fromJS(data: any): SubdivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["district_code"] = this.district_code !== undefined ? this.district_code : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["par_code"] = this.par_code !== undefined ? this.par_code : <any>null;
        data["par_id"] = this.par_id !== undefined ? this.par_id : <any>null;
        data["par_name"] = this.par_name !== undefined ? this.par_name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        data["type_code"] = this.type_code !== undefined ? this.type_code : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        if (this.zone && this.zone.constructor === Array) {
            data["zone"] = [];
            for (let item of this.zone)
                data["zone"].push(item);
        }
        return data; 
    }
}

export interface ISubdivisionDto {
    address?: FiasAddressDto | null;
    code?: string | null;
    deleted?: boolean | null;
    district_code?: string | null;
    email?: string | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    par_code?: string | null;
    par_id?: number | null;
    par_name?: string | null;
    phone?: string | null;
    picture?: string | null;
    short_name?: string | null;
    type_code?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    website?: string | null;
    zone?: number[][] | null;
}

export class PairOfBrigadeBeanAndListOfMapOfstringAndobject implements IPairOfBrigadeBeanAndListOfMapOfstringAndobject {
    first?: BrigadeBean | null;
    second?: { [key: string] : any; }[] | null;

    constructor(data?: IPairOfBrigadeBeanAndListOfMapOfstringAndobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? BrigadeBean.fromJS(data["first"]) : <any>null;
            if (data["second"] && data["second"].constructor === Array) {
                this.second = [];
                for (let item of data["second"])
                    this.second.push(item);
            }
        }
    }

    static fromJS(data: any): PairOfBrigadeBeanAndListOfMapOfstringAndobject {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfBrigadeBeanAndListOfMapOfstringAndobject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        if (this.second && this.second.constructor === Array) {
            data["second"] = [];
            for (let item of this.second)
                data["second"].push(item);
        }
        return data; 
    }
}

export interface IPairOfBrigadeBeanAndListOfMapOfstringAndobject {
    first?: BrigadeBean | null;
    second?: { [key: string] : any; }[] | null;
}

export class TransportClassDto implements ITransportClassDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;

    constructor(data?: ITransportClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TransportClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransportClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ITransportClassDto {
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    name?: string | null;
}

export class Config implements IConfig {
    app_name?: string | null;
    app_version?: string | null;
    is_admin?: boolean | null;
    is_mb?: boolean | null;
    is_smp?: boolean | null;
    is_tcmk?: boolean | null;
    is_turn_on_routing?: boolean | null;
    is_user?: boolean | null;
    map_url?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    permissions?: Permission[] | null;
    roles?: string[] | null;
    sub_id?: number | null;
    sub_name?: string | null;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.app_name = data["app_name"] !== undefined ? data["app_name"] : <any>null;
            this.app_version = data["app_version"] !== undefined ? data["app_version"] : <any>null;
            this.is_admin = data["is_admin"] !== undefined ? data["is_admin"] : <any>null;
            this.is_mb = data["is_mb"] !== undefined ? data["is_mb"] : <any>null;
            this.is_smp = data["is_smp"] !== undefined ? data["is_smp"] : <any>null;
            this.is_tcmk = data["is_tcmk"] !== undefined ? data["is_tcmk"] : <any>null;
            this.is_turn_on_routing = data["is_turn_on_routing"] !== undefined ? data["is_turn_on_routing"] : <any>null;
            this.is_user = data["is_user"] !== undefined ? data["is_user"] : <any>null;
            this.map_url = data["map_url"] !== undefined ? data["map_url"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_name = data["performer_name"] !== undefined ? data["performer_name"] : <any>null;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(Permission.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
        }
    }

    static fromJS(data: any): Config {
        data = typeof data === 'object' ? data : {};
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["app_name"] = this.app_name !== undefined ? this.app_name : <any>null;
        data["app_version"] = this.app_version !== undefined ? this.app_version : <any>null;
        data["is_admin"] = this.is_admin !== undefined ? this.is_admin : <any>null;
        data["is_mb"] = this.is_mb !== undefined ? this.is_mb : <any>null;
        data["is_smp"] = this.is_smp !== undefined ? this.is_smp : <any>null;
        data["is_tcmk"] = this.is_tcmk !== undefined ? this.is_tcmk : <any>null;
        data["is_turn_on_routing"] = this.is_turn_on_routing !== undefined ? this.is_turn_on_routing : <any>null;
        data["is_user"] = this.is_user !== undefined ? this.is_user : <any>null;
        data["map_url"] = this.map_url !== undefined ? this.map_url : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_name"] = this.performer_name !== undefined ? this.performer_name : <any>null;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        return data; 
    }
}

export interface IConfig {
    app_name?: string | null;
    app_version?: string | null;
    is_admin?: boolean | null;
    is_mb?: boolean | null;
    is_smp?: boolean | null;
    is_tcmk?: boolean | null;
    is_turn_on_routing?: boolean | null;
    is_user?: boolean | null;
    map_url?: string | null;
    performer_id?: number | null;
    performer_name?: string | null;
    permissions?: Permission[] | null;
    roles?: string[] | null;
    sub_id?: number | null;
    sub_name?: string | null;
}

export class ModelAndView implements IModelAndView {
    empty?: boolean | null;
    model?: any | null;
    modelMap?: { [key: string] : any; } | null;
    reference?: boolean | null;
    status?: ModelAndViewStatus | null;
    view?: View | null;
    viewName?: string | null;

    constructor(data?: IModelAndView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.empty = data["empty"] !== undefined ? data["empty"] : <any>null;
            this.model = data["model"] !== undefined ? data["model"] : <any>null;
            if (data["modelMap"]) {
                this.modelMap = {};
                for (let key in data["modelMap"]) {
                    if (data["modelMap"].hasOwnProperty(key))
                        this.modelMap[key] = data["modelMap"][key];
                }
            }
            this.reference = data["reference"] !== undefined ? data["reference"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.view = data["view"] ? View.fromJS(data["view"]) : <any>null;
            this.viewName = data["viewName"] !== undefined ? data["viewName"] : <any>null;
        }
    }

    static fromJS(data: any): ModelAndView {
        data = typeof data === 'object' ? data : {};
        let result = new ModelAndView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empty"] = this.empty !== undefined ? this.empty : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        if (this.modelMap) {
            data["modelMap"] = {};
            for (let key in this.modelMap) {
                if (this.modelMap.hasOwnProperty(key))
                    data["modelMap"][key] = this.modelMap[key] !== undefined ? this.modelMap[key] : <any>null;
            }
        }
        data["reference"] = this.reference !== undefined ? this.reference : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["view"] = this.view ? this.view.toJSON() : <any>null;
        data["viewName"] = this.viewName !== undefined ? this.viewName : <any>null;
        return data; 
    }
}

export interface IModelAndView {
    empty?: boolean | null;
    model?: any | null;
    modelMap?: { [key: string] : any; } | null;
    reference?: boolean | null;
    status?: ModelAndViewStatus | null;
    view?: View | null;
    viewName?: string | null;
}

export class CallTransferDto implements ICallTransferDto {
    call_id?: number | null;
    date_accept?: Date | null;
    date_create?: Date | null;
    date_received?: Date | null;
    id?: number | null;
    number?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    recommended_brigades?: BrigadeScheduleDto[] | null;
    sub_from_id?: number | null;
    sub_from_name?: string | null;
    sub_to_id?: number | null;
    sub_to_name?: string | null;

    constructor(data?: ICallTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.call_id = data["call_id"] !== undefined ? data["call_id"] : <any>null;
            this.date_accept = data["date_accept"] ? new Date(data["date_accept"].toString()) : <any>null;
            this.date_create = data["date_create"] ? new Date(data["date_create"].toString()) : <any>null;
            this.date_received = data["date_received"] ? new Date(data["date_received"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.number = data["number"] !== undefined ? data["number"] : <any>null;
            this.performer_accept_id = data["performer_accept_id"] !== undefined ? data["performer_accept_id"] : <any>null;
            this.performer_accept_name = data["performer_accept_name"] !== undefined ? data["performer_accept_name"] : <any>null;
            this.performer_send_id = data["performer_send_id"] !== undefined ? data["performer_send_id"] : <any>null;
            this.performer_send_name = data["performer_send_name"] !== undefined ? data["performer_send_name"] : <any>null;
            if (data["recommended_brigades"] && data["recommended_brigades"].constructor === Array) {
                this.recommended_brigades = [];
                for (let item of data["recommended_brigades"])
                    this.recommended_brigades.push(BrigadeScheduleDto.fromJS(item));
            }
            this.sub_from_id = data["sub_from_id"] !== undefined ? data["sub_from_id"] : <any>null;
            this.sub_from_name = data["sub_from_name"] !== undefined ? data["sub_from_name"] : <any>null;
            this.sub_to_id = data["sub_to_id"] !== undefined ? data["sub_to_id"] : <any>null;
            this.sub_to_name = data["sub_to_name"] !== undefined ? data["sub_to_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["call_id"] = this.call_id !== undefined ? this.call_id : <any>null;
        data["date_accept"] = this.date_accept ? this.date_accept.toISOString() : <any>null;
        data["date_create"] = this.date_create ? this.date_create.toISOString() : <any>null;
        data["date_received"] = this.date_received ? this.date_received.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["performer_accept_id"] = this.performer_accept_id !== undefined ? this.performer_accept_id : <any>null;
        data["performer_accept_name"] = this.performer_accept_name !== undefined ? this.performer_accept_name : <any>null;
        data["performer_send_id"] = this.performer_send_id !== undefined ? this.performer_send_id : <any>null;
        data["performer_send_name"] = this.performer_send_name !== undefined ? this.performer_send_name : <any>null;
        if (this.recommended_brigades && this.recommended_brigades.constructor === Array) {
            data["recommended_brigades"] = [];
            for (let item of this.recommended_brigades)
                data["recommended_brigades"].push(item.toJSON());
        }
        data["sub_from_id"] = this.sub_from_id !== undefined ? this.sub_from_id : <any>null;
        data["sub_from_name"] = this.sub_from_name !== undefined ? this.sub_from_name : <any>null;
        data["sub_to_id"] = this.sub_to_id !== undefined ? this.sub_to_id : <any>null;
        data["sub_to_name"] = this.sub_to_name !== undefined ? this.sub_to_name : <any>null;
        return data; 
    }
}

export interface ICallTransferDto {
    call_id?: number | null;
    date_accept?: Date | null;
    date_create?: Date | null;
    date_received?: Date | null;
    id?: number | null;
    number?: string | null;
    performer_accept_id?: number | null;
    performer_accept_name?: string | null;
    performer_send_id?: number | null;
    performer_send_name?: string | null;
    recommended_brigades?: BrigadeScheduleDto[] | null;
    sub_from_id?: number | null;
    sub_from_name?: string | null;
    sub_to_id?: number | null;
    sub_to_name?: string | null;
}

export class CardResultEkg implements ICardResultEkg {
    ekg_ch_s_s?: number | null;
    ekg_comments?: string | null;
    ekg_rhythm?: string | null;

    constructor(data?: ICardResultEkg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ekg_ch_s_s = data["ekg_ch_s_s"] !== undefined ? data["ekg_ch_s_s"] : <any>null;
            this.ekg_comments = data["ekg_comments"] !== undefined ? data["ekg_comments"] : <any>null;
            this.ekg_rhythm = data["ekg_rhythm"] !== undefined ? data["ekg_rhythm"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultEkg {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultEkg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ekg_ch_s_s"] = this.ekg_ch_s_s !== undefined ? this.ekg_ch_s_s : <any>null;
        data["ekg_comments"] = this.ekg_comments !== undefined ? this.ekg_comments : <any>null;
        data["ekg_rhythm"] = this.ekg_rhythm !== undefined ? this.ekg_rhythm : <any>null;
        return data; 
    }
}

export interface ICardResultEkg {
    ekg_ch_s_s?: number | null;
    ekg_comments?: string | null;
    ekg_rhythm?: string | null;
}

export class PairOfTransportBeanAndListOfBrigadeTransportScheduleBean implements IPairOfTransportBeanAndListOfBrigadeTransportScheduleBean {
    first?: TransportBean | null;
    second?: BrigadeTransportScheduleBean[] | null;

    constructor(data?: IPairOfTransportBeanAndListOfBrigadeTransportScheduleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.first = data["first"] ? TransportBean.fromJS(data["first"]) : <any>null;
            if (data["second"] && data["second"].constructor === Array) {
                this.second = [];
                for (let item of data["second"])
                    this.second.push(BrigadeTransportScheduleBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PairOfTransportBeanAndListOfBrigadeTransportScheduleBean {
        data = typeof data === 'object' ? data : {};
        let result = new PairOfTransportBeanAndListOfBrigadeTransportScheduleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first"] = this.first ? this.first.toJSON() : <any>null;
        if (this.second && this.second.constructor === Array) {
            data["second"] = [];
            for (let item of this.second)
                data["second"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPairOfTransportBeanAndListOfBrigadeTransportScheduleBean {
    first?: TransportBean | null;
    second?: BrigadeTransportScheduleBean[] | null;
}

export class CardBrigadePartDto implements ICardBrigadePartDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;

    constructor(data?: ICardBrigadePartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.br_type_code = data["br_type_code"] !== undefined ? data["br_type_code"] : <any>null;
            this.br_type_id = data["br_type_id"] !== undefined ? data["br_type_id"] : <any>null;
            this.br_type_name = data["br_type_name"] !== undefined ? data["br_type_name"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["performers"] && data["performers"].constructor === Array) {
                this.performers = [];
                for (let item of data["performers"])
                    this.performers.push(PerformerDto.fromJS(item));
            }
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.sub_code = data["sub_code"] !== undefined ? data["sub_code"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.transport_id = data["transport_id"] !== undefined ? data["transport_id"] : <any>null;
            this.transport_statemark = data["transport_statemark"] !== undefined ? data["transport_statemark"] : <any>null;
            this.workplace_id = data["workplace_id"] !== undefined ? data["workplace_id"] : <any>null;
            this.workplace_name = data["workplace_name"] !== undefined ? data["workplace_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardBrigadePartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardBrigadePartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_type_code"] = this.br_type_code !== undefined ? this.br_type_code : <any>null;
        data["br_type_id"] = this.br_type_id !== undefined ? this.br_type_id : <any>null;
        data["br_type_name"] = this.br_type_name !== undefined ? this.br_type_name : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.performers && this.performers.constructor === Array) {
            data["performers"] = [];
            for (let item of this.performers)
                data["performers"].push(item.toJSON());
        }
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["sub_code"] = this.sub_code !== undefined ? this.sub_code : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["transport_id"] = this.transport_id !== undefined ? this.transport_id : <any>null;
        data["transport_statemark"] = this.transport_statemark !== undefined ? this.transport_statemark : <any>null;
        data["workplace_id"] = this.workplace_id !== undefined ? this.workplace_id : <any>null;
        data["workplace_name"] = this.workplace_name !== undefined ? this.workplace_name : <any>null;
        return data; 
    }
}

export interface ICardBrigadePartDto {
    br_type_code?: string | null;
    br_type_id?: number | null;
    br_type_name?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    performers?: PerformerDto[] | null;
    picture?: string | null;
    sub_code?: string | null;
    sub_id?: number | null;
    transport_id?: number | null;
    transport_statemark?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;
}

export class ClassMkbBean implements IClassMkbBean {
    additionalInfo?: string | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parentCode?: string | null;
    parentFK?: ClassMkbBean | null;
    parentId?: number | null;

    constructor(data?: IClassMkbBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionalInfo = data["additionalInfo"] !== undefined ? data["additionalInfo"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.nodeCount = data["nodeCount"] !== undefined ? data["nodeCount"] : <any>null;
            this.parentCode = data["parentCode"] !== undefined ? data["parentCode"] : <any>null;
            this.parentFK = data["parentFK"] ? ClassMkbBean.fromJS(data["parentFK"]) : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
        }
    }

    static fromJS(data: any): ClassMkbBean {
        data = typeof data === 'object' ? data : {};
        let result = new ClassMkbBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalInfo"] = this.additionalInfo !== undefined ? this.additionalInfo : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nodeCount"] = this.nodeCount !== undefined ? this.nodeCount : <any>null;
        data["parentCode"] = this.parentCode !== undefined ? this.parentCode : <any>null;
        data["parentFK"] = this.parentFK ? this.parentFK.toJSON() : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        return data; 
    }
}

export interface IClassMkbBean {
    additionalInfo?: string | null;
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    nodeCount?: number | null;
    parentCode?: string | null;
    parentFK?: ClassMkbBean | null;
    parentId?: number | null;
}

export class PharmacyMatrixGroupDto implements IPharmacyMatrixGroupDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;

    constructor(data?: IPharmacyMatrixGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.group_id = data["group_id"] !== undefined ? data["group_id"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyMatrixGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyMatrixGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["group_id"] = this.group_id !== undefined ? this.group_id : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IPharmacyMatrixGroupDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    group_id?: number | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
}

export class BrigadeDutyRequestDto implements IBrigadeDutyRequestDto {
    comment?: string | null;
    date?: Date | null;
    pharmacy_package_id?: number | null;

    constructor(data?: IBrigadeDutyRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"] !== undefined ? data["comment"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.pharmacy_package_id = data["pharmacy_package_id"] !== undefined ? data["pharmacy_package_id"] : <any>null;
        }
    }

    static fromJS(data: any): BrigadeDutyRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrigadeDutyRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment !== undefined ? this.comment : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["pharmacy_package_id"] = this.pharmacy_package_id !== undefined ? this.pharmacy_package_id : <any>null;
        return data; 
    }
}

export interface IBrigadeDutyRequestDto {
    comment?: string | null;
    date?: Date | null;
    pharmacy_package_id?: number | null;
}

export class CardResultTherapyPartDto implements ICardResultTherapyPartDto {
    therapy?: string | null;

    constructor(data?: ICardResultTherapyPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.therapy = data["therapy"] !== undefined ? data["therapy"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultTherapyPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultTherapyPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["therapy"] = this.therapy !== undefined ? this.therapy : <any>null;
        return data; 
    }
}

export interface ICardResultTherapyPartDto {
    therapy?: string | null;
}

export class PharmacyCounterpartyDto implements IPharmacyCounterpartyDto {
    id?: number | null;
    is_deleted?: boolean | null;
    name?: string | null;
    parent_id?: string | null;

    constructor(data?: IPharmacyCounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.is_deleted = data["is_deleted"] !== undefined ? data["is_deleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parent_id = data["parent_id"] !== undefined ? data["parent_id"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyCounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyCounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["is_deleted"] = this.is_deleted !== undefined ? this.is_deleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parent_id"] = this.parent_id !== undefined ? this.parent_id : <any>null;
        return data; 
    }
}

export interface IPharmacyCounterpartyDto {
    id?: number | null;
    is_deleted?: boolean | null;
    name?: string | null;
    parent_id?: string | null;
}

export class PharmacyMatrixItemDto implements IPharmacyMatrixItemDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    type?: number | null;

    constructor(data?: IPharmacyMatrixItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.matrix_id = data["matrix_id"] !== undefined ? data["matrix_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
        }
    }

    static fromJS(data: any): PharmacyMatrixItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PharmacyMatrixItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["matrix_id"] = this.matrix_id !== undefined ? this.matrix_id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface IPharmacyMatrixItemDto {
    amount?: number | null;
    code?: string | null;
    deleted?: boolean | null;
    id?: number | null;
    matrix_id?: number | null;
    name?: string | null;
    type?: number | null;
}

export class SendBagDto implements ISendBagDto {
    bag_id?: number | null;
    brigade_id?: number | null;

    constructor(data?: ISendBagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bag_id = data["bag_id"] !== undefined ? data["bag_id"] : <any>null;
            this.brigade_id = data["brigade_id"] !== undefined ? data["brigade_id"] : <any>null;
        }
    }

    static fromJS(data: any): SendBagDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendBagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bag_id"] = this.bag_id !== undefined ? this.bag_id : <any>null;
        data["brigade_id"] = this.brigade_id !== undefined ? this.brigade_id : <any>null;
        return data; 
    }
}

export interface ISendBagDto {
    bag_id?: number | null;
    brigade_id?: number | null;
}

export class ListContainerOfBrigadeStatusBean implements IListContainerOfBrigadeStatusBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListContainerOfBrigadeStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.list = data["list"] !== undefined ? data["list"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListContainerOfBrigadeStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListContainerOfBrigadeStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list !== undefined ? this.list : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListContainerOfBrigadeStatusBean {
    list?: any | null;
    size?: number | null;
    total?: number | null;
}

export class CardObjectiveTonguePart implements ICardObjectiveTonguePart {
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;

    constructor(data?: ICardObjectiveTonguePart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tongue_clean_furred = data["tongue_clean_furred"] !== undefined ? data["tongue_clean_furred"] : <any>null;
            this.tongue_clean_furred_name = data["tongue_clean_furred_name"] !== undefined ? data["tongue_clean_furred_name"] : <any>null;
            this.tongue_weat_dry = data["tongue_weat_dry"] !== undefined ? data["tongue_weat_dry"] : <any>null;
            this.tongue_weat_dry_name = data["tongue_weat_dry_name"] !== undefined ? data["tongue_weat_dry_name"] : <any>null;
        }
    }

    static fromJS(data: any): CardObjectiveTonguePart {
        data = typeof data === 'object' ? data : {};
        let result = new CardObjectiveTonguePart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tongue_clean_furred"] = this.tongue_clean_furred !== undefined ? this.tongue_clean_furred : <any>null;
        data["tongue_clean_furred_name"] = this.tongue_clean_furred_name !== undefined ? this.tongue_clean_furred_name : <any>null;
        data["tongue_weat_dry"] = this.tongue_weat_dry !== undefined ? this.tongue_weat_dry : <any>null;
        data["tongue_weat_dry_name"] = this.tongue_weat_dry_name !== undefined ? this.tongue_weat_dry_name : <any>null;
        return data; 
    }
}

export interface ICardObjectiveTonguePart {
    tongue_clean_furred?: number | null;
    tongue_clean_furred_name?: string | null;
    tongue_weat_dry?: number | null;
    tongue_weat_dry_name?: string | null;
}

export class CallDeclarantPartDto implements ICallDeclarantPartDto {
    audio_file_name?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;

    constructor(data?: ICallDeclarantPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audio_file_name = data["audio_file_name"] !== undefined ? data["audio_file_name"] : <any>null;
            this.declarant_name = data["declarant_name"] !== undefined ? data["declarant_name"] : <any>null;
            this.declarant_phone = data["declarant_phone"] !== undefined ? data["declarant_phone"] : <any>null;
            this.declarant_type_id = data["declarant_type_id"] !== undefined ? data["declarant_type_id"] : <any>null;
            this.declarant_type_name = data["declarant_type_name"] !== undefined ? data["declarant_type_name"] : <any>null;
        }
    }

    static fromJS(data: any): CallDeclarantPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CallDeclarantPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audio_file_name"] = this.audio_file_name !== undefined ? this.audio_file_name : <any>null;
        data["declarant_name"] = this.declarant_name !== undefined ? this.declarant_name : <any>null;
        data["declarant_phone"] = this.declarant_phone !== undefined ? this.declarant_phone : <any>null;
        data["declarant_type_id"] = this.declarant_type_id !== undefined ? this.declarant_type_id : <any>null;
        data["declarant_type_name"] = this.declarant_type_name !== undefined ? this.declarant_type_name : <any>null;
        return data; 
    }
}

export interface ICallDeclarantPartDto {
    audio_file_name?: string | null;
    declarant_name?: string | null;
    declarant_phone?: string | null;
    declarant_type_id?: number | null;
    declarant_type_name?: string | null;
}

export class TherapyTemplateBean implements ITherapyTemplateBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Комментарий */
    text?: string | null;

    constructor(data?: ITherapyTemplateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.text = data["text"] !== undefined ? data["text"] : <any>null;
        }
    }

    static fromJS(data: any): TherapyTemplateBean {
        data = typeof data === 'object' ? data : {};
        let result = new TherapyTemplateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data; 
    }
}

export interface ITherapyTemplateBean {
    code?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    name?: string | null;
    /** Комментарий */
    text?: string | null;
}

export class LogDto implements ILogDto {
    action_type?: string | null;
    date?: Date | null;
    description?: string | null;
    id?: number | null;
    item_id?: number | null;
    item_type?: string | null;
    log_type?: string | null;
    performer_id?: number | null;
    performer_short_name?: string | null;
    subdivision_id?: number | null;
    subdivision_short_name?: string | null;
    transmit_error_text?: string | null;
    transmit_status?: string | null;

    constructor(data?: ILogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action_type = data["action_type"] !== undefined ? data["action_type"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.item_id = data["item_id"] !== undefined ? data["item_id"] : <any>null;
            this.item_type = data["item_type"] !== undefined ? data["item_type"] : <any>null;
            this.log_type = data["log_type"] !== undefined ? data["log_type"] : <any>null;
            this.performer_id = data["performer_id"] !== undefined ? data["performer_id"] : <any>null;
            this.performer_short_name = data["performer_short_name"] !== undefined ? data["performer_short_name"] : <any>null;
            this.subdivision_id = data["subdivision_id"] !== undefined ? data["subdivision_id"] : <any>null;
            this.subdivision_short_name = data["subdivision_short_name"] !== undefined ? data["subdivision_short_name"] : <any>null;
            this.transmit_error_text = data["transmit_error_text"] !== undefined ? data["transmit_error_text"] : <any>null;
            this.transmit_status = data["transmit_status"] !== undefined ? data["transmit_status"] : <any>null;
        }
    }

    static fromJS(data: any): LogDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action_type"] = this.action_type !== undefined ? this.action_type : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["item_id"] = this.item_id !== undefined ? this.item_id : <any>null;
        data["item_type"] = this.item_type !== undefined ? this.item_type : <any>null;
        data["log_type"] = this.log_type !== undefined ? this.log_type : <any>null;
        data["performer_id"] = this.performer_id !== undefined ? this.performer_id : <any>null;
        data["performer_short_name"] = this.performer_short_name !== undefined ? this.performer_short_name : <any>null;
        data["subdivision_id"] = this.subdivision_id !== undefined ? this.subdivision_id : <any>null;
        data["subdivision_short_name"] = this.subdivision_short_name !== undefined ? this.subdivision_short_name : <any>null;
        data["transmit_error_text"] = this.transmit_error_text !== undefined ? this.transmit_error_text : <any>null;
        data["transmit_status"] = this.transmit_status !== undefined ? this.transmit_status : <any>null;
        return data; 
    }
}

export interface ILogDto {
    action_type?: string | null;
    date?: Date | null;
    description?: string | null;
    id?: number | null;
    item_id?: number | null;
    item_type?: string | null;
    log_type?: string | null;
    performer_id?: number | null;
    performer_short_name?: string | null;
    subdivision_id?: number | null;
    subdivision_short_name?: string | null;
    transmit_error_text?: string | null;
    transmit_status?: string | null;
}

export class MobileCardChronic implements IMobileCardChronic {
    date?: Date | null;
    diagnosis?: string | null;
    doctor?: string | null;
    reason?: string | null;
    result?: string | null;

    constructor(data?: IMobileCardChronic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
            this.diagnosis = data["diagnosis"] !== undefined ? data["diagnosis"] : <any>null;
            this.doctor = data["doctor"] !== undefined ? data["doctor"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.result = data["result"] !== undefined ? data["result"] : <any>null;
        }
    }

    static fromJS(data: any): MobileCardChronic {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCardChronic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["diagnosis"] = this.diagnosis !== undefined ? this.diagnosis : <any>null;
        data["doctor"] = this.doctor !== undefined ? this.doctor : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["result"] = this.result !== undefined ? this.result : <any>null;
        return data; 
    }
}

export interface IMobileCardChronic {
    date?: Date | null;
    diagnosis?: string | null;
    doctor?: string | null;
    reason?: string | null;
    result?: string | null;
}

export class FiasAddressObjectDto implements IFiasAddressObjectDto {
    code?: string | null;
    full_name?: string | null;
    name?: string | null;

    constructor(data?: IFiasAddressObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): FiasAddressObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiasAddressObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["full_name"] = this.full_name !== undefined ? this.full_name : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IFiasAddressObjectDto {
    code?: string | null;
    full_name?: string | null;
    name?: string | null;
}

export class CardAnamnesisGynecologicPartDto implements ICardAnamnesisGynecologicPartDto {
    gynecologic_anamnesis?: string | null;

    constructor(data?: ICardAnamnesisGynecologicPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gynecologic_anamnesis = data["gynecologic_anamnesis"] !== undefined ? data["gynecologic_anamnesis"] : <any>null;
        }
    }

    static fromJS(data: any): CardAnamnesisGynecologicPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardAnamnesisGynecologicPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gynecologic_anamnesis"] = this.gynecologic_anamnesis !== undefined ? this.gynecologic_anamnesis : <any>null;
        return data; 
    }
}

export interface ICardAnamnesisGynecologicPartDto {
    gynecologic_anamnesis?: string | null;
}

export class PerformerType implements IPerformerType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    groupCode?: PerformerTypeGroupCode | null;
    id?: number | null;
    name?: string | null;
    shortName?: string | null;

    constructor(data?: IPerformerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.editable = data["editable"] !== undefined ? data["editable"] : <any>null;
            this.groupCode = data["groupCode"] !== undefined ? data["groupCode"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerType {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["editable"] = this.editable !== undefined ? this.editable : <any>null;
        data["groupCode"] = this.groupCode !== undefined ? this.groupCode : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        return data; 
    }
}

export interface IPerformerType {
    code?: string | null;
    deleted?: boolean | null;
    editable?: boolean | null;
    groupCode?: PerformerTypeGroupCode | null;
    id?: number | null;
    name?: string | null;
    shortName?: string | null;
}

export class ListDtoOfRole implements IListDtoOfRole {
    list?: Role[] | null;
    size?: number | null;
    total?: number | null;

    constructor(data?: IListDtoOfRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [];
                for (let item of data["list"])
                    this.list.push(Role.fromJS(item));
            }
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
        }
    }

    static fromJS(data: any): ListDtoOfRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListDtoOfRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data; 
    }
}

export interface IListDtoOfRole {
    list?: Role[] | null;
    size?: number | null;
    total?: number | null;
}

export class SubdivisionBean implements ISubdivisionBean {
    carPicture?: string | null;
    code?: string | null;
    district?: number | null;
    /** Тип подразделения */
    districtFK?: DistrictBean | null;
    email?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    parentId?: number | null;
    phone?: string | null;
    picture?: string | null;
    shortName?: string | null;
    type?: number | null;
    /** Тип подразделения */
    typeFK?: SubdivisionTypeBean | null;
    website?: string | null;

    constructor(data?: ISubdivisionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.carPicture = data["carPicture"] !== undefined ? data["carPicture"] : <any>null;
            this.code = data["code"] !== undefined ? data["code"] : <any>null;
            this.district = data["district"] !== undefined ? data["district"] : <any>null;
            this.districtFK = data["districtFK"] ? DistrictBean.fromJS(data["districtFK"]) : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.location = data["location"] !== undefined ? data["location"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.parentId = data["parentId"] !== undefined ? data["parentId"] : <any>null;
            this.phone = data["phone"] !== undefined ? data["phone"] : <any>null;
            this.picture = data["picture"] !== undefined ? data["picture"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.typeFK = data["typeFK"] ? SubdivisionTypeBean.fromJS(data["typeFK"]) : <any>null;
            this.website = data["website"] !== undefined ? data["website"] : <any>null;
        }
    }

    static fromJS(data: any): SubdivisionBean {
        data = typeof data === 'object' ? data : {};
        let result = new SubdivisionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carPicture"] = this.carPicture !== undefined ? this.carPicture : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["district"] = this.district !== undefined ? this.district : <any>null;
        data["districtFK"] = this.districtFK ? this.districtFK.toJSON() : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["typeFK"] = this.typeFK ? this.typeFK.toJSON() : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        return data; 
    }
}

export interface ISubdivisionBean {
    carPicture?: string | null;
    code?: string | null;
    district?: number | null;
    /** Тип подразделения */
    districtFK?: DistrictBean | null;
    email?: string | null;
    id?: number | null;
    isDeleted?: boolean | null;
    /** Местоположение */
    location?: string | null;
    name?: string | null;
    parentId?: number | null;
    phone?: string | null;
    picture?: string | null;
    shortName?: string | null;
    type?: number | null;
    /** Тип подразделения */
    typeFK?: SubdivisionTypeBean | null;
    website?: string | null;
}

export class CardResultMaterialsDto implements ICardResultMaterialsDto {
    bandages?: number | null;
    catheters?: number | null;
    other_materials?: string | null;
    syringes?: number | null;
    transfusion_systems?: number | null;

    constructor(data?: ICardResultMaterialsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bandages = data["bandages"] !== undefined ? data["bandages"] : <any>null;
            this.catheters = data["catheters"] !== undefined ? data["catheters"] : <any>null;
            this.other_materials = data["other_materials"] !== undefined ? data["other_materials"] : <any>null;
            this.syringes = data["syringes"] !== undefined ? data["syringes"] : <any>null;
            this.transfusion_systems = data["transfusion_systems"] !== undefined ? data["transfusion_systems"] : <any>null;
        }
    }

    static fromJS(data: any): CardResultMaterialsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardResultMaterialsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bandages"] = this.bandages !== undefined ? this.bandages : <any>null;
        data["catheters"] = this.catheters !== undefined ? this.catheters : <any>null;
        data["other_materials"] = this.other_materials !== undefined ? this.other_materials : <any>null;
        data["syringes"] = this.syringes !== undefined ? this.syringes : <any>null;
        data["transfusion_systems"] = this.transfusion_systems !== undefined ? this.transfusion_systems : <any>null;
        return data; 
    }
}

export interface ICardResultMaterialsDto {
    bandages?: number | null;
    catheters?: number | null;
    other_materials?: string | null;
    syringes?: number | null;
    transfusion_systems?: number | null;
}

export class Response implements IResponse {
    errorMessage?: string | null;
    guid?: string | null;
    items?: any[] | null;
    status?: number | null;
    success?: boolean | null;
    totalCount?: number | null;
    validationErrors?: { [key: string] : string; } | null;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorMessage = data["errorMessage"] !== undefined ? data["errorMessage"] : <any>null;
            this.guid = data["guid"] !== undefined ? data["guid"] : <any>null;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(item);
            }
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            this.totalCount = data["totalCount"] !== undefined ? data["totalCount"] : <any>null;
            if (data["validationErrors"]) {
                this.validationErrors = {};
                for (let key in data["validationErrors"]) {
                    if (data["validationErrors"].hasOwnProperty(key))
                        this.validationErrors[key] = data["validationErrors"][key];
                }
            }
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["guid"] = this.guid !== undefined ? this.guid : <any>null;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (this.validationErrors) {
            data["validationErrors"] = {};
            for (let key in this.validationErrors) {
                if (this.validationErrors.hasOwnProperty(key))
                    data["validationErrors"][key] = this.validationErrors[key] !== undefined ? this.validationErrors[key] : <any>null;
            }
        }
        return data; 
    }
}

export interface IResponse {
    errorMessage?: string | null;
    guid?: string | null;
    items?: any[] | null;
    status?: number | null;
    success?: boolean | null;
    totalCount?: number | null;
    validationErrors?: { [key: string] : string; } | null;
}

export class PerformerDto implements IPerformerDto {
    admin_config?: string | null;
    change_password?: boolean | null;
    deleted?: boolean | null;
    first_name?: string | null;
    id?: number | null;
    login?: string | null;
    online?: boolean | null;
    password?: string | null;
    password2?: string | null;
    patronymic?: string | null;
    roles?: string | null;
    second_name?: string | null;
    short_name?: string | null;
    skills?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    user_config?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;

    constructor(data?: IPerformerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.admin_config = data["admin_config"] !== undefined ? data["admin_config"] : <any>null;
            this.change_password = data["change_password"] !== undefined ? data["change_password"] : <any>null;
            this.deleted = data["deleted"] !== undefined ? data["deleted"] : <any>null;
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.login = data["login"] !== undefined ? data["login"] : <any>null;
            this.online = data["online"] !== undefined ? data["online"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.password2 = data["password2"] !== undefined ? data["password2"] : <any>null;
            this.patronymic = data["patronymic"] !== undefined ? data["patronymic"] : <any>null;
            this.roles = data["roles"] !== undefined ? data["roles"] : <any>null;
            this.second_name = data["second_name"] !== undefined ? data["second_name"] : <any>null;
            this.short_name = data["short_name"] !== undefined ? data["short_name"] : <any>null;
            this.skills = data["skills"] !== undefined ? data["skills"] : <any>null;
            this.sub_id = data["sub_id"] !== undefined ? data["sub_id"] : <any>null;
            this.sub_name = data["sub_name"] !== undefined ? data["sub_name"] : <any>null;
            this.type_id = data["type_id"] !== undefined ? data["type_id"] : <any>null;
            this.type_name = data["type_name"] !== undefined ? data["type_name"] : <any>null;
            this.user_config = data["user_config"] !== undefined ? data["user_config"] : <any>null;
            this.workplace_id = data["workplace_id"] !== undefined ? data["workplace_id"] : <any>null;
            this.workplace_name = data["workplace_name"] !== undefined ? data["workplace_name"] : <any>null;
        }
    }

    static fromJS(data: any): PerformerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin_config"] = this.admin_config !== undefined ? this.admin_config : <any>null;
        data["change_password"] = this.change_password !== undefined ? this.change_password : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["online"] = this.online !== undefined ? this.online : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["password2"] = this.password2 !== undefined ? this.password2 : <any>null;
        data["patronymic"] = this.patronymic !== undefined ? this.patronymic : <any>null;
        data["roles"] = this.roles !== undefined ? this.roles : <any>null;
        data["second_name"] = this.second_name !== undefined ? this.second_name : <any>null;
        data["short_name"] = this.short_name !== undefined ? this.short_name : <any>null;
        data["skills"] = this.skills !== undefined ? this.skills : <any>null;
        data["sub_id"] = this.sub_id !== undefined ? this.sub_id : <any>null;
        data["sub_name"] = this.sub_name !== undefined ? this.sub_name : <any>null;
        data["type_id"] = this.type_id !== undefined ? this.type_id : <any>null;
        data["type_name"] = this.type_name !== undefined ? this.type_name : <any>null;
        data["user_config"] = this.user_config !== undefined ? this.user_config : <any>null;
        data["workplace_id"] = this.workplace_id !== undefined ? this.workplace_id : <any>null;
        data["workplace_name"] = this.workplace_name !== undefined ? this.workplace_name : <any>null;
        return data; 
    }
}

export interface IPerformerDto {
    admin_config?: string | null;
    change_password?: boolean | null;
    deleted?: boolean | null;
    first_name?: string | null;
    id?: number | null;
    login?: string | null;
    online?: boolean | null;
    password?: string | null;
    password2?: string | null;
    patronymic?: string | null;
    roles?: string | null;
    second_name?: string | null;
    short_name?: string | null;
    skills?: string | null;
    sub_id?: number | null;
    sub_name?: string | null;
    type_id?: number | null;
    type_name?: string | null;
    user_config?: string | null;
    workplace_id?: number | null;
    workplace_name?: string | null;
}

/** Модель данных первой стороны карты вызова */
export class CardSideOneDto implements ICardSideOneDto {
    address?: CallFiasAddressDto | null;
    brigade?: CardBrigadePartDto | null;
    declarant?: CardDeclarantPartDto | null;
    general?: CardGeneralPartDto | null;
    patient?: CardPatientPartDto | null;

    constructor(data?: ICardSideOneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? CallFiasAddressDto.fromJS(data["address"]) : <any>null;
            this.brigade = data["brigade"] ? CardBrigadePartDto.fromJS(data["brigade"]) : <any>null;
            this.declarant = data["declarant"] ? CardDeclarantPartDto.fromJS(data["declarant"]) : <any>null;
            this.general = data["general"] ? CardGeneralPartDto.fromJS(data["general"]) : <any>null;
            this.patient = data["patient"] ? CardPatientPartDto.fromJS(data["patient"]) : <any>null;
        }
    }

    static fromJS(data: any): CardSideOneDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardSideOneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["brigade"] = this.brigade ? this.brigade.toJSON() : <any>null;
        data["declarant"] = this.declarant ? this.declarant.toJSON() : <any>null;
        data["general"] = this.general ? this.general.toJSON() : <any>null;
        data["patient"] = this.patient ? this.patient.toJSON() : <any>null;
        return data; 
    }
}

/** Модель данных первой стороны карты вызова */
export interface ICardSideOneDto {
    address?: CallFiasAddressDto | null;
    brigade?: CardBrigadePartDto | null;
    declarant?: CardDeclarantPartDto | null;
    general?: CardGeneralPartDto | null;
    patient?: CardPatientPartDto | null;
}

export class PerformerShiftBean implements IPerformerShiftBean {
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    id?: number | null;
    /** Признак базовой смены */
    isBasic?: boolean | null;
    /** Признак удаленной смены */
    isDeleted?: boolean | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;
    /** Тип графика */
    scheduleTypeFK?: ScheduleTypeBean | null;

    constructor(data?: IPerformerShiftBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateFrom = data["dateFrom"] ? new Date(data["dateFrom"].toString()) : <any>null;
            this.dateTo = data["dateTo"] ? new Date(data["dateTo"].toString()) : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.isBasic = data["isBasic"] !== undefined ? data["isBasic"] : <any>null;
            this.isDeleted = data["isDeleted"] !== undefined ? data["isDeleted"] : <any>null;
            this.performerFK = data["performerFK"] ? PerformerBean.fromJS(data["performerFK"]) : <any>null;
            this.scheduleTypeFK = data["scheduleTypeFK"] ? ScheduleTypeBean.fromJS(data["scheduleTypeFK"]) : <any>null;
        }
    }

    static fromJS(data: any): PerformerShiftBean {
        data = typeof data === 'object' ? data : {};
        let result = new PerformerShiftBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>null;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isBasic"] = this.isBasic !== undefined ? this.isBasic : <any>null;
        data["isDeleted"] = this.isDeleted !== undefined ? this.isDeleted : <any>null;
        data["performerFK"] = this.performerFK ? this.performerFK.toJSON() : <any>null;
        data["scheduleTypeFK"] = this.scheduleTypeFK ? this.scheduleTypeFK.toJSON() : <any>null;
        return data; 
    }
}

export interface IPerformerShiftBean {
    /** Начало периода */
    dateFrom?: Date | null;
    /** Конец периода */
    dateTo?: Date | null;
    id?: number | null;
    /** Признак базовой смены */
    isBasic?: boolean | null;
    /** Признак удаленной смены */
    isDeleted?: boolean | null;
    /** Сотрудник */
    performerFK?: PerformerBean | null;
    /** Тип графика */
    scheduleTypeFK?: ScheduleTypeBean | null;
}

/** action */
export enum Action {
    LOGIN = "LOGIN", 
    LOGIN_FAILURE = "LOGIN_FAILURE", 
    LOGOUT = "LOGOUT", 
}

export enum CallStatusList {
    UNDONE = "UNDONE", 
    UNCONFIRM = "UNCONFIRM", 
    CONFIRM = "CONFIRM", 
    ACTIVE = "ACTIVE", 
    DONE = "DONE", 
    UNFOUNDED = "UNFOUNDED", 
}

export enum CallPriorityList {
    URGENT = "URGENT", 
    EMERGENCY = "EMERGENCY", 
}

export enum CardStatusList {
    UNFILLED = "UNFILLED", 
    VERIFYING = "VERIFYING", 
    ARCHIVED = "ARCHIVED", 
}

/** Тип записи */
export enum RecordType {
    BRIGADE = "BRIGADE", 
    BRIGADE_STATUS = "BRIGADE_STATUS", 
    BRIGADE_TYPE = "BRIGADE_TYPE", 
    SCHEDULE_TYPE = "SCHEDULE_TYPE", 
    SUBDIVISION = "SUBDIVISION", 
    SUBDIVISION_TYPE = "SUBDIVISION_TYPE", 
    PERFORMER = "PERFORMER", 
    PERFORMER_TYPE = "PERFORMER_TYPE", 
    PERFORMER_SHIFT = "PERFORMER_SHIFT", 
    DISTRICT = "DISTRICT", 
    INQUIRER = "INQUIRER", 
    REFERENCE_TYPE = "REFERENCE_TYPE", 
    SKILL = "SKILL", 
    TRANSPORT = "TRANSPORT", 
    UNIT = "UNIT", 
    ITEM = "ITEM", 
    PERIOD = "PERIOD", 
    FIAS_ADDRESS = "FIAS_ADDRESS", 
    CALL = "CALL", 
    ASSIGNED_BRIGADE_MESSAGE = "ASSIGNED_BRIGADE_MESSAGE", 
    CARD = "CARD", 
    CARD_RESULT = "CARD_RESULT", 
    CARD_OBJECTIVE = "CARD_OBJECTIVE", 
    BRIGADE_SCHEDULE = "BRIGADE_SCHEDULE", 
}

/** Тип записи */
export enum RecordType2 {
    BRIGADE = "BRIGADE", 
    BRIGADE_STATUS = "BRIGADE_STATUS", 
    BRIGADE_TYPE = "BRIGADE_TYPE", 
    SCHEDULE_TYPE = "SCHEDULE_TYPE", 
    SUBDIVISION = "SUBDIVISION", 
    SUBDIVISION_TYPE = "SUBDIVISION_TYPE", 
    PERFORMER = "PERFORMER", 
    PERFORMER_TYPE = "PERFORMER_TYPE", 
    PERFORMER_SHIFT = "PERFORMER_SHIFT", 
    DISTRICT = "DISTRICT", 
    INQUIRER = "INQUIRER", 
    REFERENCE_TYPE = "REFERENCE_TYPE", 
    SKILL = "SKILL", 
    TRANSPORT = "TRANSPORT", 
    UNIT = "UNIT", 
    ITEM = "ITEM", 
    PERIOD = "PERIOD", 
    FIAS_ADDRESS = "FIAS_ADDRESS", 
    CALL = "CALL", 
    ASSIGNED_BRIGADE_MESSAGE = "ASSIGNED_BRIGADE_MESSAGE", 
    CARD = "CARD", 
    CARD_RESULT = "CARD_RESULT", 
    CARD_OBJECTIVE = "CARD_OBJECTIVE", 
    BRIGADE_SCHEDULE = "BRIGADE_SCHEDULE", 
}

/** type */
export enum Type {
    STORAGE = "STORAGE", 
    PACKAGE = "PACKAGE", 
}

/** group_code */
export enum Group_code {
    MEDIC = "MEDIC", 
    DRIVER = "DRIVER", 
    MANAGER = "MANAGER", 
}

/** mode */
export enum Mode {
    OFFLINE = "OFFLINE", 
    ONLINE = "ONLINE", 
    UPCOMING = "UPCOMING", 
}

/** group_code */
export enum Group_code2 {
    MEDIC = "MEDIC", 
    DRIVER = "DRIVER", 
}

/** mode */
export enum Mode2 {
    DAY = "DAY", 
    PERIOD = "PERIOD", 
}

/** mode */
export enum Mode3 {
    ALL = "ALL", 
    ACTIVE = "ACTIVE", 
    ARCHIVED = "ARCHIVED", 
}

export enum Anonymous {
    UNDONE = "UNDONE", 
    UNCONFIRM = "UNCONFIRM", 
    CONFIRM = "CONFIRM", 
    ACTIVE = "ACTIVE", 
    DONE = "DONE", 
    UNFOUNDED = "UNFOUNDED", 
}

export enum PermissionType {
    MODULE = "MODULE", 
    SECTION = "SECTION", 
    ACTION = "ACTION", 
}

export enum PlaceType {
    STORAGE = "STORAGE", 
    PACKAGE = "PACKAGE", 
}

export enum ChatMessageType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
    _4 = "4", 
}

export enum ReportFormat {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
}

export enum ReportType {
    _0 = "0", 
    _1 = "1", 
}

export enum ChatType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
}

export enum TableType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
    _3 = "3", 
    _4 = "4", 
    _5 = "5", 
    _6 = "6", 
}

export enum NomenclatureItemType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
}

export enum PharmacyReferenceItemType {
    _0 = "0", 
    _1 = "1", 
    _2 = "2", 
}

export enum ModelAndViewStatus {
    _100_CONTINUE = "100 CONTINUE", 
    _101_SWITCHING_PROTOCOLS = "101 SWITCHING_PROTOCOLS", 
    _102_PROCESSING = "102 PROCESSING", 
    _103_CHECKPOINT = "103 CHECKPOINT", 
    _200_OK = "200 OK", 
    _201_CREATED = "201 CREATED", 
    _202_ACCEPTED = "202 ACCEPTED", 
    _203_NON_AUTHORITATIVE_INFORMATION = "203 NON_AUTHORITATIVE_INFORMATION", 
    _204_NO_CONTENT = "204 NO_CONTENT", 
    _205_RESET_CONTENT = "205 RESET_CONTENT", 
    _206_PARTIAL_CONTENT = "206 PARTIAL_CONTENT", 
    _207_MULTI_STATUS = "207 MULTI_STATUS", 
    _208_ALREADY_REPORTED = "208 ALREADY_REPORTED", 
    _226_IM_USED = "226 IM_USED", 
    _300_MULTIPLE_CHOICES = "300 MULTIPLE_CHOICES", 
    _301_MOVED_PERMANENTLY = "301 MOVED_PERMANENTLY", 
    _302_FOUND = "302 FOUND", 
    _302_MOVED_TEMPORARILY = "302 MOVED_TEMPORARILY", 
    _303_SEE_OTHER = "303 SEE_OTHER", 
    _304_NOT_MODIFIED = "304 NOT_MODIFIED", 
    _305_USE_PROXY = "305 USE_PROXY", 
    _307_TEMPORARY_REDIRECT = "307 TEMPORARY_REDIRECT", 
    _308_PERMANENT_REDIRECT = "308 PERMANENT_REDIRECT", 
    _400_BAD_REQUEST = "400 BAD_REQUEST", 
    _401_UNAUTHORIZED = "401 UNAUTHORIZED", 
    _402_PAYMENT_REQUIRED = "402 PAYMENT_REQUIRED", 
    _403_FORBIDDEN = "403 FORBIDDEN", 
    _404_NOT_FOUND = "404 NOT_FOUND", 
    _405_METHOD_NOT_ALLOWED = "405 METHOD_NOT_ALLOWED", 
    _406_NOT_ACCEPTABLE = "406 NOT_ACCEPTABLE", 
    _407_PROXY_AUTHENTICATION_REQUIRED = "407 PROXY_AUTHENTICATION_REQUIRED", 
    _408_REQUEST_TIMEOUT = "408 REQUEST_TIMEOUT", 
    _409_CONFLICT = "409 CONFLICT", 
    _410_GONE = "410 GONE", 
    _411_LENGTH_REQUIRED = "411 LENGTH_REQUIRED", 
    _412_PRECONDITION_FAILED = "412 PRECONDITION_FAILED", 
    _413_PAYLOAD_TOO_LARGE = "413 PAYLOAD_TOO_LARGE", 
    _413_REQUEST_ENTITY_TOO_LARGE = "413 REQUEST_ENTITY_TOO_LARGE", 
    _414_URI_TOO_LONG = "414 URI_TOO_LONG", 
    _414_REQUEST_URI_TOO_LONG = "414 REQUEST_URI_TOO_LONG", 
    _415_UNSUPPORTED_MEDIA_TYPE = "415 UNSUPPORTED_MEDIA_TYPE", 
    _416_REQUESTED_RANGE_NOT_SATISFIABLE = "416 REQUESTED_RANGE_NOT_SATISFIABLE", 
    _417_EXPECTATION_FAILED = "417 EXPECTATION_FAILED", 
    _418_I_AM_A_TEAPOT = "418 I_AM_A_TEAPOT", 
    _419_INSUFFICIENT_SPACE_ON_RESOURCE = "419 INSUFFICIENT_SPACE_ON_RESOURCE", 
    _420_METHOD_FAILURE = "420 METHOD_FAILURE", 
    _421_DESTINATION_LOCKED = "421 DESTINATION_LOCKED", 
    _422_UNPROCESSABLE_ENTITY = "422 UNPROCESSABLE_ENTITY", 
    _423_LOCKED = "423 LOCKED", 
    _424_FAILED_DEPENDENCY = "424 FAILED_DEPENDENCY", 
    _426_UPGRADE_REQUIRED = "426 UPGRADE_REQUIRED", 
    _428_PRECONDITION_REQUIRED = "428 PRECONDITION_REQUIRED", 
    _429_TOO_MANY_REQUESTS = "429 TOO_MANY_REQUESTS", 
    _431_REQUEST_HEADER_FIELDS_TOO_LARGE = "431 REQUEST_HEADER_FIELDS_TOO_LARGE", 
    _451_UNAVAILABLE_FOR_LEGAL_REASONS = "451 UNAVAILABLE_FOR_LEGAL_REASONS", 
    _500_INTERNAL_SERVER_ERROR = "500 INTERNAL_SERVER_ERROR", 
    _501_NOT_IMPLEMENTED = "501 NOT_IMPLEMENTED", 
    _502_BAD_GATEWAY = "502 BAD_GATEWAY", 
    _503_SERVICE_UNAVAILABLE = "503 SERVICE_UNAVAILABLE", 
    _504_GATEWAY_TIMEOUT = "504 GATEWAY_TIMEOUT", 
    _505_HTTP_VERSION_NOT_SUPPORTED = "505 HTTP_VERSION_NOT_SUPPORTED", 
    _506_VARIANT_ALSO_NEGOTIATES = "506 VARIANT_ALSO_NEGOTIATES", 
    _507_INSUFFICIENT_STORAGE = "507 INSUFFICIENT_STORAGE", 
    _508_LOOP_DETECTED = "508 LOOP_DETECTED", 
    _509_BANDWIDTH_LIMIT_EXCEEDED = "509 BANDWIDTH_LIMIT_EXCEEDED", 
    _510_NOT_EXTENDED = "510 NOT_EXTENDED", 
    _511_NETWORK_AUTHENTICATION_REQUIRED = "511 NETWORK_AUTHENTICATION_REQUIRED", 
}

export enum PerformerTypeGroupCode {
    MEDIC = "MEDIC", 
    DRIVER = "DRIVER", 
    MANAGER = "MANAGER", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}